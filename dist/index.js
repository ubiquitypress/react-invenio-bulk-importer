import * as Ya from "react";
import ae, { Children as _k, PureComponent as bpe, Component as Do, createRef as bp, isValidElement as oae, cloneElement as sae, createElement as Od, useContext as Gc, useLayoutEffect as ype, useEffect as Ch, useMemo as Rv, useReducer as v0e, useRef as uy, createContext as b0e, useState as Spe, useCallback as _d, useImperativeHandle as y0e, forwardRef as S0e } from "react";
import * as Joe from "react-dom";
import { createPortal as w0e, unstable_batchedUpdates as E0e } from "react-dom";
function O1(r, o) {
  if (r == null)
    return {};
  var c = {};
  for (var i in r)
    if ({}.hasOwnProperty.call(r, i)) {
      if (o.indexOf(i) !== -1)
        continue;
      c[i] = r[i];
    }
  return c;
}
var S1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Ku(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
function q$(r) {
  if (r.__esModule)
    return r;
  var o = r.default;
  if (typeof o == "function") {
    var c = function i() {
      return this instanceof i ? Reflect.construct(o, arguments, this.constructor) : o.apply(this, arguments);
    };
    c.prototype = o.prototype;
  } else
    c = {};
  return Object.defineProperty(c, "__esModule", { value: !0 }), Object.keys(r).forEach(function(i) {
    var d = Object.getOwnPropertyDescriptor(r, i);
    Object.defineProperty(c, i, d.get ? d : {
      enumerable: !0,
      get: function() {
        return r[i];
      }
    });
  }), c;
}
var Z9 = { exports: {} }, Ai = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qle;
function C0e() {
  if (qle)
    return Ai;
  qle = 1;
  var r = typeof Symbol == "function" && Symbol.for, o = r ? Symbol.for("react.element") : 60103, c = r ? Symbol.for("react.portal") : 60106, i = r ? Symbol.for("react.fragment") : 60107, d = r ? Symbol.for("react.strict_mode") : 60108, m = r ? Symbol.for("react.profiler") : 60114, v = r ? Symbol.for("react.provider") : 60109, g = r ? Symbol.for("react.context") : 60110, C = r ? Symbol.for("react.async_mode") : 60111, O = r ? Symbol.for("react.concurrent_mode") : 60111, R = r ? Symbol.for("react.forward_ref") : 60112, I = r ? Symbol.for("react.suspense") : 60113, L = r ? Symbol.for("react.suspense_list") : 60120, Z = r ? Symbol.for("react.memo") : 60115, ne = r ? Symbol.for("react.lazy") : 60116, se = r ? Symbol.for("react.block") : 60121, Q = r ? Symbol.for("react.fundamental") : 60117, he = r ? Symbol.for("react.responder") : 60118, ue = r ? Symbol.for("react.scope") : 60119;
  function G(we) {
    if (typeof we == "object" && we !== null) {
      var be = we.$$typeof;
      switch (be) {
        case o:
          switch (we = we.type, we) {
            case C:
            case O:
            case i:
            case m:
            case d:
            case I:
              return we;
            default:
              switch (we = we && we.$$typeof, we) {
                case g:
                case R:
                case ne:
                case Z:
                case v:
                  return we;
                default:
                  return be;
              }
          }
        case c:
          return be;
      }
    }
  }
  function me(we) {
    return G(we) === O;
  }
  return Ai.AsyncMode = C, Ai.ConcurrentMode = O, Ai.ContextConsumer = g, Ai.ContextProvider = v, Ai.Element = o, Ai.ForwardRef = R, Ai.Fragment = i, Ai.Lazy = ne, Ai.Memo = Z, Ai.Portal = c, Ai.Profiler = m, Ai.StrictMode = d, Ai.Suspense = I, Ai.isAsyncMode = function(we) {
    return me(we) || G(we) === C;
  }, Ai.isConcurrentMode = me, Ai.isContextConsumer = function(we) {
    return G(we) === g;
  }, Ai.isContextProvider = function(we) {
    return G(we) === v;
  }, Ai.isElement = function(we) {
    return typeof we == "object" && we !== null && we.$$typeof === o;
  }, Ai.isForwardRef = function(we) {
    return G(we) === R;
  }, Ai.isFragment = function(we) {
    return G(we) === i;
  }, Ai.isLazy = function(we) {
    return G(we) === ne;
  }, Ai.isMemo = function(we) {
    return G(we) === Z;
  }, Ai.isPortal = function(we) {
    return G(we) === c;
  }, Ai.isProfiler = function(we) {
    return G(we) === m;
  }, Ai.isStrictMode = function(we) {
    return G(we) === d;
  }, Ai.isSuspense = function(we) {
    return G(we) === I;
  }, Ai.isValidElementType = function(we) {
    return typeof we == "string" || typeof we == "function" || we === i || we === O || we === m || we === d || we === I || we === L || typeof we == "object" && we !== null && (we.$$typeof === ne || we.$$typeof === Z || we.$$typeof === v || we.$$typeof === g || we.$$typeof === R || we.$$typeof === Q || we.$$typeof === he || we.$$typeof === ue || we.$$typeof === se);
  }, Ai.typeOf = G, Ai;
}
var ki = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Gle;
function x0e() {
  return Gle || (Gle = 1, process.env.NODE_ENV !== "production" && function() {
    var r = typeof Symbol == "function" && Symbol.for, o = r ? Symbol.for("react.element") : 60103, c = r ? Symbol.for("react.portal") : 60106, i = r ? Symbol.for("react.fragment") : 60107, d = r ? Symbol.for("react.strict_mode") : 60108, m = r ? Symbol.for("react.profiler") : 60114, v = r ? Symbol.for("react.provider") : 60109, g = r ? Symbol.for("react.context") : 60110, C = r ? Symbol.for("react.async_mode") : 60111, O = r ? Symbol.for("react.concurrent_mode") : 60111, R = r ? Symbol.for("react.forward_ref") : 60112, I = r ? Symbol.for("react.suspense") : 60113, L = r ? Symbol.for("react.suspense_list") : 60120, Z = r ? Symbol.for("react.memo") : 60115, ne = r ? Symbol.for("react.lazy") : 60116, se = r ? Symbol.for("react.block") : 60121, Q = r ? Symbol.for("react.fundamental") : 60117, he = r ? Symbol.for("react.responder") : 60118, ue = r ? Symbol.for("react.scope") : 60119;
    function G(Jt) {
      return typeof Jt == "string" || typeof Jt == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      Jt === i || Jt === O || Jt === m || Jt === d || Jt === I || Jt === L || typeof Jt == "object" && Jt !== null && (Jt.$$typeof === ne || Jt.$$typeof === Z || Jt.$$typeof === v || Jt.$$typeof === g || Jt.$$typeof === R || Jt.$$typeof === Q || Jt.$$typeof === he || Jt.$$typeof === ue || Jt.$$typeof === se);
    }
    function me(Jt) {
      if (typeof Jt == "object" && Jt !== null) {
        var wo = Jt.$$typeof;
        switch (wo) {
          case o:
            var Ge = Jt.type;
            switch (Ge) {
              case C:
              case O:
              case i:
              case m:
              case d:
              case I:
                return Ge;
              default:
                var qt = Ge && Ge.$$typeof;
                switch (qt) {
                  case g:
                  case R:
                  case ne:
                  case Z:
                  case v:
                    return qt;
                  default:
                    return wo;
                }
            }
          case c:
            return wo;
        }
      }
    }
    var we = C, be = O, q = g, Te = v, Le = o, je = R, Ie = i, Ce = ne, pt = Z, sn = c, Lt = m, z = d, bt = I, at = !1;
    function _n(Jt) {
      return at || (at = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), st(Jt) || me(Jt) === C;
    }
    function st(Jt) {
      return me(Jt) === O;
    }
    function Ne(Jt) {
      return me(Jt) === g;
    }
    function vt(Jt) {
      return me(Jt) === v;
    }
    function Gt(Jt) {
      return typeof Jt == "object" && Jt !== null && Jt.$$typeof === o;
    }
    function xt(Jt) {
      return me(Jt) === R;
    }
    function cn(Jt) {
      return me(Jt) === i;
    }
    function He(Jt) {
      return me(Jt) === ne;
    }
    function ut(Jt) {
      return me(Jt) === Z;
    }
    function oe(Jt) {
      return me(Jt) === c;
    }
    function qn(Jt) {
      return me(Jt) === m;
    }
    function Rn(Jt) {
      return me(Jt) === d;
    }
    function Zt(Jt) {
      return me(Jt) === I;
    }
    ki.AsyncMode = we, ki.ConcurrentMode = be, ki.ContextConsumer = q, ki.ContextProvider = Te, ki.Element = Le, ki.ForwardRef = je, ki.Fragment = Ie, ki.Lazy = Ce, ki.Memo = pt, ki.Portal = sn, ki.Profiler = Lt, ki.StrictMode = z, ki.Suspense = bt, ki.isAsyncMode = _n, ki.isConcurrentMode = st, ki.isContextConsumer = Ne, ki.isContextProvider = vt, ki.isElement = Gt, ki.isForwardRef = xt, ki.isFragment = cn, ki.isLazy = He, ki.isMemo = ut, ki.isPortal = oe, ki.isProfiler = qn, ki.isStrictMode = Rn, ki.isSuspense = Zt, ki.isValidElementType = G, ki.typeOf = me;
  }()), ki;
}
var Zle;
function cj() {
  return Zle || (Zle = 1, process.env.NODE_ENV === "production" ? Z9.exports = C0e() : Z9.exports = x0e()), Z9.exports;
}
var T0e = cj();
function ese(r, o) {
  return ese = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(c, i) {
    return c.__proto__ = i, c;
  }, ese(r, o);
}
function Zo(r, o) {
  r.prototype = Object.create(o.prototype), r.prototype.constructor = r, ese(r, o);
}
var $S = function(o, c) {
  if (process.env.NODE_ENV !== "production" && typeof o == "string")
    throw new Error("We do not support refs as string, this is a legacy API and will be likely to be removed in one of the future releases of React.");
  if (typeof o == "function") {
    o(c);
    return;
  }
  o !== null && typeof o == "object" && (o.current = c);
}, zA = function(o) {
  return (
    // https://github.com/facebook/react/blob/v16.8.2/packages/react-reconciler/src/ReactFiberCommitWork.js#L665
    o !== null && typeof o == "object" && o.hasOwnProperty("current")
  );
};
function Kle(r) {
  return r === null || r instanceof Element || r instanceof Text ? !1 : !!(r.type && r.tag);
}
var _0e = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.prevNode = void 0, i;
  }
  var c = o.prototype;
  return c.componentDidMount = function() {
    var d = Joe.findDOMNode(this);
    process.env.NODE_ENV !== "production" && Kle(d) && (d = null), this.prevNode = d, $S(this.props.innerRef, d);
  }, c.componentDidUpdate = function(d) {
    var m = Joe.findDOMNode(this);
    process.env.NODE_ENV !== "production" && Kle(m) && (m = null), this.prevNode !== m && (this.prevNode = m, $S(this.props.innerRef, m)), d.innerRef !== this.props.innerRef && $S(this.props.innerRef, m);
  }, c.componentWillUnmount = function() {
    $S(this.props.innerRef, null), delete this.prevNode;
  }, c.render = function() {
    var d = this.props.children;
    return d;
  }, o;
}(Ya.Component), O0e = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.currentNode = void 0, i.handleRefOverride = function(g) {
      var C = i.props, O = C.children, R = C.innerRef;
      $S(O.ref, g), $S(R, g), i.currentNode = g;
    }, i;
  }
  var c = o.prototype;
  return c.componentDidUpdate = function(d) {
    d.innerRef !== this.props.innerRef && $S(this.props.innerRef, this.currentNode);
  }, c.componentWillUnmount = function() {
    delete this.currentNode;
  }, c.render = function() {
    var d = this.props.children;
    return /* @__PURE__ */ Ya.cloneElement(d, {
      ref: this.handleRefOverride
    });
  }, o;
}(Ya.Component), A0e = ["children", "innerRef"], yp = function(o) {
  var c = o.children, i = o.innerRef, d = O1(o, A0e), m = Ya.Children.only(c), v = T0e.isForwardRef(m) ? O0e : _0e, g = m && d && Object.keys(d).length > 0 ? /* @__PURE__ */ Ya.cloneElement(m, d) : m;
  return /* @__PURE__ */ Ya.createElement(v, {
    innerRef: i
  }, g);
};
function Be() {
  return Be = Object.assign ? Object.assign.bind() : function(r) {
    for (var o = 1; o < arguments.length; o++) {
      var c = arguments[o];
      for (var i in c)
        ({}).hasOwnProperty.call(c, i) && (r[i] = c[i]);
    }
    return r;
  }, Be.apply(null, arguments);
}
var k0e = Object.prototype, N0e = k0e.hasOwnProperty;
function R0e(r, o) {
  return r != null && N0e.call(r, o);
}
var P0e = Array.isArray;
const qc = P0e;
var D0e = typeof global == "object" && global && global.Object === Object && global;
const wpe = D0e;
var $0e = typeof self == "object" && self && self.Object === Object && self, I0e = wpe || $0e || Function("return this")();
const Ph = I0e;
var M0e = Ph.Symbol;
const py = M0e;
var Epe = Object.prototype, F0e = Epe.hasOwnProperty, L0e = Epe.toString, IL = py ? py.toStringTag : void 0;
function B0e(r) {
  var o = F0e.call(r, IL), c = r[IL];
  try {
    r[IL] = void 0;
    var i = !0;
  } catch {
  }
  var d = L0e.call(r);
  return i && (o ? r[IL] = c : delete r[IL]), d;
}
var H0e = Object.prototype, z0e = H0e.toString;
function V0e(r) {
  return z0e.call(r);
}
var U0e = "[object Null]", W0e = "[object Undefined]", Yle = py ? py.toStringTag : void 0;
function XS(r) {
  return r == null ? r === void 0 ? W0e : U0e : Yle && Yle in Object(r) ? B0e(r) : V0e(r);
}
function Nh(r) {
  return r != null && typeof r == "object";
}
var j0e = "[object Symbol]";
function b2(r) {
  return typeof r == "symbol" || Nh(r) && XS(r) == j0e;
}
var q0e = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, G0e = /^\w*$/;
function aae(r, o) {
  if (qc(r))
    return !1;
  var c = typeof r;
  return c == "number" || c == "symbol" || c == "boolean" || r == null || b2(r) ? !0 : G0e.test(r) || !q0e.test(r) || o != null && r in Object(o);
}
function Fv(r) {
  var o = typeof r;
  return r != null && (o == "object" || o == "function");
}
var Z0e = "[object AsyncFunction]", K0e = "[object Function]", Y0e = "[object GeneratorFunction]", Q0e = "[object Proxy]";
function YD(r) {
  if (!Fv(r))
    return !1;
  var o = XS(r);
  return o == K0e || o == Y0e || o == Z0e || o == Q0e;
}
var X0e = Ph["__core-js_shared__"];
const Ure = X0e;
var Qle = function() {
  var r = /[^.]+$/.exec(Ure && Ure.keys && Ure.keys.IE_PROTO || "");
  return r ? "Symbol(src)_1." + r : "";
}();
function J0e(r) {
  return !!Qle && Qle in r;
}
var eSe = Function.prototype, tSe = eSe.toString;
function Ok(r) {
  if (r != null) {
    try {
      return tSe.call(r);
    } catch {
    }
    try {
      return r + "";
    } catch {
    }
  }
  return "";
}
var nSe = /[\\^$.*+?()[\]{}|]/g, rSe = /^\[object .+?Constructor\]$/, oSe = Function.prototype, sSe = Object.prototype, aSe = oSe.toString, iSe = sSe.hasOwnProperty, cSe = RegExp(
  "^" + aSe.call(iSe).replace(nSe, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function lSe(r) {
  if (!Fv(r) || J0e(r))
    return !1;
  var o = YD(r) ? cSe : rSe;
  return o.test(Ok(r));
}
function uSe(r, o) {
  return r == null ? void 0 : r[o];
}
function Ak(r, o) {
  var c = uSe(r, o);
  return lSe(c) ? c : void 0;
}
var dSe = Ak(Object, "create");
const fB = dSe;
function fSe() {
  this.__data__ = fB ? fB(null) : {}, this.size = 0;
}
function mSe(r) {
  var o = this.has(r) && delete this.__data__[r];
  return this.size -= o ? 1 : 0, o;
}
var pSe = "__lodash_hash_undefined__", hSe = Object.prototype, gSe = hSe.hasOwnProperty;
function vSe(r) {
  var o = this.__data__;
  if (fB) {
    var c = o[r];
    return c === pSe ? void 0 : c;
  }
  return gSe.call(o, r) ? o[r] : void 0;
}
var bSe = Object.prototype, ySe = bSe.hasOwnProperty;
function SSe(r) {
  var o = this.__data__;
  return fB ? o[r] !== void 0 : ySe.call(o, r);
}
var wSe = "__lodash_hash_undefined__";
function ESe(r, o) {
  var c = this.__data__;
  return this.size += this.has(r) ? 0 : 1, c[r] = fB && o === void 0 ? wSe : o, this;
}
function qA(r) {
  var o = -1, c = r == null ? 0 : r.length;
  for (this.clear(); ++o < c; ) {
    var i = r[o];
    this.set(i[0], i[1]);
  }
}
qA.prototype.clear = fSe;
qA.prototype.delete = mSe;
qA.prototype.get = vSe;
qA.prototype.has = SSe;
qA.prototype.set = ESe;
function CSe() {
  this.__data__ = [], this.size = 0;
}
function lj(r, o) {
  return r === o || r !== r && o !== o;
}
function uj(r, o) {
  for (var c = r.length; c--; )
    if (lj(r[c][0], o))
      return c;
  return -1;
}
var xSe = Array.prototype, TSe = xSe.splice;
function _Se(r) {
  var o = this.__data__, c = uj(o, r);
  if (c < 0)
    return !1;
  var i = o.length - 1;
  return c == i ? o.pop() : TSe.call(o, c, 1), --this.size, !0;
}
function OSe(r) {
  var o = this.__data__, c = uj(o, r);
  return c < 0 ? void 0 : o[c][1];
}
function ASe(r) {
  return uj(this.__data__, r) > -1;
}
function kSe(r, o) {
  var c = this.__data__, i = uj(c, r);
  return i < 0 ? (++this.size, c.push([r, o])) : c[i][1] = o, this;
}
function BC(r) {
  var o = -1, c = r == null ? 0 : r.length;
  for (this.clear(); ++o < c; ) {
    var i = r[o];
    this.set(i[0], i[1]);
  }
}
BC.prototype.clear = CSe;
BC.prototype.delete = _Se;
BC.prototype.get = OSe;
BC.prototype.has = ASe;
BC.prototype.set = kSe;
var NSe = Ak(Ph, "Map");
const mB = NSe;
function RSe() {
  this.size = 0, this.__data__ = {
    hash: new qA(),
    map: new (mB || BC)(),
    string: new qA()
  };
}
function PSe(r) {
  var o = typeof r;
  return o == "string" || o == "number" || o == "symbol" || o == "boolean" ? r !== "__proto__" : r === null;
}
function dj(r, o) {
  var c = r.__data__;
  return PSe(o) ? c[typeof o == "string" ? "string" : "hash"] : c.map;
}
function DSe(r) {
  var o = dj(this, r).delete(r);
  return this.size -= o ? 1 : 0, o;
}
function $Se(r) {
  return dj(this, r).get(r);
}
function ISe(r) {
  return dj(this, r).has(r);
}
function MSe(r, o) {
  var c = dj(this, r), i = c.size;
  return c.set(r, o), this.size += c.size == i ? 0 : 1, this;
}
function HC(r) {
  var o = -1, c = r == null ? 0 : r.length;
  for (this.clear(); ++o < c; ) {
    var i = r[o];
    this.set(i[0], i[1]);
  }
}
HC.prototype.clear = RSe;
HC.prototype.delete = DSe;
HC.prototype.get = $Se;
HC.prototype.has = ISe;
HC.prototype.set = MSe;
var FSe = "Expected a function";
function FB(r, o) {
  if (typeof r != "function" || o != null && typeof o != "function")
    throw new TypeError(FSe);
  var c = function() {
    var i = arguments, d = o ? o.apply(this, i) : i[0], m = c.cache;
    if (m.has(d))
      return m.get(d);
    var v = r.apply(this, i);
    return c.cache = m.set(d, v) || m, v;
  };
  return c.cache = new (FB.Cache || HC)(), c;
}
FB.Cache = HC;
var LSe = 500;
function BSe(r) {
  var o = FB(r, function(i) {
    return c.size === LSe && c.clear(), i;
  }), c = o.cache;
  return o;
}
var HSe = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, zSe = /\\(\\)?/g, VSe = BSe(function(r) {
  var o = [];
  return r.charCodeAt(0) === 46 && o.push(""), r.replace(HSe, function(c, i, d, m) {
    o.push(d ? m.replace(zSe, "$1") : i || c);
  }), o;
});
const Cpe = VSe;
function E1(r, o) {
  for (var c = -1, i = r == null ? 0 : r.length, d = Array(i); ++c < i; )
    d[c] = o(r[c], c, r);
  return d;
}
var USe = 1 / 0, Xle = py ? py.prototype : void 0, Jle = Xle ? Xle.toString : void 0;
function fj(r) {
  if (typeof r == "string")
    return r;
  if (qc(r))
    return E1(r, fj) + "";
  if (b2(r))
    return Jle ? Jle.call(r) : "";
  var o = r + "";
  return o == "0" && 1 / r == -USe ? "-0" : o;
}
function BS(r) {
  return r == null ? "" : fj(r);
}
function LB(r, o) {
  return qc(r) ? r : aae(r, o) ? [r] : Cpe(BS(r));
}
var WSe = "[object Arguments]";
function eue(r) {
  return Nh(r) && XS(r) == WSe;
}
var xpe = Object.prototype, jSe = xpe.hasOwnProperty, qSe = xpe.propertyIsEnumerable, GSe = eue(function() {
  return arguments;
}()) ? eue : function(r) {
  return Nh(r) && jSe.call(r, "callee") && !qSe.call(r, "callee");
};
const mj = GSe;
var ZSe = 9007199254740991, KSe = /^(?:0|[1-9]\d*)$/;
function BB(r, o) {
  var c = typeof r;
  return o = o ?? ZSe, !!o && (c == "number" || c != "symbol" && KSe.test(r)) && r > -1 && r % 1 == 0 && r < o;
}
var YSe = 9007199254740991;
function iae(r) {
  return typeof r == "number" && r > -1 && r % 1 == 0 && r <= YSe;
}
var QSe = 1 / 0;
function kk(r) {
  if (typeof r == "string" || b2(r))
    return r;
  var o = r + "";
  return o == "0" && 1 / r == -QSe ? "-0" : o;
}
function Tpe(r, o, c) {
  o = LB(o, r);
  for (var i = -1, d = o.length, m = !1; ++i < d; ) {
    var v = kk(o[i]);
    if (!(m = r != null && c(r, v)))
      break;
    r = r[v];
  }
  return m || ++i != d ? m : (d = r == null ? 0 : r.length, !!d && iae(d) && BB(v, d) && (qc(r) || mj(r)));
}
function iC(r, o) {
  return r != null && Tpe(r, o, R0e);
}
function pj(r, o, c) {
  switch (c.length) {
    case 0:
      return r.call(o);
    case 1:
      return r.call(o, c[0]);
    case 2:
      return r.call(o, c[0], c[1]);
    case 3:
      return r.call(o, c[0], c[1], c[2]);
  }
  return r.apply(o, c);
}
function XSe(r) {
  var o = r == null ? 0 : r.length;
  return o ? r[o - 1] : void 0;
}
function HB(r, o) {
  o = LB(o, r);
  for (var c = 0, i = o.length; r != null && c < i; )
    r = r[kk(o[c++])];
  return c && c == i ? r : void 0;
}
function hj(r, o, c) {
  var i = -1, d = r.length;
  o < 0 && (o = -o > d ? 0 : d + o), c = c > d ? d : c, c < 0 && (c += d), d = o > c ? 0 : c - o >>> 0, o >>>= 0;
  for (var m = Array(d); ++i < d; )
    m[i] = r[i + o];
  return m;
}
function JSe(r, o) {
  return o.length < 2 ? r : HB(r, hj(o, 0, -1));
}
function ewe(r, o, c) {
  o = LB(o, r), r = JSe(r, o);
  var i = r == null ? r : r[kk(XSe(o))];
  return i == null ? void 0 : pj(i, r, c);
}
function zC(r) {
  return r;
}
var tue = Math.max;
function _pe(r, o, c) {
  return o = tue(o === void 0 ? r.length - 1 : o, 0), function() {
    for (var i = arguments, d = -1, m = tue(i.length - o, 0), v = Array(m); ++d < m; )
      v[d] = i[o + d];
    d = -1;
    for (var g = Array(o + 1); ++d < o; )
      g[d] = i[d];
    return g[o] = c(v), pj(r, this, g);
  };
}
function Ope(r) {
  return function() {
    return r;
  };
}
var twe = function() {
  try {
    var r = Ak(Object, "defineProperty");
    return r({}, "", {}), r;
  } catch {
  }
}();
const _W = twe;
var nwe = _W ? function(r, o) {
  return _W(r, "toString", {
    configurable: !0,
    enumerable: !1,
    value: Ope(o),
    writable: !0
  });
} : zC;
const rwe = nwe;
var owe = 800, swe = 16, awe = Date.now;
function Ape(r) {
  var o = 0, c = 0;
  return function() {
    var i = awe(), d = swe - (i - c);
    if (c = i, d > 0) {
      if (++o >= owe)
        return arguments[0];
    } else
      o = 0;
    return r.apply(void 0, arguments);
  };
}
var iwe = Ape(rwe);
const cae = iwe;
function Nk(r, o) {
  return cae(_pe(r, o, zC), r + "");
}
var cwe = Nk(ewe);
const xn = cwe;
var tse = { exports: {} };
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Wre, nue;
function lwe() {
  if (nue)
    return Wre;
  nue = 1;
  var r = Object.getOwnPropertySymbols, o = Object.prototype.hasOwnProperty, c = Object.prototype.propertyIsEnumerable;
  function i(m) {
    if (m == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(m);
  }
  function d() {
    try {
      if (!Object.assign)
        return !1;
      var m = new String("abc");
      if (m[5] = "de", Object.getOwnPropertyNames(m)[0] === "5")
        return !1;
      for (var v = {}, g = 0; g < 10; g++)
        v["_" + String.fromCharCode(g)] = g;
      var C = Object.getOwnPropertyNames(v).map(function(R) {
        return v[R];
      });
      if (C.join("") !== "0123456789")
        return !1;
      var O = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(R) {
        O[R] = R;
      }), Object.keys(Object.assign({}, O)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Wre = d() ? Object.assign : function(m, v) {
    for (var g, C = i(m), O, R = 1; R < arguments.length; R++) {
      g = Object(arguments[R]);
      for (var I in g)
        o.call(g, I) && (C[I] = g[I]);
      if (r) {
        O = r(g);
        for (var L = 0; L < O.length; L++)
          c.call(g, O[L]) && (C[O[L]] = g[O[L]]);
      }
    }
    return C;
  }, Wre;
}
var jre, rue;
function lae() {
  if (rue)
    return jre;
  rue = 1;
  var r = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return jre = r, jre;
}
var qre, oue;
function kpe() {
  return oue || (oue = 1, qre = Function.call.bind(Object.prototype.hasOwnProperty)), qre;
}
var Gre, sue;
function uwe() {
  if (sue)
    return Gre;
  sue = 1;
  var r = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var o = lae(), c = {}, i = kpe();
    r = function(m) {
      var v = "Warning: " + m;
      typeof console < "u" && console.error(v);
      try {
        throw new Error(v);
      } catch {
      }
    };
  }
  function d(m, v, g, C, O) {
    if (process.env.NODE_ENV !== "production") {
      for (var R in m)
        if (i(m, R)) {
          var I;
          try {
            if (typeof m[R] != "function") {
              var L = Error(
                (C || "React class") + ": " + g + " type `" + R + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof m[R] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw L.name = "Invariant Violation", L;
            }
            I = m[R](v, R, C, g, null, o);
          } catch (ne) {
            I = ne;
          }
          if (I && !(I instanceof Error) && r(
            (C || "React class") + ": type specification of " + g + " `" + R + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof I + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), I instanceof Error && !(I.message in c)) {
            c[I.message] = !0;
            var Z = O ? O() : "";
            r(
              "Failed " + g + " type: " + I.message + (Z ?? "")
            );
          }
        }
    }
  }
  return d.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (c = {});
  }, Gre = d, Gre;
}
var Zre, aue;
function dwe() {
  if (aue)
    return Zre;
  aue = 1;
  var r = cj(), o = lwe(), c = lae(), i = kpe(), d = uwe(), m = function() {
  };
  process.env.NODE_ENV !== "production" && (m = function(g) {
    var C = "Warning: " + g;
    typeof console < "u" && console.error(C);
    try {
      throw new Error(C);
    } catch {
    }
  });
  function v() {
    return null;
  }
  return Zre = function(g, C) {
    var O = typeof Symbol == "function" && Symbol.iterator, R = "@@iterator";
    function I(st) {
      var Ne = st && (O && st[O] || st[R]);
      if (typeof Ne == "function")
        return Ne;
    }
    var L = "<<anonymous>>", Z = {
      array: he("array"),
      bigint: he("bigint"),
      bool: he("boolean"),
      func: he("function"),
      number: he("number"),
      object: he("object"),
      string: he("string"),
      symbol: he("symbol"),
      any: ue(),
      arrayOf: G,
      element: me(),
      elementType: we(),
      instanceOf: be,
      node: je(),
      objectOf: Te,
      oneOf: q,
      oneOfType: Le,
      shape: Ce,
      exact: pt
    };
    function ne(st, Ne) {
      return st === Ne ? st !== 0 || 1 / st === 1 / Ne : st !== st && Ne !== Ne;
    }
    function se(st, Ne) {
      this.message = st, this.data = Ne && typeof Ne == "object" ? Ne : {}, this.stack = "";
    }
    se.prototype = Error.prototype;
    function Q(st) {
      if (process.env.NODE_ENV !== "production")
        var Ne = {}, vt = 0;
      function Gt(cn, He, ut, oe, qn, Rn, Zt) {
        if (oe = oe || L, Rn = Rn || ut, Zt !== c) {
          if (C) {
            var Jt = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw Jt.name = "Invariant Violation", Jt;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var wo = oe + ":" + ut;
            !Ne[wo] && // Avoid spamming the console because they are often not actionable except for lib authors
            vt < 3 && (m(
              "You are manually calling a React.PropTypes validation function for the `" + Rn + "` prop on `" + oe + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), Ne[wo] = !0, vt++);
          }
        }
        return He[ut] == null ? cn ? He[ut] === null ? new se("The " + qn + " `" + Rn + "` is marked as required " + ("in `" + oe + "`, but its value is `null`.")) : new se("The " + qn + " `" + Rn + "` is marked as required in " + ("`" + oe + "`, but its value is `undefined`.")) : null : st(He, ut, oe, qn, Rn);
      }
      var xt = Gt.bind(null, !1);
      return xt.isRequired = Gt.bind(null, !0), xt;
    }
    function he(st) {
      function Ne(vt, Gt, xt, cn, He, ut) {
        var oe = vt[Gt], qn = z(oe);
        if (qn !== st) {
          var Rn = bt(oe);
          return new se(
            "Invalid " + cn + " `" + He + "` of type " + ("`" + Rn + "` supplied to `" + xt + "`, expected ") + ("`" + st + "`."),
            { expectedType: st }
          );
        }
        return null;
      }
      return Q(Ne);
    }
    function ue() {
      return Q(v);
    }
    function G(st) {
      function Ne(vt, Gt, xt, cn, He) {
        if (typeof st != "function")
          return new se("Property `" + He + "` of component `" + xt + "` has invalid PropType notation inside arrayOf.");
        var ut = vt[Gt];
        if (!Array.isArray(ut)) {
          var oe = z(ut);
          return new se("Invalid " + cn + " `" + He + "` of type " + ("`" + oe + "` supplied to `" + xt + "`, expected an array."));
        }
        for (var qn = 0; qn < ut.length; qn++) {
          var Rn = st(ut, qn, xt, cn, He + "[" + qn + "]", c);
          if (Rn instanceof Error)
            return Rn;
        }
        return null;
      }
      return Q(Ne);
    }
    function me() {
      function st(Ne, vt, Gt, xt, cn) {
        var He = Ne[vt];
        if (!g(He)) {
          var ut = z(He);
          return new se("Invalid " + xt + " `" + cn + "` of type " + ("`" + ut + "` supplied to `" + Gt + "`, expected a single ReactElement."));
        }
        return null;
      }
      return Q(st);
    }
    function we() {
      function st(Ne, vt, Gt, xt, cn) {
        var He = Ne[vt];
        if (!r.isValidElementType(He)) {
          var ut = z(He);
          return new se("Invalid " + xt + " `" + cn + "` of type " + ("`" + ut + "` supplied to `" + Gt + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return Q(st);
    }
    function be(st) {
      function Ne(vt, Gt, xt, cn, He) {
        if (!(vt[Gt] instanceof st)) {
          var ut = st.name || L, oe = _n(vt[Gt]);
          return new se("Invalid " + cn + " `" + He + "` of type " + ("`" + oe + "` supplied to `" + xt + "`, expected ") + ("instance of `" + ut + "`."));
        }
        return null;
      }
      return Q(Ne);
    }
    function q(st) {
      if (!Array.isArray(st))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? m(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : m("Invalid argument supplied to oneOf, expected an array.")), v;
      function Ne(vt, Gt, xt, cn, He) {
        for (var ut = vt[Gt], oe = 0; oe < st.length; oe++)
          if (ne(ut, st[oe]))
            return null;
        var qn = JSON.stringify(st, function(Zt, Jt) {
          var wo = bt(Jt);
          return wo === "symbol" ? String(Jt) : Jt;
        });
        return new se("Invalid " + cn + " `" + He + "` of value `" + String(ut) + "` " + ("supplied to `" + xt + "`, expected one of " + qn + "."));
      }
      return Q(Ne);
    }
    function Te(st) {
      function Ne(vt, Gt, xt, cn, He) {
        if (typeof st != "function")
          return new se("Property `" + He + "` of component `" + xt + "` has invalid PropType notation inside objectOf.");
        var ut = vt[Gt], oe = z(ut);
        if (oe !== "object")
          return new se("Invalid " + cn + " `" + He + "` of type " + ("`" + oe + "` supplied to `" + xt + "`, expected an object."));
        for (var qn in ut)
          if (i(ut, qn)) {
            var Rn = st(ut, qn, xt, cn, He + "." + qn, c);
            if (Rn instanceof Error)
              return Rn;
          }
        return null;
      }
      return Q(Ne);
    }
    function Le(st) {
      if (!Array.isArray(st))
        return process.env.NODE_ENV !== "production" && m("Invalid argument supplied to oneOfType, expected an instance of array."), v;
      for (var Ne = 0; Ne < st.length; Ne++) {
        var vt = st[Ne];
        if (typeof vt != "function")
          return m(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + at(vt) + " at index " + Ne + "."
          ), v;
      }
      function Gt(xt, cn, He, ut, oe) {
        for (var qn = [], Rn = 0; Rn < st.length; Rn++) {
          var Zt = st[Rn], Jt = Zt(xt, cn, He, ut, oe, c);
          if (Jt == null)
            return null;
          Jt.data && i(Jt.data, "expectedType") && qn.push(Jt.data.expectedType);
        }
        var wo = qn.length > 0 ? ", expected one of type [" + qn.join(", ") + "]" : "";
        return new se("Invalid " + ut + " `" + oe + "` supplied to " + ("`" + He + "`" + wo + "."));
      }
      return Q(Gt);
    }
    function je() {
      function st(Ne, vt, Gt, xt, cn) {
        return sn(Ne[vt]) ? null : new se("Invalid " + xt + " `" + cn + "` supplied to " + ("`" + Gt + "`, expected a ReactNode."));
      }
      return Q(st);
    }
    function Ie(st, Ne, vt, Gt, xt) {
      return new se(
        (st || "React class") + ": " + Ne + " type `" + vt + "." + Gt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + xt + "`."
      );
    }
    function Ce(st) {
      function Ne(vt, Gt, xt, cn, He) {
        var ut = vt[Gt], oe = z(ut);
        if (oe !== "object")
          return new se("Invalid " + cn + " `" + He + "` of type `" + oe + "` " + ("supplied to `" + xt + "`, expected `object`."));
        for (var qn in st) {
          var Rn = st[qn];
          if (typeof Rn != "function")
            return Ie(xt, cn, He, qn, bt(Rn));
          var Zt = Rn(ut, qn, xt, cn, He + "." + qn, c);
          if (Zt)
            return Zt;
        }
        return null;
      }
      return Q(Ne);
    }
    function pt(st) {
      function Ne(vt, Gt, xt, cn, He) {
        var ut = vt[Gt], oe = z(ut);
        if (oe !== "object")
          return new se("Invalid " + cn + " `" + He + "` of type `" + oe + "` " + ("supplied to `" + xt + "`, expected `object`."));
        var qn = o({}, vt[Gt], st);
        for (var Rn in qn) {
          var Zt = st[Rn];
          if (i(st, Rn) && typeof Zt != "function")
            return Ie(xt, cn, He, Rn, bt(Zt));
          if (!Zt)
            return new se(
              "Invalid " + cn + " `" + He + "` key `" + Rn + "` supplied to `" + xt + "`.\nBad object: " + JSON.stringify(vt[Gt], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(st), null, "  ")
            );
          var Jt = Zt(ut, Rn, xt, cn, He + "." + Rn, c);
          if (Jt)
            return Jt;
        }
        return null;
      }
      return Q(Ne);
    }
    function sn(st) {
      switch (typeof st) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !st;
        case "object":
          if (Array.isArray(st))
            return st.every(sn);
          if (st === null || g(st))
            return !0;
          var Ne = I(st);
          if (Ne) {
            var vt = Ne.call(st), Gt;
            if (Ne !== st.entries) {
              for (; !(Gt = vt.next()).done; )
                if (!sn(Gt.value))
                  return !1;
            } else
              for (; !(Gt = vt.next()).done; ) {
                var xt = Gt.value;
                if (xt && !sn(xt[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Lt(st, Ne) {
      return st === "symbol" ? !0 : Ne ? Ne["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && Ne instanceof Symbol : !1;
    }
    function z(st) {
      var Ne = typeof st;
      return Array.isArray(st) ? "array" : st instanceof RegExp ? "object" : Lt(Ne, st) ? "symbol" : Ne;
    }
    function bt(st) {
      if (typeof st > "u" || st === null)
        return "" + st;
      var Ne = z(st);
      if (Ne === "object") {
        if (st instanceof Date)
          return "date";
        if (st instanceof RegExp)
          return "regexp";
      }
      return Ne;
    }
    function at(st) {
      var Ne = bt(st);
      switch (Ne) {
        case "array":
        case "object":
          return "an " + Ne;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + Ne;
        default:
          return Ne;
      }
    }
    function _n(st) {
      return !st.constructor || !st.constructor.name ? L : st.constructor.name;
    }
    return Z.checkPropTypes = d, Z.resetWarningCache = d.resetWarningCache, Z.PropTypes = Z, Z;
  }, Zre;
}
var Kre, iue;
function fwe() {
  if (iue)
    return Kre;
  iue = 1;
  var r = lae();
  function o() {
  }
  function c() {
  }
  return c.resetWarningCache = o, Kre = function() {
    function i(v, g, C, O, R, I) {
      if (I !== r) {
        var L = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw L.name = "Invariant Violation", L;
      }
    }
    i.isRequired = i;
    function d() {
      return i;
    }
    var m = {
      array: i,
      bigint: i,
      bool: i,
      func: i,
      number: i,
      object: i,
      string: i,
      symbol: i,
      any: i,
      arrayOf: d,
      element: i,
      elementType: i,
      instanceOf: d,
      node: i,
      objectOf: d,
      oneOf: d,
      oneOfType: d,
      shape: d,
      exact: d,
      checkPropTypes: c,
      resetWarningCache: o
    };
    return m.PropTypes = m, m;
  }, Kre;
}
if (process.env.NODE_ENV !== "production") {
  var mwe = cj(), pwe = !0;
  tse.exports = dwe()(mwe.isElement, pwe);
} else
  tse.exports = fwe()();
var Bn = tse.exports;
const _ = /* @__PURE__ */ Ku(Bn);
function hwe(r) {
  if (r === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return r;
}
function xh(r) {
  return r === void 0;
}
function Npe(r, o, c) {
  return r === r && (c !== void 0 && (r = r <= c ? r : c), o !== void 0 && (r = r >= o ? r : o)), r;
}
var gwe = /\s/;
function vwe(r) {
  for (var o = r.length; o-- && gwe.test(r.charAt(o)); )
    ;
  return o;
}
var bwe = /^\s+/;
function Rpe(r) {
  return r && r.slice(0, vwe(r) + 1).replace(bwe, "");
}
var cue = 0 / 0, ywe = /^[-+]0x[0-9a-f]+$/i, Swe = /^0b[01]+$/i, wwe = /^0o[0-7]+$/i, Ewe = parseInt;
function UD(r) {
  if (typeof r == "number")
    return r;
  if (b2(r))
    return cue;
  if (Fv(r)) {
    var o = typeof r.valueOf == "function" ? r.valueOf() : r;
    r = Fv(o) ? o + "" : o;
  }
  if (typeof r != "string")
    return r === 0 ? r : +r;
  r = Rpe(r);
  var c = Swe.test(r);
  return c || wwe.test(r) ? Ewe(r.slice(2), c ? 2 : 8) : ywe.test(r) ? cue : +r;
}
var lue = 1 / 0, Cwe = 17976931348623157e292;
function WD(r) {
  if (!r)
    return r === 0 ? r : 0;
  if (r = UD(r), r === lue || r === -lue) {
    var o = r < 0 ? -1 : 1;
    return o * Cwe;
  }
  return r === r ? r : 0;
}
function cC(r) {
  var o = WD(r), c = o % 1;
  return o === o ? c ? o - c : o : 0;
}
function xwe(r, o, c) {
  return r = BS(r), c = c == null ? 0 : Npe(cC(c), 0, r.length), o = fj(o), r.slice(c, c + o.length) == o;
}
function Ppe(r, o) {
  for (var c = -1, i = r == null ? 0 : r.length, d = 0, m = []; ++c < i; ) {
    var v = r[c];
    o(v, c, r) && (m[d++] = v);
  }
  return m;
}
function Twe(r) {
  return function(o, c, i) {
    for (var d = -1, m = Object(o), v = i(o), g = v.length; g--; ) {
      var C = v[r ? g : ++d];
      if (c(m[C], C, m) === !1)
        break;
    }
    return o;
  };
}
var _we = Twe();
const Owe = _we;
function Dpe(r, o) {
  for (var c = -1, i = Array(r); ++c < r; )
    i[c] = o(c);
  return i;
}
function Awe() {
  return !1;
}
var $pe = typeof exports == "object" && exports && !exports.nodeType && exports, uue = $pe && typeof module == "object" && module && !module.nodeType && module, kwe = uue && uue.exports === $pe, due = kwe ? Ph.Buffer : void 0, Nwe = due ? due.isBuffer : void 0, Rwe = Nwe || Awe;
const pB = Rwe;
var Pwe = "[object Arguments]", Dwe = "[object Array]", $we = "[object Boolean]", Iwe = "[object Date]", Mwe = "[object Error]", Fwe = "[object Function]", Lwe = "[object Map]", Bwe = "[object Number]", Hwe = "[object Object]", zwe = "[object RegExp]", Vwe = "[object Set]", Uwe = "[object String]", Wwe = "[object WeakMap]", jwe = "[object ArrayBuffer]", qwe = "[object DataView]", Gwe = "[object Float32Array]", Zwe = "[object Float64Array]", Kwe = "[object Int8Array]", Ywe = "[object Int16Array]", Qwe = "[object Int32Array]", Xwe = "[object Uint8Array]", Jwe = "[object Uint8ClampedArray]", eEe = "[object Uint16Array]", tEe = "[object Uint32Array]", ul = {};
ul[Gwe] = ul[Zwe] = ul[Kwe] = ul[Ywe] = ul[Qwe] = ul[Xwe] = ul[Jwe] = ul[eEe] = ul[tEe] = !0;
ul[Pwe] = ul[Dwe] = ul[jwe] = ul[$we] = ul[qwe] = ul[Iwe] = ul[Mwe] = ul[Fwe] = ul[Lwe] = ul[Bwe] = ul[Hwe] = ul[zwe] = ul[Vwe] = ul[Uwe] = ul[Wwe] = !1;
function nEe(r) {
  return Nh(r) && iae(r.length) && !!ul[XS(r)];
}
function G$(r) {
  return function(o) {
    return r(o);
  };
}
var Ipe = typeof exports == "object" && exports && !exports.nodeType && exports, JL = Ipe && typeof module == "object" && module && !module.nodeType && module, rEe = JL && JL.exports === Ipe, Yre = rEe && wpe.process, oEe = function() {
  try {
    var r = JL && JL.require && JL.require("util").types;
    return r || Yre && Yre.binding && Yre.binding("util");
  } catch {
  }
}();
const QD = oEe;
var fue = QD && QD.isTypedArray, sEe = fue ? G$(fue) : nEe;
const uae = sEe;
var aEe = Object.prototype, iEe = aEe.hasOwnProperty;
function Mpe(r, o) {
  var c = qc(r), i = !c && mj(r), d = !c && !i && pB(r), m = !c && !i && !d && uae(r), v = c || i || d || m, g = v ? Dpe(r.length, String) : [], C = g.length;
  for (var O in r)
    (o || iEe.call(r, O)) && !(v && // Safari 9 has enumerable `arguments.length` in strict mode.
    (O == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    d && (O == "offset" || O == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    m && (O == "buffer" || O == "byteLength" || O == "byteOffset") || // Skip index properties.
    BB(O, C))) && g.push(O);
  return g;
}
var cEe = Object.prototype;
function gj(r) {
  var o = r && r.constructor, c = typeof o == "function" && o.prototype || cEe;
  return r === c;
}
function Fpe(r, o) {
  return function(c) {
    return r(o(c));
  };
}
var lEe = Fpe(Object.keys, Object);
const uEe = lEe;
var dEe = Object.prototype, fEe = dEe.hasOwnProperty;
function dae(r) {
  if (!gj(r))
    return uEe(r);
  var o = [];
  for (var c in Object(r))
    fEe.call(r, c) && c != "constructor" && o.push(c);
  return o;
}
function JS(r) {
  return r != null && iae(r.length) && !YD(r);
}
function Yf(r) {
  return JS(r) ? Mpe(r) : dae(r);
}
function fae(r, o) {
  return r && Owe(r, o, Yf);
}
function mEe(r, o) {
  return function(c, i) {
    if (c == null)
      return c;
    if (!JS(c))
      return r(c, i);
    for (var d = c.length, m = o ? d : -1, v = Object(c); (o ? m-- : ++m < d) && i(v[m], m, v) !== !1; )
      ;
    return c;
  };
}
var pEe = mEe(fae);
const Rk = pEe;
function hEe(r, o) {
  var c = [];
  return Rk(r, function(i, d, m) {
    o(i, d, m) && c.push(i);
  }), c;
}
function gEe() {
  this.__data__ = new BC(), this.size = 0;
}
function vEe(r) {
  var o = this.__data__, c = o.delete(r);
  return this.size = o.size, c;
}
function bEe(r) {
  return this.__data__.get(r);
}
function yEe(r) {
  return this.__data__.has(r);
}
var SEe = 200;
function wEe(r, o) {
  var c = this.__data__;
  if (c instanceof BC) {
    var i = c.__data__;
    if (!mB || i.length < SEe - 1)
      return i.push([r, o]), this.size = ++c.size, this;
    c = this.__data__ = new HC(i);
  }
  return c.set(r, o), this.size = c.size, this;
}
function MS(r) {
  var o = this.__data__ = new BC(r);
  this.size = o.size;
}
MS.prototype.clear = gEe;
MS.prototype.delete = vEe;
MS.prototype.get = bEe;
MS.prototype.has = yEe;
MS.prototype.set = wEe;
var EEe = "__lodash_hash_undefined__";
function CEe(r) {
  return this.__data__.set(r, EEe), this;
}
function xEe(r) {
  return this.__data__.has(r);
}
function GA(r) {
  var o = -1, c = r == null ? 0 : r.length;
  for (this.__data__ = new HC(); ++o < c; )
    this.add(r[o]);
}
GA.prototype.add = GA.prototype.push = CEe;
GA.prototype.has = xEe;
function Lpe(r, o) {
  for (var c = -1, i = r == null ? 0 : r.length; ++c < i; )
    if (o(r[c], c, r))
      return !0;
  return !1;
}
function hB(r, o) {
  return r.has(o);
}
var TEe = 1, _Ee = 2;
function Bpe(r, o, c, i, d, m) {
  var v = c & TEe, g = r.length, C = o.length;
  if (g != C && !(v && C > g))
    return !1;
  var O = m.get(r), R = m.get(o);
  if (O && R)
    return O == o && R == r;
  var I = -1, L = !0, Z = c & _Ee ? new GA() : void 0;
  for (m.set(r, o), m.set(o, r); ++I < g; ) {
    var ne = r[I], se = o[I];
    if (i)
      var Q = v ? i(se, ne, I, o, r, m) : i(ne, se, I, r, o, m);
    if (Q !== void 0) {
      if (Q)
        continue;
      L = !1;
      break;
    }
    if (Z) {
      if (!Lpe(o, function(he, ue) {
        if (!hB(Z, ue) && (ne === he || d(ne, he, c, i, m)))
          return Z.push(ue);
      })) {
        L = !1;
        break;
      }
    } else if (!(ne === se || d(ne, se, c, i, m))) {
      L = !1;
      break;
    }
  }
  return m.delete(r), m.delete(o), L;
}
var OEe = Ph.Uint8Array;
const OW = OEe;
function AEe(r) {
  var o = -1, c = Array(r.size);
  return r.forEach(function(i, d) {
    c[++o] = [d, i];
  }), c;
}
function mae(r) {
  var o = -1, c = Array(r.size);
  return r.forEach(function(i) {
    c[++o] = i;
  }), c;
}
var kEe = 1, NEe = 2, REe = "[object Boolean]", PEe = "[object Date]", DEe = "[object Error]", $Ee = "[object Map]", IEe = "[object Number]", MEe = "[object RegExp]", FEe = "[object Set]", LEe = "[object String]", BEe = "[object Symbol]", HEe = "[object ArrayBuffer]", zEe = "[object DataView]", mue = py ? py.prototype : void 0, Qre = mue ? mue.valueOf : void 0;
function VEe(r, o, c, i, d, m, v) {
  switch (c) {
    case zEe:
      if (r.byteLength != o.byteLength || r.byteOffset != o.byteOffset)
        return !1;
      r = r.buffer, o = o.buffer;
    case HEe:
      return !(r.byteLength != o.byteLength || !m(new OW(r), new OW(o)));
    case REe:
    case PEe:
    case IEe:
      return lj(+r, +o);
    case DEe:
      return r.name == o.name && r.message == o.message;
    case MEe:
    case LEe:
      return r == o + "";
    case $Ee:
      var g = AEe;
    case FEe:
      var C = i & kEe;
      if (g || (g = mae), r.size != o.size && !C)
        return !1;
      var O = v.get(r);
      if (O)
        return O == o;
      i |= NEe, v.set(r, o);
      var R = Bpe(g(r), g(o), i, d, m, v);
      return v.delete(r), R;
    case BEe:
      if (Qre)
        return Qre.call(r) == Qre.call(o);
  }
  return !1;
}
function pae(r, o) {
  for (var c = -1, i = o.length, d = r.length; ++c < i; )
    r[d + c] = o[c];
  return r;
}
function Hpe(r, o, c) {
  var i = o(r);
  return qc(r) ? i : pae(i, c(r));
}
function zpe() {
  return [];
}
var UEe = Object.prototype, WEe = UEe.propertyIsEnumerable, pue = Object.getOwnPropertySymbols, jEe = pue ? function(r) {
  return r == null ? [] : (r = Object(r), Ppe(pue(r), function(o) {
    return WEe.call(r, o);
  }));
} : zpe;
const hae = jEe;
function nse(r) {
  return Hpe(r, Yf, hae);
}
var qEe = 1, GEe = Object.prototype, ZEe = GEe.hasOwnProperty;
function KEe(r, o, c, i, d, m) {
  var v = c & qEe, g = nse(r), C = g.length, O = nse(o), R = O.length;
  if (C != R && !v)
    return !1;
  for (var I = C; I--; ) {
    var L = g[I];
    if (!(v ? L in o : ZEe.call(o, L)))
      return !1;
  }
  var Z = m.get(r), ne = m.get(o);
  if (Z && ne)
    return Z == o && ne == r;
  var se = !0;
  m.set(r, o), m.set(o, r);
  for (var Q = v; ++I < C; ) {
    L = g[I];
    var he = r[L], ue = o[L];
    if (i)
      var G = v ? i(ue, he, L, o, r, m) : i(he, ue, L, r, o, m);
    if (!(G === void 0 ? he === ue || d(he, ue, c, i, m) : G)) {
      se = !1;
      break;
    }
    Q || (Q = L == "constructor");
  }
  if (se && !Q) {
    var me = r.constructor, we = o.constructor;
    me != we && "constructor" in r && "constructor" in o && !(typeof me == "function" && me instanceof me && typeof we == "function" && we instanceof we) && (se = !1);
  }
  return m.delete(r), m.delete(o), se;
}
var YEe = Ak(Ph, "DataView");
const rse = YEe;
var QEe = Ak(Ph, "Promise");
const ose = QEe;
var XEe = Ak(Ph, "Set");
const jD = XEe;
var JEe = Ak(Ph, "WeakMap");
const gB = JEe;
var hue = "[object Map]", eCe = "[object Object]", gue = "[object Promise]", vue = "[object Set]", bue = "[object WeakMap]", yue = "[object DataView]", tCe = Ok(rse), nCe = Ok(mB), rCe = Ok(ose), oCe = Ok(jD), sCe = Ok(gB), RA = XS;
(rse && RA(new rse(new ArrayBuffer(1))) != yue || mB && RA(new mB()) != hue || ose && RA(ose.resolve()) != gue || jD && RA(new jD()) != vue || gB && RA(new gB()) != bue) && (RA = function(r) {
  var o = XS(r), c = o == eCe ? r.constructor : void 0, i = c ? Ok(c) : "";
  if (i)
    switch (i) {
      case tCe:
        return yue;
      case nCe:
        return hue;
      case rCe:
        return gue;
      case oCe:
        return vue;
      case sCe:
        return bue;
    }
  return o;
});
const ZA = RA;
var aCe = 1, Sue = "[object Arguments]", wue = "[object Array]", K9 = "[object Object]", iCe = Object.prototype, Eue = iCe.hasOwnProperty;
function cCe(r, o, c, i, d, m) {
  var v = qc(r), g = qc(o), C = v ? wue : ZA(r), O = g ? wue : ZA(o);
  C = C == Sue ? K9 : C, O = O == Sue ? K9 : O;
  var R = C == K9, I = O == K9, L = C == O;
  if (L && pB(r)) {
    if (!pB(o))
      return !1;
    v = !0, R = !1;
  }
  if (L && !R)
    return m || (m = new MS()), v || uae(r) ? Bpe(r, o, c, i, d, m) : VEe(r, o, C, c, i, d, m);
  if (!(c & aCe)) {
    var Z = R && Eue.call(r, "__wrapped__"), ne = I && Eue.call(o, "__wrapped__");
    if (Z || ne) {
      var se = Z ? r.value() : r, Q = ne ? o.value() : o;
      return m || (m = new MS()), d(se, Q, c, i, m);
    }
  }
  return L ? (m || (m = new MS()), KEe(r, o, c, i, d, m)) : !1;
}
function vj(r, o, c, i, d) {
  return r === o ? !0 : r == null || o == null || !Nh(r) && !Nh(o) ? r !== r && o !== o : cCe(r, o, c, i, vj, d);
}
var lCe = 1, uCe = 2;
function dCe(r, o, c, i) {
  var d = c.length, m = d, v = !i;
  if (r == null)
    return !m;
  for (r = Object(r); d--; ) {
    var g = c[d];
    if (v && g[2] ? g[1] !== r[g[0]] : !(g[0] in r))
      return !1;
  }
  for (; ++d < m; ) {
    g = c[d];
    var C = g[0], O = r[C], R = g[1];
    if (v && g[2]) {
      if (O === void 0 && !(C in r))
        return !1;
    } else {
      var I = new MS();
      if (i)
        var L = i(O, R, C, r, o, I);
      if (!(L === void 0 ? vj(R, O, lCe | uCe, i, I) : L))
        return !1;
    }
  }
  return !0;
}
function Vpe(r) {
  return r === r && !Fv(r);
}
function fCe(r) {
  for (var o = Yf(r), c = o.length; c--; ) {
    var i = o[c], d = r[i];
    o[c] = [i, d, Vpe(d)];
  }
  return o;
}
function Upe(r, o) {
  return function(c) {
    return c == null ? !1 : c[r] === o && (o !== void 0 || r in Object(c));
  };
}
function mCe(r) {
  var o = fCe(r);
  return o.length == 1 && o[0][2] ? Upe(o[0][0], o[0][1]) : function(c) {
    return c === r || dCe(c, r, o);
  };
}
function Oh(r, o, c) {
  var i = r == null ? void 0 : HB(r, o);
  return i === void 0 ? c : i;
}
function pCe(r, o) {
  return r != null && o in Object(r);
}
function Wpe(r, o) {
  return r != null && Tpe(r, o, pCe);
}
var hCe = 1, gCe = 2;
function vCe(r, o) {
  return aae(r) && Vpe(o) ? Upe(kk(r), o) : function(c) {
    var i = Oh(c, r);
    return i === void 0 && i === o ? Wpe(c, r) : vj(o, i, hCe | gCe);
  };
}
function jpe(r) {
  return function(o) {
    return o == null ? void 0 : o[r];
  };
}
function bCe(r) {
  return function(o) {
    return HB(o, r);
  };
}
function yCe(r) {
  return aae(r) ? jpe(kk(r)) : bCe(r);
}
function R1(r) {
  return typeof r == "function" ? r : r == null ? zC : typeof r == "object" ? qc(r) ? vCe(r[0], r[1]) : mCe(r) : yCe(r);
}
function AW(r, o) {
  var c = qc(r) ? Ppe : hEe;
  return c(r, R1(o));
}
var SCe = "[object Map]", wCe = "[object Set]", ECe = Object.prototype, CCe = ECe.hasOwnProperty;
function u2(r) {
  if (r == null)
    return !0;
  if (JS(r) && (qc(r) || typeof r == "string" || typeof r.splice == "function" || pB(r) || uae(r) || mj(r)))
    return !r.length;
  var o = ZA(r);
  if (o == SCe || o == wCe)
    return !r.size;
  if (gj(r))
    return !dae(r).length;
  for (var c in r)
    if (CCe.call(r, c))
      return !1;
  return !0;
}
function qpe(r, o, c, i) {
  for (var d = r.length, m = c + (i ? 1 : -1); i ? m-- : ++m < d; )
    if (o(r[m], m, r))
      return m;
  return -1;
}
function xCe(r) {
  return r !== r;
}
function TCe(r, o, c) {
  for (var i = c - 1, d = r.length; ++i < d; )
    if (r[i] === o)
      return i;
  return -1;
}
function bj(r, o, c) {
  return o === o ? TCe(r, o, c) : qpe(r, xCe, c);
}
function yj(r, o) {
  var c = r == null ? 0 : r.length;
  return !!c && bj(r, o, 0) > -1;
}
function gae(r, o, c) {
  for (var i = -1, d = r == null ? 0 : r.length; ++i < d; )
    if (c(o, r[i]))
      return !0;
  return !1;
}
var _Ce = Math.min;
function OCe(r, o, c) {
  for (var i = c ? gae : yj, d = r[0].length, m = r.length, v = m, g = Array(m), C = 1 / 0, O = []; v--; ) {
    var R = r[v];
    v && o && (R = E1(R, G$(o))), C = _Ce(R.length, C), g[v] = !c && (o || d >= 120 && R.length >= 120) ? new GA(v && R) : void 0;
  }
  R = r[0];
  var I = -1, L = g[0];
  e:
    for (; ++I < d && O.length < C; ) {
      var Z = R[I], ne = o ? o(Z) : Z;
      if (Z = c || Z !== 0 ? Z : 0, !(L ? hB(L, ne) : i(O, ne, c))) {
        for (v = m; --v; ) {
          var se = g[v];
          if (!(se ? hB(se, ne) : i(r[v], ne, c)))
            continue e;
        }
        L && L.push(ne), O.push(Z);
      }
    }
  return O;
}
function vB(r) {
  return Nh(r) && JS(r);
}
function ACe(r) {
  return vB(r) ? r : [];
}
var kCe = Nk(function(r) {
  var o = E1(r, ACe);
  return o.length && o[0] === r[0] ? OCe(o) : [];
});
const NCe = kCe;
function vae(r, o) {
  for (var c = -1, i = r == null ? 0 : r.length; ++c < i && o(r[c], c, r) !== !1; )
    ;
  return r;
}
function Gpe(r) {
  return typeof r == "function" ? r : zC;
}
function C1(r, o) {
  var c = qc(r) ? vae : Rk;
  return c(r, Gpe(o));
}
var sse = function(o) {
  return "default" + (o[0].toUpperCase() + o.slice(1));
}, RCe = function(o, c, i, d) {
  d === void 0 && (d = !1);
  var m = c[o];
  if (m !== void 0)
    return m;
  if (d) {
    var v = c[sse(o)];
    if (v !== void 0)
      return v;
    if (i) {
      var g = i[o];
      if (g !== void 0)
        return g;
    }
  }
  if (o === "checked")
    return !1;
  if (o === "value")
    return c.multiple ? [] : "";
}, P1 = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var c, i = arguments.length, d = new Array(i), m = 0; m < i; m++)
      d[m] = arguments[m];
    c = r.call.apply(r, [this].concat(d)) || this;
    var v = c.constructor, g = v.autoControlledProps, C = v.getAutoControlledStateFromProps, O = xn(hwe(c), "getInitialAutoControlledState", c.props) || {};
    if (process.env.NODE_ENV !== "production") {
      var R = c.constructor, I = R.defaultProps, L = R.name, Z = R.propTypes, ne = R.getDerivedStateFromProps;
      ne !== o.getDerivedStateFromProps && console.error("Auto controlled " + L + " must specify a static getAutoControlledStateFromProps() instead of getDerivedStateFromProps()."), C1(g, function(ue) {
        var G = sse(ue);
        iC(Z, G) || console.error(L + ' is missing "' + G + '" propTypes validation for auto controlled prop "' + ue + '".'), iC(Z, ue) || console.error(L + ' is missing propTypes validation for auto controlled prop "' + ue + '".');
      });
      var se = NCe(g, Yf(I));
      u2(se) || console.error(["Do not set defaultProps for autoControlledProps. You can set defaults by", "setting state in the constructor or using an ES7 property initializer", "(https://babeljs.io/blog/2015/06/07/react-on-es6-plus#property-initializers)", "See " + L + ' props: "' + se + '".'].join(" "));
      var Q = AW(g, function(ue) {
        return xwe(ue, "default");
      });
      u2(Q) || console.error(["Do not add default props to autoControlledProps.", "Default props are automatically handled.", "See " + L + ' autoControlledProps: "' + Q + '".'].join(" "));
    }
    var he = g.reduce(function(ue, G) {
      if (ue[G] = RCe(G, c.props, O, !0), process.env.NODE_ENV !== "production") {
        var me = sse(G), we = c.constructor.name;
        !xh(c.props[me]) && !xh(c.props[G]) && console.error(we + ' prop "' + G + '" is auto controlled. Specify either ' + me + " or " + G + ", but not both.");
      }
      return ue;
    }, {});
    return c.state = Be({}, O, he, {
      autoControlledProps: g,
      getAutoControlledStateFromProps: C
    }), c;
  }
  return o.getDerivedStateFromProps = function(i, d) {
    var m = d.autoControlledProps, v = d.getAutoControlledStateFromProps, g = m.reduce(function(O, R) {
      var I = !xh(i[R]);
      return I && (O[R] = i[R]), O;
    }, {});
    if (v) {
      var C = v(i, Be({}, d, g), d);
      return Be({}, g, C);
    }
    return g;
  }, o.getAutoControlledStateFromProps = function() {
    return null;
  }, o;
}(ae.Component);
function PCe(r) {
  return function(o, c, i) {
    var d = Object(o);
    if (!JS(o)) {
      var m = R1(c);
      o = Yf(o), c = function(g) {
        return m(d[g], g, d);
      };
    }
    var v = r(o, c, i);
    return v > -1 ? d[m ? o[v] : v] : void 0;
  };
}
var DCe = Math.max;
function ase(r, o, c) {
  var i = r == null ? 0 : r.length;
  if (!i)
    return -1;
  var d = c == null ? 0 : cC(c);
  return d < 0 && (d = DCe(i + d, 0)), qpe(r, R1(o), d);
}
var $Ce = PCe(ase);
const Zpe = $Ce;
function ICe(r, o) {
  var c;
  return Rk(r, function(i, d, m) {
    return c = o(i, d, m), !c;
  }), !!c;
}
function bB(r, o, c) {
  if (!Fv(c))
    return !1;
  var i = typeof o;
  return (i == "number" ? JS(c) && BB(o, c.length) : i == "string" && o in c) ? lj(c[o], r) : !1;
}
function eB(r, o, c) {
  var i = qc(r) ? Lpe : ICe;
  return c && bB(r, o, c) && (o = void 0), i(r, R1(o));
}
var MCe = function(o, c) {
  return eB(_k.toArray(o), {
    type: c
  });
}, dn = function(o) {
  return o == null || Array.isArray(o) && o.length === 0;
}, tB = {
  1: "one",
  2: "two",
  3: "three",
  4: "four",
  5: "five",
  6: "six",
  7: "seven",
  8: "eight",
  9: "nine",
  10: "ten",
  11: "eleven",
  12: "twelve",
  13: "thirteen",
  14: "fourteen",
  15: "fifteen",
  16: "sixteen"
};
function Cue(r) {
  var o = typeof r;
  return o === "string" || o === "number" ? tB[r] || r : "";
}
var $e = function(o, c) {
  return o && c;
}, _u = function(o, c) {
  return o && o !== !0 && o + " " + c;
}, mi = function(o, c) {
  return o && (o === !0 ? c : o + " " + c);
}, kW = function(o, c) {
  return !o || o === !0 ? null : o.replace("large screen", "large-screen").replace(/ vertically/g, "-vertically").split(" ").map(function(i) {
    return i.replace("-", " ") + " " + c;
  }).join(" ");
}, Dg = function(o) {
  return o === "justified" ? "justified" : _u(o, "aligned");
}, by = function(o) {
  return _u(o, "aligned");
}, Kf = function(o, c, i) {
  if (c === void 0 && (c = ""), i === void 0 && (i = !1), i && o === "equal")
    return "equal width";
  var d = typeof o;
  return (d === "string" || d === "number") && c ? Cue(o) + " " + c : Cue(o);
}, FCe = 200;
function Kpe(r, o, c, i) {
  var d = -1, m = yj, v = !0, g = r.length, C = [], O = o.length;
  if (!g)
    return C;
  c && (o = E1(o, G$(c))), i ? (m = gae, v = !1) : o.length >= FCe && (m = hB, v = !1, o = new GA(o));
  e:
    for (; ++d < g; ) {
      var R = r[d], I = c == null ? R : c(R);
      if (R = i || R !== 0 ? R : 0, v && I === I) {
        for (var L = O; L--; )
          if (o[L] === I)
            continue e;
        C.push(R);
      } else
        m(o, I, i) || C.push(R);
    }
  return C;
}
var xue = py ? py.isConcatSpreadable : void 0;
function LCe(r) {
  return qc(r) || mj(r) || !!(xue && r && r[xue]);
}
function zB(r, o, c, i, d) {
  var m = -1, v = r.length;
  for (c || (c = LCe), d || (d = []); ++m < v; ) {
    var g = r[m];
    o > 0 && c(g) ? o > 1 ? zB(g, o - 1, c, i, d) : pae(d, g) : i || (d[d.length] = g);
  }
  return d;
}
var BCe = Nk(function(r, o) {
  return vB(r) ? Kpe(r, zB(o, 1, vB, !0)) : [];
});
const ise = BCe;
function Ype(r, o, c) {
  var i = r.length;
  return c = c === void 0 ? i : c, !o && c >= i ? r : hj(r, o, c);
}
function HCe(r, o) {
  for (var c = r.length; c-- && bj(o, r[c], 0) > -1; )
    ;
  return c;
}
function zCe(r, o) {
  for (var c = -1, i = r.length; ++c < i && bj(o, r[c], 0) > -1; )
    ;
  return c;
}
function VCe(r) {
  return r.split("");
}
var UCe = "\\ud800-\\udfff", WCe = "\\u0300-\\u036f", jCe = "\\ufe20-\\ufe2f", qCe = "\\u20d0-\\u20ff", GCe = WCe + jCe + qCe, ZCe = "\\ufe0e\\ufe0f", KCe = "\\u200d", YCe = RegExp("[" + KCe + UCe + GCe + ZCe + "]");
function bae(r) {
  return YCe.test(r);
}
var Qpe = "\\ud800-\\udfff", QCe = "\\u0300-\\u036f", XCe = "\\ufe20-\\ufe2f", JCe = "\\u20d0-\\u20ff", exe = QCe + XCe + JCe, txe = "\\ufe0e\\ufe0f", nxe = "[" + Qpe + "]", cse = "[" + exe + "]", lse = "\\ud83c[\\udffb-\\udfff]", rxe = "(?:" + cse + "|" + lse + ")", Xpe = "[^" + Qpe + "]", Jpe = "(?:\\ud83c[\\udde6-\\uddff]){2}", ehe = "[\\ud800-\\udbff][\\udc00-\\udfff]", oxe = "\\u200d", the = rxe + "?", nhe = "[" + txe + "]?", sxe = "(?:" + oxe + "(?:" + [Xpe, Jpe, ehe].join("|") + ")" + nhe + the + ")*", axe = nhe + the + sxe, ixe = "(?:" + [Xpe + cse + "?", cse, Jpe, ehe, nxe].join("|") + ")", cxe = RegExp(lse + "(?=" + lse + ")|" + ixe + axe, "g");
function lxe(r) {
  return r.match(cxe) || [];
}
function use(r) {
  return bae(r) ? lxe(r) : VCe(r);
}
function uxe(r, o, c) {
  if (r = BS(r), r && (c || o === void 0))
    return Rpe(r);
  if (!r || !(o = fj(o)))
    return r;
  var i = use(r), d = use(o), m = zCe(i, d), v = HCe(i, d) + 1;
  return Ype(i, m, v).join("");
}
function Sj(r, o, c) {
  o == "__proto__" && _W ? _W(r, o, {
    configurable: !0,
    enumerable: !0,
    value: c,
    writable: !0
  }) : r[o] = c;
}
var dxe = Object.prototype, fxe = dxe.hasOwnProperty;
function yae(r, o, c) {
  var i = r[o];
  (!(fxe.call(r, o) && lj(i, c)) || c === void 0 && !(o in r)) && Sj(r, o, c);
}
function rhe(r, o, c, i) {
  if (!Fv(r))
    return r;
  o = LB(o, r);
  for (var d = -1, m = o.length, v = m - 1, g = r; g != null && ++d < m; ) {
    var C = kk(o[d]), O = c;
    if (C === "__proto__" || C === "constructor" || C === "prototype")
      return r;
    if (d != v) {
      var R = g[C];
      O = i ? i(R, C, g) : void 0, O === void 0 && (O = Fv(R) ? R : BB(o[d + 1]) ? [] : {});
    }
    yae(g, C, O), g = g[C];
  }
  return r;
}
function ohe(r, o, c) {
  for (var i = -1, d = o.length, m = {}; ++i < d; ) {
    var v = o[i], g = HB(r, v);
    c(g, v) && rhe(m, LB(v, r), g);
  }
  return m;
}
function mxe(r, o) {
  return ohe(r, o, function(c, i) {
    return Wpe(r, i);
  });
}
function pxe(r) {
  var o = r == null ? 0 : r.length;
  return o ? zB(r, 1) : [];
}
function hxe(r) {
  return cae(_pe(r, void 0, pxe), r + "");
}
var gxe = hxe(function(r, o) {
  return r == null ? {} : mxe(r, o);
});
const wj = gxe;
var vxe = Fpe(Object.getPrototypeOf, Object);
const Sae = vxe;
var bxe = "[object Object]", yxe = Function.prototype, Sxe = Object.prototype, she = yxe.toString, wxe = Sxe.hasOwnProperty, Exe = she.call(Object);
function y2(r) {
  if (!Nh(r) || XS(r) != bxe)
    return !1;
  var o = Sae(r);
  if (o === null)
    return !0;
  var c = wxe.call(o, "constructor") && o.constructor;
  return typeof c == "function" && c instanceof c && she.call(c) == Exe;
}
function ws(r) {
  return r == null;
}
function Cxe(r, o, c) {
  for (var i = -1, d = r.length; ++i < d; ) {
    var m = r[i], v = o(m);
    if (v != null && (g === void 0 ? v === v && !b2(v) : c(v, g)))
      var g = v, C = m;
  }
  return C;
}
function xxe(r, o) {
  return r < o;
}
function Tue(r) {
  return r && r.length ? Cxe(r, zC, xxe) : void 0;
}
function Txe(r, o) {
  for (var c, i = -1, d = r.length; ++i < d; ) {
    var m = o(r[i]);
    m !== void 0 && (c = c === void 0 ? m : c + m);
  }
  return c;
}
function _ue(r) {
  return r && r.length ? Txe(r, zC) : 0;
}
function ahe(r, o) {
  var c = -1, i = JS(r) ? Array(r.length) : [];
  return Rk(r, function(d, m, v) {
    i[++c] = o(d, m, v);
  }), i;
}
function fi(r, o) {
  var c = qc(r) ? E1 : ahe;
  return c(r, R1(o));
}
function _xe(r, o) {
  var c = r.length;
  for (r.sort(o); c--; )
    r[c] = r[c].value;
  return r;
}
function Oxe(r, o) {
  if (r !== o) {
    var c = r !== void 0, i = r === null, d = r === r, m = b2(r), v = o !== void 0, g = o === null, C = o === o, O = b2(o);
    if (!g && !O && !m && r > o || m && v && C && !g && !O || i && v && C || !c && C || !d)
      return 1;
    if (!i && !m && !O && r < o || O && c && d && !i && !m || g && c && d || !v && d || !C)
      return -1;
  }
  return 0;
}
function Axe(r, o, c) {
  for (var i = -1, d = r.criteria, m = o.criteria, v = d.length, g = c.length; ++i < v; ) {
    var C = Oxe(d[i], m[i]);
    if (C) {
      if (i >= g)
        return C;
      var O = c[i];
      return C * (O == "desc" ? -1 : 1);
    }
  }
  return r.index - o.index;
}
function kxe(r, o, c) {
  o.length ? o = E1(o, function(m) {
    return qc(m) ? function(v) {
      return HB(v, m.length === 1 ? m[0] : m);
    } : m;
  }) : o = [zC];
  var i = -1;
  o = E1(o, G$(R1));
  var d = ahe(r, function(m, v, g) {
    var C = E1(o, function(O) {
      return O(m);
    });
    return { criteria: C, index: ++i, value: m };
  });
  return _xe(d, function(m, v) {
    return Axe(m, v, c);
  });
}
var Nxe = Nk(function(r, o) {
  if (r == null)
    return [];
  var c = o.length;
  return c > 1 && bB(r, o[0], o[1]) ? o = [] : c > 2 && bB(o[0], o[1], o[2]) && (o = [o[0]]), kxe(r, zB(o, 1), []);
});
const Rxe = Nxe;
function Pxe(r, o, c) {
  return r && r.length ? (o = c || o === void 0 ? 1 : cC(o), hj(r, 0, o < 0 ? 0 : o)) : [];
}
var ihe = function() {
  return 0;
};
if (process.env.NODE_ENV !== "production") {
  var Xre = [], Oue = [];
  ihe = function(o, c) {
    if (o === c)
      return 0;
    var i = o.length, d = c.length;
    if (i === 0)
      return d;
    if (d === 0)
      return i;
    for (var m, v, g, C, O = 0, R = 0; O < i; )
      Oue[O] = o.charCodeAt(O), Xre[O] = ++O;
    for (; R < d; )
      for (m = c.charCodeAt(R), g = R++, v = R, O = 0; O < i; O++)
        C = m === Oue[O] ? g : g + 1, g = Xre[O], v = Xre[O] = g > v ? C > v ? v + 1 : C : C > g ? g + 1 : C;
    return v;
  };
}
const Aue = ihe;
var Dxe = function() {
  var o;
  return (o = Object.prototype.toString).call.apply(o, arguments);
}, dse = function(o, c) {
  if (o[c] !== void 0 && !(typeof Element > "u") && !(o[c] instanceof Element))
    return new Error('Invalid prop "' + c + '" supplied, expected a DOM node.');
}, che = function(o) {
  if (!Array.isArray(o))
    throw new Error("Invalid argument supplied to suggest, expected an instance of array.");
  var c = FB(function(d) {
    var m = d.split(" ");
    return Pxe(Rxe(fi(o, function(v) {
      var g = v.split(" "), C = _ue(fi(fi(m, function(R) {
        return fi(g, function(I) {
          return Aue(R, I);
        });
      }), Tue)), O = _ue(fi(fi(g, function(R) {
        return fi(m, function(I) {
          return Aue(R, I);
        });
      }), Tue));
      return {
        suggestion: v,
        score: C + O
      };
    }), ["score", "suggestion"]), 3);
  }), i = o.reduce(function(d, m) {
    return d[m.split(" ").sort().join(" ")] = !0, d;
  }, {});
  return function(d, m, v) {
    var g = d[m];
    if (!(!g || i[g])) {
      var C = g.split(" ").sort().join(" ");
      if (!i[C]) {
        var O = c(g);
        if (!O.some(function(R) {
          return R.score === 0;
        }))
          return new Error(["Invalid prop `" + m + "` of value `" + g + "` supplied to `" + v + "`.", `

Instead of \`` + g + "`, did you mean:", O.map(function(R) {
            return `
  - ` + R.suggestion;
          }).join(""), `
`].join(""));
      }
    }
  };
}, Go = function(o) {
  return function(c, i, d) {
    if (!Array.isArray(o))
      throw new Error(["Invalid argument supplied to disallow, expected an instance of array.", " See `" + i + "` prop in `" + d + "`."].join(""));
    if (!(ws(c[i]) || c[i] === !1)) {
      var m = o.reduce(function(v, g) {
        return !ws(c[g]) && c[g] !== !1 ? [].concat(v, [g]) : v;
      }, []);
      if (m.length > 0)
        return new Error(["Prop `" + i + "` in `" + d + "` conflicts with props: `" + m.join("`, `") + "`.", "They cannot be defined together, choose one or the other."].join(" "));
    }
  };
}, co = function(o) {
  return function(c, i, d) {
    for (var m = arguments.length, v = new Array(m > 3 ? m - 3 : 0), g = 3; g < m; g++)
      v[g - 3] = arguments[g];
    if (!Array.isArray(o))
      throw new Error(["Invalid argument supplied to every, expected an instance of array.", "See `" + i + "` prop in `" + d + "`."].join(" "));
    var C = [];
    return o.forEach(function(O) {
      if (typeof O != "function")
        throw new Error('every() argument "validators" should contain functions, found: ' + Dxe(O) + ".");
      var R = O.apply(void 0, [c, i, d].concat(v));
      R && C.push(R);
    }), C[0];
  };
}, lhe = function(o, c) {
  return function(i, d, m) {
    for (var v = arguments.length, g = new Array(v > 3 ? v - 3 : 0), C = 3; C < v; C++)
      g[C - 3] = arguments[C];
    if (!y2(o))
      throw new Error(["Invalid argument supplied to givenProps, expected an object.", "See `" + d + "` prop in `" + m + "`."].join(" "));
    if (typeof c != "function")
      throw new Error(["Invalid argument supplied to givenProps, expected a function.", "See `" + d + "` prop in `" + m + "`."].join(" "));
    var O = Yf(o).every(function(L) {
      var Z = o[L];
      return typeof Z == "function" ? !Z.apply(void 0, [i, L, m].concat(g)) : Z === i[d];
    });
    if (O) {
      var R = c.apply(void 0, [i, d, m].concat(g));
      if (R) {
        var I = "{ " + Yf(wj(Yf(o), i)).map(function(L) {
          var Z = i[L], ne = Z;
          return typeof Z == "string" ? ne = '"' + Z + '"' : Array.isArray(Z) ? ne = "[" + Z.join(", ") + "]" : Fv(Z) && (ne = "{...}"), L + ": " + ne;
        }).join(", ") + " }";
        return R.message = "Given props " + I + ": " + R.message, R;
      }
    }
  };
}, _h = function(o) {
  return function(c, i, d) {
    if (!Array.isArray(o))
      throw new Error(["Invalid `requiredProps` argument supplied to require, expected an instance of array.", " See `" + i + "` prop in `" + d + "`."].join(""));
    if (c[i] !== void 0) {
      var m = o.filter(function(v) {
        return c[v] === void 0;
      });
      if (m.length > 0)
        return new Error("`" + i + "` prop in `" + d + "` requires props: `" + m.join("`, `") + "`.");
    }
  };
}, NW = function(o) {
  return function(c, i, d) {
    if (!Array.isArray(o))
      throw new Error(["Invalid argument supplied to some, expected an instance of array.", "See `" + i + "` prop in `" + d + "`."].join(" "));
    var m = c[i];
    if (!(ws(m) || m === !1)) {
      var v = m.replace("large screen", "large-screen").replace(/ vertically/g, "-vertically").split(" ").map(function(C) {
        return uxe(C).replace("-", " ");
      }), g = ise(v, o);
      if (g.length > 0)
        return new Error("`" + i + "` prop in `" + d + "` has invalid values: `" + g.join("`, `") + "`.");
    }
  };
}, In = function() {
  return co([Go(["children"]), _.node]).apply(void 0, arguments);
}, Vn = function() {
  return co([Go(["children"]), _.oneOfType([_.func, _.node, _.object, _.arrayOf(_.oneOfType([_.node, _.object]))])]).apply(void 0, arguments);
}, Dh = function() {
  return co([Go(["children"]), _.arrayOf(Vn)]).apply(void 0, arguments);
}, yB = _.shape({
  current: _.object
}), uhe = _.oneOfType([_.func, yB]), wae = { exports: {} }, ML = {}, Jre = { exports: {} };
/*!
  Copyright (c) 2015 Jed Watson.
  Based on code that is Copyright 2013-2015, Facebook, Inc.
  All rights reserved.
*/
var kue;
function dhe() {
  return kue || (kue = 1, function(r) {
    (function() {
      var o = !!(typeof window < "u" && window.document && window.document.createElement), c = {
        canUseDOM: o,
        canUseWorkers: typeof Worker < "u",
        canUseEventListeners: o && !!(window.addEventListener || window.attachEvent),
        canUseViewport: o && !!window.screen
      };
      r.exports ? r.exports = c : window.ExecutionEnvironment = c;
    })();
  }(Jre)), Jre.exports;
}
var Nue;
function $xe() {
  if (Nue)
    return ML;
  Nue = 1, Object.defineProperty(ML, "__esModule", { value: !0 });
  var r = dhe(), o = ae;
  function c(be) {
    return (c = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(q) {
      return typeof q;
    } : function(q) {
      return q && typeof Symbol == "function" && q.constructor === Symbol && q !== Symbol.prototype ? "symbol" : typeof q;
    })(be);
  }
  function i(be, q) {
    if (!(be instanceof q))
      throw new TypeError("Cannot call a class as a function");
  }
  function d(be, q) {
    for (var Te = 0; Te < q.length; Te++) {
      var Le = q[Te];
      Le.enumerable = Le.enumerable || !1, Le.configurable = !0, "value" in Le && (Le.writable = !0), Object.defineProperty(be, Le.key, Le);
    }
  }
  function m(be, q, Te) {
    return q && d(be.prototype, q), Te && d(be, Te), be;
  }
  function v(be, q, Te) {
    return q in be ? Object.defineProperty(be, q, { value: Te, enumerable: !0, configurable: !0, writable: !0 }) : be[q] = Te, be;
  }
  function g(be, q) {
    if (typeof q != "function" && q !== null)
      throw new TypeError("Super expression must either be null or a function");
    be.prototype = Object.create(q && q.prototype, { constructor: { value: be, writable: !0, configurable: !0 } }), q && O(be, q);
  }
  function C(be) {
    return (C = Object.setPrototypeOf ? Object.getPrototypeOf : function(q) {
      return q.__proto__ || Object.getPrototypeOf(q);
    })(be);
  }
  function O(be, q) {
    return (O = Object.setPrototypeOf || function(Te, Le) {
      return Te.__proto__ = Le, Te;
    })(be, q);
  }
  function R(be) {
    if (be === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return be;
  }
  function I(be, q) {
    return !q || typeof q != "object" && typeof q != "function" ? R(be) : q;
  }
  var L = function() {
    function be(q) {
      i(this, be), v(this, "handlers", void 0), this.handlers = q.slice(0);
    }
    return m(be, [{ key: "addHandlers", value: function(q) {
      for (var Te = this.handlers.slice(0), Le = q.length, je = 0; je < Le; je += 1)
        Te.push(q[je]);
      return new be(Te);
    } }, { key: "dispatchEvent", value: function(q, Te) {
      var Le = this.handlers.length - 1;
      if (Te) {
        for (var je = Le; je >= 0; je -= 1)
          this.handlers[je].called || (this.handlers[je].called = !0, this.handlers[je](q));
        for (var Ie = Le; Ie >= 0; Ie -= 1)
          this.handlers[Ie].called = !1;
      } else
        (0, this.handlers[Le])(q);
    } }, { key: "hasHandlers", value: function() {
      return this.handlers.length > 0;
    } }, { key: "removeHandlers", value: function(q) {
      for (var Te = [], Le = this.handlers.length, je = 0; je < Le; je += 1) {
        var Ie = this.handlers[je];
        q.indexOf(Ie) === -1 && Te.push(Ie);
      }
      return new be(Te);
    } }]), be;
  }();
  function Z(be) {
    var q = /* @__PURE__ */ new Map();
    return be.forEach(function(Te, Le) {
      q.set(Le, Te);
    }), q;
  }
  function ne(be) {
    return Array.isArray(be) ? be : [be];
  }
  var se = function(be) {
    return be !== null && c(be) === "object" && be.hasOwnProperty("current");
  };
  function Q(be) {
    return be === "document" ? document : be === "window" ? window : se(be) ? be.current || document : be || document;
  }
  var he = function() {
    function be(q, Te) {
      i(this, be), v(this, "handlerSets", void 0), v(this, "poolName", void 0), this.handlerSets = Te, this.poolName = q;
    }
    return m(be, [{ key: "addHandlers", value: function(q, Te) {
      var Le = Z(this.handlerSets);
      if (Le.has(q)) {
        var je = Le.get(q);
        Le.set(q, je.addHandlers(Te));
      } else
        Le.set(q, new L(Te));
      return new be(this.poolName, Le);
    } }, { key: "dispatchEvent", value: function(q, Te) {
      var Le = this.handlerSets.get(q), je = this.poolName === "default";
      Le && Le.dispatchEvent(Te, je);
    } }, { key: "hasHandlers", value: function(q) {
      if (!q)
        return this.handlerSets.size > 0;
      var Te = this.handlerSets.get(q);
      return !!Te && Te.hasHandlers();
    } }, { key: "removeHandlers", value: function(q, Te) {
      var Le = Z(this.handlerSets);
      if (!Le.has(q))
        return new be(this.poolName, Le);
      var je = Le.get(q).removeHandlers(Te);
      return je.hasHandlers() ? Le.set(q, je) : Le.delete(q), new be(this.poolName, Le);
    } }]), be;
  }();
  v(he, "createByType", function(be, q, Te) {
    var Le = /* @__PURE__ */ new Map();
    return Le.set(q, new L(Te)), new he(be, Le);
  });
  var ue = function() {
    function be(q) {
      var Te = this;
      i(this, be), v(this, "handlers", /* @__PURE__ */ new Map()), v(this, "pools", /* @__PURE__ */ new Map()), v(this, "target", void 0), v(this, "createEmitter", function(Le) {
        return function(je) {
          Te.pools.forEach(function(Ie) {
            Ie.dispatchEvent(Le, je);
          });
        };
      }), this.target = q;
    }
    return m(be, [{ key: "addHandlers", value: function(q, Te, Le) {
      if (this.pools.has(q)) {
        var je = this.pools.get(q);
        this.pools.set(q, je.addHandlers(Te, Le));
      } else
        this.pools.set(q, he.createByType(q, Te, Le));
      this.handlers.has(Te) || this.addTargetHandler(Te);
    } }, { key: "hasHandlers", value: function() {
      return this.handlers.size > 0;
    } }, { key: "removeHandlers", value: function(q, Te, Le) {
      if (this.pools.has(q)) {
        var je = this.pools.get(q).removeHandlers(Te, Le);
        je.hasHandlers() ? this.pools.set(q, je) : this.pools.delete(q);
        var Ie = !1;
        this.pools.forEach(function(Ce) {
          return Ie = Ie || Ce.hasHandlers(Te);
        }), Ie || this.removeTargetHandler(Te);
      }
    } }, { key: "addTargetHandler", value: function(q) {
      var Te = this.createEmitter(q);
      this.handlers.set(q, Te), this.target.addEventListener(q, Te, !0);
    } }, { key: "removeTargetHandler", value: function(q) {
      this.handlers.has(q) && (this.target.removeEventListener(q, this.handlers.get(q), !0), this.handlers.delete(q));
    } }]), be;
  }(), G = function() {
    function be() {
      var q = this;
      i(this, be), v(this, "targets", /* @__PURE__ */ new Map()), v(this, "getTarget", function(Te) {
        var Le = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], je = Q(Te);
        if (q.targets.has(je))
          return q.targets.get(je);
        if (!Le)
          return null;
        var Ie = new ue(je);
        return q.targets.set(je, Ie), Ie;
      }), v(this, "removeTarget", function(Te) {
        q.targets.delete(Q(Te));
      });
    }
    return m(be, [{ key: "sub", value: function(q, Te) {
      var Le = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (r.canUseDOM) {
        var je = Le.target, Ie = je === void 0 ? document : je, Ce = Le.pool, pt = Ce === void 0 ? "default" : Ce;
        this.getTarget(Ie).addHandlers(pt, q, ne(Te));
      }
    } }, { key: "unsub", value: function(q, Te) {
      var Le = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (r.canUseDOM) {
        var je = Le.target, Ie = je === void 0 ? document : je, Ce = Le.pool, pt = Ce === void 0 ? "default" : Ce, sn = this.getTarget(Ie, !1);
        sn && (sn.removeHandlers(pt, q, ne(Te)), sn.hasHandlers() || this.removeTarget(Ie));
      }
    } }]), be;
  }(), me = new G(), we = function(be) {
    function q() {
      return i(this, q), I(this, C(q).apply(this, arguments));
    }
    return g(q, o.PureComponent), m(q, [{ key: "componentDidMount", value: function() {
      this.subscribe(this.props);
    } }, { key: "componentDidUpdate", value: function(Te) {
      this.unsubscribe(Te), this.subscribe(this.props);
    } }, { key: "componentWillUnmount", value: function() {
      this.unsubscribe(this.props);
    } }, { key: "subscribe", value: function(Te) {
      var Le = Te.name, je = Te.on, Ie = Te.pool, Ce = Te.target;
      me.sub(Le, je, { pool: Ie, target: Ce });
    } }, { key: "unsubscribe", value: function(Te) {
      var Le = Te.name, je = Te.on, Ie = Te.pool, Ce = Te.target;
      me.unsub(Le, je, { pool: Ie, target: Ce });
    } }, { key: "render", value: function() {
      return null;
    } }]), q;
  }();
  return v(we, "defaultProps", { pool: "default", target: "document" }), we.propTypes = {}, ML.instance = me, ML.default = we, ML;
}
var FL = {}, Rue;
function Ixe() {
  if (Rue)
    return FL;
  Rue = 1, Object.defineProperty(FL, "__esModule", { value: !0 });
  var r = dhe(), o = Bn, c = ae;
  function i(q) {
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? i = function(Te) {
      return typeof Te;
    } : i = function(Te) {
      return Te && typeof Symbol == "function" && Te.constructor === Symbol && Te !== Symbol.prototype ? "symbol" : typeof Te;
    }, i(q);
  }
  function d(q, Te) {
    if (!(q instanceof Te))
      throw new TypeError("Cannot call a class as a function");
  }
  function m(q, Te) {
    for (var Le = 0; Le < Te.length; Le++) {
      var je = Te[Le];
      je.enumerable = je.enumerable || !1, je.configurable = !0, "value" in je && (je.writable = !0), Object.defineProperty(q, je.key, je);
    }
  }
  function v(q, Te, Le) {
    return Te && m(q.prototype, Te), Le && m(q, Le), q;
  }
  function g(q, Te, Le) {
    return Te in q ? Object.defineProperty(q, Te, {
      value: Le,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : q[Te] = Le, q;
  }
  function C(q, Te) {
    if (typeof Te != "function" && Te !== null)
      throw new TypeError("Super expression must either be null or a function");
    q.prototype = Object.create(Te && Te.prototype, {
      constructor: {
        value: q,
        writable: !0,
        configurable: !0
      }
    }), Te && R(q, Te);
  }
  function O(q) {
    return O = Object.setPrototypeOf ? Object.getPrototypeOf : function(Le) {
      return Le.__proto__ || Object.getPrototypeOf(Le);
    }, O(q);
  }
  function R(q, Te) {
    return R = Object.setPrototypeOf || function(je, Ie) {
      return je.__proto__ = Ie, je;
    }, R(q, Te);
  }
  function I(q) {
    if (q === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return q;
  }
  function L(q, Te) {
    return Te && (typeof Te == "object" || typeof Te == "function") ? Te : I(q);
  }
  var Z = /* @__PURE__ */ function() {
    function q(Te) {
      d(this, q), g(this, "handlers", void 0), this.handlers = Te.slice(0);
    }
    return v(q, [{
      key: "addHandlers",
      value: function(Le) {
        for (var je = this.handlers.slice(0), Ie = Le.length, Ce = 0; Ce < Ie; Ce += 1)
          je.push(Le[Ce]);
        return new q(je);
      }
      /**
       * @see https://jsperf.com/suir-eventset-dispatchsingle
       * @see https://jsperf.com/suir-eventset-dispatchmultiple2
       */
    }, {
      key: "dispatchEvent",
      value: function(Le, je) {
        var Ie = this.handlers.length - 1;
        if (!je) {
          var Ce = this.handlers[Ie];
          Ce(Le);
          return;
        }
        for (var pt = Ie; pt >= 0; pt -= 1)
          this.handlers[pt].called || (this.handlers[pt].called = !0, this.handlers[pt](Le));
        for (var sn = Ie; sn >= 0; sn -= 1)
          this.handlers[sn].called = !1;
      }
    }, {
      key: "hasHandlers",
      value: function() {
        return this.handlers.length > 0;
      }
      /**
       * @see https://jsperf.com/suir-eventset-removehandlers
       */
    }, {
      key: "removeHandlers",
      value: function(Le) {
        for (var je = [], Ie = this.handlers.length, Ce = 0; Ce < Ie; Ce += 1) {
          var pt = this.handlers[Ce];
          Le.indexOf(pt) === -1 && je.push(pt);
        }
        return new q(je);
      }
    }]), q;
  }();
  function ne(q) {
    var Te = /* @__PURE__ */ new Map();
    return q.forEach(function(Le, je) {
      Te.set(je, Le);
    }), Te;
  }
  function se(q) {
    return Array.isArray(q) ? q : [q];
  }
  var Q = function(Te) {
    return Te !== null && i(Te) === "object" && Te.hasOwnProperty("current");
  };
  function he(q) {
    return q === "document" ? document : q === "window" ? window : Q(q) ? q.current || document : q || document;
  }
  var ue = /* @__PURE__ */ function() {
    function q(Te, Le) {
      d(this, q), g(this, "handlerSets", void 0), g(this, "poolName", void 0), this.handlerSets = Le, this.poolName = Te;
    }
    return v(q, [{
      key: "addHandlers",
      value: function(Le, je) {
        var Ie = ne(this.handlerSets);
        if (Ie.has(Le)) {
          var Ce = Ie.get(Le);
          Ie.set(Le, Ce.addHandlers(je));
        } else
          Ie.set(Le, new Z(je));
        return new q(this.poolName, Ie);
      }
    }, {
      key: "dispatchEvent",
      value: function(Le, je) {
        var Ie = this.handlerSets.get(Le), Ce = this.poolName === "default";
        Ie && Ie.dispatchEvent(je, Ce);
      }
    }, {
      key: "hasHandlers",
      value: function(Le) {
        if (!Le)
          return this.handlerSets.size > 0;
        var je = this.handlerSets.get(Le);
        return je ? je.hasHandlers() : !1;
      }
    }, {
      key: "removeHandlers",
      value: function(Le, je) {
        var Ie = ne(this.handlerSets);
        if (!Ie.has(Le))
          return new q(this.poolName, Ie);
        var Ce = Ie.get(Le), pt = Ce.removeHandlers(je);
        return pt.hasHandlers() ? Ie.set(Le, pt) : Ie.delete(Le), new q(this.poolName, Ie);
      }
    }]), q;
  }();
  g(ue, "createByType", function(q, Te, Le) {
    var je = /* @__PURE__ */ new Map();
    return je.set(Te, new Z(Le)), new ue(q, je);
  });
  var G = /* @__PURE__ */ function() {
    function q(Te) {
      var Le = this;
      d(this, q), g(this, "handlers", /* @__PURE__ */ new Map()), g(this, "pools", /* @__PURE__ */ new Map()), g(this, "target", void 0), g(this, "createEmitter", function(je) {
        return function(Ie) {
          Le.pools.forEach(function(Ce) {
            Ce.dispatchEvent(je, Ie);
          });
        };
      }), this.target = Te;
    }
    return v(q, [{
      key: "addHandlers",
      value: function(Le, je, Ie) {
        if (this.pools.has(Le)) {
          var Ce = this.pools.get(Le);
          this.pools.set(Le, Ce.addHandlers(je, Ie));
        } else
          this.pools.set(Le, ue.createByType(Le, je, Ie));
        this.handlers.has(je) || this.addTargetHandler(je);
      }
    }, {
      key: "hasHandlers",
      value: function() {
        return this.handlers.size > 0;
      }
    }, {
      key: "removeHandlers",
      value: function(Le, je, Ie) {
        if (this.pools.has(Le)) {
          var Ce = this.pools.get(Le), pt = Ce.removeHandlers(je, Ie);
          pt.hasHandlers() ? this.pools.set(Le, pt) : this.pools.delete(Le);
          var sn = !1;
          this.pools.forEach(function(Lt) {
            return sn = sn || Lt.hasHandlers(je);
          }), sn || this.removeTargetHandler(je);
        }
      }
    }, {
      key: "addTargetHandler",
      value: function(Le) {
        var je = this.createEmitter(Le);
        this.handlers.set(Le, je), this.target.addEventListener(Le, je, !0);
      }
    }, {
      key: "removeTargetHandler",
      value: function(Le) {
        this.handlers.has(Le) && (this.target.removeEventListener(Le, this.handlers.get(Le), !0), this.handlers.delete(Le));
      }
    }]), q;
  }(), me = /* @__PURE__ */ function() {
    function q() {
      var Te = this;
      d(this, q), g(this, "targets", /* @__PURE__ */ new Map()), g(this, "getTarget", function(Le) {
        var je = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, Ie = he(Le);
        if (Te.targets.has(Ie))
          return Te.targets.get(Ie);
        if (!je)
          return null;
        var Ce = new G(Ie);
        return Te.targets.set(Ie, Ce), Ce;
      }), g(this, "removeTarget", function(Le) {
        Te.targets.delete(he(Le));
      });
    }
    return v(q, [{
      key: "sub",
      value: function(Le, je) {
        var Ie = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        if (r.canUseDOM) {
          var Ce = Ie.target, pt = Ce === void 0 ? document : Ce, sn = Ie.pool, Lt = sn === void 0 ? "default" : sn, z = this.getTarget(pt);
          z.addHandlers(Lt, Le, se(je));
        }
      }
    }, {
      key: "unsub",
      value: function(Le, je) {
        var Ie = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        if (r.canUseDOM) {
          var Ce = Ie.target, pt = Ce === void 0 ? document : Ce, sn = Ie.pool, Lt = sn === void 0 ? "default" : sn, z = this.getTarget(pt, !1);
          z && (z.removeHandlers(Lt, Le, se(je)), z.hasHandlers() || this.removeTarget(pt));
        }
      }
    }]), q;
  }(), we = new me(), be = /* @__PURE__ */ function(q) {
    C(Te, q);
    function Te() {
      return d(this, Te), L(this, O(Te).apply(this, arguments));
    }
    return v(Te, [{
      key: "componentDidMount",
      value: function() {
        this.subscribe(this.props);
      }
    }, {
      key: "componentDidUpdate",
      value: function(je) {
        this.unsubscribe(je), this.subscribe(this.props);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        this.unsubscribe(this.props);
      }
    }, {
      key: "subscribe",
      value: function(je) {
        var Ie = je.name, Ce = je.on, pt = je.pool, sn = je.target;
        we.sub(Ie, Ce, {
          pool: pt,
          target: sn
        });
      }
    }, {
      key: "unsubscribe",
      value: function(je) {
        var Ie = je.name, Ce = je.on, pt = je.pool, sn = je.target;
        we.unsub(Ie, Ce, {
          pool: pt,
          target: sn
        });
      }
    }, {
      key: "render",
      value: function() {
        return null;
      }
    }]), Te;
  }(c.PureComponent);
  return g(be, "defaultProps", {
    pool: "default",
    target: "document"
  }), be.propTypes = {
    /** An event name on which we will subscribe. */
    name: o.string.isRequired,
    /** An event handler or array of event handlers. */
    on: o.oneOfType([o.func, o.arrayOf(o.func)]).isRequired,
    /** A name of pool. */
    pool: o.string,
    /** A DOM element on which we will subscribe. */
    target: o.oneOfType([
      o.oneOf(["document", "window"]),
      // Heads up!
      // This condition for SSR safety.
      o.instanceOf(r.canUseDOM ? HTMLElement : Object),
      o.shape({
        current: o.object
      })
    ])
  }, FL.instance = we, FL.default = be, FL;
}
var RW;
process.env.NODE_ENV === "production" ? RW = $xe() : RW = Ixe();
wae.exports = RW.default;
var Ql = wae.exports.instance = RW.instance, Mxe = wae.exports;
const rC = /* @__PURE__ */ Ku(Mxe);
function Eae() {
}
var Fxe = 1 / 0, Lxe = jD && 1 / mae(new jD([, -0]))[1] == Fxe ? function(r) {
  return new jD(r);
} : Eae;
const Bxe = Lxe;
var Hxe = 200;
function fhe(r, o, c) {
  var i = -1, d = yj, m = r.length, v = !0, g = [], C = g;
  if (c)
    v = !1, d = gae;
  else if (m >= Hxe) {
    var O = o ? null : Bxe(r);
    if (O)
      return mae(O);
    v = !1, d = hB, C = new GA();
  } else
    C = o ? [] : g;
  e:
    for (; ++i < m; ) {
      var R = r[i], I = o ? o(R) : R;
      if (R = c || R !== 0 ? R : 0, v && I === I) {
        for (var L = C.length; L--; )
          if (C[L] === I)
            continue e;
        o && C.push(I), g.push(R);
      } else
        d(C, I, c) || (C !== g && C.push(I), g.push(R));
    }
  return g;
}
function Ej(r) {
  return r && r.length ? fhe(r) : [];
}
var zxe = "[object Number]";
function Vxe(r) {
  return typeof r == "number" || Nh(r) && XS(r) == zxe;
}
var Uxe = "[object String]";
function Cae(r) {
  return typeof r == "string" || !qc(r) && Nh(r) && XS(r) == Uxe;
}
var Wxe = "[object Boolean]";
function jxe(r) {
  return r === !0 || r === !1 || Nh(r) && XS(r) == Wxe;
}
function mhe(r) {
  var o, c, i = "";
  if (typeof r == "string" || typeof r == "number")
    i += r;
  else if (typeof r == "object")
    if (Array.isArray(r))
      for (o = 0; o < r.length; o++)
        r[o] && (c = mhe(r[o])) && (i && (i += " "), i += c);
    else
      for (o in r)
        r[o] && (i && (i += " "), i += o);
  return i;
}
function Vt() {
  for (var r, o, c = 0, i = ""; c < arguments.length; )
    (r = arguments[c++]) && (o = mhe(r)) && (i && (i += " "), i += o);
  return i;
}
var Pue = {};
function gp(r, o, c, i) {
  if (i === void 0 && (i = {}), typeof r != "function" && typeof r != "string")
    throw new Error("createShorthand() Component must be a string or function.");
  if (ws(c) || jxe(c))
    return null;
  var d = Cae(c), m = Vxe(c), v = YD(c), g = /* @__PURE__ */ Ya.isValidElement(c), C = y2(c), O = d || m || qc(c);
  if (!v && !g && !C && !O)
    return process.env.NODE_ENV !== "production" && console.error(["Shorthand value must be a string|number|array|object|ReactElement|function.", " Use null|undefined|boolean for none", " Received " + typeof c + "."].join("")), null;
  var R = i, I = R.defaultProps, L = I === void 0 ? {} : I, Z = g && c.props || C && c || O && o(c), ne = i, se = ne.overrideProps, Q = se === void 0 ? {} : se;
  Q = YD(Q) ? Q(Be({}, L, Z)) : Q;
  var he = Be({}, L, Z, Q);
  if (L.className || Q.className || Z.className) {
    var ue = Vt(L.className, Q.className, Z.className);
    he.className = Ej(ue.split(" ")).join(" ");
  }
  if ((L.style || Q.style || Z.style) && (he.style = Be({}, L.style, Z.style, Q.style)), ws(he.key)) {
    var G = he.childKey, me = i, we = me.autoGenerateKey, be = we === void 0 ? !0 : we;
    ws(G) ? be && (d || m) && (he.key = c) : (he.key = typeof G == "function" ? G(he) : G, delete he.childKey);
  }
  if (g)
    return /* @__PURE__ */ Ya.cloneElement(c, he);
  if (typeof he.children == "function")
    return he.children(r, Be({}, he, {
      children: void 0
    }));
  if (O || C)
    return /* @__PURE__ */ Ya.createElement(r, he);
  if (v)
    return process.env.NODE_ENV !== "production" && (Pue[r] || (Pue[r] = !0, console.warn('Warning: There is a deprecated shorthand function usage for "' + r + '". It is deprecated and will be removed in v3 release. Please follow our upgrade guide: https://github.com/Semantic-Org/Semantic-UI-React/pull/4029'))), c(r, he, he.children);
}
function lo(r, o) {
  if (typeof r != "function" && typeof r != "string")
    throw new Error("createShorthandFactory() Component must be a string or function.");
  return function(c, i) {
    return gp(r, o, c, i);
  };
}
var phe = /* @__PURE__ */ lo("div", function(r) {
  return {
    children: r
  };
}), qxe = /* @__PURE__ */ lo("iframe", function(r) {
  return {
    src: r
  };
}), Cj = /* @__PURE__ */ lo("img", function(r) {
  return {
    src: r
  };
}), Gxe = /* @__PURE__ */ lo("input", function(r) {
  return {
    type: r
  };
}), fse = /* @__PURE__ */ lo("label", function(r) {
  return {
    children: r
  };
}), Zxe = /* @__PURE__ */ lo("p", function(r) {
  return {
    children: r
  };
}), Kxe = function(o, c) {
  var i = o.handledProps, d = i === void 0 ? [] : i;
  return Object.keys(c).reduce(function(m, v) {
    return v === "childKey" || d.indexOf(v) === -1 && (m[v] = c[v]), m;
  }, {});
};
const zt = Kxe;
function Xt(r, o, c) {
  var i = r.defaultProps, d = i === void 0 ? {} : i;
  if (o.as && o.as !== d.as)
    return o.as;
  if (c) {
    var m = c();
    if (m)
      return m;
  }
  return o.href ? "a" : d.as || "div";
}
function Yxe(r, o) {
  return E1(o, function(c) {
    return r[c];
  });
}
function xj(r) {
  return r == null ? [] : Yxe(r, Yf(r));
}
var Qxe = Math.max;
function Og(r, o, c, i) {
  r = JS(r) ? r : xj(r), c = c && !i ? cC(c) : 0;
  var d = r.length;
  return c < 0 && (c = Qxe(d + c, 0)), Cae(r) ? c <= d && r.indexOf(o, c) > -1 : !!d && bj(r, o, c) > -1;
}
var xae = [
  // REACT
  "selected",
  "defaultValue",
  "defaultChecked",
  // LIMITED HTML PROPS
  "accept",
  "autoCapitalize",
  "autoComplete",
  "autoCorrect",
  "autoFocus",
  "checked",
  "disabled",
  "enterKeyHint",
  "form",
  "id",
  "inputMode",
  "lang",
  "list",
  "max",
  "maxLength",
  "min",
  "minLength",
  "multiple",
  "name",
  "pattern",
  "placeholder",
  "readOnly",
  "required",
  "step",
  "title",
  "type",
  "value"
], Xxe = [
  // EVENTS
  // keyboard
  "onKeyDown",
  "onKeyPress",
  "onKeyUp",
  // focus
  "onFocus",
  "onBlur",
  // form
  "onChange",
  "onInput",
  // mouse
  "onClick",
  "onContextMenu",
  "onDrag",
  "onDragEnd",
  "onDragEnter",
  "onDragExit",
  "onDragLeave",
  "onDragOver",
  "onDragStart",
  "onDrop",
  "onMouseDown",
  "onMouseEnter",
  "onMouseLeave",
  "onMouseMove",
  "onMouseOut",
  "onMouseOver",
  "onMouseUp",
  // selection
  "onSelect",
  // touch
  "onTouchCancel",
  "onTouchEnd",
  "onTouchMove",
  "onTouchStart"
], Jxe = [].concat(xae, Xxe), hhe = ["alt", "height", "src", "srcSet", "width", "loading"], VB = function(o, c) {
  c === void 0 && (c = {});
  var i = c, d = i.htmlProps, m = d === void 0 ? Jxe : d, v = i.includeAria, g = v === void 0 ? !0 : v, C = {}, O = {};
  return C1(o, function(R, I) {
    var L = g && (/^aria-.*$/.test(I) || I === "role"), Z = Og(m, I) || L ? C : O;
    Z[I] = R;
  }), [C, O];
}, eTe = typeof document == "object" && document !== null, tTe = typeof window == "object" && window !== null && window.self === window, nTe = function r() {
  return ws(r.override) ? eTe && tTe : r.override;
};
const $v = nTe;
var rTe = Math.max, oTe = Math.min;
function sTe(r, o, c) {
  return r >= oTe(o, c) && r < rTe(o, c);
}
function mse(r, o, c) {
  return o = WD(o), c === void 0 ? (c = o, o = 0) : c = WD(c), r = UD(r), sTe(r, o, c);
}
function aTe(r) {
  return r && r.length ? r[0] : void 0;
}
var iTe = function(o, c) {
  if (eB([c, o], ws))
    return !1;
  if (c.target && (xn(c.target, "setAttribute", "data-suir-click-target", !0), document.querySelector("[data-suir-click-target=true]")))
    return xn(c.target, "removeAttribute", "data-suir-click-target"), o.contains(c.target);
  var i = c.clientX, d = c.clientY;
  if (eB([i, d], ws))
    return !1;
  var m = o.getClientRects();
  if (!o.offsetWidth || !o.offsetHeight || !m || !m.length)
    return !1;
  var v = aTe(m), g = v.top, C = v.bottom, O = v.left, R = v.right;
  return eB([g, C, O, R], ws) ? !1 : mse(d, g, C + 1e-3) && mse(i, O, R + 1e-3);
};
const f2 = iTe;
var ghe = function(o) {
  return {
    active: !1,
    type: "ellipsisItem",
    value: o
  };
}, cTe = function() {
  return {
    active: !1,
    type: "firstItem",
    value: 1
  };
}, lTe = function(o) {
  return {
    active: !1,
    type: "prevItem",
    value: Math.max(1, o - 1)
  };
}, uTe = function(o) {
  return function(c) {
    return {
      active: o === c,
      type: "pageItem",
      value: c
    };
  };
}, dTe = function(o, c) {
  return {
    active: !1,
    type: "nextItem",
    value: Math.min(o + 1, c)
  };
}, fTe = function(o) {
  return {
    active: !1,
    type: "lastItem",
    value: o
  };
}, mTe = Math.ceil, pTe = Math.max;
function hTe(r, o, c, i) {
  for (var d = -1, m = pTe(mTe((o - r) / (c || 1)), 0), v = Array(m); m--; )
    v[i ? m : ++d] = r, r += c;
  return v;
}
function gTe(r) {
  return function(o, c, i) {
    return i && typeof i != "number" && bB(o, c, i) && (c = i = void 0), o = WD(o), c === void 0 ? (c = o, o = 0) : c = WD(c), i = i === void 0 ? o < c ? 1 : -1 : WD(i), hTe(o, c, i, r);
  };
}
var vTe = gTe();
const bTe = vTe;
var yTe = function(o, c, i) {
  var d = c - 1, m = d !== o + 1, v = m ? ghe : i;
  return v(d);
}, STe = function(o, c, i) {
  var d = o + 1, m = d !== c - 1, v = m ? ghe : i;
  return v(d);
}, cW = function(o, c, i) {
  return fi(bTe(o, c + 1), i);
}, wTe = function(o, c) {
  var i = o.activePage, d = o.boundaryRange, m = o.hideEllipsis, v = o.siblingRange, g = o.totalPages, C = m ? 0 : 1, O = d, R = cW(1, O, c), I = g + 1 - d, L = cW(I, g, c), Z = Math.min(Math.max(i - v, O + C + 1), I - C - 2 * v - 1), ne = Z + 2 * v, se = cW(Z, ne, c);
  return [].concat(R, [!m && yTe(O, Z, c)], se, [!m && STe(ne, I, c)], L).filter(Boolean);
}, ETe = function(o) {
  var c = o.boundaryRange, i = o.hideEllipsis, d = o.siblingRange, m = o.totalPages, v = 2 * c, g = i ? 0 : 2, C = 2 * d;
  return 1 + g + C + v >= m;
}, CTe = function(o) {
  var c = o.activePage, i = o.boundaryRange, d = o.hideEllipsis, m = o.siblingRange, v = o.totalPages;
  return {
    activePage: +c,
    boundaryRange: +i,
    hideEllipsis: !!d,
    siblingRange: +m,
    totalPages: +v
  };
}, xTe = function(o) {
  var c = CTe(o), i = c.activePage, d = c.totalPages, m = uTe(i), v = ETe(c) ? cW(1, d, m) : wTe(c, m);
  return [cTe(), lTe(i)].concat(v, [dTe(i, d), fTe(d)]);
};
const TTe = xTe;
var Om = ["red", "orange", "yellow", "olive", "green", "teal", "blue", "violet", "purple", "pink", "brown", "grey", "black"], ew = ["left", "right"], mc = ["mini", "tiny", "small", "medium", "large", "big", "huge", "massive"], $g = ["left", "center", "right", "justified"], D1 = ["bottom", "middle", "top"], vhe = ["mobile", "tablet", "computer", "large screen", "widescreen"], hp = [].concat(Yf(tB), Yf(tB).map(Number), xj(tB)), bhe = ["browse", "browse right", "drop", "fade", "fade up", "fade down", "fade left", "fade right", "fly up", "fly down", "fly left", "fly right", "horizontal flip", "vertical flip", "scale", "slide up", "slide down", "slide left", "slide right", "swing up", "swing down", "swing left", "swing right", "zoom"], _Te = ["jiggle", "flash", "shake", "pulse", "tada", "bounce", "glow"], yhe = [].concat(bhe, _Te), OTe = ["american sign language interpreting", "assistive listening systems", "audio description", "blind", "braille", "closed captioning", "closed captioning outline", "deaf", "low vision", "phone volume", "question circle", "question circle outline", "sign language", "tty", "universal access", "wheelchair"], ATe = ["angle double down", "angle double left", "angle double right", "angle double up", "angle down", "angle left", "angle right", "angle up", "arrow alternate circle down", "arrow alternate circle down outline", "arrow alternate circle left", "arrow alternate circle left outline", "arrow alternate circle right", "arrow alternate circle right outline", "arrow alternate circle up", "arrow alternate circle up outline", "arrow circle down", "arrow circle left", "arrow circle right", "arrow circle up", "arrow down", "arrow left", "arrow right", "arrow up", "arrows alternate", "arrows alternate horizontal", "arrows alternate vertical", "caret down", "caret left", "caret right", "caret square down", "caret square down outline", "caret square left", "caret square left outline", "caret square right", "caret square right outline", "caret square up", "caret square up outline", "caret up", "cart arrow down", "chart line", "chevron circle down", "chevron circle left", "chevron circle right", "chevron circle up", "chevron down", "chevron left", "chevron right", "chevron up", "cloud download", "cloud upload", "download", "exchange", "expand arrows alternate", "external alternate", "external square alternate", "hand point down", "hand point down outline", "hand point left", "hand point left outline", "hand point right", "hand point right outline", "hand point up", "hand point up outline", "hand pointer", "hand pointer outline", "history", "level down alternate", "level up alternate", "location arrow", "long arrow alternate down", "long arrow alternate left", "long arrow alternate right", "long arrow alternate up", "mouse pointer", "play", "random", "recycle", "redo", "redo alternate", "reply", "reply all", "retweet", "share", "share square", "share square outline", "sign-in", "sign-out", "sign-in alternate", "sign-out alternate", "sort", "sort alphabet down", "sort alphabet up", "sort amount down", "sort amount up", "sort down", "sort numeric down", "sort numeric up", "sort up", "sync", "sync alternate", "text height", "text width", "undo", "undo alternate", "upload", "zoom-in", "zoom-out"], kTe = ["audio description", "backward", "circle", "circle outline", "closed captioning", "closed captioning outline", "compress", "eject", "expand", "expand arrows alternate", "fast backward", "fast forward", "file audio", "file audio outline", "file video", "file video outline", "film", "forward", "headphones", "microphone", "microphone slash", "music", "pause", "pause circle", "pause circle outline", "phone volume", "play", "play circle", "play circle outline", "podcast", "random", "redo", "redo alternate", "rss", "rss square", "step backward", "step forward", "stop", "stop circle", "stop circle outline", "sync", "sync alternate", "undo", "undo alternate", "video", "volume down", "volume off", "volume up"], NTe = ["address book", "address book outline", "address card", "address card outline", "archive", "balance scale", "birthday cake", "book", "briefcase", "building", "building outline", "bullhorn", "bullseye", "calculator", "calendar", "calendar outline", "calendar alternate", "calendar alternate outline", "certificate", "chart area", "chart bar", "chart bar outline", "chart line", "chart pie", "clipboard", "clipboard outline", "coffee", "columns", "compass", "compass outline", "copy", "copy outline", "copyright", "copyright outline", "cut", "edit", "edit outline", "envelope", "envelope outline", "envelope open", "envelope open outline", "envelope square", "eraser", "fax", "file", "file outline", "file alternate", "file alternate outline", "folder", "folder outline", "folder open", "folder open outline", "globe", "industry", "paperclip", "paste", "pen square", "pencil alternate", "percent", "phone", "phone square", "phone volume", "registered", "registered outline", "save", "save outline", "sitemap", "sticky note", "sticky note outline", "suitcase", "table", "tag", "tags", "tasks", "thumbtack", "trademark"], RTe = ["chess", "chess bishop", "chess board", "chess king", "chess knight", "chess pawn", "chess queen", "chess rook", "square full"], PTe = ["archive", "barcode", "bath", "bug", "code", "code branch", "coffee", "file", "file outline", "file alternate", "file alternate outline", "file code", "file code outline", "filter", "fire extinguisher", "folder", "folder outline", "folder open", "folder open outline", "keyboard", "keyboard outline", "microchip", "qrcode", "shield alternate", "sitemap", "terminal", "user secret", "window close", "window close outline", "window maximize", "window maximize outline", "window minimize", "window minimize outline", "window restore", "window restore outline"], DTe = ["address book", "address book outline", "address card", "address card outline", "american sign language interpreting", "assistive listening systems", "at", "bell", "bell outline", "bell slash", "bell slash outline", "bullhorn", "comment", "comment outline", "comment alternate", "comment alternate outline", "comments", "comments outline", "envelope", "envelope outline", "envelope open", "envelope open outline", "envelope square", "fax", "inbox", "language", "microphone", "microphone slash", "mobile", "mobile alternate", "paper plane", "paper plane outline", "phone", "phone square", "phone volume", "rss", "rss square", "tty", "wifi"], $Te = ["desktop", "download", "hdd", "hdd outline", "headphones", "keyboard", "keyboard outline", "laptop", "microchip", "mobile", "mobile alternate", "plug", "power off", "print", "save", "save outline", "server", "tablet", "tablet alternate", "tv", "upload"], ITe = ["dollar sign", "euro sign", "lira sign", "money bill alternate", "money bill alternate outline", "pound sign", "ruble sign", "rupee sign", "shekel sign", "won sign", "yen sign"], MTe = ["bell", "bell outline", "bell slash", "bell slash outline", "calendar", "calendar outline", "calendar alternate", "calendar alternate outline", "calendar check", "calendar check outline", "calendar minus", "calendar minus outline", "calendar plus", "calendar plus outline", "calendar times", "calendar times outline", "clock", "clock outline", "hourglass", "hourglass outline", "hourglass end", "hourglass half", "hourglass start", "stopwatch"], FTe = ["adjust", "clone", "clone outline", "copy", "copy outline", "crop", "crosshairs", "cut", "edit", "edit outline", "eraser", "eye", "eye dropper", "eye slash", "eye slash outline", "object group", "object group outline", "object ungroup", "object ungroup outline", "paint brush", "paste", "pencil alternate", "save", "save outline", "tint"], LTe = ["align center", "align justify", "align left", "align right", "bold", "clipboard", "clipboard outline", "clone", "clone outline", "columns", "copy", "copy outline", "cut", "edit", "edit outline", "eraser", "file", "file outline", "file alternate", "file alternate outline", "font", "heading", "i cursor", "indent", "italic", "linkify", "list", "list alternate", "list alternate outline", "list ol", "list ul", "outdent", "paper plane", "paper plane outline", "paperclip", "paragraph", "paste", "pencil alternate", "print", "quote left", "quote right", "redo", "redo alternate", "reply", "reply all", "share", "strikethrough", "subscript", "superscript", "sync", "sync alternate", "table", "tasks", "text height", "text width", "th", "th large", "th list", "trash", "trash alternate", "trash alternate outline", "underline", "undo", "undo alternate", "unlink"], BTe = ["archive", "clone", "clone outline", "copy", "copy outline", "cut", "file", "file outline", "file alternate", "file alternate outline", "file archive", "file archive outline", "file audio", "file audio outline", "file code", "file code outline", "file excel", "file excel outline", "file image", "file image outline", "file pdf", "file pdf outline", "file powerpoint", "file powerpoint outline", "file video", "file video outline", "file word", "file word outline", "folder", "folder outline", "folder open", "folder open outline", "paste", "save", "save outline", "sticky note", "sticky note outline"], HTe = ["genderless", "mars", "mars double", "mars stroke", "mars stroke horizontal", "mars stroke vertical", "mercury", "neuter", "transgender", "transgender alternate", "venus", "venus double", "venus mars"], zTe = ["hand lizard", "hand lizard outline", "hand paper", "hand paper outline", "hand peace", "hand peace outline", "hand point down", "hand point down outline", "hand point left", "hand point left outline", "hand point right", "hand point right outline", "hand point up", "hand point up outline", "hand pointer", "hand pointer outline", "hand rock", "hand rock outline", "hand scissors", "hand scissors outline", "hand spock", "hand spock outline", "handshake", "handshake outline", "thumbs down", "thumbs down outline", "thumbs up", "thumbs up outline"], VTe = ["ambulance", "h square", "heart", "heart outline", "heartbeat", "hospital", "hospital outline", "medkit", "plus square", "plus square outline", "stethoscope", "user md", "wheelchair"], UTe = ["adjust", "bolt", "camera", "camera retro", "clone", "clone outline", "compress", "expand", "eye", "eye dropper", "eye slash", "eye slash outline", "file image", "file image outline", "film", "id badge", "id badge outline", "id card", "id card outline", "image", "image outline", "images", "images outline", "sliders horizontal", "tint"], WTe = ["ban", "barcode", "bars", "beer", "bell", "bell outline", "bell slash", "bell slash outline", "bug", "bullhorn", "bullseye", "calculator", "calendar", "calendar outline", "calendar alternate", "calendar alternate outline", "calendar check", "calendar check outline", "calendar minus", "calendar minus outline", "calendar plus", "calendar plus outline", "calendar times", "calendar times outline", "certificate", "check", "check circle", "check circle outline", "check square", "check square outline", "circle", "circle outline", "clipboard", "clipboard outline", "clone", "clone outline", "cloud", "cloud download", "cloud upload", "coffee", "cog", "cogs", "copy", "copy outline", "cut", "database", "dot circle", "dot circle outline", "download", "edit", "edit outline", "ellipsis horizontal", "ellipsis vertical", "envelope", "envelope outline", "envelope open", "envelope open outline", "eraser", "exclamation", "exclamation circle", "exclamation triangle", "external alternate", "external square alternate", "eye", "eye slash", "eye slash outline", "file", "file outline", "file alternate", "file alternate outline", "filter", "flag", "flag outline", "flag checkered", "folder", "folder outline", "folder open", "folder open outline", "frown", "frown outline", "hashtag", "heart", "heart outline", "history", "home", "i cursor", "info", "info circle", "language", "magic", "meh", "meh outline", "microphone", "microphone slash", "minus", "minus circle", "minus square", "minus square outline", "paste", "pencil alternate", "plus", "plus circle", "plus square", "plus square outline", "qrcode", "question", "question circle", "question circle outline", "quote left", "quote right", "redo", "redo alternate", "reply", "reply all", "rss", "rss square", "save", "save outline", "search", "search minus", "search plus", "share", "share alternate", "share alternate square", "share square", "share square outline", "shield alternate", "sign-in", "sign-out", "signal", "sitemap", "sliders horizontal", "smile", "smile outline", "sort", "sort alphabet down", "sort alphabet up", "sort amount down", "sort amount up", "sort down", "sort numeric down", "sort numeric up", "sort up", "star", "star outline", "star half", "star half outline", "sync", "sync alternate", "thumbs down", "thumbs down outline", "thumbs up", "thumbs up outline", "times", "times circle", "times circle outline", "toggle off", "toggle on", "trash", "trash alternate", "trash alternate outline", "trophy", "undo", "undo alternate", "upload", "user", "user outline", "user circle", "user circle outline", "wifi"], jTe = ["box", "boxes", "clipboard check", "clipboard list", "dolly", "dolly flatbed", "pallet", "shipping fast", "truck", "warehouse"], qTe = ["ambulance", "anchor", "balance scale", "bath", "bed", "beer", "bell", "bell outline", "bell slash", "bell slash outline", "bicycle", "binoculars", "birthday cake", "blind", "bomb", "book", "bookmark", "bookmark outline", "briefcase", "building", "building outline", "car", "coffee", "crosshairs", "dollar sign", "eye", "eye slash", "eye slash outline", "fighter jet", "fire", "fire extinguisher", "flag", "flag outline", "flag checkered", "flask", "gamepad", "gavel", "gift", "glass martini", "globe", "graduation cap", "h square", "heart", "heart outline", "heartbeat", "home", "hospital", "hospital outline", "image", "image outline", "images", "images outline", "industry", "info", "info circle", "key", "leaf", "lemon", "lemon outline", "life ring", "life ring outline", "lightbulb", "lightbulb outline", "location arrow", "low vision", "magnet", "male", "map", "map outline", "map marker", "map marker alternate", "map pin", "map signs", "medkit", "money bill alternate", "money bill alternate outline", "motorcycle", "music", "newspaper", "newspaper outline", "paw", "phone", "phone square", "phone volume", "plane", "plug", "plus", "plus square", "plus square outline", "print", "recycle", "road", "rocket", "search", "search minus", "search plus", "ship", "shopping bag", "shopping basket", "shopping cart", "shower", "street view", "subway", "suitcase", "tag", "tags", "taxi", "thumbtack", "ticket alternate", "tint", "train", "tree", "trophy", "truck", "tty", "umbrella", "university", "utensil spoon", "utensils", "wheelchair", "wifi", "wrench"], GTe = ["ambulance", "band aid", "dna", "first aid", "heart", "heart outline", "heartbeat", "hospital", "hospital outline", "hospital symbol", "pills", "plus", "stethoscope", "syringe", "thermometer", "user md", "weight"], ZTe = ["ambulance", "anchor", "archive", "balance scale", "bath", "bed", "beer", "bell", "bell outline", "bicycle", "binoculars", "birthday cake", "bomb", "book", "bookmark", "bookmark outline", "briefcase", "bug", "building", "building outline", "bullhorn", "bullseye", "bus", "calculator", "calendar", "calendar outline", "calendar alternate", "calendar alternate outline", "camera", "camera retro", "car", "clipboard", "clipboard outline", "cloud", "coffee", "cog", "cogs", "compass", "compass outline", "copy", "copy outline", "cube", "cubes", "cut", "envelope", "envelope outline", "envelope open", "envelope open outline", "eraser", "eye", "eye dropper", "fax", "fighter jet", "file", "file outline", "file alternate", "file alternate outline", "film", "fire", "fire extinguisher", "flag", "flag outline", "flag checkered", "flask", "futbol", "futbol outline", "gamepad", "gavel", "gem", "gem outline", "gift", "glass martini", "globe", "graduation cap", "hdd", "hdd outline", "headphones", "heart", "heart outline", "home", "hospital", "hospital outline", "hourglass", "hourglass outline", "image", "image outline", "images", "images outline", "industry", "key", "keyboard", "keyboard outline", "laptop", "leaf", "lemon", "lemon outline", "life ring", "life ring outline", "lightbulb", "lightbulb outline", "lock", "lock open", "magic", "magnet", "map", "map outline", "map marker", "map marker alternate", "map pin", "map signs", "medkit", "microchip", "microphone", "mobile", "mobile alternate", "money bill alternate", "money bill alternate outline", "moon", "moon outline", "motorcycle", "newspaper", "newspaper outline", "paint brush", "paper plane", "paper plane outline", "paperclip", "paste", "paw", "pencil alternate", "phone", "plane", "plug", "print", "puzzle piece", "road", "rocket", "save", "save outline", "search", "shield alternate", "shopping bag", "shopping basket", "shopping cart", "shower", "snowflake", "snowflake outline", "space shuttle", "star", "star outline", "sticky note", "sticky note outline", "stopwatch", "subway", "suitcase", "sun", "sun outline", "tablet", "tablet alternate", "tachometer alternate", "tag", "tags", "taxi", "thumbtack", "ticket alternate", "train", "trash", "trash alternate", "trash alternate outline", "tree", "trophy", "truck", "tv", "umbrella", "university", "unlock", "unlock alternate", "utensil spoon", "utensils", "wheelchair", "wrench"], KTe = ["bell", "bell outline", "bookmark", "bookmark outline", "bullhorn", "camera", "camera retro", "cart arrow down", "cart plus", "certificate", "credit card", "credit card outline", "gem", "gem outline", "gift", "handshake", "handshake outline", "heart", "heart outline", "key", "shopping bag", "shopping basket", "shopping cart", "star", "star outline", "tag", "tags", "thumbs down", "thumbs down outline", "thumbs up", "thumbs up outline", "trophy"], YTe = ["bookmark", "bookmark outline", "calendar", "calendar outline", "certificate", "circle", "circle outline", "cloud", "comment", "comment outline", "file", "file outline", "folder", "folder outline", "heart", "heart outline", "map marker", "play", "square", "square outline", "star", "star outline"], QTe = ["asterisk", "certificate", "circle notch", "cog", "compass", "compass outline", "crosshairs", "life ring", "life ring outline", "snowflake", "snowflake outline", "spinner", "sun", "sun outline", "sync"], XTe = ["baseball ball", "basketball ball", "bowling ball", "football ball", "futbol", "futbol outline", "golf ball", "hockey puck", "quidditch", "table tennis", "volleyball ball"], JTe = ["ban", "battery empty", "battery full", "battery half", "battery quarter", "battery three quarters", "bell", "bell outline", "bell slash", "bell slash outline", "calendar", "calendar outline", "calendar alternate", "calendar alternate outline", "calendar check", "calendar check outline", "calendar minus", "calendar minus outline", "calendar plus", "calendar plus outline", "calendar times", "calendar times outline", "cart arrow down", "cart plus", "exclamation", "exclamation circle", "exclamation triangle", "eye", "eye slash", "eye slash outline", "file", "file outline", "file alternate", "file alternate outline", "folder", "folder outline", "folder open", "folder open outline", "info", "info circle", "lock", "lock open", "minus", "minus circle", "minus square", "minus square outline", "plus", "plus circle", "plus square", "plus square outline", "question", "question circle", "question circle outline", "shield alternate", "shopping cart", "sign in alternate", "sign out alternate", "thermometer empty", "thermometer full", "thermometer half", "thermometer quarter", "thermometer three quarters", "thumbs down", "thumbs down outline", "thumbs up", "thumbs up outline", "toggle off", "toggle on", "unlock", "unlock alternate"], e2e = ["address book", "address book outline", "address card", "address card outline", "bed", "blind", "child", "female", "frown", "frown outline", "id badge", "id badge outline", "id card", "id card outline", "male", "meh", "meh outline", "power off", "smile", "smile outline", "street view", "user", "user outline", "user circle", "user circle outline", "user md", "user plus", "user secret", "user times", "users", "wheelchair"], t2e = ["ambulance", "bicycle", "bus", "car", "fighter jet", "motorcycle", "paper plane", "paper plane outline", "plane", "rocket", "ship", "shopping cart", "space shuttle", "subway", "taxi", "train", "truck", "wheelchair"], n2e = ["archive", "book", "bookmark", "bookmark outline", "edit", "edit outline", "envelope", "envelope outline", "envelope open", "envelope open outline", "eraser", "file", "file outline", "file alternate", "file alternate outline", "folder", "folder outline", "folder open", "folder open outline", "keyboard", "keyboard outline", "newspaper", "newspaper outline", "paper plane", "paper plane outline", "paperclip", "paragraph", "pen square", "pencil alternate", "quote left", "quote right", "sticky note", "sticky note outline", "thumbtack"], r2e = ["500px", "accessible", "accusoft", "adn", "adversal", "affiliatetheme", "algolia", "amazon", "amazon pay", "amilia", "android", "angellist", "angrycreative", "angular", "app store", "app store ios", "apper", "apple", "apple pay", "asymmetrik", "audible", "autoprefixer", "avianex", "aviato", "aws", "bandcamp", "behance", "behance square", "bimobject", "bitbucket", "bitcoin", "bity", "black tie", "blackberry", "blogger", "blogger b", "bluetooth", "bluetooth b", "btc", "buromobelexperte", "buysellads", "cc amazon pay", "cc amex", "cc apple pay", "cc diners club", "cc discover", "cc jcb", "cc mastercard", "cc paypal", "cc stripe", "cc visa", "centercode", "chrome", "cloudscale", "cloudsmith", "cloudversify", "codepen", "codiepie", "connectdevelop", "contao", "cpanel", "creative commons", "css3", "css3 alternate", "cuttlefish", "d and d", "dashcube", "delicious", "deploydog", "deskpro", "deviantart", "digg", "digital ocean", "discord", "discourse", "dochub", "docker", "draft2digital", "dribbble", "dribbble square", "dropbox", "drupal", "dyalog", "earlybirds", "edge", "elementor", "ember", "empire", "envira", "erlang", "ethereum", "etsy", "expeditedssl", "facebook", "facebook f", "facebook messenger", "facebook square", "firefox", "first order", "firstdraft", "flickr", "flipboard", "fly", "font awesome", "font awesome alternate", "font awesome flag", "fonticons", "fonticons fi", "fort awesome", "fort awesome alternate", "forumbee", "foursquare", "free code camp", "freebsd", "get pocket", "gg", "gg circle", "git", "git square", "github", "github alternate", "github square", "gitkraken", "gitlab", "gitter", "glide", "glide g", "gofore", "goodreads", "goodreads g", "google", "google drive", "google play", "google plus", "google plus g", "google plus square", "google wallet", "gratipay", "grav", "gripfire", "grunt", "gulp", "hacker news", "hacker news square", "hips", "hire a helper", "hooli", "hotjar", "houzz", "html5", "hubspot", "imdb", "instagram", "internet explorer", "ioxhost", "itunes", "itunes note", "jenkins", "joget", "joomla", "js", "js square", "jsfiddle", "keycdn", "kickstarter", "kickstarter k", "korvue", "laravel", "lastfm", "lastfm square", "leanpub", "less", "linechat", "linkedin", "linkedin alternate", "linode", "linux", "lyft", "magento", "maxcdn", "medapps", "medium", "medium m", "medrt", "meetup", "microsoft", "mix", "mixcloud", "mizuni", "modx", "monero", "napster", "nintendo switch", "node", "node js", "npm", "ns8", "nutritionix", "odnoklassniki", "odnoklassniki square", "opencart", "openid", "opera", "optin monster", "osi", "page4", "pagelines", "palfed", "patreon", "paypal", "periscope", "phabricator", "phoenix framework", "php", "pied piper", "pied piper alternate", "pied piper pp", "pinterest", "pinterest p", "pinterest square", "playstation", "product hunt", "pushed", "python", "qq", "quinscape", "quora", "ravelry", "react", "rebel", "redriver", "reddit", "reddit alien", "reddit square", "rendact", "renren", "replyd", "resolving", "rocketchat", "rockrms", "safari", "sass", "schlix", "scribd", "searchengin", "sellcast", "sellsy", "servicestack", "shirtsinbulk", "simplybuilt", "sistrix", "skyatlas", "skype", "slack", "slack hash", "slideshare", "snapchat", "snapchat ghost", "snapchat square", "soundcloud", "speakap", "spotify", "stack exchange", "stack overflow", "staylinked", "steam", "steam square", "steam symbol", "sticker mule", "strava", "stripe", "stripe s", "studiovinari", "stumbleupon", "stumbleupon circle", "superpowers", "supple", "telegram", "telegram plane", "tencent weibo", "themeisle", "trello", "tripadvisor", "tumblr", "tumblr square", "twitch", "twitter", "twitter square", "typo3", "uber", "uikit", "uniregistry", "untappd", "usb", "ussunnah", "vaadin", "viacoin", "viadeo", "viadeo square", "viber", "vimeo", "vimeo square", "vimeo v", "vine", "vk", "vnv", "vuejs", "wechat", "weibo", "weixin", "whatsapp", "whatsapp square", "whmcs", "wikipedia w", "windows", "wordpress", "wordpress simple", "wpbeginner", "wpexplorer", "wpforms", "xbox", "xing", "xing square", "y combinator", "yahoo", "yandex", "yandex international", "yelp", "yoast", "youtube", "youtube square"], o2e = Ej([].concat(OTe, ATe, kTe, NTe, RTe, PTe, DTe, $Te, ITe, MTe, FTe, LTe, BTe, HTe, zTe, VTe, UTe, WTe, jTe, qTe, GTe, ZTe, KTe, YTe, QTe, XTe, JTe, e2e, t2e, n2e, r2e)), s2e = ["chess rock", "ordered list", "unordered list", "user doctor", "shield", "puzzle", "add circle", "add square", "add to calendar", "add to cart", "add user", "add", "alarm mute", "alarm", "ald", "als", "announcement", "area chart", "area graph", "arrow down cart", "asexual", "asl interpreting", "asl", "assistive listening devices", "attach", "attention", "balance", "bar", "bathtub", "battery four", "battery high", "battery low", "battery one", "battery three", "battery two", "battery zero", "birthday", "block layout", "bluetooth alternative", "broken chain", "browser", "call square", "call", "cancel", "cart", "cc", "chain", "chat", "checked calendar", "checkmark", "circle notched", "close", "cny", "cocktail", "commenting", "computer", "configure", "content", "deafness", "delete calendar", "delete", "detective", "discussions", "doctor", "dollar", "dont", "drivers license", "dropdown", "emergency", "envira gallery", "erase", "eur", "euro", "eyedropper", "factory", "favorite", "feed", "female homosexual", "file text", "file text outline", "find", "first aid", "fork", "game", "gay", "gbp", "google plus circle", "google plus official", "grab", "graduation", "grid layout", "group", "h", "hand victory", "handicap", "hard of hearing", "header", "help circle", "help", "heterosexual", "hide", "hotel", "hourglass four", "hourglass full", "hourglass one", "hourglass three", "hourglass two", "idea", "ils", "in cart", "inr", "intergender", "intersex", "jpy", "krw", "lab", "law", "legal", "lesbian", "lightning", "like", "line graph", "linkedin square", "linkify", "lira", "list layout", "magnify", "mail forward", "mail outline", "mail square", "mail", "male homosexual", "man", "marker", "mars alternate", "mars horizontal", "mars vertical", "microsoft edge", "military", "ms edge", "mute", "new pied piper", "non binary transgender", "numbered list", "options", "other gender horizontal", "other gender vertical", "other gender", "payment", "paypal card", "pencil square", "photo", "picture", "pie chart", "pie graph", "pied piper hat", "pin", "plus cart", "point", "pointing down", "pointing left", "pointing right", "pointing up", "pound", "power cord", "power", "privacy", "r circle", "rain", "record", "refresh", "remove circle", "remove from calendar", "remove user", "remove", "repeat", "rmb", "rouble", "rub", "ruble", "rupee", "s15", "selected radio", "send", "setting", "settings", "shekel", "sheqel", "shipping", "shop", "shuffle", "shutdown", "sidebar", "signing", "signup", "sliders", "soccer", "sort alphabet ascending", "sort alphabet descending", "sort ascending", "sort content ascending", "sort content descending", "sort descending", "sort numeric ascending", "sort numeric descending", "sound", "spy", "stripe card", "student", "talk", "target", "teletype", "television", "text cursor", "text telephone", "theme", "thermometer", "thumb tack", "time", "tm", "toggle down", "toggle left", "toggle right", "toggle up", "translate", "travel", "treatment", "triangle down", "triangle left", "triangle right", "triangle up", "try", "unhide", "unlinkify", "unmute", "usd", "user cancel", "user close", "user delete", "user x", "vcard", "video camera", "video play", "volume control phone", "wait", "warning circle", "warning sign", "warning", "wi-fi", "winner", "wizard", "woman", "won", "wordpress beginner", "wordpress forms", "world", "write square", "x", "yen", "zip", "zoom in", "zoom out", "zoom", "bitbucket square", "checkmark box", "circle thin", "cloud download", "cloud upload", "compose", "conversation", "credit card alternative", "currency", "dashboard", "diamond", "disk", "exchange", "external share", "external square", "external", "facebook official", "food", "hourglass zero", "level down", "level up", "log out", "meanpath", "money", "move", "pencil", "protect", "radio", "remove bookmark", "resize horizontal", "resize vertical", "sign in", "sign out", "spoon", "star half empty", "star half full", "ticket", "times rectangle", "write", "youtube play"], a2e = Ej([].concat(o2e, s2e)), i2e = [
  "left dropdown"
  // nested dropdown menu direction icon
], c2e = Ej([].concat(a2e, i2e));
const l2e = function(r) {
  return typeof r == "number" || typeof r == "string" ? [r, r] : r;
}, Due = function(r, o) {
  return typeof r == "number" || typeof r == "string" ? r : r[o];
};
function u2e(r, o) {
  return vj(r, o);
}
var $ue = Object.create, d2e = function() {
  function r() {
  }
  return function(o) {
    if (!Fv(o))
      return {};
    if ($ue)
      return $ue(o);
    r.prototype = o;
    var c = new r();
    return r.prototype = void 0, c;
  };
}();
const Tj = d2e;
var f2e = $v() && process.env.NODE_ENV !== "test" ? ae.useLayoutEffect : ae.useEffect;
const Iue = f2e;
var m2e = /\s+/;
function p2e(r) {
  var o = [];
  return r ? (r.forEach(function(c) {
    if (typeof c.current == "string") {
      var i = c.current.split(m2e);
      i.forEach(function(d) {
        o.push(d);
      });
    }
  }), o.filter(function(c, i, d) {
    return c.length > 0 && d.indexOf(c) === i;
  })) : [];
}
function h2e(r, o) {
  return [o.filter(function(c) {
    return r.indexOf(c) === -1;
  }), r.filter(function(c) {
    return o.indexOf(c) === -1;
  })];
}
var Mue = /* @__PURE__ */ new Map(), eoe = function(o, c) {
  var i = p2e(c), d = h2e(Mue.get(o) || [], i), m = d[0], v = d[1];
  o && (m.forEach(function(g) {
    return o.classList.add(g);
  }), v.forEach(function(g) {
    return o.classList.remove(g);
  })), Mue.set(o, i);
}, g2e = function() {
  var o = this;
  this.add = function(c, i) {
    if (o.nodes.has(c)) {
      var d = o.nodes.get(c);
      d.add(i);
      return;
    }
    var m = /* @__PURE__ */ new Set();
    m.add(i), o.nodes.set(c, m);
  }, this.del = function(c, i) {
    if (o.nodes.has(c)) {
      var d = o.nodes.get(c);
      if (d.size === 1) {
        o.nodes.delete(c);
        return;
      }
      d.delete(i);
    }
  }, this.emit = function(c, i) {
    i(c, o.nodes.get(c));
  }, this.nodes = /* @__PURE__ */ new Map();
}, LL = new g2e();
function v2e(r, o) {
  var c = ae.useRef(), i = ae.useRef(!1);
  Iue(function() {
    if (c.current = o, i.current) {
      var d = zA(r) ? r.current : r;
      LL.emit(d, eoe);
    }
    i.current = !0;
  }, [o]), Iue(function() {
    var d = zA(r) ? r.current : r;
    return LL.add(d, c), LL.emit(d, eoe), function() {
      LL.del(d, c), LL.emit(d, eoe);
    };
  }, [r]);
}
var b2e = Nk(function(r, o) {
  return vB(r) ? Kpe(r, o) : [];
});
const pi = b2e;
function KA(r) {
  var o = r.children, c = r.className, i = r.content, d = r.size, m = Vt(d, "icons", c), v = zt(KA, r), g = Xt(KA, r);
  return /* @__PURE__ */ ae.createElement(g, Be({}, v, {
    className: m
  }), dn(o) ? i : o);
}
KA.handledProps = ["as", "children", "className", "content", "size"];
KA.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** Size of the icon group. */
  size: _.oneOf(pi(mc, "medium"))
} : {};
KA.defaultProps = {
  as: "i"
};
var YA = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.handleClick = function(g) {
      var C = i.props.disabled;
      if (C) {
        g.preventDefault();
        return;
      }
      xn(i.props, "onClick", g, i.props);
    }, i;
  }
  var c = o.prototype;
  return c.getIconAriaOptions = function() {
    var d = {}, m = this.props, v = m["aria-label"], g = m["aria-hidden"];
    return ws(v) ? d["aria-hidden"] = "true" : d["aria-label"] = v, ws(g) || (d["aria-hidden"] = g), d;
  }, c.render = function() {
    var d = this.props, m = d.bordered, v = d.circular, g = d.className, C = d.color, O = d.corner, R = d.disabled, I = d.fitted, L = d.flipped, Z = d.inverted, ne = d.link, se = d.loading, Q = d.name, he = d.rotated, ue = d.size, G = Vt(C, Q, ue, $e(m, "bordered"), $e(v, "circular"), $e(R, "disabled"), $e(I, "fitted"), $e(Z, "inverted"), $e(ne, "link"), $e(se, "loading"), mi(O, "corner"), _u(L, "flipped"), _u(he, "rotated"), "icon", g), me = zt(o, this.props), we = Xt(o, this.props), be = this.getIconAriaOptions();
    return /* @__PURE__ */ ae.createElement(we, Be({}, me, be, {
      className: G,
      onClick: this.handleClick
    }));
  }, o;
}(bpe);
YA.handledProps = ["aria-hidden", "aria-label", "as", "bordered", "circular", "className", "color", "corner", "disabled", "fitted", "flipped", "inverted", "link", "loading", "name", "rotated", "size"];
YA.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Formatted to appear bordered. */
  bordered: _.bool,
  /** Icon can formatted to appear circular. */
  circular: _.bool,
  /** Additional classes. */
  className: _.string,
  /** Color of the icon. */
  color: _.oneOf(Om),
  /** Icons can display a smaller corner icon. */
  corner: _.oneOfType([_.bool, _.oneOf(["top left", "top right", "bottom left", "bottom right"])]),
  /** Show that the icon is inactive. */
  disabled: _.bool,
  /** Fitted, without space to left or right of Icon. */
  fitted: _.bool,
  /** Icon can be flipped. */
  flipped: _.oneOf(["horizontally", "vertically"]),
  /** Formatted to have its colors inverted for contrast. */
  inverted: _.bool,
  /** Icon can be formatted as a link. */
  link: _.bool,
  /** Icon can be used as a simple loader. */
  loading: _.bool,
  /** Name of the icon. */
  name: che(c2e),
  /** Icon can rotated. */
  rotated: _.oneOf(["clockwise", "counterclockwise"]),
  /** Size of the icon. */
  size: _.oneOf(pi(mc, "medium")),
  /** Icon can have an aria label. */
  "aria-hidden": _.string,
  /** Icon can have an aria label. */
  "aria-label": _.string
} : {};
YA.defaultProps = {
  as: "i"
};
YA.Group = KA;
YA.create = lo(YA, function(r) {
  return {
    name: r
  };
});
const fc = YA;
var Fue = function(o) {
  return o !== null && !Array.isArray(o) && typeof o == "object";
}, PW = {
  // ----------------------------------------
  // By Code
  // ----------------------------------------
  3: "Cancel",
  6: "Help",
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  28: "Convert",
  29: "NonConvert",
  30: "Accept",
  31: "ModeChange",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  41: "Select",
  42: "Print",
  43: "Execute",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  48: ["0", ")"],
  49: ["1", "!"],
  50: ["2", "@"],
  51: ["3", "#"],
  52: ["4", "$"],
  53: ["5", "%"],
  54: ["6", "^"],
  55: ["7", "&"],
  56: ["8", "*"],
  57: ["9", "("],
  91: "OS",
  93: "ContextMenu",
  144: "NumLock",
  145: "ScrollLock",
  181: "VolumeMute",
  182: "VolumeDown",
  183: "VolumeUp",
  186: [";", ":"],
  187: ["=", "+"],
  188: [",", "<"],
  189: ["-", "_"],
  190: [".", ">"],
  191: ["/", "?"],
  192: ["`", "~"],
  219: ["[", "{"],
  220: ["\\", "|"],
  221: ["]", "}"],
  222: ["'", '"'],
  224: "Meta",
  225: "AltGraph",
  246: "Attn",
  247: "CrSel",
  248: "ExSel",
  249: "EraseEof",
  250: "Play",
  251: "ZoomOut"
};
for (var Y9 = 0; Y9 < 24; Y9 += 1)
  PW[112 + Y9] = "F" + (Y9 + 1);
for (var toe = 0; toe < 26; toe += 1) {
  var noe = toe + 65;
  PW[noe] = [String.fromCharCode(noe + 32), String.fromCharCode(noe)];
}
var fr = {
  codes: PW,
  /**
   * Get the `keyCode` or `which` value from a keyboard event or `key` name.
   * @param {string|object} eventOrKey A keyboard event-like object or `key` name.
   * @param {string} [eventOrKey.key] If object, it must have one of these keys.
   * @param {number} [eventOrKey.keyCode] If object, it must have one of these keys.
   * @param {number} [eventOrKey.which] If object, it must have one of these keys.
   * @returns {number|undefined}
   */
  getCode: function(o) {
    return Fue(o) ? o.keyCode || o.which || this[o.key] : this[o];
  },
  /**
   * Get the key name from a keyboard event, `keyCode`, or `which` value.
   * @param {number|object} eventOrCode A keyboard event-like object or key code.
   * @param {string} [eventOrCode.key] If object with a `key` name, it will be returned.
   * @param {number} [eventOrCode.keyCode] If object, it must have one of these keys.
   * @param {number} [eventOrCode.which] If object, it must have one of these keys.
   * @param {boolean} [eventOrCode.shiftKey] If object, it must have one of these keys.
   * @returns {string|undefined}
   */
  getKey: function(o) {
    var c = Fue(o);
    if (c && o.key)
      return o.key;
    var i = PW[c ? o.keyCode || o.which : o];
    return Array.isArray(i) && (c ? i = i[o.shiftKey ? 1 : 0] : i = i[0]), i;
  },
  // ----------------------------------------
  // By Name
  // ----------------------------------------
  // declare these manually for static analysis
  Cancel: 3,
  Help: 6,
  Backspace: 8,
  Tab: 9,
  Clear: 12,
  Enter: 13,
  Shift: 16,
  Control: 17,
  Alt: 18,
  Pause: 19,
  CapsLock: 20,
  Escape: 27,
  Convert: 28,
  NonConvert: 29,
  Accept: 30,
  ModeChange: 31,
  " ": 32,
  PageUp: 33,
  PageDown: 34,
  End: 35,
  Home: 36,
  ArrowLeft: 37,
  ArrowUp: 38,
  ArrowRight: 39,
  ArrowDown: 40,
  Select: 41,
  Print: 42,
  Execute: 43,
  PrintScreen: 44,
  Insert: 45,
  Delete: 46,
  0: 48,
  ")": 48,
  1: 49,
  "!": 49,
  2: 50,
  "@": 50,
  3: 51,
  "#": 51,
  4: 52,
  $: 52,
  5: 53,
  "%": 53,
  6: 54,
  "^": 54,
  7: 55,
  "&": 55,
  8: 56,
  "*": 56,
  9: 57,
  "(": 57,
  a: 65,
  A: 65,
  b: 66,
  B: 66,
  c: 67,
  C: 67,
  d: 68,
  D: 68,
  e: 69,
  E: 69,
  f: 70,
  F: 70,
  g: 71,
  G: 71,
  h: 72,
  H: 72,
  i: 73,
  I: 73,
  j: 74,
  J: 74,
  k: 75,
  K: 75,
  l: 76,
  L: 76,
  m: 77,
  M: 77,
  n: 78,
  N: 78,
  o: 79,
  O: 79,
  p: 80,
  P: 80,
  q: 81,
  Q: 81,
  r: 82,
  R: 82,
  s: 83,
  S: 83,
  t: 84,
  T: 84,
  u: 85,
  U: 85,
  v: 86,
  V: 86,
  w: 87,
  W: 87,
  x: 88,
  X: 88,
  y: 89,
  Y: 89,
  z: 90,
  Z: 90,
  OS: 91,
  ContextMenu: 93,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123,
  F13: 124,
  F14: 125,
  F15: 126,
  F16: 127,
  F17: 128,
  F18: 129,
  F19: 130,
  F20: 131,
  F21: 132,
  F22: 133,
  F23: 134,
  F24: 135,
  NumLock: 144,
  ScrollLock: 145,
  VolumeMute: 181,
  VolumeDown: 182,
  VolumeUp: 183,
  ";": 186,
  ":": 186,
  "=": 187,
  "+": 187,
  ",": 188,
  "<": 188,
  "-": 189,
  _: 189,
  ".": 190,
  ">": 190,
  "/": 191,
  "?": 191,
  "`": 192,
  "~": 192,
  "[": 219,
  "{": 219,
  "\\": 220,
  "|": 220,
  "]": 221,
  "}": 221,
  "'": 222,
  '"': 222,
  Meta: 224,
  AltGraph: 225,
  Attn: 246,
  CrSel: 247,
  ExSel: 248,
  EraseEof: 249,
  Play: 250,
  ZoomOut: 251
};
fr.Spacebar = fr[" "];
fr.Digit0 = fr[0];
fr.Digit1 = fr[1];
fr.Digit2 = fr[2];
fr.Digit3 = fr[3];
fr.Digit4 = fr[4];
fr.Digit5 = fr[5];
fr.Digit6 = fr[6];
fr.Digit7 = fr[7];
fr.Digit8 = fr[8];
fr.Digit9 = fr[9];
fr.Tilde = fr["~"];
fr.GraveAccent = fr["`"];
fr.ExclamationPoint = fr["!"];
fr.AtSign = fr["@"];
fr.PoundSign = fr["#"];
fr.PercentSign = fr["%"];
fr.Caret = fr["^"];
fr.Ampersand = fr["&"];
fr.PlusSign = fr["+"];
fr.MinusSign = fr["-"];
fr.EqualsSign = fr["="];
fr.DivisionSign = fr["/"];
fr.MultiplicationSign = fr["*"];
fr.Comma = fr[","];
fr.Decimal = fr["."];
fr.Colon = fr[":"];
fr.Semicolon = fr[";"];
fr.Pipe = fr["|"];
fr.BackSlash = fr["\\"];
fr.QuestionMark = fr["?"];
fr.SingleQuote = fr["'"];
fr.DoubleQuote = fr['"'];
fr.LeftCurlyBrace = fr["{"];
fr.RightCurlyBrace = fr["}"];
fr.LeftParenthesis = fr["("];
fr.RightParenthesis = fr[")"];
fr.LeftAngleBracket = fr["<"];
fr.RightAngleBracket = fr[">"];
fr.LeftSquareBracket = fr["["];
fr.RightSquareBracket = fr["]"];
var y2e = fr;
const Di = /* @__PURE__ */ Ku(y2e);
var pse = { exports: {} }, Ni = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Lue;
function S2e() {
  if (Lue)
    return Ni;
  Lue = 1;
  var r = Symbol.for("react.element"), o = Symbol.for("react.portal"), c = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), d = Symbol.for("react.profiler"), m = Symbol.for("react.provider"), v = Symbol.for("react.context"), g = Symbol.for("react.server_context"), C = Symbol.for("react.forward_ref"), O = Symbol.for("react.suspense"), R = Symbol.for("react.suspense_list"), I = Symbol.for("react.memo"), L = Symbol.for("react.lazy"), Z = Symbol.for("react.offscreen"), ne;
  ne = Symbol.for("react.module.reference");
  function se(Q) {
    if (typeof Q == "object" && Q !== null) {
      var he = Q.$$typeof;
      switch (he) {
        case r:
          switch (Q = Q.type, Q) {
            case c:
            case d:
            case i:
            case O:
            case R:
              return Q;
            default:
              switch (Q = Q && Q.$$typeof, Q) {
                case g:
                case v:
                case C:
                case L:
                case I:
                case m:
                  return Q;
                default:
                  return he;
              }
          }
        case o:
          return he;
      }
    }
  }
  return Ni.ContextConsumer = v, Ni.ContextProvider = m, Ni.Element = r, Ni.ForwardRef = C, Ni.Fragment = c, Ni.Lazy = L, Ni.Memo = I, Ni.Portal = o, Ni.Profiler = d, Ni.StrictMode = i, Ni.Suspense = O, Ni.SuspenseList = R, Ni.isAsyncMode = function() {
    return !1;
  }, Ni.isConcurrentMode = function() {
    return !1;
  }, Ni.isContextConsumer = function(Q) {
    return se(Q) === v;
  }, Ni.isContextProvider = function(Q) {
    return se(Q) === m;
  }, Ni.isElement = function(Q) {
    return typeof Q == "object" && Q !== null && Q.$$typeof === r;
  }, Ni.isForwardRef = function(Q) {
    return se(Q) === C;
  }, Ni.isFragment = function(Q) {
    return se(Q) === c;
  }, Ni.isLazy = function(Q) {
    return se(Q) === L;
  }, Ni.isMemo = function(Q) {
    return se(Q) === I;
  }, Ni.isPortal = function(Q) {
    return se(Q) === o;
  }, Ni.isProfiler = function(Q) {
    return se(Q) === d;
  }, Ni.isStrictMode = function(Q) {
    return se(Q) === i;
  }, Ni.isSuspense = function(Q) {
    return se(Q) === O;
  }, Ni.isSuspenseList = function(Q) {
    return se(Q) === R;
  }, Ni.isValidElementType = function(Q) {
    return typeof Q == "string" || typeof Q == "function" || Q === c || Q === d || Q === i || Q === O || Q === R || Q === Z || typeof Q == "object" && Q !== null && (Q.$$typeof === L || Q.$$typeof === I || Q.$$typeof === m || Q.$$typeof === v || Q.$$typeof === C || Q.$$typeof === ne || Q.getModuleId !== void 0);
  }, Ni.typeOf = se, Ni;
}
var Ri = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Bue;
function w2e() {
  return Bue || (Bue = 1, process.env.NODE_ENV !== "production" && function() {
    var r = Symbol.for("react.element"), o = Symbol.for("react.portal"), c = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), d = Symbol.for("react.profiler"), m = Symbol.for("react.provider"), v = Symbol.for("react.context"), g = Symbol.for("react.server_context"), C = Symbol.for("react.forward_ref"), O = Symbol.for("react.suspense"), R = Symbol.for("react.suspense_list"), I = Symbol.for("react.memo"), L = Symbol.for("react.lazy"), Z = Symbol.for("react.offscreen"), ne = !1, se = !1, Q = !1, he = !1, ue = !1, G;
    G = Symbol.for("react.module.reference");
    function me(Ge) {
      return !!(typeof Ge == "string" || typeof Ge == "function" || Ge === c || Ge === d || ue || Ge === i || Ge === O || Ge === R || he || Ge === Z || ne || se || Q || typeof Ge == "object" && Ge !== null && (Ge.$$typeof === L || Ge.$$typeof === I || Ge.$$typeof === m || Ge.$$typeof === v || Ge.$$typeof === C || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      Ge.$$typeof === G || Ge.getModuleId !== void 0));
    }
    function we(Ge) {
      if (typeof Ge == "object" && Ge !== null) {
        var qt = Ge.$$typeof;
        switch (qt) {
          case r:
            var St = Ge.type;
            switch (St) {
              case c:
              case d:
              case i:
              case O:
              case R:
                return St;
              default:
                var ke = St && St.$$typeof;
                switch (ke) {
                  case g:
                  case v:
                  case C:
                  case L:
                  case I:
                  case m:
                    return ke;
                  default:
                    return qt;
                }
            }
          case o:
            return qt;
        }
      }
    }
    var be = v, q = m, Te = r, Le = C, je = c, Ie = L, Ce = I, pt = o, sn = d, Lt = i, z = O, bt = R, at = !1, _n = !1;
    function st(Ge) {
      return at || (at = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function Ne(Ge) {
      return _n || (_n = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function vt(Ge) {
      return we(Ge) === v;
    }
    function Gt(Ge) {
      return we(Ge) === m;
    }
    function xt(Ge) {
      return typeof Ge == "object" && Ge !== null && Ge.$$typeof === r;
    }
    function cn(Ge) {
      return we(Ge) === C;
    }
    function He(Ge) {
      return we(Ge) === c;
    }
    function ut(Ge) {
      return we(Ge) === L;
    }
    function oe(Ge) {
      return we(Ge) === I;
    }
    function qn(Ge) {
      return we(Ge) === o;
    }
    function Rn(Ge) {
      return we(Ge) === d;
    }
    function Zt(Ge) {
      return we(Ge) === i;
    }
    function Jt(Ge) {
      return we(Ge) === O;
    }
    function wo(Ge) {
      return we(Ge) === R;
    }
    Ri.ContextConsumer = be, Ri.ContextProvider = q, Ri.Element = Te, Ri.ForwardRef = Le, Ri.Fragment = je, Ri.Lazy = Ie, Ri.Memo = Ce, Ri.Portal = pt, Ri.Profiler = sn, Ri.StrictMode = Lt, Ri.Suspense = z, Ri.SuspenseList = bt, Ri.isAsyncMode = st, Ri.isConcurrentMode = Ne, Ri.isContextConsumer = vt, Ri.isContextProvider = Gt, Ri.isElement = xt, Ri.isForwardRef = cn, Ri.isFragment = He, Ri.isLazy = ut, Ri.isMemo = oe, Ri.isPortal = qn, Ri.isProfiler = Rn, Ri.isStrictMode = Zt, Ri.isSuspense = Jt, Ri.isSuspenseList = wo, Ri.isValidElementType = me, Ri.typeOf = we;
  }()), Ri;
}
process.env.NODE_ENV === "production" ? pse.exports = S2e() : pse.exports = w2e();
var E2e = pse.exports;
function C2e(r) {
  if (r && (ae.Children.only(r), E2e.isFragment(r)))
    throw new Error('An "React.Fragment" cannot be used as a `trigger`.');
}
var Tae = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.handleRef = function(g) {
      $S(i.props.innerRef, g);
    }, i;
  }
  var c = o.prototype;
  return c.componentDidMount = function() {
    xn(this.props, "onMount", null, this.props);
  }, c.componentWillUnmount = function() {
    xn(this.props, "onUnmount", null, this.props);
  }, c.render = function() {
    if (!$v())
      return null;
    var d = this.props, m = d.children, v = d.mountNode, g = v === void 0 ? document.body : v;
    return /* @__PURE__ */ w0e(/* @__PURE__ */ ae.createElement(yp, {
      innerRef: this.handleRef
    }, m), g);
  }, o;
}(Do);
Tae.handledProps = ["children", "innerRef", "mountNode", "onMount", "onUnmount"];
Tae.propTypes = process.env.NODE_ENV !== "production" ? {
  /** Primary content. */
  children: _.node.isRequired,
  /** Called with a ref to the inner node. */
  innerRef: uhe,
  /** The node where the portal should mount. */
  mountNode: _.any,
  /**
   * Called when the portal is mounted on the DOM
   *
   * @param {null}
   * @param {object} data - All props.
   */
  onMount: _.func,
  /**
   * Called when the portal is unmounted from the DOM
   *
   * @param {null}
   * @param {object} data - All props.
   */
  onUnmount: _.func
} : {};
const _ae = Tae;
var Z$ = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.contentRef = /* @__PURE__ */ ae.createRef(), i.triggerRef = /* @__PURE__ */ ae.createRef(), i.latestDocumentMouseDownEvent = null, i.handleDocumentMouseDown = function(g) {
      i.latestDocumentMouseDownEvent = g;
    }, i.handleDocumentClick = function(g) {
      var C = i.props.closeOnDocumentClick, O = i.latestDocumentMouseDownEvent;
      i.latestDocumentMouseDownEvent = null, !(!i.contentRef.current || // no portal
      f2(i.triggerRef.current, g) || // event happened in trigger (delegate to trigger handlers)
      O && f2(i.contentRef.current, O) || // event originated in the portal but was ended outside
      f2(i.contentRef.current, g)) && C && i.close(g);
    }, i.handleEscape = function(g) {
      i.props.closeOnEscape && Di.getCode(g) === Di.Escape && i.close(g);
    }, i.handlePortalMouseLeave = function(g) {
      var C = i.props, O = C.closeOnPortalMouseLeave, R = C.mouseLeaveDelay;
      O && g.target === i.contentRef.current && (i.mouseLeaveTimer = i.closeWithTimeout(g, R));
    }, i.handlePortalMouseEnter = function() {
      var g = i.props.closeOnPortalMouseLeave;
      g && clearTimeout(i.mouseLeaveTimer);
    }, i.handleTriggerBlur = function(g) {
      for (var C = i.props, O = C.trigger, R = C.closeOnTriggerBlur, I = arguments.length, L = new Array(I > 1 ? I - 1 : 0), Z = 1; Z < I; Z++)
        L[Z - 1] = arguments[Z];
      xn.apply(void 0, [O, "props.onBlur", g].concat(L));
      var ne = g.relatedTarget || document.activeElement, se = xn(i.contentRef.current, "contains", ne);
      !R || se || i.close(g);
    }, i.handleTriggerClick = function(g) {
      for (var C = i.props, O = C.trigger, R = C.closeOnTriggerClick, I = C.openOnTriggerClick, L = i.state.open, Z = arguments.length, ne = new Array(Z > 1 ? Z - 1 : 0), se = 1; se < Z; se++)
        ne[se - 1] = arguments[se];
      xn.apply(void 0, [O, "props.onClick", g].concat(ne)), L && R ? i.close(g) : !L && I && i.open(g);
    }, i.handleTriggerFocus = function(g) {
      for (var C = i.props, O = C.trigger, R = C.openOnTriggerFocus, I = arguments.length, L = new Array(I > 1 ? I - 1 : 0), Z = 1; Z < I; Z++)
        L[Z - 1] = arguments[Z];
      xn.apply(void 0, [O, "props.onFocus", g].concat(L)), R && i.open(g);
    }, i.handleTriggerMouseLeave = function(g) {
      clearTimeout(i.mouseEnterTimer);
      for (var C = i.props, O = C.trigger, R = C.closeOnTriggerMouseLeave, I = C.mouseLeaveDelay, L = arguments.length, Z = new Array(L > 1 ? L - 1 : 0), ne = 1; ne < L; ne++)
        Z[ne - 1] = arguments[ne];
      xn.apply(void 0, [O, "props.onMouseLeave", g].concat(Z)), R && (i.mouseLeaveTimer = i.closeWithTimeout(g, I));
    }, i.handleTriggerMouseEnter = function(g) {
      clearTimeout(i.mouseLeaveTimer);
      for (var C = i.props, O = C.trigger, R = C.mouseEnterDelay, I = C.openOnTriggerMouseEnter, L = arguments.length, Z = new Array(L > 1 ? L - 1 : 0), ne = 1; ne < L; ne++)
        Z[ne - 1] = arguments[ne];
      xn.apply(void 0, [O, "props.onMouseEnter", g].concat(Z)), I && (i.mouseEnterTimer = i.openWithTimeout(g, R));
    }, i.open = function(g) {
      xn(i.props, "onOpen", g, Be({}, i.props, {
        open: !0
      })), i.setState({
        open: !0
      });
    }, i.openWithTimeout = function(g, C) {
      var O = Be({}, g);
      return setTimeout(function() {
        return i.open(O);
      }, C || 0);
    }, i.close = function(g) {
      i.setState({
        open: !1
      }), xn(i.props, "onClose", g, Be({}, i.props, {
        open: !1
      }));
    }, i.closeWithTimeout = function(g, C) {
      var O = Be({}, g);
      return setTimeout(function() {
        return i.close(O);
      }, C || 0);
    }, i.handleMount = function() {
      xn(i.props, "onMount", null, i.props);
    }, i.handleUnmount = function() {
      xn(i.props, "onUnmount", null, i.props);
    }, i.handleTriggerRef = function(g) {
      i.triggerRef.current = g, $S(i.props.triggerRef, g);
    }, i;
  }
  var c = o.prototype;
  return c.componentWillUnmount = function() {
    clearTimeout(this.mouseEnterTimer), clearTimeout(this.mouseLeaveTimer);
  }, c.render = function() {
    var d = this.props, m = d.children, v = d.eventPool, g = d.mountNode, C = d.trigger, O = this.state.open;
    return process.env.NODE_ENV !== "production" && C2e(C), /* @__PURE__ */ ae.createElement(ae.Fragment, null, O && /* @__PURE__ */ ae.createElement(ae.Fragment, null, /* @__PURE__ */ ae.createElement(_ae, {
      innerRef: this.contentRef,
      mountNode: g,
      onMount: this.handleMount,
      onUnmount: this.handleUnmount
    }, m), /* @__PURE__ */ ae.createElement(rC, {
      name: "mouseleave",
      on: this.handlePortalMouseLeave,
      pool: v,
      target: this.contentRef
    }), /* @__PURE__ */ ae.createElement(rC, {
      name: "mouseenter",
      on: this.handlePortalMouseEnter,
      pool: v,
      target: this.contentRef
    }), /* @__PURE__ */ ae.createElement(rC, {
      name: "mousedown",
      on: this.handleDocumentMouseDown,
      pool: v
    }), /* @__PURE__ */ ae.createElement(rC, {
      name: "click",
      on: this.handleDocumentClick,
      pool: v
    }), /* @__PURE__ */ ae.createElement(rC, {
      name: "keydown",
      on: this.handleEscape,
      pool: v
    })), C && /* @__PURE__ */ ae.createElement(yp, {
      innerRef: this.handleTriggerRef
    }, /* @__PURE__ */ ae.cloneElement(C, {
      onBlur: this.handleTriggerBlur,
      onClick: this.handleTriggerClick,
      onFocus: this.handleTriggerFocus,
      onMouseLeave: this.handleTriggerMouseLeave,
      onMouseEnter: this.handleTriggerMouseEnter
    })));
  }, o;
}(P1);
Z$.handledProps = ["children", "closeOnDocumentClick", "closeOnEscape", "closeOnPortalMouseLeave", "closeOnTriggerBlur", "closeOnTriggerClick", "closeOnTriggerMouseLeave", "defaultOpen", "eventPool", "mountNode", "mouseEnterDelay", "mouseLeaveDelay", "onClose", "onMount", "onOpen", "onUnmount", "open", "openOnTriggerClick", "openOnTriggerFocus", "openOnTriggerMouseEnter", "trigger", "triggerRef"];
Z$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** Primary content. */
  children: _.node.isRequired,
  /** Controls whether or not the portal should close when the document is clicked. */
  closeOnDocumentClick: _.bool,
  /** Controls whether or not the portal should close when escape is pressed is displayed. */
  closeOnEscape: _.bool,
  /**
   * Controls whether or not the portal should close when mousing out of the portal.
   * NOTE: This will prevent `closeOnTriggerMouseLeave` when mousing over the
   * gap from the trigger to the portal.
   */
  closeOnPortalMouseLeave: _.bool,
  /** Controls whether or not the portal should close on blur of the trigger. */
  closeOnTriggerBlur: _.bool,
  /** Controls whether or not the portal should close on click of the trigger. */
  closeOnTriggerClick: _.bool,
  /** Controls whether or not the portal should close when mousing out of the trigger. */
  closeOnTriggerMouseLeave: _.bool,
  /** Initial value of open. */
  defaultOpen: _.bool,
  /** Event pool namespace that is used to handle component events */
  eventPool: _.string,
  /** The node where the portal should mount. */
  mountNode: _.any,
  /** Milliseconds to wait before opening on mouse over */
  mouseEnterDelay: _.number,
  /** Milliseconds to wait before closing on mouse leave */
  mouseLeaveDelay: _.number,
  /**
   * Called when a close event happens
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onClose: _.func,
  /**
   * Called when the portal is mounted on the DOM.
   *
   * @param {null}
   * @param {object} data - All props.
   */
  onMount: _.func,
  /**
   * Called when an open event happens
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onOpen: _.func,
  /**
   * Called when the portal is unmounted from the DOM.
   *
   * @param {null}
   * @param {object} data - All props.
   */
  onUnmount: _.func,
  /** Controls whether or not the portal is displayed. */
  open: _.bool,
  /** Controls whether or not the portal should open when the trigger is clicked. */
  openOnTriggerClick: _.bool,
  /** Controls whether or not the portal should open on focus of the trigger. */
  openOnTriggerFocus: _.bool,
  /** Controls whether or not the portal should open when mousing over the trigger. */
  openOnTriggerMouseEnter: _.bool,
  /** Element to be rendered in-place where the portal is defined. */
  trigger: _.node,
  /** Called with a ref to the trigger node. */
  triggerRef: uhe
} : {};
Z$.defaultProps = {
  closeOnDocumentClick: !0,
  closeOnEscape: !0,
  eventPool: "default",
  openOnTriggerClick: !0
};
Z$.autoControlledProps = ["open"];
Z$.Inner = _ae;
const m2 = Z$;
function XD(r) {
  var o = r.blurring, c = r.className, i = r.children, d = r.content, m = r.dimmed, v = Vt($e(o, "blurring"), $e(m, "dimmed"), "dimmable", c), g = zt(XD, r), C = Xt(XD, r);
  return /* @__PURE__ */ ae.createElement(C, Be({}, g, {
    className: v
  }), dn(i) ? d : i);
}
XD.handledProps = ["as", "blurring", "children", "className", "content", "dimmed"];
XD.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** A dimmable element can blur its contents. */
  blurring: _.bool,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** Controls whether or not the dim is displayed. */
  dimmed: _.bool
} : {};
var JD = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.containerRef = /* @__PURE__ */ bp(), i.contentRef = /* @__PURE__ */ bp(), i.handleClick = function(g) {
      var C = i.contentRef.current;
      xn(i.props, "onClick", g, i.props), !(C && C !== g.target && f2(C, g)) && xn(i.props, "onClickOutside", g, i.props);
    }, i;
  }
  var c = o.prototype;
  return c.componentDidMount = function() {
    var d = this.props.active;
    this.toggleStyles(d);
  }, c.componentDidUpdate = function(d) {
    var m = this.props.active, v = d.active;
    v !== m && this.toggleStyles(m);
  }, c.toggleStyles = function(d) {
    var m = this.containerRef.current;
    !m || !m.style || (d ? m.style.setProperty("display", "flex", "important") : m.style.removeProperty("display"));
  }, c.render = function() {
    var d = this.props, m = d.active, v = d.children, g = d.className, C = d.content, O = d.disabled, R = d.inverted, I = d.page, L = d.simple, Z = d.verticalAlign, ne = Vt("ui", $e(m, "active transition visible"), $e(O, "disabled"), $e(R, "inverted"), $e(I, "page"), $e(L, "simple"), by(Z), "dimmer", g), se = zt(o, this.props), Q = Xt(o, this.props), he = dn(v) ? C : v;
    return /* @__PURE__ */ ae.createElement(yp, {
      innerRef: this.containerRef
    }, /* @__PURE__ */ ae.createElement(Q, Be({}, se, {
      className: ne,
      onClick: this.handleClick
    }), he && /* @__PURE__ */ ae.createElement("div", {
      className: "content",
      ref: this.contentRef
    }, he)));
  }, o;
}(Do);
JD.handledProps = ["active", "as", "children", "className", "content", "disabled", "inverted", "onClick", "onClickOutside", "page", "simple", "verticalAlign"];
JD.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** An active dimmer will dim its parent container. */
  active: _.bool,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** A disabled dimmer cannot be activated */
  disabled: _.bool,
  /**
   * Called on click.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onClick: _.func,
  /**
   * Handles click outside Dimmer's content, but inside Dimmer area.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onClickOutside: _.func,
  /** A dimmer can be formatted to have its colors inverted. */
  inverted: _.bool,
  /** A dimmer can be formatted to be fixed to the page. */
  page: _.bool,
  /** A dimmer can be controlled with simple prop. */
  simple: _.bool,
  /** A dimmer can have its content top or bottom aligned. */
  verticalAlign: _.oneOf(["bottom", "top"])
} : {};
var S2 = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.handlePortalMount = function() {
      $v() && (document.body.classList.add("dimmed"), document.body.classList.add("dimmable"));
    }, i.handlePortalUnmount = function() {
      $v() && (document.body.classList.remove("dimmed"), document.body.classList.remove("dimmable"));
    }, i;
  }
  var c = o.prototype;
  return c.render = function() {
    var d = this.props, m = d.active, v = d.page, g = zt(o, this.props);
    return v ? /* @__PURE__ */ ae.createElement(m2, {
      closeOnEscape: !1,
      closeOnDocumentClick: !1,
      onMount: this.handlePortalMount,
      onUnmount: this.handlePortalUnmount,
      open: m,
      openOnTriggerClick: !1
    }, /* @__PURE__ */ ae.createElement(JD, Be({}, g, {
      active: m,
      page: v
    }))) : /* @__PURE__ */ ae.createElement(JD, Be({}, g, {
      active: m,
      page: v
    }));
  }, o;
}(Do);
S2.handledProps = ["active", "page"];
S2.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An active dimmer will dim its parent container. */
  active: _.bool,
  /** A dimmer can be formatted to be fixed to the page. */
  page: _.bool
} : {};
S2.Dimmable = XD;
S2.Inner = JD;
S2.create = lo(S2, function(r) {
  return {
    content: r
  };
});
function e$(r) {
  var o = r.children, c = r.className, i = r.content, d = r.size, m = Vt("ui", d, c, "images"), v = zt(e$, r), g = Xt(e$, r);
  return /* @__PURE__ */ ae.createElement(g, Be({}, v, {
    className: m
  }), dn(o) ? i : o);
}
e$.handledProps = ["as", "children", "className", "content", "size"];
e$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** A group of images can be formatted to have the same size. */
  size: _.oneOf(mc)
} : {};
function Qf(r) {
  var o = r.avatar, c = r.bordered, i = r.centered, d = r.children, m = r.circular, v = r.className, g = r.content, C = r.dimmer, O = r.disabled, R = r.floated, I = r.fluid, L = r.hidden, Z = r.href, ne = r.inline, se = r.label, Q = r.rounded, he = r.size, ue = r.spaced, G = r.verticalAlign, me = r.wrapped, we = r.ui, be = Vt($e(we, "ui"), he, $e(o, "avatar"), $e(c, "bordered"), $e(m, "circular"), $e(i, "centered"), $e(O, "disabled"), $e(I, "fluid"), $e(L, "hidden"), $e(ne, "inline"), $e(Q, "rounded"), mi(ue, "spaced"), _u(R, "floated"), by(G), "image", v), q = zt(Qf, r), Te = VB(q, {
    htmlProps: hhe
  }), Le = Te[0], je = Te[1], Ie = Xt(Qf, r, function() {
    if (!ws(C) || !ws(se) || !ws(me) || !dn(d))
      return "div";
  });
  return dn(d) ? dn(g) ? Ie === "img" ? /* @__PURE__ */ ae.createElement(Ie, Be({}, je, Le, {
    className: be
  })) : /* @__PURE__ */ ae.createElement(Ie, Be({}, je, {
    className: be,
    href: Z
  }), S2.create(C, {
    autoGenerateKey: !1
  }), Rh.create(se, {
    autoGenerateKey: !1
  }), /* @__PURE__ */ ae.createElement("img", Le)) : /* @__PURE__ */ ae.createElement(Ie, Be({}, q, {
    className: be
  }), g) : /* @__PURE__ */ ae.createElement(Ie, Be({}, q, {
    className: be
  }), d);
}
Qf.handledProps = ["as", "avatar", "bordered", "centered", "children", "circular", "className", "content", "dimmer", "disabled", "floated", "fluid", "hidden", "href", "inline", "label", "rounded", "size", "spaced", "ui", "verticalAlign", "wrapped"];
Qf.Group = e$;
Qf.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** An image may be formatted to appear inline with text as an avatar. */
  avatar: _.bool,
  /** An image may include a border to emphasize the edges of white or transparent content. */
  bordered: _.bool,
  /** An image can appear centered in a content block. */
  centered: _.bool,
  /** Primary content. */
  children: _.node,
  /** An image may appear circular. */
  circular: _.bool,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** An image can show that it is disabled and cannot be selected. */
  disabled: _.bool,
  /** Shorthand for Dimmer. */
  dimmer: Vn,
  /** An image can sit to the left or right of other content. */
  floated: _.oneOf(ew),
  /** An image can take up the width of its container. */
  fluid: co([_.bool, Go(["size"])]),
  /** An image can be hidden. */
  hidden: _.bool,
  /** Renders the Image as an <a> tag with this href. */
  href: _.string,
  /** An image may appear inline. */
  inline: _.bool,
  /** Shorthand for Label. */
  label: Vn,
  /** An image may appear rounded. */
  rounded: _.bool,
  /** An image may appear at different sizes. */
  size: _.oneOf(mc),
  /** An image can specify that it needs an additional spacing to separate it from nearby content. */
  spaced: _.oneOfType([_.bool, _.oneOf(["left", "right"])]),
  /** Whether or not to add the ui className. */
  ui: _.bool,
  /** An image can specify its vertical alignment. */
  verticalAlign: _.oneOf(D1),
  /** An image can render wrapped in a `div.ui.image` as alternative HTML markup. */
  wrapped: _.bool
} : {};
Qf.defaultProps = {
  as: "img",
  ui: !0
};
Qf.create = lo(Qf, function(r) {
  return {
    src: r
  };
});
function lC(r) {
  var o = r.children, c = r.className, i = r.content, d = Vt("detail", c), m = zt(lC, r), v = Xt(lC, r);
  return /* @__PURE__ */ ae.createElement(v, Be({}, m, {
    className: d
  }), dn(o) ? i : o);
}
lC.handledProps = ["as", "children", "className", "content"];
lC.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
lC.create = lo(lC, function(r) {
  return {
    content: r
  };
});
function t$(r) {
  var o = r.children, c = r.circular, i = r.className, d = r.color, m = r.content, v = r.size, g = r.tag, C = Vt("ui", d, v, $e(c, "circular"), $e(g, "tag"), "labels", i), O = zt(t$, r), R = Xt(t$, r);
  return /* @__PURE__ */ ae.createElement(R, Be({}, O, {
    className: C
  }), dn(o) ? m : o);
}
t$.handledProps = ["as", "children", "circular", "className", "color", "content", "size", "tag"];
t$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Labels can share shapes. */
  circular: _.bool,
  /** Additional classes. */
  className: _.string,
  /** Label group can share colors together. */
  color: _.oneOf(Om),
  /** Shorthand for primary content. */
  content: In,
  /** Label group can share sizes together. */
  size: _.oneOf(mc),
  /** Label group can share tag formatting. */
  tag: _.bool
} : {};
var Rh = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.handleClick = function(g) {
      var C = i.props.onClick;
      C && C(g, i.props);
    }, i.handleIconOverrides = function(g) {
      return {
        onClick: function(O) {
          xn(g, "onClick", O), xn(i.props, "onRemove", O, i.props);
        }
      };
    }, i;
  }
  var c = o.prototype;
  return c.render = function() {
    var d = this.props, m = d.active, v = d.attached, g = d.basic, C = d.children, O = d.circular, R = d.className, I = d.color, L = d.content, Z = d.corner, ne = d.detail, se = d.empty, Q = d.floating, he = d.horizontal, ue = d.icon, G = d.image, me = d.onRemove, we = d.pointing, be = d.prompt, q = d.removeIcon, Te = d.ribbon, Le = d.size, je = d.tag, Ie = we === !0 && "pointing" || (we === "left" || we === "right") && we + " pointing" || (we === "above" || we === "below") && "pointing " + we, Ce = Vt("ui", I, Ie, Le, $e(m, "active"), $e(g, "basic"), $e(O, "circular"), $e(se, "empty"), $e(Q, "floating"), $e(he, "horizontal"), $e(G === !0, "image"), $e(be, "prompt"), $e(je, "tag"), mi(Z, "corner"), mi(Te, "ribbon"), _u(v, "attached"), "label", R), pt = zt(o, this.props), sn = Xt(o, this.props);
    if (!dn(C))
      return /* @__PURE__ */ ae.createElement(sn, Be({}, pt, {
        className: Ce,
        onClick: this.handleClick
      }), C);
    var Lt = xh(q) ? "delete" : q;
    return /* @__PURE__ */ ae.createElement(sn, Be({
      className: Ce,
      onClick: this.handleClick
    }, pt), fc.create(ue, {
      autoGenerateKey: !1
    }), typeof G != "boolean" && Qf.create(G, {
      autoGenerateKey: !1
    }), L, lC.create(ne, {
      autoGenerateKey: !1
    }), me && fc.create(Lt, {
      autoGenerateKey: !1,
      overrideProps: this.handleIconOverrides
    }));
  }, o;
}(Do);
Rh.handledProps = ["active", "as", "attached", "basic", "children", "circular", "className", "color", "content", "corner", "detail", "empty", "floating", "horizontal", "icon", "image", "onClick", "onRemove", "pointing", "prompt", "removeIcon", "ribbon", "size", "tag"];
Rh.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** A label can be active. */
  active: _.bool,
  /** A label can attach to a content segment. */
  attached: _.oneOf(["top", "bottom", "top right", "top left", "bottom left", "bottom right"]),
  /** A label can reduce its complexity. */
  basic: _.bool,
  /** Primary content. */
  children: _.node,
  /** A label can be circular. */
  circular: _.bool,
  /** Additional classes. */
  className: _.string,
  /** Color of the label. */
  color: _.oneOf(Om),
  /** Shorthand for primary content. */
  content: In,
  /** A label can position itself in the corner of an element. */
  corner: _.oneOfType([_.bool, _.oneOf(["left", "right"])]),
  /** Shorthand for LabelDetail. */
  detail: Vn,
  /** Formats the label as a dot. */
  empty: co([_.bool, _h(["circular"])]),
  /** Float above another element in the upper right corner. */
  floating: _.bool,
  /** A horizontal label is formatted to label content along-side it horizontally. */
  horizontal: _.bool,
  /** Shorthand for Icon. */
  icon: Vn,
  /** A label can be formatted to emphasize an image or prop can be used as shorthand for Image. */
  image: _.oneOfType([_.bool, Vn]),
  /**
   * Called on click.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onClick: _.func,
  /**
   * Adds an "x" icon, called when "x" is clicked.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onRemove: _.func,
  /** A label can point to content next to it. */
  pointing: _.oneOfType([_.bool, _.oneOf(["above", "below", "left", "right"])]),
  /** A label can prompt for an error in your forms. */
  prompt: _.bool,
  /** Shorthand for Icon to appear as the last child and trigger onRemove. */
  removeIcon: Vn,
  /** A label can appear as a ribbon attaching itself to an element. */
  ribbon: _.oneOfType([_.bool, _.oneOf(["right"])]),
  /** A label can have different sizes. */
  size: _.oneOf(mc),
  /** A label can appear as a tag. */
  tag: _.bool
} : {};
Rh.Detail = lC;
Rh.Group = t$;
Rh.create = lo(Rh, function(r) {
  return {
    content: r
  };
});
function n$(r) {
  var o = r.children, c = r.className, i = r.content, d = r.hidden, m = r.visible, v = Vt($e(m, "visible"), $e(d, "hidden"), "content", c), g = zt(n$, r), C = Xt(n$, r);
  return /* @__PURE__ */ ae.createElement(C, Be({}, g, {
    className: v
  }), dn(o) ? i : o);
}
n$.handledProps = ["as", "children", "className", "content", "hidden", "visible"];
n$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** Initially hidden, visible on hover. */
  hidden: _.bool,
  /** Initially visible, hidden on hover. */
  visible: _.bool
} : {};
function r$(r) {
  var o = r.attached, c = r.basic, i = r.buttons, d = r.children, m = r.className, v = r.color, g = r.compact, C = r.content, O = r.floated, R = r.fluid, I = r.icon, L = r.inverted, Z = r.labeled, ne = r.negative, se = r.positive, Q = r.primary, he = r.secondary, ue = r.size, G = r.toggle, me = r.vertical, we = r.widths, be = Vt("ui", v, ue, $e(c, "basic"), $e(g, "compact"), $e(R, "fluid"), $e(I, "icon"), $e(L, "inverted"), $e(Z, "labeled"), $e(ne, "negative"), $e(se, "positive"), $e(Q, "primary"), $e(he, "secondary"), $e(G, "toggle"), $e(me, "vertical"), mi(o, "attached"), _u(O, "floated"), Kf(we), "buttons", m), q = zt(r$, r), Te = Xt(r$, r);
  return ws(i) ? /* @__PURE__ */ ae.createElement(Te, Be({}, q, {
    className: be
  }), dn(d) ? C : d) : /* @__PURE__ */ ae.createElement(Te, Be({}, q, {
    className: be
  }), fi(i, function(Le) {
    return hy.create(Le);
  }));
}
r$.handledProps = ["as", "attached", "basic", "buttons", "children", "className", "color", "compact", "content", "floated", "fluid", "icon", "inverted", "labeled", "negative", "positive", "primary", "secondary", "size", "toggle", "vertical", "widths"];
r$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Groups can be attached to other content. */
  attached: _.oneOfType([_.bool, _.oneOf(["left", "right", "top", "bottom"])]),
  /** Groups can be less pronounced. */
  basic: _.bool,
  /** Array of shorthand Button values. */
  buttons: Dh,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Groups can have a shared color. */
  color: _.oneOf(Om),
  /** Groups can reduce their padding to fit into tighter spaces. */
  compact: _.bool,
  /** Shorthand for primary content. */
  content: In,
  /** Groups can be aligned to the left or right of its container. */
  floated: _.oneOf(ew),
  /** Groups can take the width of their container. */
  fluid: _.bool,
  /** Groups can be formatted as icons. */
  icon: _.bool,
  /** Groups can be formatted to appear on dark backgrounds. */
  inverted: _.bool,
  /** Groups can be formatted as labeled icon buttons. */
  labeled: _.bool,
  /** Groups can hint towards a negative consequence. */
  negative: _.bool,
  /** Groups can hint towards a positive consequence. */
  positive: _.bool,
  /** Groups can be formatted to show different levels of emphasis. */
  primary: _.bool,
  /** Groups can be formatted to show different levels of emphasis. */
  secondary: _.bool,
  /** Groups can have different sizes. */
  size: _.oneOf(mc),
  /** Groups can be formatted to toggle on and off. */
  toggle: _.bool,
  /** Groups can be formatted to appear vertically. */
  vertical: _.bool,
  /** Groups can have their widths divided evenly. */
  widths: _.oneOf(hp)
} : {};
function o$(r) {
  var o = r.className, c = r.text, i = Vt("or", o), d = zt(o$, r), m = Xt(o$, r);
  return /* @__PURE__ */ ae.createElement(m, Be({}, d, {
    className: i,
    "data-text": c
  }));
}
o$.handledProps = ["as", "className", "text"];
o$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Additional classes. */
  className: _.string,
  /** Or buttons can have their text localized, or adjusted by using the text prop. */
  text: _.oneOfType([_.number, _.string])
} : {};
var uC = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.ref = /* @__PURE__ */ bp(), i.computeElementType = function() {
      var g = i.props, C = g.attached, O = g.label;
      if (!ws(C) || !ws(O))
        return "div";
    }, i.computeTabIndex = function(g) {
      var C = i.props, O = C.disabled, R = C.tabIndex;
      if (!ws(R))
        return R;
      if (O)
        return -1;
      if (g === "div")
        return 0;
    }, i.focus = function(g) {
      return xn(i.ref.current, "focus", g);
    }, i.handleClick = function(g) {
      var C = i.props.disabled;
      if (C) {
        g.preventDefault();
        return;
      }
      xn(i.props, "onClick", g, i.props);
    }, i.hasIconClass = function() {
      var g = i.props, C = g.labelPosition, O = g.children, R = g.content, I = g.icon;
      return I === !0 ? !0 : I && (C || dn(O) && ws(R));
    }, i;
  }
  var c = o.prototype;
  return c.computeButtonAriaRole = function(d) {
    var m = this.props.role;
    if (!ws(m))
      return m;
    if (d !== "button")
      return "button";
  }, c.render = function() {
    var d = this.props, m = d.active, v = d.animated, g = d.attached, C = d.basic, O = d.children, R = d.circular, I = d.className, L = d.color, Z = d.compact, ne = d.content, se = d.disabled, Q = d.floated, he = d.fluid, ue = d.icon, G = d.inverted, me = d.label, we = d.labelPosition, be = d.loading, q = d.negative, Te = d.positive, Le = d.primary, je = d.secondary, Ie = d.size, Ce = d.toggle, pt = d.type, sn = Vt(L, Ie, $e(m, "active"), $e(C, "basic"), $e(R, "circular"), $e(Z, "compact"), $e(he, "fluid"), $e(this.hasIconClass(), "icon"), $e(G, "inverted"), $e(be, "loading"), $e(q, "negative"), $e(Te, "positive"), $e(Le, "primary"), $e(je, "secondary"), $e(Ce, "toggle"), mi(v, "animated"), mi(g, "attached")), Lt = Vt(mi(we || !!me, "labeled")), z = Vt($e(se, "disabled"), _u(Q, "floated")), bt = zt(o, this.props), at = Xt(o, this.props, this.computeElementType), _n = this.computeTabIndex(at);
    if (!ws(me)) {
      var st = Vt("ui", sn, "button", I), Ne = Vt("ui", Lt, "button", I, z), vt = Rh.create(me, {
        defaultProps: {
          basic: !0,
          pointing: we === "left" ? "right" : "left"
        },
        autoGenerateKey: !1
      });
      return /* @__PURE__ */ ae.createElement(at, Be({}, bt, {
        className: Ne,
        onClick: this.handleClick
      }), we === "left" && vt, /* @__PURE__ */ ae.createElement(yp, {
        innerRef: this.ref
      }, /* @__PURE__ */ ae.createElement("button", {
        className: st,
        "aria-pressed": Ce ? !!m : void 0,
        disabled: se,
        type: pt,
        tabIndex: _n
      }, fc.create(ue, {
        autoGenerateKey: !1
      }), " ", ne)), (we === "right" || !we) && vt);
    }
    var Gt = Vt("ui", sn, z, Lt, "button", I), xt = !dn(O), cn = this.computeButtonAriaRole(at);
    return /* @__PURE__ */ ae.createElement(yp, {
      innerRef: this.ref
    }, /* @__PURE__ */ ae.createElement(at, Be({}, bt, {
      className: Gt,
      "aria-pressed": Ce ? !!m : void 0,
      disabled: se && at === "button" || void 0,
      onClick: this.handleClick,
      role: cn,
      type: pt,
      tabIndex: _n
    }), xt && O, !xt && fc.create(ue, {
      autoGenerateKey: !1
    }), !xt && ne));
  }, o;
}(Do);
uC.handledProps = ["active", "animated", "as", "attached", "basic", "children", "circular", "className", "color", "compact", "content", "disabled", "floated", "fluid", "icon", "inverted", "label", "labelPosition", "loading", "negative", "onClick", "positive", "primary", "role", "secondary", "size", "tabIndex", "toggle", "type"];
uC.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** A button can show it is currently the active user selection. */
  active: _.bool,
  /** A button can animate to show hidden content. */
  animated: _.oneOfType([_.bool, _.oneOf(["fade", "vertical"])]),
  /** A button can be attached to other content. */
  attached: _.oneOfType([_.bool, _.oneOf(["left", "right", "top", "bottom"])]),
  /** A basic button is less pronounced. */
  basic: _.bool,
  /** Primary content. */
  children: co([_.node, Go(["label"]), lhe({
    icon: _.oneOfType([_.string.isRequired, _.object.isRequired, _.element.isRequired])
  }, Go(["icon"]))]),
  /** A button can be circular. */
  circular: _.bool,
  /** Additional classes. */
  className: _.string,
  /** A button can have different colors */
  color: _.oneOf([].concat(Om, ["facebook", "google plus", "instagram", "linkedin", "twitter", "vk", "youtube"])),
  /** A button can reduce its padding to fit into tighter spaces. */
  compact: _.bool,
  /** Shorthand for primary content. */
  content: In,
  /** A button can show it is currently unable to be interacted with. */
  disabled: _.bool,
  /** A button can be aligned to the left or right of its container. */
  floated: _.oneOf(ew),
  /** A button can take the width of its container. */
  fluid: _.bool,
  /** Add an Icon by name, props object, or pass an <Icon />. */
  icon: _.oneOfType([_.bool, _.string, _.object, _.element]),
  /** A button can be formatted to appear on dark backgrounds. */
  inverted: _.bool,
  /** Add a Label by text, props object, or pass a <Label />. */
  label: _.oneOfType([_.string, _.object, _.element]),
  /** A labeled button can format a Label or Icon to appear on the left or right. */
  labelPosition: _.oneOf(["right", "left"]),
  /** A button can show a loading indicator. */
  loading: _.bool,
  /** A button can hint towards a negative consequence. */
  negative: _.bool,
  /**
   * Called after user's click.
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onClick: _.func,
  /** A button can hint towards a positive consequence. */
  positive: _.bool,
  /** A button can be formatted to show different levels of emphasis. */
  primary: _.bool,
  /** The role of the HTML element. */
  role: _.string,
  /** A button can be formatted to show different levels of emphasis. */
  secondary: _.bool,
  /** A button can have different sizes. */
  size: _.oneOf(mc),
  /** A button can receive focus. */
  tabIndex: _.oneOfType([_.number, _.string]),
  /** A button can be formatted to toggle on and off. */
  toggle: _.bool,
  /** The type of the HTML element. */
  type: _.oneOf(["button", "submit", "reset"])
} : {};
uC.defaultProps = {
  as: "button"
};
uC.Content = n$;
uC.Group = r$;
uC.Or = o$;
uC.create = lo(uC, function(r) {
  return {
    content: r
  };
});
const hy = uC;
function She(r, o, c, i) {
  var d = -1, m = r == null ? 0 : r.length;
  for (i && m && (c = r[++d]); ++d < m; )
    c = o(c, r[d], d, r);
  return c;
}
function x2e(r, o, c, i, d) {
  return d(r, function(m, v, g) {
    c = i ? (i = !1, m) : o(c, m, v, g);
  }), c;
}
function _j(r, o, c) {
  var i = qc(r) ? She : x2e, d = arguments.length < 3;
  return i(r, R1(o), c, d, Rk);
}
var T2e = function(o, c, i, d) {
  var m = i ? i.call(d, o, c) : void 0;
  if (m !== void 0)
    return !!m;
  if (o === c)
    return !0;
  if (typeof o != "object" || !o || typeof c != "object" || !c)
    return !1;
  var v = Object.keys(o), g = Object.keys(c);
  if (v.length !== g.length)
    return !1;
  for (var C = Object.prototype.hasOwnProperty.bind(c), O = 0; O < v.length; O++) {
    var R = v[O];
    if (!C(R))
      return !1;
    var I = o[R], L = c[R];
    if (m = i ? i.call(d, I, L, R) : void 0, m === !1 || m === void 0 && I !== L)
      return !1;
  }
  return !0;
};
const p2 = /* @__PURE__ */ Ku(T2e);
var w2 = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.handleButtonOverrides = function(g) {
      return {
        onClick: function(O, R) {
          xn(g, "onClick", O, R), xn(i.props, "onActionClick", O, R);
        }
      };
    }, i;
  }
  var c = o.prototype;
  return c.render = function() {
    var d = this, m = this.props, v = m.actions, g = m.children, C = m.className, O = m.content, R = Vt("actions", C), I = zt(o, this.props), L = Xt(o, this.props);
    return dn(g) ? dn(O) ? /* @__PURE__ */ ae.createElement(L, Be({}, I, {
      className: R
    }), fi(v, function(Z) {
      return hy.create(Z, {
        overrideProps: d.handleButtonOverrides
      });
    })) : /* @__PURE__ */ ae.createElement(L, Be({}, I, {
      className: R
    }), O) : /* @__PURE__ */ ae.createElement(L, Be({}, I, {
      className: R
    }), g);
  }, o;
}(Do);
w2.handledProps = ["actions", "as", "children", "className", "content", "onActionClick"];
w2.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Array of shorthand buttons. */
  actions: Dh,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /**
   * Action onClick handler when using shorthand `actions`.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props from the clicked action.
   */
  onActionClick: co([Go(["children"]), _.func])
} : {};
w2.create = lo(w2, function(r) {
  return {
    actions: r
  };
});
function HS(r) {
  var o = r.children, c = r.className, i = r.content, d = r.image, m = r.scrolling, v = Vt(c, $e(d, "image"), $e(m, "scrolling"), "content"), g = zt(HS, r), C = Xt(HS, r);
  return /* @__PURE__ */ ae.createElement(C, Be({}, g, {
    className: v
  }), dn(o) ? i : o);
}
HS.handledProps = ["as", "children", "className", "content", "image", "scrolling"];
HS.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** A modal can contain image content. */
  image: _.bool,
  /** A modal can use the entire size of the screen. */
  scrolling: _.bool
} : {};
HS.create = lo(HS, function(r) {
  return {
    content: r
  };
});
function s$(r) {
  var o = r.children, c = r.className, i = r.content, d = Vt("description", c), m = zt(s$, r), v = Xt(s$, r);
  return /* @__PURE__ */ ae.createElement(v, Be({}, m, {
    className: d
  }), dn(o) ? i : o);
}
s$.handledProps = ["as", "children", "className", "content"];
s$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
function dC(r) {
  var o = r.blurring, c = r.children, i = r.className, d = r.centered, m = r.content, v = r.inverted, g = r.mountNode, C = r.scrolling, O = ae.useRef(), R = Vt("ui", $e(v, "inverted"), $e(!d, "top aligned"), "page modals dimmer transition visible active", i), I = Vt("dimmable dimmed", $e(o, "blurring"), $e(C, "scrolling")), L = zt(dC, r), Z = Xt(dC, r);
  return v2e(g, I), ae.useEffect(function() {
    O.current && O.current.style && O.current.style.setProperty("display", "flex", "important");
  }, []), /* @__PURE__ */ ae.createElement(yp, {
    innerRef: O
  }, /* @__PURE__ */ ae.createElement(Z, Be({}, L, {
    className: R
  }), dn(c) ? m : c));
}
dC.handledProps = ["as", "blurring", "centered", "children", "className", "content", "inverted", "mountNode", "scrolling"];
dC.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** A dimmer can be blurred. */
  blurring: _.bool,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** A dimmer can center its contents in the viewport. */
  centered: _.bool,
  /** Shorthand for primary content. */
  content: In,
  /** A dimmer can be inverted. */
  inverted: _.bool,
  /** The node where the modal should mount. Defaults to document.body. */
  mountNode: _.any,
  /** A dimmer can make body scrollable. */
  scrolling: _.bool
} : {};
dC.create = lo(dC, function(r) {
  return {
    content: r
  };
});
function zS(r) {
  var o = r.children, c = r.className, i = r.content, d = Vt("header", c), m = zt(zS, r), v = Xt(zS, r);
  return /* @__PURE__ */ ae.createElement(v, Be({}, m, {
    className: d
  }), dn(o) ? i : o);
}
zS.handledProps = ["as", "children", "className", "content"];
zS.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
zS.create = lo(zS, function(r) {
  return {
    content: r
  };
});
var Hue = 0, _2e = 50, O2e = function(o) {
  var c = o.height + Hue, i = o.height + Hue, d = window.innerHeight, m = d / 2, v = -(i / 2), g = _2e, C = m + v;
  return C + c + g < d;
}, A2e = function(o, c, i) {
  var d = c && o ? -(i.height / 2) : 0, m = -(i.width / 2);
  return {
    marginLeft: m,
    marginTop: d
  };
}, k2e = function() {
  return !window.ActiveXObject && "ActiveXObject" in window;
}, tw = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.legacy = $v() && k2e(), i.ref = /* @__PURE__ */ bp(), i.dimmerRef = /* @__PURE__ */ bp(), i.latestDocumentMouseDownEvent = null, i.getMountNode = function() {
      return $v() ? i.props.mountNode || document.body : null;
    }, i.handleActionsOverrides = function(g) {
      return {
        onActionClick: function(O, R) {
          xn(g, "onActionClick", O, R), xn(i.props, "onActionClick", O, i.props), i.handleClose(O);
        }
      };
    }, i.handleClose = function(g) {
      i.setState({
        open: !1
      }), xn(i.props, "onClose", g, Be({}, i.props, {
        open: !1
      }));
    }, i.handleDocumentMouseDown = function(g) {
      i.latestDocumentMouseDownEvent = g;
    }, i.handleDocumentClick = function(g) {
      var C = i.props.closeOnDimmerClick, O = i.latestDocumentMouseDownEvent;
      i.latestDocumentMouseDownEvent = null, !(!C || f2(i.ref.current, O) || f2(i.ref.current, g)) && (i.setState({
        open: !1
      }), xn(i.props, "onClose", g, Be({}, i.props, {
        open: !1
      })));
    }, i.handleIconOverrides = function(g) {
      return {
        onClick: function(O) {
          xn(g, "onClick", O), i.handleClose(O);
        }
      };
    }, i.handleOpen = function(g) {
      xn(i.props, "onOpen", g, Be({}, i.props, {
        open: !0
      })), i.setState({
        open: !0
      });
    }, i.handlePortalMount = function(g) {
      var C = i.props.eventPool;
      i.setState({
        scrolling: !1
      }), i.setPositionAndClassNames(), Ql.sub("mousedown", i.handleDocumentMouseDown, {
        pool: C,
        target: i.dimmerRef.current
      }), Ql.sub("click", i.handleDocumentClick, {
        pool: C,
        target: i.dimmerRef.current
      }), xn(i.props, "onMount", g, i.props);
    }, i.handlePortalUnmount = function(g) {
      var C = i.props.eventPool;
      cancelAnimationFrame(i.animationRequestId), Ql.unsub("mousedown", i.handleDocumentMouseDown, {
        pool: C,
        target: i.dimmerRef.current
      }), Ql.unsub("click", i.handleDocumentClick, {
        pool: C,
        target: i.dimmerRef.current
      }), xn(i.props, "onUnmount", g, i.props);
    }, i.setPositionAndClassNames = function() {
      var g = i.props.centered, C, O = {};
      if (i.ref.current) {
        var R = i.ref.current.getBoundingClientRect(), I = O2e(R);
        C = !I;
        var L = i.legacy ? A2e(I, g, R) : {};
        p2(i.state.legacyStyles, L) || (O.legacyStyles = L), i.state.scrolling !== C && (O.scrolling = C);
      }
      u2(O) || i.setState(O), i.animationRequestId = requestAnimationFrame(i.setPositionAndClassNames);
    }, i.renderContent = function(g) {
      var C = i.props, O = C.actions, R = C.basic, I = C.children, L = C.className, Z = C.closeIcon, ne = C.content, se = C.header, Q = C.size, he = C.style, ue = i.state, G = ue.legacyStyles, me = ue.scrolling, we = Vt("ui", Q, $e(R, "basic"), $e(i.legacy, "legacy"), $e(me, "scrolling"), "modal transition visible active", L), be = Xt(o, i.props), q = Z === !0 ? "close" : Z, Te = fc.create(q, {
        overrideProps: i.handleIconOverrides
      });
      return /* @__PURE__ */ ae.createElement(yp, {
        innerRef: i.ref
      }, /* @__PURE__ */ ae.createElement(be, Be({}, g, {
        className: we,
        style: Be({}, G, he)
      }), Te, dn(I) ? /* @__PURE__ */ ae.createElement(ae.Fragment, null, zS.create(se, {
        autoGenerateKey: !1
      }), HS.create(ne, {
        autoGenerateKey: !1
      }), w2.create(O, {
        overrideProps: i.handleActionsOverrides
      })) : I));
    }, i;
  }
  var c = o.prototype;
  return c.componentWillUnmount = function() {
    this.handlePortalUnmount();
  }, c.render = function() {
    var d = this.props, m = d.centered, v = d.closeOnDocumentClick, g = d.dimmer, C = d.eventPool, O = d.trigger, R = this.state, I = R.open, L = R.scrolling, Z = this.getMountNode();
    if (!$v())
      return /* @__PURE__ */ oae(O) ? O : null;
    var ne = zt(o, this.props), se = m2.handledProps, Q = _j(ne, function(ue, G, me) {
      return Og(se, me) || (ue[me] = G), ue;
    }, {}), he = wj(ne, se);
    return /* @__PURE__ */ ae.createElement(m2, Be({
      closeOnDocumentClick: v
    }, he, {
      trigger: O,
      eventPool: C,
      mountNode: Z,
      open: I,
      onClose: this.handleClose,
      onMount: this.handlePortalMount,
      onOpen: this.handleOpen,
      onUnmount: this.handlePortalUnmount
    }), /* @__PURE__ */ ae.createElement(yp, {
      innerRef: this.dimmerRef
    }, dC.create(y2(g) ? g : {}, {
      autoGenerateKey: !1,
      defaultProps: {
        blurring: g === "blurring",
        inverted: g === "inverted"
      },
      overrideProps: {
        children: this.renderContent(Q),
        centered: m,
        mountNode: Z,
        scrolling: L
      }
    })));
  }, o;
}(P1);
tw.handledProps = ["actions", "as", "basic", "centered", "children", "className", "closeIcon", "closeOnDimmerClick", "closeOnDocumentClick", "content", "defaultOpen", "dimmer", "eventPool", "header", "mountNode", "onActionClick", "onClose", "onMount", "onOpen", "onUnmount", "open", "size", "style", "trigger"];
tw.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Shorthand for Modal.Actions. Typically an array of button shorthand. */
  actions: Vn,
  /** A modal can reduce its complexity */
  basic: _.bool,
  /** A modal can be vertically centered in the viewport */
  centered: _.bool,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for the close icon. Closes the modal on click. */
  closeIcon: _.oneOfType([_.node, _.object, _.bool]),
  /** Whether or not the Modal should close when the dimmer is clicked. */
  closeOnDimmerClick: _.bool,
  /** Whether or not the Modal should close when the document is clicked. */
  closeOnDocumentClick: _.bool,
  /** Simple text content for the Modal. */
  content: Vn,
  /** Initial value of open. */
  defaultOpen: _.bool,
  /** A Modal can appear in a dimmer. */
  dimmer: _.oneOfType([_.bool, _.func, _.object, _.oneOf(["inverted", "blurring"])]),
  /** Event pool namespace that is used to handle component events */
  eventPool: _.string,
  /** Modal displayed above the content in bold. */
  header: Vn,
  /** The node where the modal should mount. Defaults to document.body. */
  mountNode: _.any,
  /**
   * Action onClick handler when using shorthand `actions`.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onActionClick: _.func,
  /**
   * Called when a close event happens.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onClose: _.func,
  /**
   * Called when the modal is mounted on the DOM.
   *
   * @param {null}
   * @param {object} data - All props.
   */
  onMount: _.func,
  /**
   * Called when an open event happens.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onOpen: _.func,
  /**
   * Called when the modal is unmounted from the DOM.
   *
   * @param {null}
   * @param {object} data - All props.
   */
  onUnmount: _.func,
  /** Controls whether or not the Modal is displayed. */
  open: _.bool,
  /** A modal can vary in size */
  size: _.oneOf(["mini", "tiny", "small", "large", "fullscreen"]),
  /** Custom styles. */
  style: _.object,
  /** Element to be rendered in-place where the modal is defined. */
  trigger: _.node
  /**
   * NOTE: Any unhandled props that are defined in Modal are passed-through
   * to the inner Portal.
   */
} : {};
tw.defaultProps = {
  centered: !0,
  dimmer: !0,
  closeOnDimmerClick: !0,
  closeOnDocumentClick: !1,
  eventPool: "Modal"
};
tw.autoControlledProps = ["open"];
tw.Actions = w2;
tw.Content = HS;
tw.Description = s$;
tw.Dimmer = dC;
tw.Header = zS;
const HD = tw;
var Oj = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.handleCancel = function(g) {
      xn(i.props, "onCancel", g, i.props);
    }, i.handleCancelOverrides = function(g) {
      return {
        onClick: function(O, R) {
          xn(g, "onClick", O, R), i.handleCancel(O);
        }
      };
    }, i.handleConfirmOverrides = function(g) {
      return {
        onClick: function(O, R) {
          xn(g, "onClick", O, R), xn(i.props, "onConfirm", O, i.props);
        }
      };
    }, i;
  }
  var c = o.prototype;
  return c.render = function() {
    var d = this.props, m = d.cancelButton, v = d.confirmButton, g = d.content, C = d.header, O = d.open, R = d.size, I = zt(o, this.props), L = {};
    return iC(this.props, "open") && (L.open = O), /* @__PURE__ */ ae.createElement(HD, Be({}, I, L, {
      size: R,
      onClose: this.handleCancel
    }), HD.Header.create(C, {
      autoGenerateKey: !1
    }), HD.Content.create(g, {
      autoGenerateKey: !1
    }), /* @__PURE__ */ ae.createElement(HD.Actions, null, hy.create(m, {
      autoGenerateKey: !1,
      overrideProps: this.handleCancelOverrides
    }), hy.create(v, {
      autoGenerateKey: !1,
      defaultProps: {
        primary: !0
      },
      overrideProps: this.handleConfirmOverrides
    })));
  }, o;
}(Do);
Oj.handledProps = ["cancelButton", "confirmButton", "content", "header", "onCancel", "onConfirm", "open", "size"];
Oj.propTypes = process.env.NODE_ENV !== "production" ? {
  /** The cancel button text. */
  cancelButton: Vn,
  /** The OK button text. */
  confirmButton: Vn,
  /** The ModalContent text. */
  content: Vn,
  /** The ModalHeader text. */
  header: Vn,
  /**
   * Called when the Modal is closed without clicking confirm.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onCancel: _.func,
  /**
   * Called when the OK button is clicked.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onConfirm: _.func,
  /** Whether or not the modal is visible. */
  open: _.bool,
  /** A Confirm can vary in size */
  size: _.oneOf(["mini", "tiny", "small", "large", "fullscreen"])
} : {};
Oj.defaultProps = {
  cancelButton: "Cancel",
  confirmButton: "OK",
  content: "Are you sure?",
  size: "small"
};
const N2e = Oj;
function a$(r) {
  var o = r.children, c = r.className, i = r.content, d = Vt("header", c), m = zt(a$, r), v = Xt(a$, r);
  return /* @__PURE__ */ ae.createElement(v, Be({}, m, {
    className: d
  }), dn(o) ? i : o);
}
a$.handledProps = ["as", "children", "className", "content"];
a$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
function R2e(r) {
  return function(o) {
    return r == null ? void 0 : r[o];
  };
}
var P2e = {
  // Latin-1 Supplement block.
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "C",
  : "c",
  : "D",
  : "d",
  : "E",
  : "E",
  : "E",
  : "E",
  : "e",
  : "e",
  : "e",
  : "e",
  : "I",
  : "I",
  : "I",
  : "I",
  : "i",
  : "i",
  : "i",
  : "i",
  : "N",
  : "n",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "U",
  : "U",
  : "U",
  : "U",
  : "u",
  : "u",
  : "u",
  : "u",
  : "Y",
  : "y",
  : "y",
  : "Ae",
  : "ae",
  : "Th",
  : "th",
  : "ss",
  // Latin Extended-A block.
  : "A",
  : "A",
  : "A",
  : "a",
  : "a",
  : "a",
  : "C",
  : "C",
  : "C",
  : "C",
  : "c",
  : "c",
  : "c",
  : "c",
  : "D",
  : "D",
  : "d",
  : "d",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "G",
  : "G",
  : "G",
  : "G",
  : "g",
  : "g",
  : "g",
  : "g",
  : "H",
  : "H",
  : "h",
  : "h",
  : "I",
  : "I",
  : "I",
  : "I",
  : "I",
  : "i",
  : "i",
  : "i",
  : "i",
  : "i",
  : "J",
  : "j",
  : "K",
  : "k",
  : "k",
  : "L",
  : "L",
  : "L",
  : "L",
  : "L",
  : "l",
  : "l",
  : "l",
  : "l",
  : "l",
  : "N",
  : "N",
  : "N",
  : "N",
  : "n",
  : "n",
  : "n",
  : "n",
  : "O",
  : "O",
  : "O",
  : "o",
  : "o",
  : "o",
  : "R",
  : "R",
  : "R",
  : "r",
  : "r",
  : "r",
  : "S",
  : "S",
  : "S",
  : "S",
  : "s",
  : "s",
  : "s",
  : "s",
  : "T",
  : "T",
  : "T",
  : "t",
  : "t",
  : "t",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "W",
  : "w",
  : "Y",
  : "y",
  : "Y",
  : "Z",
  : "Z",
  : "Z",
  : "z",
  : "z",
  : "z",
  : "IJ",
  : "ij",
  : "Oe",
  : "oe",
  : "'n",
  : "s"
}, D2e = R2e(P2e);
const $2e = D2e;
var I2e = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, M2e = "\\u0300-\\u036f", F2e = "\\ufe20-\\ufe2f", L2e = "\\u20d0-\\u20ff", B2e = M2e + F2e + L2e, H2e = "[" + B2e + "]", z2e = RegExp(H2e, "g");
function hse(r) {
  return r = BS(r), r && r.replace(I2e, $2e).replace(z2e, "");
}
var V2e = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function U2e(r) {
  return r.match(V2e) || [];
}
var W2e = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function j2e(r) {
  return W2e.test(r);
}
var whe = "\\ud800-\\udfff", q2e = "\\u0300-\\u036f", G2e = "\\ufe20-\\ufe2f", Z2e = "\\u20d0-\\u20ff", K2e = q2e + G2e + Z2e, Ehe = "\\u2700-\\u27bf", Che = "a-z\\xdf-\\xf6\\xf8-\\xff", Y2e = "\\xac\\xb1\\xd7\\xf7", Q2e = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", X2e = "\\u2000-\\u206f", J2e = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", xhe = "A-Z\\xc0-\\xd6\\xd8-\\xde", e_e = "\\ufe0e\\ufe0f", The = Y2e + Q2e + X2e + J2e, _he = "[']", zue = "[" + The + "]", t_e = "[" + K2e + "]", Ohe = "\\d+", n_e = "[" + Ehe + "]", Ahe = "[" + Che + "]", khe = "[^" + whe + The + Ohe + Ehe + Che + xhe + "]", r_e = "\\ud83c[\\udffb-\\udfff]", o_e = "(?:" + t_e + "|" + r_e + ")", s_e = "[^" + whe + "]", Nhe = "(?:\\ud83c[\\udde6-\\uddff]){2}", Rhe = "[\\ud800-\\udbff][\\udc00-\\udfff]", MD = "[" + xhe + "]", a_e = "\\u200d", Vue = "(?:" + Ahe + "|" + khe + ")", i_e = "(?:" + MD + "|" + khe + ")", Uue = "(?:" + _he + "(?:d|ll|m|re|s|t|ve))?", Wue = "(?:" + _he + "(?:D|LL|M|RE|S|T|VE))?", Phe = o_e + "?", Dhe = "[" + e_e + "]?", c_e = "(?:" + a_e + "(?:" + [s_e, Nhe, Rhe].join("|") + ")" + Dhe + Phe + ")*", l_e = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", u_e = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", d_e = Dhe + Phe + c_e, f_e = "(?:" + [n_e, Nhe, Rhe].join("|") + ")" + d_e, m_e = RegExp([
  MD + "?" + Ahe + "+" + Uue + "(?=" + [zue, MD, "$"].join("|") + ")",
  i_e + "+" + Wue + "(?=" + [zue, MD + Vue, "$"].join("|") + ")",
  MD + "?" + Vue + "+" + Uue,
  MD + "+" + Wue,
  u_e,
  l_e,
  Ohe,
  f_e
].join("|"), "g");
function p_e(r) {
  return r.match(m_e) || [];
}
function h_e(r, o, c) {
  return r = BS(r), o = c ? void 0 : o, o === void 0 ? j2e(r) ? p_e(r) : U2e(r) : r.match(o) || [];
}
var g_e = "[']", v_e = RegExp(g_e, "g");
function b_e(r) {
  return function(o) {
    return She(h_e(hse(o).replace(v_e, "")), r, "");
  };
}
function y_e(r) {
  return function(o) {
    o = BS(o);
    var c = bae(o) ? use(o) : void 0, i = c ? c[0] : o.charAt(0), d = c ? Ype(c, 1).join("") : o.slice(1);
    return i[r]() + d;
  };
}
var S_e = y_e("toUpperCase");
const w_e = S_e;
var E_e = b_e(function(r, o, c) {
  return r + (c ? " " : "") + w_e(o);
});
const C_e = E_e;
var E2 = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.handleClick = function(g) {
      var C = i.props.disabled;
      C || xn(i.props, "onClick", g, i.props);
    }, i;
  }
  var c = o.prototype;
  return c.render = function() {
    var d = this.props, m = d.active, v = d.children, g = d.className, C = d.color, O = d.content, R = d.disabled, I = d.fitted, L = d.header, Z = d.icon, ne = d.link, se = d.name, Q = d.onClick, he = d.position, ue = Vt(C, he, $e(m, "active"), $e(R, "disabled"), $e(Z === !0 || Z && !(se || O), "icon"), $e(L, "header"), $e(ne, "link"), mi(I, "fitted"), "item", g), G = Xt(o, this.props, function() {
      if (Q)
        return "a";
    }), me = zt(o, this.props);
    return dn(v) ? /* @__PURE__ */ ae.createElement(G, Be({}, me, {
      className: ue,
      onClick: this.handleClick
    }), fc.create(Z, {
      autoGenerateKey: !1
    }), dn(O) ? C_e(se) : O) : /* @__PURE__ */ ae.createElement(G, Be({}, me, {
      className: ue,
      onClick: this.handleClick
    }), v);
  }, o;
}(Do);
E2.handledProps = ["active", "as", "children", "className", "color", "content", "disabled", "fitted", "header", "icon", "index", "link", "name", "onClick", "position"];
E2.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** A menu item can be active. */
  active: _.bool,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Additional colors can be specified. */
  color: _.oneOf(Om),
  /** Shorthand for primary content. */
  content: In,
  /** A menu item can be disabled. */
  disabled: _.bool,
  /** A menu item or menu can remove element padding, vertically or horizontally. */
  fitted: _.oneOfType([_.bool, _.oneOf(["horizontally", "vertically"])]),
  /** A menu item may include a header or may itself be a header. */
  header: _.bool,
  /** MenuItem can be only icon. */
  icon: _.oneOfType([_.bool, Vn]),
  /** MenuItem index inside Menu. */
  index: _.number,
  /** A menu item can be link. */
  link: _.bool,
  /** Internal name of the MenuItem. */
  name: _.string,
  /**
   * Called on click. When passed, the component will render as an `a`
   * tag by default instead of a `div`.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onClick: _.func,
  /** A menu item can take left or right position. */
  position: _.oneOf(["left", "right"])
} : {};
E2.create = lo(E2, function(r) {
  return {
    content: r,
    name: r
  };
});
function i$(r) {
  var o = r.children, c = r.className, i = r.content, d = r.position, m = Vt(d, "menu", c), v = zt(i$, r), g = Xt(i$, r);
  return /* @__PURE__ */ ae.createElement(g, Be({}, v, {
    className: m
  }), dn(o) ? i : o);
}
i$.handledProps = ["as", "children", "className", "content", "position"];
i$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** A sub menu can take left or right position. */
  position: _.oneOf(["left", "right"])
} : {};
var fC = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.handleItemOverrides = function(g) {
      return {
        onClick: function(O, R) {
          var I = R.index;
          i.setState({
            activeIndex: I
          }), xn(g, "onClick", O, R), xn(i.props, "onItemClick", O, R);
        }
      };
    }, i;
  }
  var c = o.prototype;
  return c.renderItems = function() {
    var d = this, m = this.props.items, v = this.state.activeIndex;
    return fi(m, function(g, C) {
      return E2.create(g, {
        defaultProps: {
          active: parseInt(v, 10) === C,
          index: C
        },
        overrideProps: d.handleItemOverrides
      });
    });
  }, c.render = function() {
    var d = this.props, m = d.attached, v = d.borderless, g = d.children, C = d.className, O = d.color, R = d.compact, I = d.fixed, L = d.floated, Z = d.fluid, ne = d.icon, se = d.inverted, Q = d.pagination, he = d.pointing, ue = d.secondary, G = d.size, me = d.stackable, we = d.tabular, be = d.text, q = d.vertical, Te = d.widths, Le = Vt("ui", O, G, $e(v, "borderless"), $e(R, "compact"), $e(Z, "fluid"), $e(se, "inverted"), $e(Q, "pagination"), $e(he, "pointing"), $e(ue, "secondary"), $e(me, "stackable"), $e(be, "text"), $e(q, "vertical"), mi(m, "attached"), mi(L, "floated"), mi(ne, "icon"), mi(we, "tabular"), _u(I, "fixed"), Kf(Te, "item"), C, "menu"), je = zt(o, this.props), Ie = Xt(o, this.props);
    return /* @__PURE__ */ ae.createElement(Ie, Be({}, je, {
      className: Le
    }), dn(g) ? this.renderItems() : g);
  }, o;
}(P1);
fC.handledProps = ["activeIndex", "as", "attached", "borderless", "children", "className", "color", "compact", "defaultActiveIndex", "fixed", "floated", "fluid", "icon", "inverted", "items", "onItemClick", "pagination", "pointing", "secondary", "size", "stackable", "tabular", "text", "vertical", "widths"];
fC.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Index of the currently active item. */
  activeIndex: _.oneOfType([_.number, _.string]),
  /** A menu may be attached to other content segments. */
  attached: _.oneOfType([_.bool, _.oneOf(["top", "bottom"])]),
  /** A menu item or menu can have no borders. */
  borderless: _.bool,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Additional colors can be specified. */
  color: _.oneOf(Om),
  /** A menu can take up only the space necessary to fit its content. */
  compact: _.bool,
  /** Initial activeIndex value. */
  defaultActiveIndex: _.oneOfType([_.number, _.string]),
  /** A menu can be fixed to a side of its context. */
  fixed: _.oneOf(["left", "right", "bottom", "top"]),
  /** A menu can be floated. */
  floated: _.oneOfType([_.bool, _.oneOf(["right"])]),
  /** A vertical menu may take the size of its container. */
  fluid: _.bool,
  /** A menu may have just icons (bool) or labeled icons. */
  icon: _.oneOfType([_.bool, _.oneOf(["labeled"])]),
  /** A menu may have its colors inverted to show greater contrast. */
  inverted: _.bool,
  /** Shorthand array of props for Menu. */
  items: Dh,
  /**
   * onClick handler for MenuItem. Mutually exclusive with children.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All item props.
   */
  onItemClick: co([Go(["children"]), _.func]),
  /** A pagination menu is specially formatted to present links to pages of content. */
  pagination: _.bool,
  /** A menu can point to show its relationship to nearby content. */
  pointing: _.bool,
  /** A menu can adjust its appearance to de-emphasize its contents. */
  secondary: _.bool,
  /** A menu can vary in size. */
  size: _.oneOf(pi(mc, "medium", "big")),
  /** A menu can stack at mobile resolutions. */
  stackable: _.bool,
  /** A menu can be formatted to show tabs of information. */
  tabular: _.oneOfType([_.bool, _.oneOf(["right"])]),
  /** A menu can be formatted for text content. */
  text: _.bool,
  /** A vertical menu displays elements vertically. */
  vertical: _.bool,
  /** A menu can have its items divided evenly. */
  widths: _.oneOf(hp)
} : {};
fC.autoControlledProps = ["activeIndex"];
fC.Header = a$;
fC.Item = E2;
fC.Menu = i$;
fC.create = lo(fC, function(r) {
  return {
    items: r
  };
});
const h2 = fC;
var SB = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.handleClick = function(g) {
      xn(i.props, "onClick", g, i.props);
    }, i.handleKeyDown = function(g) {
      xn(i.props, "onKeyDown", g, i.props), Di.getCode(g) === Di.Enter && xn(i.props, "onClick", g, i.props);
    }, i.handleOverrides = function() {
      return {
        onClick: i.handleClick,
        onKeyDown: i.handleKeyDown
      };
    }, i;
  }
  var c = o.prototype;
  return c.render = function() {
    var d = this.props, m = d.active, v = d.type, g = this.props.disabled || v === "ellipsisItem";
    return E2.create(this.props, {
      defaultProps: {
        active: m,
        "aria-current": m,
        "aria-disabled": g,
        disabled: g,
        onClick: this.handleClick,
        onKeyDown: this.handleKeyDown,
        tabIndex: g ? -1 : 0
      },
      overrideProps: this.handleOverrides
    });
  }, o;
}(Do);
SB.handledProps = ["active", "disabled", "onClick", "onKeyDown", "type"];
SB.propTypes = process.env.NODE_ENV !== "production" ? {
  /** A pagination item can be active. */
  active: _.bool,
  /** A pagination item can be disabled. */
  disabled: _.bool,
  /**
   * Called on click.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onClick: _.func,
  /**
   * Called on key down.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onKeyDown: _.func,
  /** A pagination should have a type. */
  type: _.oneOf(["ellipsisItem", "firstItem", "prevItem", "pageItem", "nextItem", "lastItem"])
} : {};
SB.create = lo(SB, function(r) {
  return {
    content: r
  };
});
const Oae = SB;
var Pk = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.handleItemClick = function(g, C) {
      var O = C.value, R = i.state.activePage;
      +R != +O && (i.setState({
        activePage: O
      }), xn(i.props, "onPageChange", g, Be({}, i.props, {
        activePage: O
      })));
    }, i.handleItemOverrides = function(g, C, O) {
      return function(R) {
        return {
          active: g,
          type: C,
          key: C + "-" + O,
          onClick: function(L, Z) {
            xn(R, "onClick", L, Z), Z.type !== "ellipsisItem" && i.handleItemClick(L, Z);
          }
        };
      };
    }, i;
  }
  var c = o.prototype;
  return c.getInitialAutoControlledState = function() {
    return {
      activePage: 1
    };
  }, c.render = function() {
    var d = this, m = this.props, v = m["aria-label"], g = m.boundaryRange, C = m.disabled, O = m.ellipsisItem, R = m.siblingRange, I = m.totalPages, L = this.state.activePage, Z = TTe({
      activePage: L,
      boundaryRange: g,
      hideEllipsis: ws(O),
      siblingRange: R,
      totalPages: I
    }), ne = zt(o, this.props);
    return /* @__PURE__ */ ae.createElement(h2, Be({}, ne, {
      "aria-label": v,
      pagination: !0,
      role: "navigation"
    }), fi(Z, function(se) {
      var Q = se.active, he = se.type, ue = se.value;
      return Oae.create(d.props[he], {
        defaultProps: {
          content: ue,
          disabled: C,
          value: ue
        },
        overrideProps: d.handleItemOverrides(Q, he, ue)
      });
    }));
  }, o;
}(P1);
Pk.handledProps = ["activePage", "aria-label", "boundaryRange", "defaultActivePage", "disabled", "ellipsisItem", "firstItem", "lastItem", "nextItem", "onPageChange", "pageItem", "prevItem", "siblingRange", "totalPages"];
Pk.propTypes = process.env.NODE_ENV !== "production" ? {
  /** A pagination item can have an aria label. */
  "aria-label": _.string,
  /** Initial activePage value. */
  defaultActivePage: _.oneOfType([_.number, _.string]),
  /** Index of the currently active page. */
  activePage: _.oneOfType([_.number, _.string]),
  /** Number of always visible pages at the beginning and end. */
  boundaryRange: _.oneOfType([_.number, _.string]),
  /** A pagination can be disabled. */
  disabled: _.bool,
  /** A shorthand for PaginationItem. */
  ellipsisItem: Vn,
  /** A shorthand for PaginationItem. */
  firstItem: Vn,
  /** A shorthand for PaginationItem. */
  lastItem: Vn,
  /** A shorthand for PaginationItem. */
  nextItem: Vn,
  /** A shorthand for PaginationItem. */
  pageItem: Vn,
  /** A shorthand for PaginationItem. */
  prevItem: Vn,
  /**
   * Called on change of an active page.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onPageChange: _.func,
  /** Number of always visible pages before and after the current one. */
  siblingRange: _.oneOfType([_.number, _.string]),
  /** Total number of pages. */
  totalPages: _.oneOfType([_.number, _.string]).isRequired
} : {};
Pk.autoControlledProps = ["activePage"];
Pk.defaultProps = {
  "aria-label": "Pagination Navigation",
  boundaryRange: 1,
  ellipsisItem: "...",
  firstItem: {
    "aria-label": "First item",
    content: ""
  },
  lastItem: {
    "aria-label": "Last item",
    content: ""
  },
  nextItem: {
    "aria-label": "Next item",
    content: ""
  },
  pageItem: {},
  prevItem: {
    "aria-label": "Previous item",
    content: ""
  },
  siblingRange: 1
};
Pk.Item = Oae;
function x_e(r, o, c) {
  return r == null ? r : rhe(r, o, c);
}
var Iv = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.inputRef = /* @__PURE__ */ bp(), i.labelRef = /* @__PURE__ */ bp(), i.canToggle = function() {
      var g = i.props, C = g.disabled, O = g.radio, R = g.readOnly, I = i.state.checked;
      return !C && !R && !(O && I);
    }, i.computeTabIndex = function() {
      var g = i.props, C = g.disabled, O = g.tabIndex;
      return ws(O) ? C ? -1 : 0 : O;
    }, i.handleClick = function(g) {
      var C = i.props.id, O = i.state, R = O.checked, I = O.indeterminate, L = xn(i.inputRef.current, "contains", g.target), Z = xn(i.labelRef.current, "contains", g.target), ne = !Z && !L, se = !ws(C), Q = Z && se;
      Q || xn(i.props, "onClick", g, Be({}, i.props, {
        checked: !R,
        indeterminate: !!I
      })), i.isClickFromMouse && (i.isClickFromMouse = !1, Z && !se && i.handleChange(g), ne && i.handleChange(g), Z && se && g.stopPropagation());
    }, i.handleChange = function(g) {
      var C = i.state.checked;
      i.canToggle() && (xn(i.props, "onChange", g, Be({}, i.props, {
        checked: !C,
        indeterminate: !1
      })), i.setState({
        checked: !C,
        indeterminate: !1
      }));
    }, i.handleMouseDown = function(g) {
      var C = i.state, O = C.checked, R = C.indeterminate;
      xn(i.props, "onMouseDown", g, Be({}, i.props, {
        checked: !!O,
        indeterminate: !!R
      })), g.defaultPrevented || xn(i.inputRef.current, "focus"), g.preventDefault();
    }, i.handleMouseUp = function(g) {
      var C = i.state, O = C.checked, R = C.indeterminate;
      i.isClickFromMouse = !0, xn(i.props, "onMouseUp", g, Be({}, i.props, {
        checked: !!O,
        indeterminate: !!R
      }));
    }, i.setIndeterminate = function() {
      var g = i.state.indeterminate;
      x_e(i.inputRef, "current.indeterminate", !!g);
    }, i;
  }
  var c = o.prototype;
  return c.componentDidMount = function() {
    this.setIndeterminate();
  }, c.componentDidUpdate = function() {
    this.setIndeterminate();
  }, c.render = function() {
    var d = this.props, m = d.className, v = d.disabled, g = d.label, C = d.id, O = d.name, R = d.radio, I = d.readOnly, L = d.slider, Z = d.toggle, ne = d.type, se = d.value, Q = this.state, he = Q.checked, ue = Q.indeterminate, G = Vt(
      "ui",
      $e(he, "checked"),
      $e(v, "disabled"),
      $e(ue, "indeterminate"),
      // auto apply fitted class to compact white space when there is no label
      // https://semantic-ui.com/modules/checkbox.html#fitted
      $e(ws(g), "fitted"),
      $e(R, "radio"),
      $e(I, "read-only"),
      $e(L, "slider"),
      $e(Z, "toggle"),
      "checkbox",
      m
    ), me = zt(o, this.props), we = Xt(o, this.props), be = VB(me, {
      htmlProps: xae
    }), q = be[0], Te = be[1], Le = fse(g, {
      defaultProps: {
        htmlFor: C
      },
      autoGenerateKey: !1
    }) || /* @__PURE__ */ ae.createElement("label", {
      htmlFor: C
    });
    return /* @__PURE__ */ ae.createElement(we, Be({}, Te, {
      className: G,
      onClick: this.handleClick,
      onChange: this.handleChange,
      onMouseDown: this.handleMouseDown,
      onMouseUp: this.handleMouseUp
    }), /* @__PURE__ */ ae.createElement(yp, {
      innerRef: this.inputRef
    }, /* @__PURE__ */ ae.createElement("input", Be({}, q, {
      checked: he,
      className: "hidden",
      disabled: v,
      id: C,
      name: O,
      readOnly: !0,
      tabIndex: this.computeTabIndex(),
      type: ne,
      value: se
    }))), /* @__PURE__ */ ae.createElement(yp, {
      innerRef: this.labelRef
    }, Le));
  }, o;
}(P1);
Iv.handledProps = ["as", "checked", "className", "defaultChecked", "defaultIndeterminate", "disabled", "fitted", "id", "indeterminate", "label", "name", "onChange", "onClick", "onMouseDown", "onMouseUp", "radio", "readOnly", "slider", "tabIndex", "toggle", "type", "value"];
Iv.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Whether or not checkbox is checked. */
  checked: _.bool,
  /** Additional classes. */
  className: _.string,
  /** The initial value of checked. */
  defaultChecked: _.bool,
  /** Whether or not checkbox is indeterminate. */
  defaultIndeterminate: _.bool,
  /** A checkbox can appear disabled and be unable to change states */
  disabled: _.bool,
  /** Removes padding for a label. Auto applied when there is no label. */
  fitted: _.bool,
  /** A unique identifier. */
  id: _.oneOfType([_.number, _.string]),
  /** Whether or not checkbox is indeterminate. */
  indeterminate: _.bool,
  /** The text of the associated label element. */
  label: Vn,
  /** The HTML input name. */
  name: _.string,
  /**
   * Called when the user attempts to change the checked state.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props and proposed checked/indeterminate state.
   */
  onChange: _.func,
  /**
   * Called when the checkbox or label is clicked.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props and current checked/indeterminate state.
   */
  onClick: _.func,
  /**
   * Called when the user presses down on the mouse.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props and current checked/indeterminate state.
   */
  onMouseDown: _.func,
  /**
   * Called when the user releases the mouse.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props and current checked/indeterminate state.
   */
  onMouseUp: _.func,
  /** Format as a radio element. This means it is an exclusive option. */
  radio: co([_.bool, Go(["slider", "toggle"])]),
  /** A checkbox can be read-only and unable to change states. */
  readOnly: _.bool,
  /** Format to emphasize the current selection state. */
  slider: co([_.bool, Go(["radio", "toggle"])]),
  /** A checkbox can receive focus. */
  tabIndex: _.oneOfType([_.number, _.string]),
  /** Format to show an on or off choice. */
  toggle: co([_.bool, Go(["radio", "slider"])]),
  /** HTML input type, either checkbox or radio. */
  type: _.oneOf(["checkbox", "radio"]),
  /** The HTML input value. */
  value: _.oneOfType([_.string, _.number])
} : {};
Iv.defaultProps = {
  type: "checkbox"
};
Iv.autoControlledProps = ["checked", "indeterminate"];
function Dk(r) {
  var o = r.slider, c = r.toggle, i = r.type, d = zt(Dk, r), m = !(o || c) || void 0;
  return /* @__PURE__ */ ae.createElement(Iv, Be({}, d, {
    type: i,
    radio: m,
    slider: o,
    toggle: c
  }));
}
Dk.handledProps = ["slider", "toggle", "type"];
Dk.propTypes = process.env.NODE_ENV !== "production" ? {
  /** Format to emphasize the current selection state. */
  slider: Iv.propTypes.slider,
  /** Format to show an on or off choice. */
  toggle: Iv.propTypes.toggle,
  /** HTML input type, either checkbox or radio. */
  type: Iv.propTypes.type
} : {};
Dk.defaultProps = {
  type: "radio"
};
function T_e(r) {
  for (var o = -1, c = r == null ? 0 : r.length, i = 0, d = []; ++o < c; ) {
    var m = r[o];
    m && (d[i++] = m);
  }
  return d;
}
function __e(r, o) {
  for (var c = -1, i = r == null ? 0 : r.length; ++c < i; )
    if (!o(r[c], c, r))
      return !1;
  return !0;
}
function O_e(r, o) {
  var c = !0;
  return Rk(r, function(i, d, m) {
    return c = !!o(i, d, m), c;
  }), c;
}
function A_e(r, o, c) {
  var i = qc(r) ? __e : O_e;
  return c && bB(r, o, c) && (o = void 0), i(r, R1(o));
}
function k_e(r, o, c) {
  var i = r == null ? 0 : r.length;
  return i ? (o = c || o === void 0 ? 1 : cC(o), o = i - o, hj(r, 0, o < 0 ? 0 : o)) : [];
}
var N_e = jpe("length");
const R_e = N_e;
var $he = "\\ud800-\\udfff", P_e = "\\u0300-\\u036f", D_e = "\\ufe20-\\ufe2f", $_e = "\\u20d0-\\u20ff", I_e = P_e + D_e + $_e, M_e = "\\ufe0e\\ufe0f", F_e = "[" + $he + "]", gse = "[" + I_e + "]", vse = "\\ud83c[\\udffb-\\udfff]", L_e = "(?:" + gse + "|" + vse + ")", Ihe = "[^" + $he + "]", Mhe = "(?:\\ud83c[\\udde6-\\uddff]){2}", Fhe = "[\\ud800-\\udbff][\\udc00-\\udfff]", B_e = "\\u200d", Lhe = L_e + "?", Bhe = "[" + M_e + "]?", H_e = "(?:" + B_e + "(?:" + [Ihe, Mhe, Fhe].join("|") + ")" + Bhe + Lhe + ")*", z_e = Bhe + Lhe + H_e, V_e = "(?:" + [Ihe + gse + "?", gse, Mhe, Fhe, F_e].join("|") + ")", jue = RegExp(vse + "(?=" + vse + ")|" + V_e + z_e, "g");
function U_e(r) {
  for (var o = jue.lastIndex = 0; jue.test(r); )
    ++o;
  return o;
}
function W_e(r) {
  return bae(r) ? U_e(r) : R_e(r);
}
var j_e = "[object Map]", q_e = "[object Set]";
function G_e(r) {
  if (r == null)
    return 0;
  if (JS(r))
    return Cae(r) ? W_e(r) : r.length;
  var o = ZA(r);
  return o == j_e || o == q_e ? r.size : dae(r).length;
}
var Z_e = Nk(function(r) {
  return fhe(zB(r, 1, vB, !0));
});
const que = Z_e;
var K_e = ["ad", "andorra", "ae", "united arab emirates", "uae", "af", "afghanistan", "ag", "antigua", "ai", "anguilla", "al", "albania", "am", "armenia", "an", "netherlands antilles", "ao", "angola", "ar", "argentina", "as", "american samoa", "at", "austria", "au", "australia", "aw", "aruba", "ax", "aland islands", "az", "azerbaijan", "ba", "bosnia", "bb", "barbados", "bd", "bangladesh", "be", "belgium", "bf", "burkina faso", "bg", "bulgaria", "bh", "bahrain", "bi", "burundi", "bj", "benin", "bm", "bermuda", "bn", "brunei", "bo", "bolivia", "br", "brazil", "bs", "bahamas", "bt", "bhutan", "bv", "bouvet island", "bw", "botswana", "by", "belarus", "bz", "belize", "ca", "canada", "cc", "cocos islands", "cd", "congo", "cf", "central african republic", "cg", "congo brazzaville", "ch", "switzerland", "ci", "cote divoire", "ck", "cook islands", "cl", "chile", "cm", "cameroon", "cn", "china", "co", "colombia", "cr", "costa rica", "cs", "cu", "cuba", "cv", "cape verde", "cx", "christmas island", "cy", "cyprus", "cz", "czech republic", "de", "germany", "dj", "djibouti", "dk", "denmark", "dm", "dominica", "do", "dominican republic", "dz", "algeria", "ec", "ecuador", "england", "gb eng", "ee", "estonia", "eg", "egypt", "eh", "western sahara", "er", "eritrea", "es", "spain", "et", "ethiopia", "eu", "european union", "fi", "finland", "fj", "fiji", "fk", "falkland islands", "fm", "micronesia", "fo", "faroe islands", "fr", "france", "ga", "gabon", "gb", "uk", "united kingdom", "gd", "grenada", "ge", "georgia", "gf", "french guiana", "gh", "ghana", "gi", "gibraltar", "gl", "greenland", "gm", "gambia", "gn", "guinea", "gp", "guadeloupe", "gq", "equatorial guinea", "gr", "greece", "gs", "sandwich islands", "gt", "guatemala", "gu", "guam", "gw", "guinea-bissau", "gy", "guyana", "hk", "hong kong", "hm", "heard island", "hn", "honduras", "hr", "croatia", "ht", "haiti", "hu", "hungary", "id", "indonesia", "ie", "ireland", "il", "israel", "in", "india", "io", "indian ocean territory", "iq", "iraq", "ir", "iran", "is", "iceland", "it", "italy", "jm", "jamaica", "jo", "jordan", "jp", "japan", "ke", "kenya", "kg", "kyrgyzstan", "kh", "cambodia", "ki", "kiribati", "km", "comoros", "kn", "saint kitts and nevis", "kp", "north korea", "kr", "south korea", "kw", "kuwait", "ky", "cayman islands", "kz", "kazakhstan", "la", "laos", "lb", "lebanon", "lc", "saint lucia", "li", "liechtenstein", "lk", "sri lanka", "lr", "liberia", "ls", "lesotho", "lt", "lithuania", "lu", "luxembourg", "lv", "latvia", "ly", "libya", "ma", "morocco", "mc", "monaco", "md", "moldova", "me", "montenegro", "mg", "madagascar", "mh", "marshall islands", "mk", "macedonia", "ml", "mali", "mm", "myanmar", "burma", "mn", "mongolia", "mo", "macau", "mp", "northern mariana islands", "mq", "martinique", "mr", "mauritania", "ms", "montserrat", "mt", "malta", "mu", "mauritius", "mv", "maldives", "mw", "malawi", "mx", "mexico", "my", "malaysia", "mz", "mozambique", "na", "namibia", "nc", "new caledonia", "ne", "niger", "nf", "norfolk island", "ng", "nigeria", "ni", "nicaragua", "nl", "netherlands", "no", "norway", "np", "nepal", "nr", "nauru", "nu", "niue", "nz", "new zealand", "om", "oman", "pa", "panama", "pe", "peru", "pf", "french polynesia", "pg", "new guinea", "ph", "philippines", "pk", "pakistan", "pl", "poland", "pm", "saint pierre", "pn", "pitcairn islands", "pr", "puerto rico", "ps", "palestine", "pt", "portugal", "pw", "palau", "py", "paraguay", "qa", "qatar", "re", "reunion", "ro", "romania", "rs", "serbia", "ru", "russia", "rw", "rwanda", "sa", "saudi arabia", "sb", "solomon islands", "sc", "seychelles", "gb sct", "scotland", "sd", "sudan", "se", "sweden", "sg", "singapore", "sh", "saint helena", "si", "slovenia", "sj", "svalbard", "jan mayen", "sk", "slovakia", "sl", "sierra leone", "sm", "san marino", "sn", "senegal", "so", "somalia", "sr", "suriname", "st", "sao tome", "sv", "el salvador", "sy", "syria", "sz", "swaziland", "tc", "caicos islands", "td", "chad", "tf", "french territories", "tg", "togo", "th", "thailand", "tj", "tajikistan", "tk", "tokelau", "tl", "timorleste", "tm", "turkmenistan", "tn", "tunisia", "to", "tonga", "tr", "turkey", "tt", "trinidad", "tv", "tuvalu", "tw", "taiwan", "tz", "tanzania", "ua", "ukraine", "ug", "uganda", "um", "us minor islands", "us", "america", "united states", "uy", "uruguay", "uz", "uzbekistan", "va", "vatican city", "vc", "saint vincent", "ve", "venezuela", "vg", "british virgin islands", "vi", "us virgin islands", "vn", "vietnam", "vu", "vanuatu", "gb wls", "wales", "wf", "wallis and futuna", "ws", "samoa", "ye", "yemen", "yt", "mayotte", "za", "south africa", "zm", "zambia", "zw", "zimbabwe"], c$ = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    return r.apply(this, arguments) || this;
  }
  var c = o.prototype;
  return c.render = function() {
    var d = this.props, m = d.className, v = d.name, g = Vt(v, "flag", m), C = zt(o, this.props), O = Xt(o, this.props);
    return /* @__PURE__ */ ae.createElement(O, Be({}, C, {
      className: g
    }));
  }, o;
}(bpe);
c$.handledProps = ["as", "className", "name"];
c$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Additional classes. */
  className: _.string,
  /** Flag name, can use the two digit country code, the full name, or a common alias. */
  name: che(K_e)
} : {};
c$.defaultProps = {
  as: "i"
};
c$.create = lo(c$, function(r) {
  return {
    name: r
  };
});
const Aae = c$;
function l$(r) {
  var o = r.className, c = Vt("divider", o), i = zt(l$, r), d = Xt(l$, r);
  return /* @__PURE__ */ ae.createElement(d, Be({}, i, {
    className: c
  }));
}
l$.handledProps = ["as", "className"];
l$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Additional classes. */
  className: _.string
} : {};
var wB = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.handleClick = function(g) {
      xn(i.props, "onClick", g, i.props);
    }, i;
  }
  var c = o.prototype;
  return c.render = function() {
    var d = this.props, m = d.active, v = d.children, g = d.className, C = d.content, O = d.disabled, R = d.description, I = d.flag, L = d.icon, Z = d.image, ne = d.label, se = d.selected, Q = d.text, he = Vt($e(m, "active"), $e(O, "disabled"), $e(se, "selected"), "item", g), ue = ws(L) ? MCe(v, "DropdownMenu") && "dropdown" : L, G = zt(o, this.props), me = Xt(o, this.props), we = {
      role: "option",
      "aria-disabled": O,
      "aria-checked": m,
      "aria-selected": se
    };
    if (!dn(v))
      return /* @__PURE__ */ ae.createElement(me, Be({}, G, we, {
        className: he,
        onClick: this.handleClick
      }), v);
    var be = Aae.create(I, {
      autoGenerateKey: !1
    }), q = fc.create(ue, {
      autoGenerateKey: !1
    }), Te = Qf.create(Z, {
      autoGenerateKey: !1
    }), Le = Rh.create(ne, {
      autoGenerateKey: !1
    }), je = gp("span", function(Ce) {
      return {
        children: Ce
      };
    }, R, {
      defaultProps: {
        className: "description"
      },
      autoGenerateKey: !1
    }), Ie = gp("span", function(Ce) {
      return {
        children: Ce
      };
    }, dn(C) ? Q : C, {
      defaultProps: {
        className: "text"
      },
      autoGenerateKey: !1
    });
    return /* @__PURE__ */ ae.createElement(me, Be({}, G, we, {
      className: he,
      onClick: this.handleClick
    }), Te, q, be, Le, je, Ie);
  }, o;
}(Do);
wB.handledProps = ["active", "as", "children", "className", "content", "description", "disabled", "flag", "icon", "image", "label", "onClick", "selected", "text", "value"];
wB.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Style as the currently chosen item. */
  active: _.bool,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** Additional text with less emphasis. */
  description: Vn,
  /** A dropdown item can be disabled. */
  disabled: _.bool,
  /** Shorthand for Flag. */
  flag: Vn,
  /** Shorthand for Icon. */
  icon: Vn,
  /** Shorthand for Image. */
  image: Vn,
  /** Shorthand for Label. */
  label: Vn,
  /**
   * Called on click.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onClick: _.func,
  /**
   * The item currently selected by keyboard shortcut.
   * This is not the active item.
   */
  selected: _.bool,
  /** Display text. */
  text: In,
  /** Stored value. */
  value: _.oneOfType([_.bool, _.number, _.string])
} : {};
wB.create = lo(wB, function(r) {
  return r;
});
const Aj = wB;
function mC(r) {
  var o = r.children, c = r.className, i = r.content, d = r.icon, m = Vt("header", c), v = zt(mC, r), g = Xt(mC, r);
  return dn(o) ? /* @__PURE__ */ ae.createElement(g, Be({}, v, {
    className: m
  }), fc.create(d, {
    autoGenerateKey: !1
  }), i) : /* @__PURE__ */ ae.createElement(g, Be({}, v, {
    className: m
  }), o);
}
mC.handledProps = ["as", "children", "className", "content", "icon"];
mC.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function) */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** Shorthand for Icon. */
  icon: Vn
} : {};
mC.create = lo(mC, function(r) {
  return {
    content: r
  };
});
function QA(r) {
  var o = r.children, c = r.className, i = r.content, d = r.direction, m = r.open, v = r.scrolling, g = Vt(d, $e(m, "visible"), $e(v, "scrolling"), "menu transition", c), C = zt(QA, r), O = Xt(QA, r);
  return /* @__PURE__ */ ae.createElement(O, Be({}, C, {
    className: g
  }), dn(o) ? i : o);
}
QA.handledProps = ["as", "children", "className", "content", "direction", "open", "scrolling"];
QA.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** A dropdown menu can open to the left or to the right. */
  direction: _.oneOf(["left", "right"]),
  /** Whether or not the dropdown menu is displayed. */
  open: _.bool,
  /** A dropdown menu can scroll. */
  scrolling: _.bool
} : {};
var u$ = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.handleChange = function(g) {
      var C = Oh(g, "target.value");
      xn(i.props, "onChange", g, Be({}, i.props, {
        value: C
      }));
    }, i;
  }
  var c = o.prototype;
  return c.render = function() {
    var d = this.props, m = d.autoComplete, v = d.className, g = d.tabIndex, C = d.type, O = d.value, R = Vt("search", v), I = zt(o, this.props);
    return /* @__PURE__ */ ae.createElement("input", Be({}, I, {
      "aria-autocomplete": "list",
      autoComplete: m,
      className: R,
      onChange: this.handleChange,
      tabIndex: g,
      type: C,
      value: O
    }));
  }, o;
}(Do);
u$.handledProps = ["as", "autoComplete", "className", "tabIndex", "type", "value"];
u$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** An input can have the auto complete. */
  autoComplete: _.string,
  /** Additional classes. */
  className: _.string,
  /** An input can receive focus. */
  tabIndex: _.oneOfType([_.number, _.string]),
  /** The HTML input type. */
  type: _.string,
  /** Stored value. */
  value: _.oneOfType([_.number, _.string])
} : {};
u$.defaultProps = {
  autoComplete: "off",
  type: "text"
};
u$.create = lo(u$, function(r) {
  return {
    type: r
  };
});
const kae = u$;
function pC(r) {
  var o = r.children, c = r.className, i = r.content, d = Vt("divider", c), m = zt(pC, r), v = Xt(pC, r);
  return /* @__PURE__ */ ae.createElement(v, Be({
    "aria-atomic": !0,
    "aria-live": "polite",
    role: "alert"
  }, m, {
    className: d
  }), dn(o) ? i : o);
}
pC.handledProps = ["as", "children", "className", "content"];
pC.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
pC.create = lo(pC, function(r) {
  return {
    content: r
  };
});
var Hhe = /[\\^$.*+?()[\]{}|]/g, Y_e = RegExp(Hhe.source);
function Q_e(r) {
  return r = BS(r), r && Y_e.test(r) ? r.replace(Hhe, "\\$&") : r;
}
function zD(r) {
  var o = r.additionLabel, c = r.additionPosition, i = r.allowAdditions, d = r.deburr, m = r.multiple, v = r.options, g = r.search, C = r.searchQuery, O = r.value, R = v;
  if (m && (R = AW(R, function(se) {
    return !Og(O, se.value);
  })), g && C)
    if (YD(g))
      R = g(R, C);
    else {
      var I = d ? hse(C) : C, L = new RegExp(Q_e(I), "i");
      R = AW(R, function(se) {
        return L.test(d ? hse(se.text) : se.text);
      });
    }
  if (i && g && C && !eB(R, {
    text: C
  })) {
    var Z = /* @__PURE__ */ ae.isValidElement(o) ? /* @__PURE__ */ ae.cloneElement(o, {
      key: "addition-label"
    }) : o || "", ne = {
      key: "addition",
      // by using an array, we can pass multiple elements, but when doing so
      // we must specify a `key` for React to know which one is which
      text: [Z, /* @__PURE__ */ ae.createElement("b", {
        key: "addition-query"
      }, C)],
      value: C,
      className: "addition",
      "data-additional": !0
    };
    c === "top" ? R.unshift(ne) : R.push(ne);
  }
  return R;
}
zD.handledProps = [];
function Gue(r) {
  var o = r.additionLabel, c = r.additionPosition, i = r.allowAdditions, d = r.deburr, m = r.multiple, v = r.options, g = r.search, C = r.searchQuery, O = r.selectedIndex, R = r.value, I = zD({
    value: R,
    options: v,
    searchQuery: C,
    additionLabel: o,
    additionPosition: c,
    allowAdditions: i,
    deburr: d,
    multiple: m,
    search: g
  }), L = _j(I, function(Q, he, ue) {
    return he.disabled || Q.push(ue), Q;
  }, []), Z;
  if (!O || O < 0) {
    var ne = L[0];
    Z = m ? ne : ase(I, ["value", R]) || L[0];
  } else if (m)
    Z = Zpe(L, function(Q) {
      return Q >= O;
    }), O >= I.length - 1 && (Z = L[L.length - 1]);
  else {
    var se = ase(I, ["value", R]);
    Z = Og(L, se) ? se : void 0;
  }
  return (!Z || Z < 0) && (Z = L[0]), Z;
}
var Zue = function(o, c) {
  return ws(o) ? c : o;
}, Kue = function(o) {
  return o && o.map(function(c) {
    return wj(c, ["key", "value"]);
  });
};
function zhe(r) {
  var o = r.flag, c = r.image, i = r.text;
  return YD(i) ? i : {
    content: /* @__PURE__ */ ae.createElement(ae.Fragment, null, Aae.create(o), Qf.create(c), i)
  };
}
var kl = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.searchRef = /* @__PURE__ */ bp(), i.sizerRef = /* @__PURE__ */ bp(), i.ref = /* @__PURE__ */ bp(), i.handleChange = function(g, C) {
      xn(i.props, "onChange", g, Be({}, i.props, {
        value: C
      }));
    }, i.closeOnChange = function(g) {
      var C = i.props, O = C.closeOnChange, R = C.multiple, I = xh(O) ? !R : O;
      I && i.close(g, Eae);
    }, i.closeOnEscape = function(g) {
      i.props.closeOnEscape && Di.getCode(g) === Di.Escape && (g.preventDefault(), i.close(g));
    }, i.moveSelectionOnKeyDown = function(g) {
      var C, O = i.props, R = O.multiple, I = O.selectOnNavigation, L = i.state.open;
      if (L) {
        var Z = (C = {}, C[Di.ArrowDown] = 1, C[Di.ArrowUp] = -1, C), ne = Z[Di.getCode(g)];
        if (ne !== void 0) {
          g.preventDefault();
          var se = i.getSelectedIndexAfterMove(ne);
          !R && I && i.makeSelectedItemActive(g, se), i.setState({
            selectedIndex: se
          });
        }
      }
    }, i.openOnSpace = function(g) {
      var C, O, R, I = i.state.focus && !i.state.open && Di.getCode(g) === Di.Spacebar, L = ((C = g.target) == null ? void 0 : C.tagName) !== "INPUT" && ((O = g.target) == null ? void 0 : O.tagName) !== "TEXTAREA" && ((R = g.target) == null ? void 0 : R.isContentEditable) !== !0;
      I && (L && g.preventDefault(), i.open(g));
    }, i.openOnArrow = function(g) {
      var C = i.state, O = C.focus, R = C.open;
      if (O && !R) {
        var I = Di.getCode(g);
        (I === Di.ArrowDown || I === Di.ArrowUp) && (g.preventDefault(), i.open(g));
      }
    }, i.makeSelectedItemActive = function(g, C) {
      var O = i.state, R = O.open, I = O.value, L = i.props.multiple, Z = i.getSelectedItem(C), ne = Oh(Z, "value"), se = Oh(Z, "disabled");
      if (ws(ne) || !R || se)
        return I;
      var Q = L ? que(I, [ne]) : ne, he = L ? !!ise(Q, I).length : Q !== I;
      return he && (i.setState({
        value: Q
      }), i.handleChange(g, Q), Z["data-additional"] && xn(i.props, "onAddItem", g, Be({}, i.props, {
        value: ne
      }))), I;
    }, i.selectItemOnEnter = function(g) {
      var C = i.props.search, O = i.state, R = O.open, I = O.selectedIndex;
      if (R) {
        var L = Di.getCode(g) === Di.Enter || // https://github.com/Semantic-Org/Semantic-UI-React/pull/3766
        !C && Di.getCode(g) === Di.Spacebar;
        if (L) {
          g.preventDefault();
          var Z = G_e(zD({
            value: i.state.value,
            options: i.props.options,
            searchQuery: i.state.searchQuery,
            additionLabel: i.props.additionLabel,
            additionPosition: i.props.additionPosition,
            allowAdditions: i.props.allowAdditions,
            deburr: i.props.deburr,
            multiple: i.props.multiple,
            search: i.props.search
          }));
          if (!(C && Z === 0)) {
            var ne = i.makeSelectedItemActive(g, I);
            i.setState({
              selectedIndex: Gue({
                additionLabel: i.props.additionLabel,
                additionPosition: i.props.additionPosition,
                allowAdditions: i.props.allowAdditions,
                deburr: i.props.deburr,
                multiple: i.props.multiple,
                search: i.props.search,
                selectedIndex: I,
                value: ne,
                options: i.props.options,
                searchQuery: ""
              })
            }), i.closeOnChange(g), i.clearSearchQuery(), C && xn(i.searchRef.current, "focus");
          }
        }
      }
    }, i.removeItemOnBackspace = function(g) {
      var C = i.props, O = C.multiple, R = C.search, I = i.state, L = I.searchQuery, Z = I.value;
      if (Di.getCode(g) === Di.Backspace && !(L || !R || !O || u2(Z))) {
        g.preventDefault();
        var ne = k_e(Z);
        i.setState({
          value: ne
        }), i.handleChange(g, ne);
      }
    }, i.closeOnDocumentClick = function(g) {
      i.props.closeOnBlur && (i.ref.current && f2(i.ref.current, g) || i.close());
    }, i.handleMouseDown = function(g) {
      i.isMouseDown = !0, xn(i.props, "onMouseDown", g, i.props), document.addEventListener("mouseup", i.handleDocumentMouseUp);
    }, i.handleDocumentMouseUp = function() {
      i.isMouseDown = !1, document.removeEventListener("mouseup", i.handleDocumentMouseUp);
    }, i.handleClick = function(g) {
      var C = i.props, O = C.minCharacters, R = C.search, I = i.state, L = I.open, Z = I.searchQuery;
      if (xn(i.props, "onClick", g, i.props), g.stopPropagation(), !R)
        return i.toggle(g);
      if (L) {
        xn(i.searchRef.current, "focus");
        return;
      }
      if (Z.length >= O || O === 1) {
        i.open(g);
        return;
      }
      xn(i.searchRef.current, "focus");
    }, i.handleIconClick = function(g) {
      var C = i.props.clearable, O = i.hasValue();
      xn(i.props, "onClick", g, i.props), g.stopPropagation(), C && O ? i.clearValue(g) : i.toggle(g);
    }, i.handleItemClick = function(g, C) {
      var O = i.props, R = O.multiple, I = O.search, L = i.state.value, Z = C.value;
      if (g.stopPropagation(), (R || C.disabled) && g.nativeEvent.stopImmediatePropagation(), !C.disabled) {
        var ne = C["data-additional"], se = R ? que(i.state.value, [Z]) : Z, Q = R ? !!ise(se, L).length : se !== L;
        Q && (i.setState({
          value: se
        }), i.handleChange(g, se)), i.clearSearchQuery(), xn(I ? i.searchRef.current : i.ref.current, "focus"), i.closeOnChange(g), ne && xn(i.props, "onAddItem", g, Be({}, i.props, {
          value: Z
        }));
      }
    }, i.handleFocus = function(g) {
      var C = i.state.focus;
      C || (xn(i.props, "onFocus", g, i.props), i.setState({
        focus: !0
      }));
    }, i.handleBlur = function(g) {
      var C = Oh(g, "currentTarget");
      if (!(C && C.contains(document.activeElement))) {
        var O = i.props, R = O.closeOnBlur, I = O.multiple, L = O.selectOnBlur;
        i.isMouseDown || (xn(i.props, "onBlur", g, i.props), L && !I && (i.makeSelectedItemActive(g, i.state.selectedIndex), R && i.close()), i.setState({
          focus: !1
        }), i.clearSearchQuery());
      }
    }, i.handleSearchChange = function(g, C) {
      var O = C.value;
      g.stopPropagation();
      var R = i.props.minCharacters, I = i.state.open, L = O;
      if (xn(i.props, "onSearchChange", g, Be({}, i.props, {
        searchQuery: L
      })), i.setState({
        searchQuery: L,
        selectedIndex: 0
      }), !I && L.length >= R) {
        i.open();
        return;
      }
      I && R !== 1 && L.length < R && i.close();
    }, i.handleKeyDown = function(g) {
      i.moveSelectionOnKeyDown(g), i.openOnArrow(g), i.openOnSpace(g), i.selectItemOnEnter(g), xn(i.props, "onKeyDown", g);
    }, i.getSelectedItem = function(g) {
      var C = zD({
        value: i.state.value,
        options: i.props.options,
        searchQuery: i.state.searchQuery,
        additionLabel: i.props.additionLabel,
        additionPosition: i.props.additionPosition,
        allowAdditions: i.props.allowAdditions,
        deburr: i.props.deburr,
        multiple: i.props.multiple,
        search: i.props.search
      });
      return Oh(C, "[" + g + "]");
    }, i.getItemByValue = function(g) {
      var C = i.props.options;
      return Zpe(C, {
        value: g
      });
    }, i.getDropdownAriaOptions = function() {
      var g = i.props, C = g.loading, O = g.disabled, R = g.search, I = g.multiple, L = i.state.open, Z = {
        role: R ? "combobox" : "listbox",
        "aria-busy": C,
        "aria-disabled": O,
        "aria-expanded": !!L
      };
      return Z.role === "listbox" && (Z["aria-multiselectable"] = I), Z;
    }, i.clearSearchQuery = function() {
      var g = i.state.searchQuery;
      g === void 0 || g === "" || i.setState({
        searchQuery: ""
      });
    }, i.handleLabelClick = function(g, C) {
      g.stopPropagation(), i.setState({
        selectedLabel: C.value
      }), xn(i.props, "onLabelClick", g, C);
    }, i.handleLabelRemove = function(g, C) {
      g.stopPropagation();
      var O = i.state.value, R = pi(O, C.value);
      i.setState({
        value: R
      }), i.handleChange(g, R);
    }, i.getSelectedIndexAfterMove = function(g, C) {
      C === void 0 && (C = i.state.selectedIndex);
      var O = zD({
        value: i.state.value,
        options: i.props.options,
        searchQuery: i.state.searchQuery,
        additionLabel: i.props.additionLabel,
        additionPosition: i.props.additionPosition,
        allowAdditions: i.props.allowAdditions,
        deburr: i.props.deburr,
        multiple: i.props.multiple,
        search: i.props.search
      });
      if (!(O === void 0 || A_e(O, "disabled"))) {
        var R = O.length - 1, I = i.props.wrapSelection, L = C + g;
        return !I && (L > R || L < 0) ? L = C : L > R ? L = 0 : L < 0 && (L = R), O[L].disabled ? i.getSelectedIndexAfterMove(g, L) : L;
      }
    }, i.handleIconOverrides = function(g) {
      var C = i.props.clearable, O = Vt(C && i.hasValue() && "clear", g.className);
      return {
        className: O,
        onClick: function(I) {
          xn(g, "onClick", I, g), i.handleIconClick(I);
        }
      };
    }, i.clearValue = function(g) {
      var C = i.props.multiple, O = C ? [] : "";
      i.setState({
        value: O
      }), i.handleChange(g, O);
    }, i.computeSearchInputTabIndex = function() {
      var g = i.props, C = g.disabled, O = g.tabIndex;
      return ws(O) ? C ? -1 : 0 : O;
    }, i.computeSearchInputWidth = function() {
      var g = i.state.searchQuery;
      if (i.sizerRef.current && g) {
        i.sizerRef.current.style.display = "inline", i.sizerRef.current.textContent = g;
        var C = Math.ceil(i.sizerRef.current.getBoundingClientRect().width);
        return i.sizerRef.current.style.removeProperty("display"), C;
      }
    }, i.computeTabIndex = function() {
      var g = i.props, C = g.disabled, O = g.search, R = g.tabIndex;
      if (!O)
        return C ? -1 : ws(R) ? 0 : R;
    }, i.handleSearchInputOverrides = function(g) {
      return {
        onChange: function(O, R) {
          xn(g, "onChange", O, R), i.handleSearchChange(O, R);
        }
      };
    }, i.hasValue = function() {
      var g = i.props.multiple, C = i.state.value;
      return g ? !u2(C) : !ws(C) && C !== "";
    }, i.scrollSelectedItemIntoView = function() {
      if (i.ref.current) {
        var g = i.ref.current.querySelector(".menu.visible");
        if (g) {
          var C = g.querySelector(".item.selected");
          if (C) {
            var O = C.offsetTop < g.scrollTop, R = C.offsetTop + C.clientHeight > g.scrollTop + g.clientHeight;
            O ? g.scrollTop = C.offsetTop : R && (g.scrollTop = C.offsetTop + C.clientHeight - g.clientHeight);
          }
        }
      }
    }, i.setOpenDirection = function() {
      if (i.ref.current) {
        var g = i.ref.current.querySelector(".menu.visible");
        if (g) {
          var C = i.ref.current.getBoundingClientRect(), O = g.clientHeight, R = document.documentElement.clientHeight - C.top - C.height - O, I = C.top - O, L = R < 0 && I > R;
          !L != !i.state.upward && i.setState({
            upward: L
          });
        }
      }
    }, i.open = function(g, C) {
      g === void 0 && (g = null), C === void 0 && (C = !0);
      var O = i.props, R = O.disabled, I = O.search;
      R || (I && xn(i.searchRef.current, "focus"), xn(i.props, "onOpen", g, i.props), C && i.setState({
        open: !0
      }), i.scrollSelectedItemIntoView());
    }, i.close = function(g, C) {
      C === void 0 && (C = i.handleClose), i.state.open && (xn(i.props, "onClose", g, i.props), i.setState({
        open: !1
      }, C));
    }, i.handleClose = function() {
      var g = document.activeElement === i.searchRef.current;
      !g && i.ref.current && i.ref.current.blur();
      var C = document.activeElement === i.ref.current, O = g || C;
      i.setState({
        focus: O
      });
    }, i.toggle = function(g) {
      return i.state.open ? i.close(g) : i.open(g);
    }, i.renderText = function() {
      var g = i.props, C = g.multiple, O = g.placeholder, R = g.search, I = g.text, L = i.state, Z = L.searchQuery, ne = L.selectedIndex, se = L.value, Q = L.open, he = i.hasValue(), ue = Vt(O && !he && "default", "text", R && Z && "filtered"), G = O, me;
      return I ? G = I : Q && !C ? me = i.getSelectedItem(ne) : he && (me = i.getItemByValue(se)), pC.create(me ? zhe(me) : G, {
        defaultProps: {
          className: ue
        }
      });
    }, i.renderSearchInput = function() {
      var g = i.props, C = g.search, O = g.searchInput, R = i.state.searchQuery;
      return C && /* @__PURE__ */ ae.createElement(yp, {
        innerRef: i.searchRef
      }, kae.create(O, {
        defaultProps: {
          style: {
            width: i.computeSearchInputWidth()
          },
          tabIndex: i.computeSearchInputTabIndex(),
          value: R
        },
        overrideProps: i.handleSearchInputOverrides
      }));
    }, i.renderSearchSizer = function() {
      var g = i.props, C = g.search, O = g.multiple;
      return C && O && /* @__PURE__ */ ae.createElement("span", {
        className: "sizer",
        ref: i.sizerRef
      });
    }, i.renderLabels = function() {
      var g = i.props, C = g.multiple, O = g.renderLabel, R = i.state, I = R.selectedLabel, L = R.value;
      if (!(!C || u2(L))) {
        var Z = fi(L, i.getItemByValue);
        return fi(T_e(Z), function(ne, se) {
          var Q = {
            active: ne.value === I,
            as: "a",
            key: Zue(ne.key, ne.value),
            onClick: i.handleLabelClick,
            onRemove: i.handleLabelRemove,
            value: ne.value
          };
          return Rh.create(O(ne, se, Q), {
            defaultProps: Q
          });
        });
      }
    }, i.renderOptions = function() {
      var g = i.props, C = g.lazyLoad, O = g.multiple, R = g.search, I = g.noResultsMessage, L = i.state, Z = L.open, ne = L.selectedIndex, se = L.value;
      if (C && !Z)
        return null;
      var Q = zD({
        value: i.state.value,
        options: i.props.options,
        searchQuery: i.state.searchQuery,
        additionLabel: i.props.additionLabel,
        additionPosition: i.props.additionPosition,
        allowAdditions: i.props.allowAdditions,
        deburr: i.props.deburr,
        multiple: i.props.multiple,
        search: i.props.search
      });
      if (I !== null && R && u2(Q))
        return /* @__PURE__ */ ae.createElement("div", {
          className: "message"
        }, I);
      var he = O ? function(ue) {
        return Og(se, ue);
      } : function(ue) {
        return ue === se;
      };
      return fi(Q, function(ue, G) {
        return Aj.create(Be({
          active: he(ue.value),
          selected: ne === G
        }, ue, {
          key: Zue(ue.key, ue.value),
          // Needed for handling click events on disabled items
          style: Be({}, ue.style, {
            pointerEvents: "all"
          })
        }), {
          generateKey: !1,
          overrideProps: function(we) {
            return {
              onClick: function(q, Te) {
                we.onClick == null || we.onClick(q, Te), i.handleItemClick(q, Te);
              }
            };
          }
        });
      });
    }, i.renderMenu = function() {
      var g = i.props, C = g.children, O = g.direction, R = g.header, I = i.state.open, L = i.getDropdownMenuAriaOptions();
      if (!dn(C)) {
        var Z = _k.only(C), ne = Vt(O, $e(I, "visible"), Z.props.className);
        return /* @__PURE__ */ sae(Z, Be({
          className: ne
        }, L));
      }
      return /* @__PURE__ */ ae.createElement(QA, Be({}, L, {
        direction: O,
        open: I
      }), mC.create(R, {
        autoGenerateKey: !1
      }), i.renderOptions());
    }, i;
  }
  var c = o.prototype;
  return c.getInitialAutoControlledState = function() {
    return {
      focus: !1,
      searchQuery: ""
    };
  }, o.getAutoControlledStateFromProps = function(d, m, v) {
    var g = {
      __options: d.options,
      __value: m.value
    }, C = (
      // On value change
      !p2(v.__value, m.value) || // On option keys/values, we only check those properties to avoid recursive performance impacts.
      // https://github.com/Semantic-Org/Semantic-UI-React/issues/3000
      !u2e(Kue(d.options), Kue(v.__options))
    );
    return C && (g.selectedIndex = Gue({
      additionLabel: d.additionLabel,
      additionPosition: d.additionPosition,
      allowAdditions: d.allowAdditions,
      deburr: d.deburr,
      multiple: d.multiple,
      search: d.search,
      selectedIndex: m.selectedIndex,
      value: m.value,
      options: d.options,
      searchQuery: m.searchQuery
    })), g;
  }, c.componentDidMount = function() {
    var d = this.state.open;
    d && this.open(null, !1);
  }, c.shouldComponentUpdate = function(d, m) {
    return !p2(d, this.props) || !p2(m, this.state);
  }, c.componentDidUpdate = function(d, m) {
    var v = this.props, g = v.closeOnBlur, C = v.minCharacters, O = v.openOnFocus, R = v.search;
    if (process.env.NODE_ENV !== "production") {
      var I = Array.isArray(this.props.value), L = iC(this.props, "value");
      L && this.props.multiple && !I ? console.error("Dropdown `value` must be an array when `multiple` is set." + (" Received type: `" + Object.prototype.toString.call(this.props.value) + "`.")) : L && !this.props.multiple && I && console.error("Dropdown `value` must not be an array when `multiple` is not set. Either set `multiple={true}` or use a string or number value.");
    }
    if (!m.focus && this.state.focus) {
      if (!this.isMouseDown) {
        var Z = !R || R && C === 1 && !this.state.open;
        O && Z && this.open();
      }
    } else
      m.focus && !this.state.focus && !this.isMouseDown && g && this.close();
    !m.open && this.state.open ? (this.setOpenDirection(), this.scrollSelectedItemIntoView()) : m.open && this.state.open, m.selectedIndex !== this.state.selectedIndex && this.scrollSelectedItemIntoView();
  }, c.getDropdownMenuAriaOptions = function() {
    var d = this.props, m = d.search, v = d.multiple, g = {};
    return m && (g["aria-multiselectable"] = v, g.role = "listbox"), g;
  }, c.render = function() {
    var d = this.props, m = d.basic, v = d.button, g = d.className, C = d.compact, O = d.disabled, R = d.error, I = d.fluid, L = d.floating, Z = d.icon, ne = d.inline, se = d.item, Q = d.labeled, he = d.loading, ue = d.multiple, G = d.pointing, me = d.search, we = d.selection, be = d.scrolling, q = d.simple, Te = d.trigger, Le = this.state, je = Le.focus, Ie = Le.open, Ce = Le.upward, pt = Vt(
      "ui",
      $e(Ie, "active visible"),
      $e(O, "disabled"),
      $e(R, "error"),
      $e(he, "loading"),
      $e(m, "basic"),
      $e(v, "button"),
      $e(C, "compact"),
      $e(I, "fluid"),
      $e(L, "floating"),
      $e(ne, "inline"),
      // TODO: consider augmentation to render Dropdowns as Button/Menu, solves icon/link item issues
      // https://github.com/Semantic-Org/Semantic-UI-React/issues/401#issuecomment-240487229
      // TODO: the icon class is only required when a dropdown is a button
      // useKeyOnly(icon, 'icon'),
      $e(Q, "labeled"),
      $e(se, "item"),
      $e(ue, "multiple"),
      $e(me, "search"),
      $e(we, "selection"),
      $e(q, "simple"),
      $e(be, "scrolling"),
      $e(Ce, "upward"),
      mi(G, "pointing"),
      "dropdown",
      g
    ), sn = zt(o, this.props), Lt = Xt(o, this.props), z = this.getDropdownAriaOptions(Lt, this.props);
    return /* @__PURE__ */ ae.createElement(yp, {
      innerRef: this.ref
    }, /* @__PURE__ */ ae.createElement(Lt, Be({}, sn, z, {
      className: pt,
      onBlur: this.handleBlur,
      onClick: this.handleClick,
      onKeyDown: this.handleKeyDown,
      onMouseDown: this.handleMouseDown,
      onFocus: this.handleFocus,
      onChange: this.handleChange,
      tabIndex: this.computeTabIndex()
    }), this.renderLabels(), this.renderSearchInput(), this.renderSearchSizer(), Te || this.renderText(), fc.create(Z, {
      overrideProps: this.handleIconOverrides,
      autoGenerateKey: !1
    }), this.renderMenu(), Ie && /* @__PURE__ */ ae.createElement(rC, {
      name: "keydown",
      on: this.closeOnEscape
    }), Ie && /* @__PURE__ */ ae.createElement(rC, {
      name: "click",
      on: this.closeOnDocumentClick
    }), je && /* @__PURE__ */ ae.createElement(rC, {
      name: "keydown",
      on: this.removeItemOnBackspace
    })));
  }, o;
}(P1);
kl.handledProps = ["additionLabel", "additionPosition", "allowAdditions", "as", "basic", "button", "children", "className", "clearable", "closeOnBlur", "closeOnChange", "closeOnEscape", "compact", "deburr", "defaultOpen", "defaultSearchQuery", "defaultSelectedLabel", "defaultUpward", "defaultValue", "direction", "disabled", "error", "floating", "fluid", "header", "icon", "inline", "item", "labeled", "lazyLoad", "loading", "minCharacters", "multiple", "noResultsMessage", "onAddItem", "onBlur", "onChange", "onClick", "onClose", "onFocus", "onLabelClick", "onMouseDown", "onOpen", "onSearchChange", "open", "openOnFocus", "options", "placeholder", "pointing", "renderLabel", "scrolling", "search", "searchInput", "searchQuery", "selectOnBlur", "selectOnNavigation", "selectedLabel", "selection", "simple", "tabIndex", "text", "trigger", "upward", "value", "wrapSelection"];
kl.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Label prefixed to an option added by a user. */
  additionLabel: _.oneOfType([_.element, _.string]),
  /** Position of the `Add: ...` option in the dropdown list ('top' or 'bottom'). */
  additionPosition: _.oneOf(["top", "bottom"]),
  /**
   * Allow user additions to the list of options (boolean).
   * Requires the use of `selection`, `options` and `search`.
   */
  allowAdditions: co([_h(["options", "selection", "search"]), _.bool]),
  /** A Dropdown can reduce its complexity. */
  basic: _.bool,
  /** Format the Dropdown to appear as a button. */
  button: _.bool,
  /** Primary content. */
  children: co([Go(["options", "selection"]), lhe({
    children: _.any.isRequired
  }, _.element.isRequired)]),
  /** Additional classes. */
  className: _.string,
  /** Using the clearable setting will let users remove their selection from a dropdown. */
  clearable: _.bool,
  /** Whether or not the menu should close when the dropdown is blurred. */
  closeOnBlur: _.bool,
  /** Whether or not the dropdown should close when the escape key is pressed. */
  closeOnEscape: _.bool,
  /**
   * Whether or not the menu should close when a value is selected from the dropdown.
   * By default, multiple selection dropdowns will remain open on change, while single
   * selection dropdowns will close on change.
   */
  closeOnChange: _.bool,
  /** A compact dropdown has no minimum width. */
  compact: _.bool,
  /** Whether or not the dropdown should strip diacritics in options and input search */
  deburr: _.bool,
  /** Initial value of open. */
  defaultOpen: _.bool,
  /** Initial value of searchQuery. */
  defaultSearchQuery: _.string,
  /** Currently selected label in multi-select. */
  defaultSelectedLabel: co([_h(["multiple"]), _.oneOfType([_.number, _.string])]),
  /** Initial value of upward. */
  defaultUpward: _.bool,
  /** Initial value or value array if multiple. */
  defaultValue: _.oneOfType([_.number, _.string, _.bool, _.arrayOf(_.oneOfType([_.string, _.number, _.bool]))]),
  /** A dropdown menu can open to the left or to the right. */
  direction: _.oneOf(["left", "right"]),
  /** A disabled dropdown menu or item does not allow user interaction. */
  disabled: _.bool,
  /** An errored dropdown can alert a user to a problem. */
  error: _.bool,
  /** A dropdown menu can contain floated content. */
  floating: _.bool,
  /** A dropdown can take the full width of its parent */
  fluid: _.bool,
  /** A dropdown menu can contain a header. */
  header: _.node,
  /** Shorthand for Icon. */
  icon: _.oneOfType([_.node, _.object]),
  /** A dropdown can be formatted to appear inline in other content. */
  inline: _.bool,
  /** A dropdown can be formatted as a Menu item. */
  item: _.bool,
  /** A dropdown can be labeled. */
  labeled: _.bool,
  /** A dropdown can defer rendering its options until it is open. */
  lazyLoad: _.bool,
  /** A dropdown can show that it is currently loading data. */
  loading: _.bool,
  /** The minimum characters for a search to begin showing results. */
  minCharacters: _.number,
  /** A selection dropdown can allow multiple selections. */
  multiple: _.bool,
  /** Message to display when there are no results. */
  noResultsMessage: _.node,
  /**
   * Called when a user adds a new item. Use this to update the options list.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props and the new item's value.
   */
  onAddItem: _.func,
  /**
   * Called on blur.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onBlur: _.func,
  /**
   * Called when the user attempts to change the value.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props and proposed value.
   */
  onChange: _.func,
  /**
   * Called on click.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onClick: _.func,
  /**
   * Called when a close event happens.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onClose: _.func,
  /**
   * Called on focus.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onFocus: _.func,
  /**
   * Called when a multi-select label is clicked.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All label props.
   */
  onLabelClick: _.func,
  /**
   * Called on mousedown.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onMouseDown: _.func,
  /**
   * Called when an open event happens.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onOpen: _.func,
  /**
   * Called on search input change.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props, includes current value of searchQuery.
   */
  onSearchChange: _.func,
  /** Controls whether or not the dropdown menu is displayed. */
  open: _.bool,
  /** Whether or not the menu should open when the dropdown is focused. */
  openOnFocus: _.bool,
  /** Array of Dropdown.Item props e.g. `{ text: '', value: '' }` */
  options: co([Go(["children"]), _.arrayOf(_.shape(Aj.propTypes))]),
  /** Placeholder text. */
  placeholder: _.string,
  /** A dropdown can be formatted so that its menu is pointing. */
  pointing: _.oneOfType([_.bool, _.oneOf(["left", "right", "top", "top left", "top right", "bottom", "bottom left", "bottom right"])]),
  /**
   * Mapped over the active items and returns shorthand for the active item Labels.
   * Only applies to `multiple` Dropdowns.
   *
   * @param {object} item - A currently active dropdown item.
   * @param {number} index - The current index.
   * @param {object} defaultLabelProps - The default props for an active item Label.
   * @returns {*} Shorthand for a Label.
   */
  renderLabel: _.func,
  /** A dropdown can have its menu scroll. */
  scrolling: _.bool,
  /**
   * A selection dropdown can allow a user to search through a large list of choices.
   * Pass a function here to replace the default search.
   */
  search: _.oneOfType([_.bool, _.func]),
  /** A shorthand for a search input. */
  searchInput: _.oneOfType([_.array, _.node, _.object]),
  /** Current value of searchQuery. Creates a controlled component. */
  searchQuery: _.string,
  // TODO 'searchInMenu' or 'search='in menu' or ???  How to handle this markup and functionality?
  /** Define whether the highlighted item should be selected on blur. */
  selectOnBlur: _.bool,
  /**
   * Whether or not to change the value when navigating the menu using arrow keys.
   * Setting to false will require enter or left click to confirm a choice.
   */
  selectOnNavigation: _.bool,
  /** Currently selected label in multi-select. */
  selectedLabel: co([_h(["multiple"]), _.oneOfType([_.string, _.number])]),
  /** A dropdown can be used to select between choices in a form. */
  selection: co([Go(["children"]), _h(["options"]), _.bool]),
  /** A simple dropdown can open without Javascript. */
  simple: _.bool,
  /** A dropdown can receive focus. */
  tabIndex: _.oneOfType([_.number, _.string]),
  /** The text displayed in the dropdown, usually for the active item. */
  text: _.string,
  /** Custom element to trigger the menu to become visible. Takes place of 'text'. */
  trigger: co([Go(["selection", "text"]), _.node]),
  /** Current value or value array if multiple. Creates a controlled component. */
  value: _.oneOfType([_.bool, _.string, _.number, _.arrayOf(_.oneOfType([_.bool, _.string, _.number]))]),
  /** Controls whether the dropdown will open upward. */
  upward: _.bool,
  /**
   * A dropdown will go to the last element when ArrowUp is pressed on the first,
   * or go to the first when ArrowDown is pressed on the last( aka infinite selection )
   */
  wrapSelection: _.bool
} : {};
kl.defaultProps = {
  additionLabel: "Add ",
  additionPosition: "top",
  closeOnBlur: !0,
  closeOnEscape: !0,
  deburr: !1,
  icon: "dropdown",
  minCharacters: 1,
  noResultsMessage: "No results found.",
  openOnFocus: !0,
  renderLabel: zhe,
  searchInput: "text",
  selectOnBlur: !0,
  selectOnNavigation: !0,
  wrapSelection: !0
};
kl.autoControlledProps = ["open", "searchQuery", "selectedLabel", "value", "upward"];
kl.Divider = l$;
kl.Header = mC;
kl.Item = Aj;
kl.Menu = QA;
kl.SearchInput = kae;
kl.Text = pC;
function N2(r) {
  return /* @__PURE__ */ ae.createElement(kl, Be({}, r, {
    selection: !0
  }));
}
N2.handledProps = ["options"];
N2.propTypes = process.env.NODE_ENV !== "production" ? {
  /** Array of Dropdown.Item props e.g. `{ text: '', value: '' }` */
  options: _.arrayOf(_.shape(kl.Item.propTypes)).isRequired
} : {};
N2.Divider = kl.Divider;
N2.Header = kl.Header;
N2.Item = kl.Item;
N2.Menu = kl.Menu;
var kj = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.ref = /* @__PURE__ */ bp(), i.focus = function() {
      return i.ref.current.focus();
    }, i.handleChange = function(g) {
      var C = Oh(g, "target.value");
      xn(i.props, "onChange", g, Be({}, i.props, {
        value: C
      }));
    }, i.handleInput = function(g) {
      var C = Oh(g, "target.value");
      xn(i.props, "onInput", g, Be({}, i.props, {
        value: C
      }));
    }, i;
  }
  var c = o.prototype;
  return c.render = function() {
    var d = this.props, m = d.rows, v = d.value, g = zt(o, this.props), C = Xt(o, this.props);
    return /* @__PURE__ */ ae.createElement(yp, {
      innerRef: this.ref
    }, /* @__PURE__ */ ae.createElement(C, Be({}, g, {
      onChange: this.handleChange,
      onInput: this.handleInput,
      rows: m,
      value: v
    })));
  }, o;
}(Do);
kj.handledProps = ["as", "onChange", "onInput", "rows", "value"];
kj.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /**
   * Called on change.
   * @param {SyntheticEvent} event - The React SyntheticEvent object
   * @param {object} data - All props and the event value.
   */
  onChange: _.func,
  /**
   * Called on input.
   * @param {SyntheticEvent} event - The React SyntheticEvent object
   * @param {object} data - All props and the event value.
   */
  onInput: _.func,
  /** Indicates row count for a TextArea. */
  rows: _.oneOfType([_.number, _.string]),
  /** The value of the textarea. */
  value: _.oneOfType([_.number, _.string])
} : {};
kj.defaultProps = {
  as: "textarea",
  rows: 3
};
const Vhe = kj;
function X_e(r, o) {
  var c = {};
  return o = R1(o), fae(r, function(i, d, m) {
    Sj(c, d, o(i, d, m));
  }), c;
}
function J_e(r, o, c, i) {
  for (var d = -1, m = r == null ? 0 : r.length; ++d < m; ) {
    var v = r[d];
    o(i, v, c(v), r);
  }
  return i;
}
function eOe(r, o, c, i) {
  return Rk(r, function(d, m, v) {
    o(i, d, c(d), v);
  }), i;
}
function tOe(r, o) {
  return function(c, i) {
    var d = qc(c) ? J_e : eOe, m = o ? o() : {};
    return d(c, r, R1(i), m);
  };
}
var nOe = tOe(function(r, o, c) {
  Sj(r, c, o);
});
const rOe = nOe;
var Yue = function(o) {
  return rOe(AW(_k.toArray(o), oae), "key");
}, oOe = function(o, c) {
  var i = {}, d = [];
  return C1(Yf(o), function(m) {
    if (!iC(c, m)) {
      d.push(m);
      return;
    }
    d.length && (i[m] = d, d = []);
  }), [i, d];
}, roe = function(o, c, i) {
  return iC(i, o) ? i[o] : c[o];
}, sOe = function(o, c) {
  o === void 0 && (o = {}), c === void 0 && (c = {});
  var i = {}, d = oOe(o, c), m = d[0], v = d[1];
  return C1(Yf(c), function(g) {
    iC(m, g) && C1(m[g], function(C) {
      i[C] = roe(C, o, c);
    }), i[g] = roe(g, o, c);
  }), C1(v, function(g) {
    i[g] = roe(g, o, c);
  }), i;
};
function lW(r, o, c) {
  c === void 0 && (c = {});
  var i = r.key, d = c, m = d.animation, v = d.directional, g = d.duration, C = d.transitionOnMount, O = C === void 0 ? !1 : C, R = d.visible, I = R === void 0 ? !0 : R;
  return /* @__PURE__ */ ae.createElement(zv, {
    animation: m,
    directional: v,
    duration: g,
    key: i,
    onHide: o,
    reactKey: i,
    transitionOnMount: O,
    visible: I
  }, r);
}
lW.handledProps = [];
var UB = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.state = {
      // Keeping a callback under the state is a hack to make it accessible under getDerivedStateFromProps()
      handleOnHide: function(C, O) {
        var R = O.reactKey;
        i.setState(function(I) {
          var L = Be({}, I.children);
          return delete L[R], {
            children: L
          };
        });
      }
    }, i;
  }
  o.getDerivedStateFromProps = function(d, m) {
    var v = d.animation, g = d.duration, C = d.directional, O = m.children;
    if (typeof O > "u")
      return {
        children: X_e(Yue(d.children), function(L) {
          return lW(L, m.handleOnHide, {
            animation: v,
            duration: g,
            directional: C
          });
        })
      };
    var R = Yue(d.children), I = sOe(O, R);
    return C1(I, function(L, Z) {
      var ne = iC(O, Z), se = iC(R, Z), Q = O[Z], he = !Oh(Q, "props.visible");
      if (se && (!ne || he)) {
        I[Z] = lW(L, m.handleOnHide, {
          animation: v,
          duration: g,
          directional: C,
          transitionOnMount: !0
        });
        return;
      }
      if (!se && ne && !he) {
        I[Z] = /* @__PURE__ */ ae.cloneElement(Q, {
          visible: !1
        });
        return;
      }
      var ue = Q.props, G = ue.visible, me = ue.transitionOnMount;
      I[Z] = lW(L, m.handleOnHide, {
        animation: v,
        duration: g,
        directional: C,
        transitionOnMount: me,
        visible: G
      });
    }), {
      children: I
    };
  };
  var c = o.prototype;
  return c.render = function() {
    var d = this.state.children, m = Xt(o, this.props), v = zt(o, this.props);
    return /* @__PURE__ */ ae.createElement(m, v, xj(d));
  }, o;
}(ae.Component);
UB.handledProps = ["animation", "as", "children", "directional", "duration"];
UB.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Named animation event to used. Must be defined in CSS. */
  animation: _.oneOfType([_.oneOf(yhe), _.string]),
  /** Primary content. */
  children: _.node,
  /** Whether it is directional animation event or not. Use it only for custom transitions. */
  directional: _.bool,
  /** Duration of the CSS transition animation in milliseconds. */
  duration: _.oneOfType([_.number, _.shape({
    hide: _.number.isRequired,
    show: _.number.isRequired
  }), _.string])
} : {};
UB.defaultProps = {
  as: ae.Fragment,
  animation: "fade",
  duration: 500
};
var DW = "INITIAL", RS = "ENTERED", oC = "ENTERING", sC = "EXITED", qD = "EXITING", IA = "UNMOUNTED";
function aOe(r) {
  var o = r.mountOnShow, c = r.status, i = r.transitionOnMount, d = r.visible, m = r.unmountOnHide;
  if (d) {
    if (c === DW)
      return i ? {
        animating: !0,
        status: oC,
        nextStatus: RS
      } : {
        animating: !1,
        status: RS,
        nextStatus: void 0
      };
    if (c === IA)
      return {
        animating: !0,
        status: oC,
        nextStatus: RS
      };
    if (c === sC || c === qD)
      return {
        animating: !0,
        status: oC,
        nextStatus: RS
      };
    if (c === oC)
      return {};
    if (c === RS)
      return {
        animating: !1,
        status: RS,
        nextStatus: void 0
      };
  }
  if (c === DW)
    return o || m ? {
      animating: !1,
      status: IA,
      nextStatus: void 0
    } : {
      animating: !1,
      status: sC,
      nextStatus: void 0
    };
  if (c === RS || c === oC)
    return {
      animating: !0,
      status: qD,
      nextStatus: m ? IA : sC
    };
  if (c === qD)
    return {};
  if (c === sC)
    return {
      animating: !1,
      status: sC,
      nextStatus: void 0
    };
  if (c === IA)
    return {
      animating: !1,
      status: IA,
      nextStatus: void 0
    };
  throw new Error("Transition:computeStatuses(): an unexpected status transition: { visible: " + d + ", status: " + c + " }");
}
var Q9, X9, iOe = (Q9 = {}, Q9[RS] = "show", Q9[sC] = "hide", Q9), cOe = (X9 = {}, X9[oC] = "show", X9[qD] = "hide", X9), zv = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.state = {
      status: DW
    }, i.handleStart = function(g) {
      var C = i.props.duration, O = iOe[g], R = Due(C, O);
      i.timeoutId = setTimeout(function() {
        return i.setState({
          status: g
        });
      }, R);
    }, i.updateStatus = function(g) {
      if (g.status !== i.state.status && (clearTimeout(i.timeoutId), i.state.nextStatus && i.handleStart(i.state.nextStatus)), !g.animating && i.state.animating && xn(i.props, "onStart", null, Be({}, i.props, {
        status: i.state.status
      })), g.animating && !i.state.animating) {
        var C = i.state.status === RS ? "onShow" : "onHide";
        xn(i.props, "onComplete", null, Be({}, i.props, {
          status: i.state.status
        })), xn(i.props, C, null, Be({}, i.props, {
          status: i.state.status
        }));
      }
    }, i.computeClasses = function() {
      var g = i.props, C = g.animation, O = g.directional, R = g.children, I = i.state, L = I.animating, Z = I.status, ne = Oh(R, "props.className"), se = ws(O) ? Og(bhe, C) : O;
      return se ? Vt(C, ne, $e(L, "animating"), $e(Z === oC, "in"), $e(Z === qD, "out"), $e(Z === sC, "hidden"), $e(Z !== sC, "visible"), "transition") : Vt(C, ne, $e(L, "animating transition"));
    }, i.computeStyle = function() {
      var g = i.props, C = g.children, O = g.duration, R = i.state.status, I = Oh(C, "props.style"), L = cOe[R], Z = L && Due(O, L) + "ms";
      return Be({}, I, {
        animationDuration: Z
      });
    }, i;
  }
  o.getDerivedStateFromProps = function(d, m) {
    var v = aOe({
      mountOnShow: d.mountOnShow,
      status: m.status,
      transitionOnMount: d.transitionOnMount,
      visible: d.visible,
      unmountOnHide: d.unmountOnHide
    });
    return v;
  };
  var c = o.prototype;
  return c.componentDidMount = function() {
    this.updateStatus({});
  }, c.componentDidUpdate = function(d, m) {
    this.updateStatus(m);
  }, c.componentWillUnmount = function() {
    clearTimeout(this.timeoutId);
  }, c.render = function() {
    var d = this.props.children, m = this.state.status;
    return m === IA ? null : /* @__PURE__ */ sae(d, {
      className: this.computeClasses(),
      style: this.computeStyle()
    });
  }, o;
}(Do);
zv.INITIAL = DW;
zv.ENTERED = RS;
zv.ENTERING = oC;
zv.EXITED = sC;
zv.EXITING = qD;
zv.UNMOUNTED = IA;
zv.Group = UB;
zv.handledProps = ["animation", "children", "directional", "duration", "mountOnShow", "onComplete", "onHide", "onShow", "onStart", "reactKey", "transitionOnMount", "unmountOnHide", "visible"];
zv.propTypes = process.env.NODE_ENV !== "production" ? {
  /** Named animation event to used. Must be defined in CSS. */
  animation: _.oneOfType([_.oneOf(yhe), _.string]),
  /** Primary content. */
  children: _.element.isRequired,
  /** Whether it is directional animation event or not. Use it only for custom transitions. */
  directional: _.bool,
  /** Duration of the CSS transition animation in milliseconds. */
  duration: _.oneOfType([_.number, _.shape({
    hide: _.number,
    show: _.number
  }), _.string]),
  /** Show the component; triggers the enter or exit animation. */
  visible: _.bool,
  /** Wait until the first "enter" transition to mount the component (add it to the DOM). */
  mountOnShow: _.bool,
  /**
   * Callback on each transition that changes visibility to shown.
   *
   * @param {null}
   * @param {object} data - All props with status.
   */
  onComplete: _.func,
  /**
   * Callback on each transition that changes visibility to hidden.
   *
   * @param {null}
   * @param {object} data - All props with status.
   */
  onHide: _.func,
  /**
   * Callback on each transition that changes visibility to shown.
   *
   * @param {null}
   * @param {object} data - All props with status.
   */
  onShow: _.func,
  /**
   * Callback on animation start.
   *
   * @param {null}
   * @param {object} data - All props with status.
   */
  onStart: _.func,
  /** React's key of the element. */
  reactKey: _.string,
  /** Run the enter animation when the component mounts, if it is initially shown. */
  transitionOnMount: _.bool,
  /** Unmount the component (remove it from the DOM) when it is not shown. */
  unmountOnHide: _.bool
} : {};
zv.defaultProps = {
  animation: "fade",
  duration: 500,
  visible: !0,
  mountOnShow: !0,
  transitionOnMount: !1,
  unmountOnHide: !1
};
var Nj = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.state = {}, i.handlePortalClose = function() {
      i.setState({
        portalOpen: -1
      });
    }, i.handlePortalOpen = function() {
      i.setState({
        portalOpen: !0
      });
    }, i.handleTransitionHide = function(g, C) {
      var O = i.state.portalOpen;
      i.setState({
        transitionVisible: !1
      }), xn(i.props, "onClose", null, Be({}, C, {
        portalOpen: !1,
        transitionVisible: !1
      })), xn(i.props, "onHide", null, Be({}, C, {
        portalOpen: O,
        transitionVisible: !1
      }));
    }, i.handleTransitionStart = function(g, C) {
      var O = i.state.portalOpen, R = C.status, I = R === oC;
      xn(i.props, "onStart", null, Be({}, C, {
        portalOpen: O,
        transitionVisible: I
      })), I && (i.setState({
        transitionVisible: I
      }), xn(i.props, "onOpen", null, Be({}, C, {
        transitionVisible: I,
        portalOpen: !0
      })));
    }, i;
  }
  o.getDerivedStateFromProps = function(d, m) {
    return m.portalOpen === -1 ? {
      portalOpen: !1
    } : xh(d.open) ? null : {
      portalOpen: d.open
    };
  };
  var c = o.prototype;
  return c.render = function() {
    var d = this.props, m = d.children, v = d.transition, g = this.state, C = g.portalOpen, O = g.transitionVisible, R = C || O, I = zt(o, this.props);
    return /* @__PURE__ */ ae.createElement(m2, Be({}, I, {
      open: R,
      onOpen: this.handlePortalOpen,
      onClose: this.handlePortalClose
    }), /* @__PURE__ */ ae.createElement(zv, Be({}, v, {
      transitionOnMount: !0,
      onStart: this.handleTransitionStart,
      onHide: this.handleTransitionHide,
      visible: C
    }), m));
  }, o;
}(Do);
Nj.handledProps = ["children", "onClose", "onHide", "onOpen", "onStart", "open", "transition"];
Nj.propTypes = process.env.NODE_ENV !== "production" ? {
  /** Primary content. */
  children: _.node.isRequired,
  /**
   * Called when a close event happens.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props and internal state.
   */
  onClose: _.func,
  /**
   * Callback on each transition that changes visibility to hidden.
   *
   * @param {null}
   * @param {object} data - All props with transition status and internal state.
   */
  onHide: _.func,
  /**
   * Called when an open event happens.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props and internal state.
   */
  onOpen: _.func,
  /**
   * Callback on animation start.
   *
   * @param {null}
   * @param {object} data - All props with transition status and internal state.
   */
  onStart: _.func,
  /** Controls whether or not the portal is displayed. */
  open: _.bool,
  /** Transition props. */
  transition: _.object
} : {};
Nj.defaultProps = {
  transition: {
    animation: "scale",
    duration: 400
  }
};
var Rj = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.calculations = {
      bottomPassed: !1,
      bottomVisible: !1,
      fits: !1,
      passing: !1,
      offScreen: !1,
      onScreen: !1,
      topPassed: !1,
      topVisible: !1
    }, i.firedCallbacks = [], i.ref = /* @__PURE__ */ bp(), i.fire = function(g, C, O) {
      var R = g.callback, I = g.name;
      O === void 0 && (O = !1);
      var L = i.props, Z = L.continuous, ne = L.once, se = i.calculations[C] !== O, Q = Z || i.calculations[C] !== i.oldCalculations[C];
      se && Q && i.execute(R, I), ne || (i.firedCallbacks = pi(i.firedCallbacks, I));
    }, i.handleUpdate = function() {
      i.ticking || (i.ticking = !0, i.frameId = requestAnimationFrame(i.update));
    }, i.update = function() {
      if (i.mounted) {
        i.ticking = !1, i.oldCalculations = i.calculations, i.calculations = i.computeCalculations(), i.pageYOffset = i.getPageYOffset();
        var g = i.props, C = g.onBottomPassed, O = g.onBottomPassedReverse, R = g.onBottomVisible, I = g.onBottomVisibleReverse, L = g.onPassing, Z = g.onPassingReverse, ne = g.onTopPassed, se = g.onTopPassedReverse, Q = g.onTopVisible, he = g.onTopVisibleReverse, ue = g.onOffScreen, G = g.onOnScreen, me = g.updateOn, we = {
          bottomPassed: {
            callback: C,
            name: "onBottomPassed"
          },
          bottomVisible: {
            callback: R,
            name: "onBottomVisible"
          },
          passing: {
            callback: L,
            name: "onPassing"
          },
          offScreen: {
            callback: ue,
            name: "onOffScreen"
          },
          onScreen: {
            callback: G,
            name: "onOnScreen"
          },
          topPassed: {
            callback: ne,
            name: "onTopPassed"
          },
          topVisible: {
            callback: Q,
            name: "onTopVisible"
          }
        }, be = {
          bottomPassed: {
            callback: O,
            name: "onBottomPassedReverse"
          },
          bottomVisible: {
            callback: I,
            name: "onBottomVisibleReverse"
          },
          passing: {
            callback: Z,
            name: "onPassingReverse"
          },
          topPassed: {
            callback: se,
            name: "onTopPassedReverse"
          },
          topVisible: {
            callback: he,
            name: "onTopVisibleReverse"
          }
        };
        xn(i.props, "onUpdate", null, Be({}, i.props, {
          calculations: i.calculations
        })), i.fireOnPassed(), C1(be, function(q, Te) {
          return i.fire(q, Te, !0);
        }), C1(we, function(q, Te) {
          return i.fire(q, Te);
        }), me === "repaint" && i.handleUpdate();
      }
    }, i;
  }
  var c = o.prototype;
  return c.componentDidMount = function() {
    if (this.mounted = !0, !!$v()) {
      var d = this.props, m = d.context, v = d.fireOnMount, g = d.updateOn;
      this.pageYOffset = this.getPageYOffset(), this.attachHandlers(m, g), v && this.update();
    }
  }, c.componentDidUpdate = function(d) {
    var m = d.continuous !== this.props.continuous || d.once !== this.props.once || d.updateOn !== this.props.updateOn;
    m && (this.firedCallbacks = []), (d.context !== this.props.context || d.updateOn !== this.props.updateOn) && (this.unattachHandlers(d.context), this.attachHandlers(this.props.context, this.props.updateOn));
  }, c.componentWillUnmount = function() {
    var d = this.props.context;
    this.unattachHandlers(d), this.mounted = !1;
  }, c.attachHandlers = function(d, m) {
    if (m === "events") {
      d && (Ql.sub("resize", this.handleUpdate, {
        target: d
      }), Ql.sub("scroll", this.handleUpdate, {
        target: d
      }));
      return;
    }
    this.handleUpdate();
  }, c.unattachHandlers = function(d) {
    d && (Ql.unsub("resize", this.handleUpdate, {
      target: d
    }), Ql.unsub("scroll", this.handleUpdate, {
      target: d
    })), this.frameId && cancelAnimationFrame(this.frameId);
  }, c.execute = function(d, m) {
    var v = this.props.continuous;
    d && (!v && Og(this.firedCallbacks, m) || (d(null, Be({}, this.props, {
      calculations: this.calculations
    })), this.firedCallbacks.push(m)));
  }, c.fireOnPassed = function() {
    var d = this, m = this.calculations, v = m.percentagePassed, g = m.pixelsPassed, C = this.props.onPassed;
    C1(C, function(O, R) {
      var I = Number(R);
      if (I && g >= I) {
        d.execute(O, R);
        return;
      }
      var L = ("" + R).match(/^(\d+)%$/);
      if (L) {
        var Z = Number(L[1]) / 100;
        v >= Z && d.execute(O, R);
      }
    });
  }, c.computeCalculations = function() {
    var d = this.props.offset, m = this.ref.current.getBoundingClientRect(), v = m.bottom, g = m.height, C = m.top, O = m.width, R = l2e(d), I = R[0], L = R[1], Z = this.getPageYOffset(), ne = Z > this.pageYOffset ? "down" : "up", se = C < I, Q = v < L, he = Q ? 0 : Math.max(C * -1, 0), ue = he / g, G = v >= L && v <= window.innerHeight, me = C >= I && C <= window.innerHeight, we = me && G, be = se && !Q, q = (me || se) && !Q, Te = !q;
    return {
      bottomPassed: Q,
      bottomVisible: G,
      direction: ne,
      fits: we,
      height: g,
      passing: be,
      percentagePassed: ue,
      pixelsPassed: he,
      offScreen: Te,
      onScreen: q,
      topPassed: se,
      topVisible: me,
      width: O
    };
  }, c.getPageYOffset = function() {
    var d = this.props.context;
    return d ? d === window ? window.pageYOffset : d.scrollTop : 0;
  }, c.render = function() {
    var d = this.props.children, m = Xt(o, this.props), v = zt(o, this.props);
    return /* @__PURE__ */ ae.createElement(yp, {
      innerRef: this.ref
    }, /* @__PURE__ */ ae.createElement(m, v, d));
  }, o;
}(Do);
Rj.handledProps = ["as", "children", "context", "continuous", "fireOnMount", "offset", "onBottomPassed", "onBottomPassedReverse", "onBottomVisible", "onBottomVisibleReverse", "onOffScreen", "onOnScreen", "onPassed", "onPassing", "onPassingReverse", "onTopPassed", "onTopPassedReverse", "onTopVisible", "onTopVisibleReverse", "onUpdate", "once", "updateOn"];
Rj.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Context which visibility should attach onscroll events. */
  context: _.object,
  /**
   * When set to true a callback will occur anytime an element passes a condition not just immediately after the
   * threshold is met.
   */
  continuous: _.bool,
  /** Fires callbacks immediately after mount. */
  fireOnMount: _.bool,
  /**
   * Element's bottom edge has passed top of screen.
   *
   * @param {null}
   * @param {object} data - All props.
   */
  onBottomPassed: _.func,
  /**
   * Element's bottom edge has not passed top of screen.
   *
   * @param {null}
   * @param {object} data - All props.
   */
  onBottomPassedReverse: _.func,
  /**
   * Element's bottom edge has passed bottom of screen
   *
   * @param {null}
   * @param {object} data - All props.
   */
  onBottomVisible: _.func,
  /**
   * Element's bottom edge has not passed bottom of screen.
   *
   * @param {null}
   * @param {object} data - All props.
   */
  onBottomVisibleReverse: _.func,
  /**
   * Value that context should be adjusted in pixels. Useful for making content appear below content fixed to the
   * page.
   */
  offset: _.oneOfType([_.number, _.string, _.arrayOf(_.oneOfType([_.number, _.string]))]),
  /** When set to false a callback will occur each time an element passes the threshold for a condition. */
  once: _.bool,
  /** Element is not visible on the screen. */
  onPassed: _.object,
  /**
   * Any part of an element is visible on screen.
   *
   * @param {null}
   * @param {object} data - All props.
   */
  onPassing: _.func,
  /**
   * Element's top has not passed top of screen but bottom has.
   *
   * @param {null}
   * @param {object} data - All props.
   */
  onPassingReverse: _.func,
  /**
   * Element is not visible on the screen.
   *
   * @param {null}
   * @param {object} data - All props.
   */
  onOffScreen: _.func,
  /**
   * Element is visible on the screen.
   *
   * @param {null}
   * @param {object} data - All props.
   */
  onOnScreen: _.func,
  /**
   * Element's top edge has passed top of the screen.
   *
   * @param {null}
   * @param {object} data - All props.
   */
  onTopPassed: _.func,
  /**
   * Element's top edge has not passed top of the screen.
   *
   * @param {null}
   * @param {object} data - All props.
   */
  onTopPassedReverse: _.func,
  /**
   * Element's top edge has passed bottom of screen.
   *
   * @param {null}
   * @param {object} data - All props.
   */
  onTopVisible: _.func,
  /**
   * Element's top edge has not passed bottom of screen.
   *
   * @param {null}
   * @param {object} data - All props.
   */
  onTopVisibleReverse: _.func,
  /**
   * Element's top edge has passed bottom of screen.
   *
   * @param {null}
   * @param {object} data - All props.
   */
  onUpdate: _.func,
  /**
   * Allows to choose the mode of the position calculations:
   * - `events` - (default) update and fire callbacks only on scroll/resize events
   * - `repaint` - update and fire callbacks on browser repaint (animation frames)
   */
  updateOn: _.oneOf(["events", "repaint"])
} : {};
Rj.defaultProps = {
  context: $v() ? window : null,
  continuous: !1,
  offset: [0, 0],
  once: !0,
  updateOn: "events"
};
function hC(r) {
  var o = r.children, c = r.className, i = r.content, d = r.icon, m = Vt("divider", c), v = zt(hC, r), g = Xt(hC, r);
  return ws(d) ? ws(i) ? /* @__PURE__ */ ae.createElement(g, Be({}, v, {
    className: m
  }), dn(o) ? "/" : o) : /* @__PURE__ */ ae.createElement(g, Be({}, v, {
    className: m
  }), i) : fc.create(d, {
    defaultProps: Be({}, v, {
      className: m
    }),
    autoGenerateKey: !1
  });
}
hC.handledProps = ["as", "children", "className", "content", "icon"];
hC.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** Render as an `Icon` component with `divider` class instead of a `div`. */
  icon: Vn
} : {};
hC.create = lo(hC, function(r) {
  return {
    icon: r
  };
});
var XA = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.computeElementType = function() {
      var g = i.props, C = g.link, O = g.onClick;
      if (C || O)
        return "a";
    }, i.handleClick = function(g) {
      return xn(i.props, "onClick", g, i.props);
    }, i;
  }
  var c = o.prototype;
  return c.render = function() {
    var d = this.props, m = d.active, v = d.children, g = d.className, C = d.content, O = d.href, R = Vt($e(m, "active"), "section", g), I = zt(o, this.props), L = Xt(o, this.props, this.computeElementType);
    return /* @__PURE__ */ ae.createElement(L, Be({}, I, {
      className: R,
      href: O,
      onClick: this.handleClick
    }), dn(v) ? C : v);
  }, o;
}(Do);
XA.handledProps = ["active", "as", "children", "className", "content", "href", "link", "onClick"];
XA.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Style as the currently active section. */
  active: _.bool,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** Render as an `a` tag instead of a `div` and adds the href attribute. */
  href: co([Go(["link"]), _.string]),
  /** Render as an `a` tag instead of a `div`. */
  link: co([Go(["href"]), _.bool]),
  /**
   * Called on click. When passed, the component will render as an `a`
   * tag by default instead of a `div`.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onClick: _.func
} : {};
XA.create = lo(XA, function(r) {
  return {
    content: r,
    link: !0
  };
});
function JA(r) {
  var o = r.children, c = r.className, i = r.divider, d = r.icon, m = r.sections, v = r.size, g = Vt("ui", v, "breadcrumb", c), C = zt(JA, r), O = Xt(JA, r);
  if (!dn(o))
    return /* @__PURE__ */ ae.createElement(O, Be({}, C, {
      className: g
    }), o);
  var R = [];
  return C1(m, function(I, L) {
    var Z = XA.create(I);
    if (R.push(Z), L !== m.length - 1) {
      var ne = Z.key + "_divider" || JSON.stringify(I);
      R.push(hC.create({
        content: i,
        icon: d,
        key: ne
      }));
    }
  }), /* @__PURE__ */ ae.createElement(O, Be({}, C, {
    className: g
  }), R);
}
JA.handledProps = ["as", "children", "className", "divider", "icon", "sections", "size"];
JA.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content of the Breadcrumb.Divider. */
  divider: co([Go(["icon"]), In]),
  /** For use with the sections prop. Render as an `Icon` component with `divider` class instead of a `div` in
   *  Breadcrumb.Divider. */
  icon: co([Go(["divider"]), Vn]),
  /** Shorthand array of props for Breadcrumb.Section. */
  sections: Dh,
  /** Size of Breadcrumb. */
  size: _.oneOf(pi(mc, "medium"))
} : {};
JA.Divider = hC;
JA.Section = XA;
function kd(r) {
  var o = r.children, c = r.className, i = r.content, d = r.control, m = r.disabled, v = r.error, g = r.inline, C = r.label, O = r.required, R = r.type, I = r.width, L = r.id, Z = Vt($e(m, "disabled"), $e(v, "error"), $e(g, "inline"), $e(O, "required"), Kf(I, "wide"), "field", c), ne = zt(kd, r), se = Xt(kd, r), Q = Oh(v, "pointing", "above"), he = Rh.create(v, {
    autoGenerateKey: !1,
    defaultProps: {
      prompt: !0,
      pointing: Q,
      id: L ? L + "-error-message" : void 0,
      role: "alert",
      "aria-atomic": !0
    }
  }), ue = (Q === "below" || Q === "right") && he, G = (Q === "above" || Q === "left") && he;
  if (ws(d))
    return ws(C) ? /* @__PURE__ */ ae.createElement(se, Be({}, ne, {
      className: Z,
      id: L
    }), dn(o) ? i : o) : /* @__PURE__ */ ae.createElement(se, Be({}, ne, {
      className: Z,
      id: L
    }), ue, fse(C, {
      autoGenerateKey: !1
    }), G);
  var me = L && v ? L + "-error-message" : null, we = {
    "aria-describedby": me,
    "aria-invalid": v ? !0 : void 0
  }, be = Be({}, ne, {
    content: i,
    children: o,
    disabled: m,
    required: O,
    type: R,
    id: L
  });
  return d === "input" && (R === "checkbox" || R === "radio") ? /* @__PURE__ */ ae.createElement(se, {
    className: Z
  }, /* @__PURE__ */ ae.createElement("label", null, ue, /* @__PURE__ */ Od(d, Be({}, we, be)), " ", C, G)) : d === Iv || d === Dk ? /* @__PURE__ */ ae.createElement(se, {
    className: Z
  }, ue, /* @__PURE__ */ Od(d, Be({}, we, be, {
    label: C
  })), G) : /* @__PURE__ */ ae.createElement(se, {
    className: Z
  }, fse(C, {
    defaultProps: {
      htmlFor: L
    },
    autoGenerateKey: !1
  }), ue, /* @__PURE__ */ Od(d, Be({}, we, be)), G);
}
kd.handledProps = ["as", "children", "className", "content", "control", "disabled", "error", "id", "inline", "label", "required", "type", "width"];
kd.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /**
   * A form control component (i.e. Dropdown) or HTML tagName (i.e. 'input').
   * Extra FormField props are passed to the control component.
   * Mutually exclusive with children.
   */
  control: _.oneOfType([_.elementType, _.oneOf(["button", "input", "select", "textarea"])]),
  /** Individual fields may be disabled. */
  disabled: _.bool,
  /** Individual fields may display an error state along with a message. */
  error: _.oneOfType([_.bool, Vn]),
  /** The id of the control */
  id: _.string,
  /** A field can have its label next to instead of above it. */
  inline: _.bool,
  // Heads Up!
  // Do not disallow children with `label` shorthand
  // The `control` might accept a `label` prop and `children`
  /** Mutually exclusive with children. */
  label: _.oneOfType([_.node, _.object]),
  /** A field can show that input is mandatory. */
  required: _.bool,
  /** Passed to the control component (i.e. <input type='password' />) */
  type: co([
    _h(["control"])
    // don't strictly validate HTML types
    // a control might be passed that uses a `type` prop with unknown values
    // let the control validate if for us
  ]),
  /** A field can specify its width in grid columns */
  width: _.oneOf(hp)
} : {};
function ek(r) {
  var o = r.control, c = zt(ek, r), i = Xt(ek, r);
  return /* @__PURE__ */ ae.createElement(i, Be({}, c, {
    control: o
  }));
}
ek.handledProps = ["as", "control"];
ek.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** A FormField control prop. */
  control: kd.propTypes.control
} : {};
ek.defaultProps = {
  as: kd,
  control: hy
};
function tk(r) {
  var o = r.control, c = zt(tk, r), i = Xt(tk, r);
  return /* @__PURE__ */ ae.createElement(i, Be({}, c, {
    control: o
  }));
}
tk.handledProps = ["as", "control"];
tk.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** A FormField control prop. */
  control: kd.propTypes.control
} : {};
tk.defaultProps = {
  as: kd,
  control: Iv
};
function nk(r) {
  var o = r.control, c = zt(nk, r), i = Xt(nk, r);
  return /* @__PURE__ */ ae.createElement(i, Be({}, c, {
    control: o
  }));
}
nk.handledProps = ["as", "control"];
nk.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** A FormField control prop. */
  control: kd.propTypes.control
} : {};
nk.defaultProps = {
  as: kd,
  control: kl
};
function d$(r) {
  var o = r.children, c = r.className, i = r.grouped, d = r.inline, m = r.unstackable, v = r.widths, g = Vt($e(i, "grouped"), $e(d, "inline"), $e(m, "unstackable"), Kf(v, null, !0), "fields", c), C = zt(d$, r), O = Xt(d$, r);
  return /* @__PURE__ */ ae.createElement(O, Be({}, C, {
    className: g
  }), o);
}
d$.handledProps = ["as", "children", "className", "grouped", "inline", "unstackable", "widths"];
d$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Fields can show related choices. */
  grouped: co([Go(["inline"]), _.bool]),
  /** Multiple fields may be inline in a row. */
  inline: co([Go(["grouped"]), _.bool]),
  /** A form group can prevent itself from stacking on mobile. */
  unstackable: _.bool,
  /** Fields Groups can specify their width in grid columns or automatically divide fields to be equal width. */
  widths: _.oneOf([].concat(hp, ["equal"]))
} : {};
var f$ = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.inputRef = /* @__PURE__ */ bp(), i.computeIcon = function() {
      var g = i.props, C = g.loading, O = g.icon;
      if (!ws(O))
        return O;
      if (C)
        return "spinner";
    }, i.computeTabIndex = function() {
      var g = i.props, C = g.disabled, O = g.tabIndex;
      if (!ws(O))
        return O;
      if (C)
        return -1;
    }, i.focus = function(g) {
      return i.inputRef.current.focus(g);
    }, i.select = function() {
      return i.inputRef.current.select();
    }, i.handleChange = function(g) {
      var C = Oh(g, "target.value");
      xn(i.props, "onChange", g, Be({}, i.props, {
        value: C
      }));
    }, i.handleChildOverrides = function(g, C) {
      return Be({}, C, g.props, {
        ref: function(R) {
          $S(g.ref, R), i.inputRef.current = R;
        }
      });
    }, i.partitionProps = function() {
      var g = i.props, C = g.disabled, O = g.type, R = i.computeTabIndex(), I = zt(o, i.props), L = VB(I), Z = L[0], ne = L[1];
      return [Be({}, Z, {
        disabled: C,
        type: O,
        tabIndex: R,
        onChange: i.handleChange,
        ref: i.inputRef
      }), ne];
    }, i;
  }
  var c = o.prototype;
  return c.render = function() {
    var d = this, m = this.props, v = m.action, g = m.actionPosition, C = m.children, O = m.className, R = m.disabled, I = m.error, L = m.fluid, Z = m.focus, ne = m.icon, se = m.iconPosition, Q = m.input, he = m.inverted, ue = m.label, G = m.labelPosition, me = m.loading, we = m.size, be = m.transparent, q = m.type, Te = Vt("ui", we, $e(R, "disabled"), $e(I, "error"), $e(L, "fluid"), $e(Z, "focus"), $e(he, "inverted"), $e(me, "loading"), $e(be, "transparent"), _u(g, "action") || $e(v, "action"), _u(se, "icon") || $e(ne || me, "icon"), _u(G, "labeled") || $e(ue, "labeled"), "input", O), Le = Xt(o, this.props), je = this.partitionProps(), Ie = je[0], Ce = je[1];
    if (!dn(C)) {
      var pt = fi(_k.toArray(C), function(z) {
        return z.type !== "input" ? z : /* @__PURE__ */ sae(z, d.handleChildOverrides(z, Ie));
      });
      return /* @__PURE__ */ ae.createElement(Le, Be({}, Ce, {
        className: Te
      }), pt);
    }
    var sn = hy.create(v, {
      autoGenerateKey: !1
    }), Lt = Rh.create(ue, {
      defaultProps: {
        className: Vt(
          "label",
          // add 'left|right corner'
          Og(G, "corner") && G
        )
      },
      autoGenerateKey: !1
    });
    return /* @__PURE__ */ ae.createElement(Le, Be({}, Ce, {
      className: Te
    }), g === "left" && sn, G !== "right" && Lt, Gxe(Q || q, {
      defaultProps: Ie,
      autoGenerateKey: !1
    }), fc.create(this.computeIcon(), {
      autoGenerateKey: !1
    }), g !== "left" && sn, G === "right" && Lt);
  }, o;
}(Do);
f$.handledProps = ["action", "actionPosition", "as", "children", "className", "disabled", "error", "fluid", "focus", "icon", "iconPosition", "input", "inverted", "label", "labelPosition", "loading", "onChange", "size", "tabIndex", "transparent", "type"];
f$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** An Input can be formatted to alert the user to an action they may perform. */
  action: _.oneOfType([_.bool, Vn]),
  /** An action can appear along side an Input on the left or right. */
  actionPosition: _.oneOf(["left"]),
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** An Input field can show that it is disabled. */
  disabled: _.bool,
  /** An Input field can show the data contains errors. */
  error: _.bool,
  /** Take on the size of its container. */
  fluid: _.bool,
  /** An Input field can show a user is currently interacting with it. */
  focus: _.bool,
  /** Optional Icon to display inside the Input. */
  icon: _.oneOfType([_.bool, Vn]),
  /** An Icon can appear inside an Input on the left or right. */
  iconPosition: _.oneOf(["left"]),
  /** Shorthand for creating the HTML Input. */
  input: Vn,
  /** Format to appear on dark backgrounds. */
  inverted: _.bool,
  /** Optional Label to display along side the Input. */
  label: Vn,
  /** A Label can appear outside an Input on the left or right. */
  labelPosition: _.oneOf(["left", "right", "left corner", "right corner"]),
  /** An Icon Input field can show that it is currently loading data. */
  loading: _.bool,
  /**
   * Called on change.
   *
   * @param {ChangeEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props and a proposed value.
   */
  onChange: _.func,
  /** An Input can vary in size. */
  size: _.oneOf(["mini", "small", "large", "big", "huge", "massive"]),
  /** An Input can receive focus. */
  tabIndex: _.oneOfType([_.number, _.string]),
  /** Transparent Input has no background. */
  transparent: _.bool,
  /** The HTML input type. */
  type: _.string
} : {};
f$.defaultProps = {
  type: "text"
};
f$.create = lo(f$, function(r) {
  return {
    type: r
  };
});
const WB = f$;
function rk(r) {
  var o = r.control, c = zt(rk, r), i = Xt(rk, r);
  return /* @__PURE__ */ ae.createElement(i, Be({}, c, {
    control: o
  }));
}
rk.handledProps = ["as", "control"];
rk.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** A FormField control prop. */
  control: kd.propTypes.control
} : {};
rk.defaultProps = {
  as: kd,
  control: WB
};
function ok(r) {
  var o = r.control, c = zt(ok, r), i = Xt(ok, r);
  return /* @__PURE__ */ ae.createElement(i, Be({}, c, {
    control: o
  }));
}
ok.handledProps = ["as", "control"];
ok.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** A FormField control prop. */
  control: kd.propTypes.control
} : {};
ok.defaultProps = {
  as: kd,
  control: Dk
};
function sk(r) {
  var o = r.control, c = r.options, i = zt(sk, r), d = Xt(sk, r);
  return /* @__PURE__ */ ae.createElement(d, Be({}, i, {
    control: o,
    options: c
  }));
}
sk.handledProps = ["as", "control", "options"];
sk.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** A FormField control prop. */
  control: kd.propTypes.control,
  /** Array of Dropdown.Item props e.g. `{ text: '', value: '' }` */
  options: _.arrayOf(_.shape(kl.Item.propTypes)).isRequired
} : {};
sk.defaultProps = {
  as: kd,
  control: N2
};
function ak(r) {
  var o = r.control, c = zt(ak, r), i = Xt(ak, r);
  return /* @__PURE__ */ ae.createElement(i, Be({}, c, {
    control: o
  }));
}
ak.handledProps = ["as", "control"];
ak.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** A FormField control prop. */
  control: kd.propTypes.control
} : {};
ak.defaultProps = {
  as: kd,
  control: Vhe
};
var Vv = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.handleSubmit = function(g) {
      var C = i.props.action;
      typeof C != "string" && xn(g, "preventDefault");
      for (var O = arguments.length, R = new Array(O > 1 ? O - 1 : 0), I = 1; I < O; I++)
        R[I - 1] = arguments[I];
      xn.apply(void 0, [i.props, "onSubmit", g, i.props].concat(R));
    }, i;
  }
  var c = o.prototype;
  return c.render = function() {
    var d = this.props, m = d.action, v = d.children, g = d.className, C = d.error, O = d.inverted, R = d.loading, I = d.reply, L = d.size, Z = d.success, ne = d.unstackable, se = d.warning, Q = d.widths, he = Vt("ui", L, $e(C, "error"), $e(O, "inverted"), $e(R, "loading"), $e(I, "reply"), $e(Z, "success"), $e(ne, "unstackable"), $e(se, "warning"), Kf(Q, null, !0), "form", g), ue = zt(o, this.props), G = Xt(o, this.props);
    return /* @__PURE__ */ ae.createElement(G, Be({}, ue, {
      action: m,
      className: he,
      onSubmit: this.handleSubmit
    }), v);
  }, o;
}(Do);
Vv.handledProps = ["action", "as", "children", "className", "error", "inverted", "loading", "onSubmit", "reply", "size", "success", "unstackable", "warning", "widths"];
Vv.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** The HTML form action */
  action: _.string,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Automatically show any error Message children. */
  error: _.bool,
  /** A form can have its color inverted for contrast. */
  inverted: _.bool,
  /** Automatically show a loading indicator. */
  loading: _.bool,
  /** The HTML form submit handler. */
  onSubmit: _.func,
  /** A comment can contain a form to reply to a comment. This may have arbitrary content. */
  reply: _.bool,
  /** A form can vary in size. */
  size: _.oneOf(pi(mc, "medium")),
  /** Automatically show any success Message children. */
  success: _.bool,
  /** A form can prevent itself from stacking on mobile. */
  unstackable: _.bool,
  /** Automatically show any warning Message children. */
  warning: _.bool,
  /** Forms can automatically divide fields to be equal width. */
  widths: _.oneOf(["equal"])
} : {};
Vv.defaultProps = {
  as: "form"
};
Vv.Field = kd;
Vv.Button = ek;
Vv.Checkbox = tk;
Vv.Dropdown = nk;
Vv.Group = d$;
Vv.Input = rk;
Vv.Radio = ok;
Vv.Select = sk;
Vv.TextArea = ak;
const lOe = Vv;
function x1(r) {
  var o = r.children, c = r.className, i = r.computer, d = r.color, m = r.floated, v = r.largeScreen, g = r.mobile, C = r.only, O = r.stretched, R = r.tablet, I = r.textAlign, L = r.verticalAlign, Z = r.widescreen, ne = r.width, se = Vt(d, $e(O, "stretched"), kW(C, "only"), Dg(I), _u(m, "floated"), by(L), Kf(i, "wide computer"), Kf(v, "wide large screen"), Kf(g, "wide mobile"), Kf(R, "wide tablet"), Kf(Z, "wide widescreen"), Kf(ne, "wide"), "column", c), Q = zt(x1, r), he = Xt(x1, r);
  return /* @__PURE__ */ ae.createElement(he, Be({}, Q, {
    className: se
  }), o);
}
x1.handledProps = ["as", "children", "className", "color", "computer", "floated", "largeScreen", "mobile", "only", "stretched", "tablet", "textAlign", "verticalAlign", "widescreen", "width"];
x1.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** A grid column can be colored. */
  color: _.oneOf(Om),
  /** A column can specify a width for a computer. */
  computer: co([Go(["width"]), _.oneOf(hp)]),
  /** A column can sit flush against the left or right edge of a row. */
  floated: _.oneOf(ew),
  /** A column can specify a width for a large screen device. */
  largeScreen: co([Go(["width"]), _.oneOf(hp)]),
  /** A column can specify a width for a mobile device. */
  mobile: co([Go(["width"]), _.oneOf(hp)]),
  /** A column can appear only for a specific device, or screen sizes. */
  only: NW(vhe),
  /** A column can stretch its contents to take up the entire grid or row height. */
  stretched: _.bool,
  /** A column can specify a width for a tablet device. */
  tablet: co([Go(["width"]), _.oneOf(hp)]),
  /** A column can specify its text alignment. */
  textAlign: _.oneOf($g),
  /** A column can specify its vertical alignment to have all its columns vertically centered. */
  verticalAlign: _.oneOf(D1),
  /** A column can specify a width for a wide screen device. */
  widescreen: co([Go(["width"]), _.oneOf(hp)]),
  /** Represents width of column. */
  width: co([Go(["computer", "largeScreen", "mobile", "tablet", "widescreen"]), _.oneOf(hp)])
} : {};
x1.create = lo(x1, function(r) {
  return {
    children: r
  };
});
function m$(r) {
  var o = r.centered, c = r.children, i = r.className, d = r.color, m = r.columns, v = r.divided, g = r.only, C = r.reversed, O = r.stretched, R = r.textAlign, I = r.verticalAlign, L = Vt(d, $e(o, "centered"), $e(v, "divided"), $e(O, "stretched"), kW(g, "only"), kW(C, "reversed"), Dg(R), by(I), Kf(m, "column", !0), "row", i), Z = zt(m$, r), ne = Xt(m$, r);
  return /* @__PURE__ */ ae.createElement(ne, Be({}, Z, {
    className: L
  }), c);
}
m$.handledProps = ["as", "centered", "children", "className", "color", "columns", "divided", "only", "reversed", "stretched", "textAlign", "verticalAlign"];
m$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** A row can have its columns centered. */
  centered: _.bool,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** A grid row can be colored. */
  color: _.oneOf(Om),
  /** Represents column count per line in Row. */
  columns: _.oneOf([].concat(hp, ["equal"])),
  /** A row can have dividers between its columns. */
  divided: _.bool,
  /** A row can appear only for a specific device, or screen sizes. */
  only: NW(vhe),
  /** A row can specify that its columns should reverse order at different device sizes. */
  reversed: NW(["computer", "computer vertically", "mobile", "mobile vertically", "tablet", "tablet vertically"]),
  /** A row can stretch its contents to take up the entire column height. */
  stretched: _.bool,
  /** A row can specify its text alignment. */
  textAlign: _.oneOf($g),
  /** A row can specify its vertical alignment to have all its columns vertically centered. */
  verticalAlign: _.oneOf(D1)
} : {};
function Pv(r) {
  var o = r.celled, c = r.centered, i = r.children, d = r.className, m = r.columns, v = r.container, g = r.divided, C = r.doubling, O = r.inverted, R = r.padded, I = r.relaxed, L = r.reversed, Z = r.stackable, ne = r.stretched, se = r.textAlign, Q = r.verticalAlign, he = Vt("ui", $e(c, "centered"), $e(v, "container"), $e(C, "doubling"), $e(O, "inverted"), $e(Z, "stackable"), $e(ne, "stretched"), mi(o, "celled"), mi(g, "divided"), mi(R, "padded"), mi(I, "relaxed"), kW(L, "reversed"), Dg(se), by(Q), Kf(m, "column", !0), "grid", d), ue = zt(Pv, r), G = Xt(Pv, r);
  return /* @__PURE__ */ ae.createElement(G, Be({}, ue, {
    className: he
  }), i);
}
Pv.handledProps = ["as", "celled", "centered", "children", "className", "columns", "container", "divided", "doubling", "inverted", "padded", "relaxed", "reversed", "stackable", "stretched", "textAlign", "verticalAlign"];
Pv.Column = x1;
Pv.Row = m$;
Pv.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** A grid can have rows divided into cells. */
  celled: _.oneOfType([_.bool, _.oneOf(["internally"])]),
  /** A grid can have its columns centered. */
  centered: _.bool,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Represents column count per row in Grid. */
  columns: _.oneOf([].concat(hp, ["equal"])),
  /** A grid can be combined with a container to use the available layout and alignment. */
  container: _.bool,
  /** A grid can have dividers between its columns. */
  divided: _.oneOfType([_.bool, _.oneOf(["vertically"])]),
  /** A grid can double its column width on tablet and mobile sizes. */
  doubling: _.bool,
  /** A grid's colors can be inverted. */
  inverted: _.bool,
  /** A grid can preserve its vertical and horizontal gutters on first and last columns. */
  padded: _.oneOfType([_.bool, _.oneOf(["horizontally", "vertically"])]),
  /** A grid can increase its gutters to allow for more negative space. */
  relaxed: _.oneOfType([_.bool, _.oneOf(["very"])]),
  /** A grid can specify that its columns should reverse order at different device sizes. */
  reversed: NW(["computer", "computer vertically", "mobile", "mobile vertically", "tablet", "tablet vertically"]),
  /** A grid can have its columns stack on-top of each other after reaching mobile breakpoints. */
  stackable: _.bool,
  /** A grid can stretch its contents to take up the entire grid height. */
  stretched: _.bool,
  /** A grid can specify its text alignment. */
  textAlign: _.oneOf($g),
  /** A grid can specify its vertical alignment to have all its columns vertically centered. */
  verticalAlign: _.oneOf(D1)
} : {};
function ik(r) {
  var o = r.children, c = r.className, i = r.content, d = Vt("content", c), m = zt(ik, r), v = Xt(ik, r);
  return /* @__PURE__ */ ae.createElement(v, Be({}, m, {
    className: d
  }), dn(o) ? i : o);
}
ik.handledProps = ["as", "children", "className", "content"];
ik.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
function gC(r) {
  var o = r.children, c = r.className, i = r.content, d = Vt("header", c), m = zt(gC, r), v = Xt(gC, r);
  return /* @__PURE__ */ ae.createElement(v, Be({}, m, {
    className: d
  }), dn(o) ? i : o);
}
gC.handledProps = ["as", "children", "className", "content"];
gC.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
gC.create = lo(gC, function(r) {
  return {
    content: r
  };
});
function VS(r) {
  var o = r.children, c = r.className, i = r.content, d = Vt("content", c), m = zt(VS, r), v = Xt(VS, r);
  return /* @__PURE__ */ ae.createElement(v, Be({}, m, {
    className: d
  }), dn(o) ? i : o);
}
VS.handledProps = ["as", "children", "className", "content"];
VS.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
VS.defaultProps = {
  as: "li"
};
VS.create = lo(VS, function(r) {
  return {
    content: r
  };
});
function US(r) {
  var o = r.children, c = r.className, i = r.items, d = Vt("list", c), m = zt(US, r), v = Xt(US, r);
  return /* @__PURE__ */ ae.createElement(v, Be({}, m, {
    className: d
  }), dn(o) ? fi(i, VS.create) : o);
}
US.handledProps = ["as", "children", "className", "items"];
US.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand Message.Items. */
  items: Dh
} : {};
US.defaultProps = {
  as: "ul"
};
US.create = lo(US, function(r) {
  return {
    items: r
  };
});
var $k = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.handleDismiss = function(g) {
      var C = i.props.onDismiss;
      C && C(g, i.props);
    }, i;
  }
  var c = o.prototype;
  return c.render = function() {
    var d = this.props, m = d.attached, v = d.children, g = d.className, C = d.color, O = d.compact, R = d.content, I = d.error, L = d.floating, Z = d.header, ne = d.hidden, se = d.icon, Q = d.info, he = d.list, ue = d.negative, G = d.onDismiss, me = d.positive, we = d.size, be = d.success, q = d.visible, Te = d.warning, Le = Vt("ui", C, we, $e(O, "compact"), $e(I, "error"), $e(L, "floating"), $e(ne, "hidden"), $e(se, "icon"), $e(Q, "info"), $e(ue, "negative"), $e(me, "positive"), $e(be, "success"), $e(q, "visible"), $e(Te, "warning"), mi(m, "attached"), "message", g), je = G && /* @__PURE__ */ ae.createElement(fc, {
      name: "close",
      onClick: this.handleDismiss
    }), Ie = zt(o, this.props), Ce = Xt(o, this.props);
    return dn(v) ? /* @__PURE__ */ ae.createElement(Ce, Be({}, Ie, {
      className: Le
    }), je, fc.create(se, {
      autoGenerateKey: !1
    }), (!ws(Z) || !ws(R) || !ws(he)) && /* @__PURE__ */ ae.createElement(ik, null, gC.create(Z, {
      autoGenerateKey: !1
    }), US.create(he, {
      autoGenerateKey: !1
    }), Zxe(R, {
      autoGenerateKey: !1
    }))) : /* @__PURE__ */ ae.createElement(Ce, Be({}, Ie, {
      className: Le
    }), je, v);
  }, o;
}(Do);
$k.handledProps = ["as", "attached", "children", "className", "color", "compact", "content", "error", "floating", "header", "hidden", "icon", "info", "list", "negative", "onDismiss", "positive", "size", "success", "visible", "warning"];
$k.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** A message can be formatted to attach itself to other content. */
  attached: _.oneOfType([_.bool, _.oneOf(["bottom", "top"])]),
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** A message can be formatted to be different colors. */
  color: _.oneOf(Om),
  /** A message can only take up the width of its content. */
  compact: _.bool,
  /** Shorthand for primary content. */
  content: In,
  /** A message may be formatted to display a negative message. Same as `negative`. */
  error: _.bool,
  /** A message can float above content that it is related to. */
  floating: _.bool,
  /** Shorthand for MessageHeader. */
  header: Vn,
  /** A message can be hidden. */
  hidden: _.bool,
  /** A message can contain an icon. */
  icon: _.oneOfType([Vn, _.bool]),
  /** A message may be formatted to display information. */
  info: _.bool,
  /** Array shorthand items for the MessageList. Mutually exclusive with children. */
  list: Dh,
  /** A message may be formatted to display a negative message. Same as `error`. */
  negative: _.bool,
  /**
   * A message that the user can choose to hide.
   * Called when the user clicks the "x" icon. This also adds the "x" icon.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onDismiss: _.func,
  /** A message may be formatted to display a positive message.  Same as `success`. */
  positive: _.bool,
  /** A message can have different sizes. */
  size: _.oneOf(pi(mc, "medium")),
  /** A message may be formatted to display a positive message.  Same as `positive`. */
  success: _.bool,
  /** A message can be set to visible to force itself to be shown. */
  visible: _.bool,
  /** A message may be formatted to display warning messages. */
  warning: _.bool
} : {};
$k.Content = ik;
$k.Header = gC;
$k.List = US;
$k.Item = VS;
function vC(r) {
  var o = r.children, c = r.className, i = Vt(c), d = zt(vC, r), m = Xt(vC, r);
  return /* @__PURE__ */ ae.createElement(m, Be({}, d, {
    className: i
  }), o);
}
vC.handledProps = ["as", "children", "className"];
vC.defaultProps = {
  as: "tbody"
};
vC.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string
} : {};
function nf(r) {
  var o = r.active, c = r.children, i = r.className, d = r.collapsing, m = r.content, v = r.disabled, g = r.error, C = r.icon, O = r.negative, R = r.positive, I = r.selectable, L = r.singleLine, Z = r.textAlign, ne = r.verticalAlign, se = r.warning, Q = r.width, he = Vt($e(o, "active"), $e(d, "collapsing"), $e(v, "disabled"), $e(g, "error"), $e(O, "negative"), $e(R, "positive"), $e(I, "selectable"), $e(L, "single line"), $e(se, "warning"), Dg(Z), by(ne), Kf(Q, "wide"), i), ue = zt(nf, r), G = Xt(nf, r);
  return dn(c) ? /* @__PURE__ */ ae.createElement(G, Be({}, ue, {
    className: he
  }), fc.create(C), m) : /* @__PURE__ */ ae.createElement(G, Be({}, ue, {
    className: he
  }), c);
}
nf.handledProps = ["active", "as", "children", "className", "collapsing", "content", "disabled", "error", "icon", "negative", "positive", "selectable", "singleLine", "textAlign", "verticalAlign", "warning", "width"];
nf.defaultProps = {
  as: "td"
};
nf.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** A cell can be active or selected by a user. */
  active: _.bool,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** A cell can be collapsing so that it only uses as much space as required. */
  collapsing: _.bool,
  /** Shorthand for primary content. */
  content: In,
  /** A cell can be disabled. */
  disabled: _.bool,
  /** A cell may call attention to an error or a negative value. */
  error: _.bool,
  /** Add an Icon by name, props object, or pass an <Icon /> */
  icon: Vn,
  /** A cell may let a user know whether a value is bad. */
  negative: _.bool,
  /** A cell may let a user know whether a value is good. */
  positive: _.bool,
  /** A cell can be selectable. */
  selectable: _.bool,
  /** A cell can specify that its contents should remain on a single line and not wrap. */
  singleLine: _.bool,
  /** A table cell can adjust its text alignment. */
  textAlign: _.oneOf(pi($g, "justified")),
  /** A table cell can adjust its text alignment. */
  verticalAlign: _.oneOf(D1),
  /** A cell may warn a user. */
  warning: _.bool,
  /** A table can specify the width of individual columns independently. */
  width: _.oneOf(hp)
} : {};
nf.create = lo(nf, function(r) {
  return {
    content: r
  };
});
function WS(r) {
  var o = r.children, c = r.className, i = r.content, d = r.fullWidth, m = Vt($e(d, "full-width"), c), v = zt(WS, r), g = Xt(WS, r);
  return /* @__PURE__ */ ae.createElement(g, Be({}, v, {
    className: m
  }), dn(o) ? i : o);
}
WS.handledProps = ["as", "children", "className", "content", "fullWidth"];
WS.defaultProps = {
  as: "thead"
};
WS.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** A definition table can have a full width header or footer, filling in the gap left by the first column. */
  fullWidth: _.bool
} : {};
function Ik(r) {
  var o = r.as, c = zt(Ik, r);
  return /* @__PURE__ */ ae.createElement(WS, Be({}, c, {
    as: o
  }));
}
Ik.handledProps = ["as"];
Ik.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType
} : {};
Ik.defaultProps = {
  as: "tfoot"
};
function _g(r) {
  var o = r.as, c = r.className, i = r.sorted, d = Vt(_u(i, "sorted"), c), m = zt(_g, r);
  return /* @__PURE__ */ ae.createElement(nf, Be({}, m, {
    as: o,
    className: d
  }));
}
_g.handledProps = ["as", "className", "sorted"];
_g.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Additional classes. */
  className: _.string,
  /** A header cell can be sorted in ascending or descending order. */
  sorted: _.oneOf(["ascending", "descending"])
} : {};
_g.defaultProps = {
  as: "th"
};
function Ah(r) {
  var o = r.active, c = r.cellAs, i = r.cells, d = r.children, m = r.className, v = r.disabled, g = r.error, C = r.negative, O = r.positive, R = r.textAlign, I = r.verticalAlign, L = r.warning, Z = Vt($e(o, "active"), $e(v, "disabled"), $e(g, "error"), $e(C, "negative"), $e(O, "positive"), $e(L, "warning"), Dg(R), by(I), m), ne = zt(Ah, r), se = Xt(Ah, r);
  return dn(d) ? /* @__PURE__ */ ae.createElement(se, Be({}, ne, {
    className: Z
  }), fi(i, function(Q) {
    return nf.create(Q, {
      defaultProps: {
        as: c
      }
    });
  })) : /* @__PURE__ */ ae.createElement(se, Be({}, ne, {
    className: Z
  }), d);
}
Ah.handledProps = ["active", "as", "cellAs", "cells", "children", "className", "disabled", "error", "negative", "positive", "textAlign", "verticalAlign", "warning"];
Ah.defaultProps = {
  as: "tr",
  cellAs: "td"
};
Ah.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** A row can be active or selected by a user. */
  active: _.bool,
  /** An element type to render as (string or function). */
  cellAs: _.elementType,
  /** Shorthand array of props for TableCell. */
  cells: Dh,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** A row can be disabled. */
  disabled: _.bool,
  /** A row may call attention to an error or a negative value. */
  error: _.bool,
  /** A row may let a user know whether a value is bad. */
  negative: _.bool,
  /** A row may let a user know whether a value is good. */
  positive: _.bool,
  /** A table row can adjust its text alignment. */
  textAlign: _.oneOf(pi($g, "justified")),
  /** A table row can adjust its vertical alignment. */
  verticalAlign: _.oneOf(D1),
  /** A row may warn a user. */
  warning: _.bool
} : {};
Ah.create = lo(Ah, function(r) {
  return {
    cells: r
  };
});
function Lv(r) {
  var o = r.attached, c = r.basic, i = r.celled, d = r.children, m = r.className, v = r.collapsing, g = r.color, C = r.columns, O = r.compact, R = r.definition, I = r.fixed, L = r.footerRow, Z = r.headerRow, ne = r.headerRows, se = r.inverted, Q = r.padded, he = r.renderBodyRow, ue = r.selectable, G = r.singleLine, me = r.size, we = r.sortable, be = r.stackable, q = r.striped, Te = r.structured, Le = r.tableData, je = r.textAlign, Ie = r.unstackable, Ce = r.verticalAlign, pt = Vt("ui", g, me, $e(i, "celled"), $e(v, "collapsing"), $e(R, "definition"), $e(I, "fixed"), $e(se, "inverted"), $e(ue, "selectable"), $e(G, "single line"), $e(we, "sortable"), $e(be, "stackable"), $e(q, "striped"), $e(Te, "structured"), $e(Ie, "unstackable"), mi(o, "attached"), mi(c, "basic"), mi(O, "compact"), mi(Q, "padded"), Dg(je), by(Ce), Kf(C, "column"), "table", m), sn = zt(Lv, r), Lt = Xt(Lv, r);
  if (!dn(d))
    return /* @__PURE__ */ ae.createElement(Lt, Be({}, sn, {
      className: pt
    }), d);
  var z = Z || ne, bt = {
    defaultProps: {
      cellAs: "th"
    }
  }, at = z && /* @__PURE__ */ ae.createElement(WS, null, Ah.create(Z, bt), fi(ne, function(_n) {
    return Ah.create(_n, bt);
  }));
  return /* @__PURE__ */ ae.createElement(Lt, Be({}, sn, {
    className: pt
  }), at, /* @__PURE__ */ ae.createElement(vC, null, he && fi(Le, function(_n, st) {
    return Ah.create(he(_n, st));
  })), L && /* @__PURE__ */ ae.createElement(Ik, null, Ah.create(L)));
}
Lv.handledProps = ["as", "attached", "basic", "celled", "children", "className", "collapsing", "color", "columns", "compact", "definition", "fixed", "footerRow", "headerRow", "headerRows", "inverted", "padded", "renderBodyRow", "selectable", "singleLine", "size", "sortable", "stackable", "striped", "structured", "tableData", "textAlign", "unstackable", "verticalAlign"];
Lv.defaultProps = {
  as: "table"
};
Lv.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Attach table to other content */
  attached: _.oneOfType([_.bool, _.oneOf(["top", "bottom"])]),
  /** A table can reduce its complexity to increase readability. */
  basic: _.oneOfType([_.oneOf(["very"]), _.bool]),
  /** A table may be divided into individual cells. */
  celled: _.bool,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** A table can be collapsing, taking up only as much space as its rows. */
  collapsing: _.bool,
  /** A table can be given a color to distinguish it from other tables. */
  color: _.oneOf(Om),
  /** A table can specify its column count to divide its content evenly. */
  columns: _.oneOf(hp),
  /** A table may sometimes need to be more compact to make more rows visible at a time. */
  compact: _.oneOfType([_.bool, _.oneOf(["very"])]),
  /** A table may be formatted to emphasize a first column that defines a rows content. */
  definition: _.bool,
  /**
   * A table can use fixed a special faster form of table rendering that does not resize table cells based on content
   */
  fixed: _.bool,
  /** Shorthand for a TableRow to be placed within Table.Footer. */
  footerRow: Vn,
  /** Shorthand for a TableRow to be placed within Table.Header. */
  headerRow: co([Go(["headerRows"]), Vn]),
  /** Shorthand for multiple TableRows to be placed within Table.Header. */
  headerRows: co([Go(["headerRow"]), Dh]),
  /** A table's colors can be inverted. */
  inverted: _.bool,
  /** A table may sometimes need to be more padded for legibility. */
  padded: _.oneOfType([_.bool, _.oneOf(["very"])]),
  /**
   * Mapped over `tableData` and should return shorthand for each Table.Row to be placed within Table.Body.
   *
   * @param {*} data - An element in the `tableData` array.
   * @param {number} index - The index of the current element in `tableData`.
   * @returns {*} Shorthand for a Table.Row.
   */
  renderBodyRow: co([Go(["children"]), _h(["tableData"]), _.func]),
  /** A table can have its rows appear selectable. */
  selectable: _.bool,
  /** A table can specify that its cell contents should remain on a single line and not wrap. */
  singleLine: _.bool,
  /** A table can also be small or large. */
  size: _.oneOf(pi(mc, "mini", "tiny", "medium", "big", "huge", "massive")),
  /** A table may allow a user to sort contents by clicking on a table header. */
  sortable: _.bool,
  /** A table can specify how it stacks table content responsively. */
  stackable: _.bool,
  /** A table can stripe alternate rows of content with a darker color to increase contrast. */
  striped: _.bool,
  /** A table can be formatted to display complex structured data. */
  structured: _.bool,
  /** Data to be passed to the renderBodyRow function. */
  tableData: co([Go(["children"]), _h(["renderBodyRow"]), _.array]),
  /** A table can adjust its text alignment. */
  textAlign: _.oneOf(pi($g, "justified")),
  /** A table can specify how it stacks table content responsively. */
  unstackable: _.bool,
  /** A table can adjust its text alignment. */
  verticalAlign: _.oneOf(D1)
} : {};
Lv.Body = vC;
Lv.Cell = nf;
Lv.Footer = Ik;
Lv.Header = WS;
Lv.HeaderCell = _g;
Lv.Row = Ah;
function EB(r) {
  var o = r.children, c = r.className, i = r.content, d = r.fluid, m = r.text, v = r.textAlign, g = Vt("ui", $e(m, "text"), $e(d, "fluid"), Dg(v), "container", c), C = zt(EB, r), O = Xt(EB, r);
  return /* @__PURE__ */ ae.createElement(O, Be({}, C, {
    className: g
  }), dn(o) ? i : o);
}
EB.handledProps = ["as", "children", "className", "content", "fluid", "text", "textAlign"];
EB.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** Container has no maximum width. */
  fluid: _.bool,
  /** Reduce maximum width to more naturally accommodate text. */
  text: _.bool,
  /** Align container text. */
  textAlign: _.oneOf($g)
} : {};
function CB(r) {
  var o = r.children, c = r.className, i = r.clearing, d = r.content, m = r.fitted, v = r.hidden, g = r.horizontal, C = r.inverted, O = r.section, R = r.vertical, I = Vt("ui", $e(i, "clearing"), $e(m, "fitted"), $e(v, "hidden"), $e(g, "horizontal"), $e(C, "inverted"), $e(O, "section"), $e(R, "vertical"), "divider", c), L = zt(CB, r), Z = Xt(CB, r);
  return /* @__PURE__ */ ae.createElement(Z, Be({}, L, {
    className: I
  }), dn(o) ? d : o);
}
CB.handledProps = ["as", "children", "className", "clearing", "content", "fitted", "hidden", "horizontal", "inverted", "section", "vertical"];
CB.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Divider can clear the content above it. */
  clearing: _.bool,
  /** Shorthand for primary content. */
  content: In,
  /** Divider can be fitted without any space above or below it. */
  fitted: _.bool,
  /** Divider can divide content without creating a dividing line. */
  hidden: _.bool,
  /** Divider can segment content horizontally. */
  horizontal: _.bool,
  /** Divider can have its colours inverted. */
  inverted: _.bool,
  /** Divider can provide greater margins to divide sections of content. */
  section: _.bool,
  /** Divider can segment content vertically. */
  vertical: _.bool
} : {};
function bC(r) {
  var o = r.children, c = r.className, i = r.content, d = Vt("sub header", c), m = zt(bC, r), v = Xt(bC, r);
  return /* @__PURE__ */ ae.createElement(v, Be({}, m, {
    className: d
  }), dn(o) ? i : o);
}
bC.handledProps = ["as", "children", "className", "content"];
bC.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
bC.create = lo(bC, function(r) {
  return {
    content: r
  };
});
function ck(r) {
  var o = r.children, c = r.className, i = r.content, d = Vt("content", c), m = zt(ck, r), v = Xt(ck, r);
  return /* @__PURE__ */ ae.createElement(v, Be({}, m, {
    className: d
  }), dn(o) ? i : o);
}
ck.handledProps = ["as", "children", "className", "content"];
ck.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
function yC(r) {
  var o = r.attached, c = r.block, i = r.children, d = r.className, m = r.color, v = r.content, g = r.disabled, C = r.dividing, O = r.floated, R = r.icon, I = r.image, L = r.inverted, Z = r.size, ne = r.sub, se = r.subheader, Q = r.textAlign, he = Vt("ui", m, Z, $e(c, "block"), $e(g, "disabled"), $e(C, "dividing"), _u(O, "floated"), $e(R === !0, "icon"), $e(I === !0, "image"), $e(L, "inverted"), $e(ne, "sub"), mi(o, "attached"), Dg(Q), "header", d), ue = zt(yC, r), G = Xt(yC, r);
  if (!dn(i))
    return /* @__PURE__ */ ae.createElement(G, Be({}, ue, {
      className: he
    }), i);
  var me = fc.create(R, {
    autoGenerateKey: !1
  }), we = Qf.create(I, {
    autoGenerateKey: !1
  }), be = bC.create(se, {
    autoGenerateKey: !1
  });
  return me || we ? /* @__PURE__ */ ae.createElement(G, Be({}, ue, {
    className: he
  }), me || we, (v || be) && /* @__PURE__ */ ae.createElement(ck, null, v, be)) : /* @__PURE__ */ ae.createElement(G, Be({}, ue, {
    className: he
  }), v, be);
}
yC.handledProps = ["as", "attached", "block", "children", "className", "color", "content", "disabled", "dividing", "floated", "icon", "image", "inverted", "size", "sub", "subheader", "textAlign"];
yC.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Attach header  to other content, like a segment. */
  attached: _.oneOfType([_.bool, _.oneOf(["top", "bottom"])]),
  /** Format header to appear inside a content block. */
  block: _.bool,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Color of the header. */
  color: _.oneOf(Om),
  /** Shorthand for primary content. */
  content: In,
  /** Show that the header is inactive. */
  disabled: _.bool,
  /** Divide header from the content below it. */
  dividing: _.bool,
  /** Header can sit to the left or right of other content. */
  floated: _.oneOf(ew),
  /** Add an icon by icon name or pass an Icon. */
  icon: co([Go(["image"]), _.oneOfType([_.bool, Vn])]),
  /** Add an image by img src or pass an Image. */
  image: co([Go(["icon"]), _.oneOfType([_.bool, Vn])]),
  /** Inverts the color of the header for dark backgrounds. */
  inverted: _.bool,
  /** Content headings are sized with em and are based on the font-size of their container. */
  size: _.oneOf(pi(mc, "big", "massive", "mini")),
  /** Headers may be formatted to label smaller or de-emphasized content. */
  sub: _.bool,
  /** Shorthand for Header.Subheader. */
  subheader: Vn,
  /** Align header content. */
  textAlign: _.oneOf($g)
} : {};
yC.Content = ck;
yC.Subheader = bC;
function jS(r) {
  var o = r.children, c = r.className, i = r.content, d = Vt(c, "description"), m = zt(jS, r), v = Xt(jS, r);
  return /* @__PURE__ */ ae.createElement(v, Be({}, m, {
    className: d
  }), dn(o) ? i : o);
}
jS.handledProps = ["as", "children", "className", "content"];
jS.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
jS.create = lo(jS, function(r) {
  return {
    content: r
  };
});
function qS(r) {
  var o = r.children, c = r.className, i = r.content, d = Vt("header", c), m = zt(qS, r), v = Xt(qS, r);
  return /* @__PURE__ */ ae.createElement(v, Be({}, m, {
    className: d
  }), dn(o) ? i : o);
}
qS.handledProps = ["as", "children", "className", "content"];
qS.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
qS.create = lo(qS, function(r) {
  return {
    content: r
  };
});
function GS(r) {
  var o = r.children, c = r.className, i = r.content, d = r.description, m = r.floated, v = r.header, g = r.verticalAlign, C = Vt(_u(m, "floated"), by(g), "content", c), O = zt(GS, r), R = Xt(GS, r);
  return dn(o) ? /* @__PURE__ */ ae.createElement(R, Be({}, O, {
    className: C
  }), qS.create(v), jS.create(d), i) : /* @__PURE__ */ ae.createElement(R, Be({}, O, {
    className: C
  }), o);
}
GS.handledProps = ["as", "children", "className", "content", "description", "floated", "header", "verticalAlign"];
GS.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** Shorthand for ListDescription. */
  description: Vn,
  /** An list content can be floated left or right. */
  floated: _.oneOf(ew),
  /** Shorthand for ListHeader. */
  header: Vn,
  /** An element inside a list can be vertically aligned. */
  verticalAlign: _.oneOf(D1)
} : {};
GS.create = lo(GS, function(r) {
  return {
    content: r
  };
});
function C2(r) {
  var o = r.className, c = r.verticalAlign, i = Vt(by(c), o), d = zt(C2, r);
  return /* @__PURE__ */ ae.createElement(fc, Be({}, d, {
    className: i
  }));
}
C2.handledProps = ["className", "verticalAlign"];
C2.propTypes = process.env.NODE_ENV !== "production" ? {
  /** Additional classes. */
  className: _.string,
  /** An element inside a list can be vertically aligned. */
  verticalAlign: _.oneOf(D1)
} : {};
C2.create = lo(C2, function(r) {
  return {
    name: r
  };
});
var xB = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.handleClick = function(g) {
      var C = i.props.disabled;
      C || xn(i.props, "onClick", g, i.props);
    }, i;
  }
  var c = o.prototype;
  return c.render = function() {
    var d = this.props, m = d.active, v = d.children, g = d.className, C = d.content, O = d.description, R = d.disabled, I = d.header, L = d.icon, Z = d.image, ne = d.value, se = Xt(o, this.props), Q = Vt($e(m, "active"), $e(R, "disabled"), $e(se !== "li", "item"), g), he = zt(o, this.props), ue = se === "li" ? {
      value: ne
    } : {
      "data-value": ne
    };
    if (!dn(v))
      return /* @__PURE__ */ ae.createElement(se, Be({}, ue, {
        role: "listitem",
        className: Q,
        onClick: this.handleClick
      }, he), v);
    var G = C2.create(L, {
      autoGenerateKey: !1
    }), me = Qf.create(Z, {
      autoGenerateKey: !1
    });
    if (!/* @__PURE__ */ oae(C) && y2(C))
      return /* @__PURE__ */ ae.createElement(se, Be({}, ue, {
        role: "listitem",
        className: Q,
        onClick: this.handleClick
      }, he), G || me, GS.create(C, {
        autoGenerateKey: !1,
        defaultProps: {
          header: I,
          description: O
        }
      }));
    var we = qS.create(I, {
      autoGenerateKey: !1
    }), be = jS.create(O, {
      autoGenerateKey: !1
    });
    return G || me ? /* @__PURE__ */ ae.createElement(se, Be({}, ue, {
      role: "listitem",
      className: Q,
      onClick: this.handleClick
    }, he), G || me, (C || we || be) && /* @__PURE__ */ ae.createElement(GS, null, we, be, C)) : /* @__PURE__ */ ae.createElement(se, Be({}, ue, {
      role: "listitem",
      className: Q,
      onClick: this.handleClick
    }, he), we, be, C);
  }, o;
}(Do);
xB.handledProps = ["active", "as", "children", "className", "content", "description", "disabled", "header", "icon", "image", "onClick", "value"];
xB.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** A list item can active. */
  active: _.bool,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /**
   * Shorthand for primary content.
   *
   * Heads up!
   *
   * This is handled slightly differently than the typical `content` prop since
   * the wrapping ListContent is not used when there's no icon or image.
   *
   * If you pass content as:
   * - an element/literal, it's treated as the sibling node to
   * header/description (whether wrapped in Item.Content or not).
   * - a props object, it forces the presence of Item.Content and passes those
   * props to it. If you pass a content prop within that props object, it
   * will be treated as the sibling node to header/description.
   */
  content: Vn,
  /** Shorthand for ListDescription. */
  description: Vn,
  /** A list item can disabled. */
  disabled: _.bool,
  /** Shorthand for ListHeader. */
  header: Vn,
  /** Shorthand for ListIcon. */
  icon: co([Go(["image"]), Vn]),
  /** Shorthand for Image. */
  image: co([Go(["icon"]), Vn]),
  /** A ListItem can be clicked */
  onClick: _.func,
  /** A value for an ordered list. */
  value: _.string
} : {};
xB.create = lo(xB, function(r) {
  return {
    content: r
  };
});
const Nae = xB;
function p$(r) {
  var o = r.children, c = r.className, i = r.content, d = zt(p$, r), m = Xt(p$, r), v = Vt($e(m !== "ul" && m !== "ol", "list"), c);
  return /* @__PURE__ */ ae.createElement(m, Be({}, d, {
    className: v
  }), dn(o) ? i : o);
}
p$.handledProps = ["as", "children", "className", "content"];
p$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
var VC = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.handleItemOverrides = function(g) {
      return {
        onClick: function(O, R) {
          xn(g, "onClick", O, R), xn(i.props, "onItemClick", O, R);
        }
      };
    }, i;
  }
  var c = o.prototype;
  return c.render = function() {
    var d = this, m = this.props, v = m.animated, g = m.bulleted, C = m.celled, O = m.children, R = m.className, I = m.content, L = m.divided, Z = m.floated, ne = m.horizontal, se = m.inverted, Q = m.items, he = m.link, ue = m.ordered, G = m.relaxed, me = m.selection, we = m.size, be = m.verticalAlign, q = Vt("ui", we, $e(v, "animated"), $e(g, "bulleted"), $e(C, "celled"), $e(L, "divided"), $e(ne, "horizontal"), $e(se, "inverted"), $e(he, "link"), $e(ue, "ordered"), $e(me, "selection"), mi(G, "relaxed"), _u(Z, "floated"), by(be), "list", R), Te = zt(o, this.props), Le = Xt(o, this.props);
    return dn(O) ? dn(I) ? /* @__PURE__ */ ae.createElement(Le, Be({
      role: "list",
      className: q
    }, Te), fi(Q, function(je) {
      return Nae.create(je, {
        overrideProps: d.handleItemOverrides
      });
    })) : /* @__PURE__ */ ae.createElement(Le, Be({
      role: "list",
      className: q
    }, Te), I) : /* @__PURE__ */ ae.createElement(Le, Be({
      role: "list",
      className: q
    }, Te), O);
  }, o;
}(Do);
VC.handledProps = ["animated", "as", "bulleted", "celled", "children", "className", "content", "divided", "floated", "horizontal", "inverted", "items", "link", "onItemClick", "ordered", "relaxed", "selection", "size", "verticalAlign"];
VC.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** A list can animate to set the current item apart from the list. */
  animated: _.bool,
  /** A list can mark items with a bullet. */
  bulleted: _.bool,
  /** A list can divide its items into cells. */
  celled: _.bool,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** A list can show divisions between content. */
  divided: _.bool,
  /** An list can be floated left or right. */
  floated: _.oneOf(ew),
  /** A list can be formatted to have items appear horizontally. */
  horizontal: _.bool,
  /** A list can be inverted to appear on a dark background. */
  inverted: _.bool,
  /** Shorthand array of props for ListItem. */
  items: Dh,
  /** A list can be specially formatted for navigation links. */
  link: _.bool,
  /**
   * onClick handler for ListItem. Mutually exclusive with children.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All item props.
   */
  onItemClick: co([Go(["children"]), _.func]),
  /** A list can be ordered numerically. */
  ordered: _.bool,
  /** A list can relax its padding to provide more negative space. */
  relaxed: _.oneOfType([_.bool, _.oneOf(["very"])]),
  /** A selection list formats list items as possible choices. */
  selection: _.bool,
  /** A list can vary in size. */
  size: _.oneOf(mc),
  /** An element inside a list can be vertically aligned. */
  verticalAlign: _.oneOf(D1)
} : {};
VC.Content = GS;
VC.Description = jS;
VC.Header = qS;
VC.Icon = C2;
VC.Item = Nae;
VC.List = p$;
const Rae = VC;
function h$(r) {
  var o = r.active, c = r.children, i = r.className, d = r.content, m = r.disabled, v = r.indeterminate, g = r.inline, C = r.inverted, O = r.size, R = Vt("ui", O, $e(o, "active"), $e(m, "disabled"), $e(v, "indeterminate"), $e(C, "inverted"), $e(c || d, "text"), mi(g, "inline"), "loader", i), I = zt(h$, r), L = Xt(h$, r);
  return /* @__PURE__ */ ae.createElement(L, Be({}, I, {
    className: R
  }), dn(c) ? d : c);
}
h$.handledProps = ["active", "as", "children", "className", "content", "disabled", "indeterminate", "inline", "inverted", "size"];
h$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** A loader can be active or visible. */
  active: _.bool,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** A loader can be disabled or hidden. */
  disabled: _.bool,
  /** A loader can show it's unsure of how long a task will take. */
  indeterminate: _.bool,
  /** Loaders can appear inline with content. */
  inline: _.oneOfType([_.bool, _.oneOf(["centered"])]),
  /** Loaders can have their colors inverted. */
  inverted: _.bool,
  /** Loaders can have different sizes. */
  size: _.oneOf(mc)
} : {};
function g$(r) {
  var o = r.children, c = r.className, i = r.content, d = r.image, m = Vt($e(d, "image"), "header", c), v = zt(g$, r), g = Xt(g$, r);
  return /* @__PURE__ */ ae.createElement(g, Be({}, v, {
    className: m
  }), dn(o) ? i : o);
}
g$.handledProps = ["as", "children", "className", "content", "image"];
g$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** A placeholder can contain an image. */
  image: _.bool
} : {};
function v$(r) {
  var o = r.className, c = r.square, i = r.rectangular, d = Vt($e(c, "square"), $e(i, "rectangular"), "image", o), m = zt(v$, r), v = Xt(v$, r);
  return /* @__PURE__ */ ae.createElement(v, Be({}, m, {
    className: d
  }));
}
v$.handledProps = ["as", "className", "rectangular", "square"];
v$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Additional classes. */
  className: _.string,
  /** An image can modify size correctly with responsive styles. */
  square: co([Go(["rectangular"]), _.bool]),
  /** An image can modify size correctly with responsive styles. */
  rectangular: co([Go(["square"]), _.bool])
} : {};
function b$(r) {
  var o = r.className, c = r.length, i = Vt("line", c, o), d = zt(b$, r), m = Xt(b$, r);
  return /* @__PURE__ */ ae.createElement(m, Be({}, d, {
    className: i
  }));
}
b$.handledProps = ["as", "className", "length"];
b$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Additional classes. */
  className: _.string,
  /** A line can specify how long its contents should appear. */
  length: _.oneOf(["full", "very long", "long", "medium", "short", "very short"])
} : {};
function y$(r) {
  var o = r.children, c = r.className, i = r.content, d = Vt("paragraph", c), m = zt(y$, r), v = Xt(y$, r);
  return /* @__PURE__ */ ae.createElement(v, Be({}, m, {
    className: d
  }), dn(o) ? i : o);
}
y$.handledProps = ["as", "children", "className", "content"];
y$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
function SC(r) {
  var o = r.children, c = r.className, i = r.content, d = r.fluid, m = r.inverted, v = Vt("ui", $e(d, "fluid"), $e(m, "inverted"), "placeholder", c), g = zt(SC, r), C = Xt(SC, r);
  return /* @__PURE__ */ ae.createElement(C, Be({}, g, {
    className: v
  }), dn(o) ? i : o);
}
SC.handledProps = ["as", "children", "className", "content", "fluid", "inverted"];
SC.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** A fluid placeholder takes up the width of its container. */
  fluid: _.bool,
  /** A placeholder can have their colors inverted. */
  inverted: _.bool
} : {};
SC.Header = g$;
SC.Image = v$;
SC.Line = b$;
SC.Paragraph = y$;
function TB(r) {
  var o = r.attached, c = r.children, i = r.className, d = r.close, m = r.content, v = r.dividing, g = r.internal, C = r.position, O = r.size, R = Vt("ui", C, O, $e(o, "attached"), $e(v, "dividing"), $e(g, "internal"), mi(d, "close"), "rail", i), I = zt(TB, r), L = Xt(TB, r);
  return /* @__PURE__ */ ae.createElement(L, Be({}, I, {
    className: R
  }), dn(c) ? m : c);
}
TB.handledProps = ["as", "attached", "children", "className", "close", "content", "dividing", "internal", "position", "size"];
TB.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** A rail can appear attached to the main viewport. */
  attached: _.bool,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** A rail can appear closer to the main viewport. */
  close: _.oneOfType([_.bool, _.oneOf(["very"])]),
  /** Shorthand for primary content. */
  content: In,
  /** A rail can create a division between itself and a container. */
  dividing: _.bool,
  /** A rail can attach itself to the inside of a container. */
  internal: _.bool,
  /** A rail can be presented on the left or right side of a container. */
  position: _.oneOf(ew).isRequired,
  /** A rail can have different sizes. */
  size: _.oneOf(pi(mc, "medium"))
} : {};
function S$(r) {
  var o = r.children, c = r.className, i = r.content, d = r.hidden, m = r.visible, v = Vt("ui", $e(d, "hidden"), $e(m, "visible"), "content", c), g = zt(S$, r), C = Xt(S$, r);
  return /* @__PURE__ */ ae.createElement(C, Be({}, g, {
    className: v
  }), dn(o) ? i : o);
}
S$.handledProps = ["as", "children", "className", "content", "hidden", "visible"];
S$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** A reveal may contain content that is visible before interaction. */
  hidden: _.bool,
  /** A reveal may contain content that is hidden before user interaction. */
  visible: _.bool
} : {};
function w$(r) {
  var o = r.active, c = r.animated, i = r.children, d = r.className, m = r.content, v = r.disabled, g = r.instant, C = Vt("ui", c, $e(o, "active"), $e(v, "disabled"), $e(g, "instant"), "reveal", d), O = zt(w$, r), R = Xt(w$, r);
  return /* @__PURE__ */ ae.createElement(R, Be({}, O, {
    className: C
  }), dn(i) ? m : i);
}
w$.handledProps = ["active", "animated", "as", "children", "className", "content", "disabled", "instant"];
w$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** An active reveal displays its hidden content. */
  active: _.bool,
  /** An animation name that will be applied to Reveal. */
  animated: _.oneOf(["fade", "small fade", "move", "move right", "move up", "move down", "rotate", "rotate left"]),
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** A disabled reveal will not animate when hovered. */
  disabled: _.bool,
  /** An element can show its content without delay. */
  instant: _.bool
} : {};
w$.Content = S$;
function E$(r) {
  var o = r.children, c = r.className, i = r.compact, d = r.content, m = r.horizontal, v = r.piled, g = r.raised, C = r.size, O = r.stacked, R = Vt("ui", C, $e(i, "compact"), $e(m, "horizontal"), $e(v, "piled"), $e(g, "raised"), $e(O, "stacked"), "segments", c), I = zt(E$, r), L = Xt(E$, r);
  return /* @__PURE__ */ ae.createElement(L, Be({}, I, {
    className: R
  }), dn(o) ? d : o);
}
E$.handledProps = ["as", "children", "className", "compact", "content", "horizontal", "piled", "raised", "size", "stacked"];
E$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** A segment may take up only as much space as is necessary. */
  compact: _.bool,
  /** Shorthand for primary content. */
  content: In,
  /** Formats content to be aligned horizontally. */
  horizontal: _.bool,
  /** Formatted to look like a pile of pages. */
  piled: _.bool,
  /** A segment group may be formatted to raise above the page. */
  raised: _.bool,
  /** A segment group can have different sizes. */
  size: _.oneOf(pi(mc, "medium")),
  /** Formatted to show it contains multiple pages. */
  stacked: _.bool
} : {};
function C$(r) {
  var o = r.children, c = r.className, i = r.content, d = Vt("inline", c), m = zt(C$, r), v = Xt(C$, r);
  return /* @__PURE__ */ ae.createElement(v, Be({}, m, {
    className: d
  }), dn(o) ? i : o);
}
C$.handledProps = ["as", "children", "className", "content"];
C$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
function ZS(r) {
  var o = r.attached, c = r.basic, i = r.children, d = r.circular, m = r.className, v = r.clearing, g = r.color, C = r.compact, O = r.content, R = r.disabled, I = r.floated, L = r.inverted, Z = r.loading, ne = r.placeholder, se = r.padded, Q = r.piled, he = r.raised, ue = r.secondary, G = r.size, me = r.stacked, we = r.tertiary, be = r.textAlign, q = r.vertical, Te = Vt("ui", g, G, $e(c, "basic"), $e(d, "circular"), $e(v, "clearing"), $e(C, "compact"), $e(R, "disabled"), $e(L, "inverted"), $e(Z, "loading"), $e(ne, "placeholder"), $e(Q, "piled"), $e(he, "raised"), $e(ue, "secondary"), $e(me, "stacked"), $e(we, "tertiary"), $e(q, "vertical"), mi(o, "attached"), mi(se, "padded"), Dg(be), _u(I, "floated"), "segment", m), Le = zt(ZS, r), je = Xt(ZS, r);
  return /* @__PURE__ */ ae.createElement(je, Be({}, Le, {
    className: Te
  }), dn(i) ? O : i);
}
ZS.handledProps = ["as", "attached", "basic", "children", "circular", "className", "clearing", "color", "compact", "content", "disabled", "floated", "inverted", "loading", "padded", "piled", "placeholder", "raised", "secondary", "size", "stacked", "tertiary", "textAlign", "vertical"];
ZS.Group = E$;
ZS.Inline = C$;
ZS.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Attach segment to other content, like a header. */
  attached: _.oneOfType([_.bool, _.oneOf(["top", "bottom"])]),
  /** A basic segment has no special formatting. */
  basic: _.bool,
  /** Primary content. */
  children: _.node,
  /** A segment can be circular. */
  circular: _.bool,
  /** Additional classes. */
  className: _.string,
  /** A segment can clear floated content. */
  clearing: _.bool,
  /** Segment can be colored. */
  color: _.oneOf(Om),
  /** A segment may take up only as much space as is necessary. */
  compact: _.bool,
  /** Shorthand for primary content. */
  content: In,
  /** A segment may show its content is disabled. */
  disabled: _.bool,
  /** Segment content can be floated to the left or right. */
  floated: _.oneOf(ew),
  /** A segment can have its colors inverted for contrast. */
  inverted: _.bool,
  /** A segment may show its content is being loaded. */
  loading: _.bool,
  /** A segment can increase its padding. */
  padded: _.oneOfType([_.bool, _.oneOf(["very"])]),
  /** A segment can be used to reserve space for conditionally displayed content. */
  placeholder: _.bool,
  /** Formatted to look like a pile of pages. */
  piled: _.bool,
  /** A segment may be formatted to raise above the page. */
  raised: _.bool,
  /** A segment can be formatted to appear less noticeable. */
  secondary: _.bool,
  /** A segment can have different sizes. */
  size: _.oneOf(pi(mc, "medium")),
  /** Formatted to show it contains multiple pages. */
  stacked: _.bool,
  /** A segment can be formatted to appear even less noticeable. */
  tertiary: _.bool,
  /** Formats content to be aligned as part of a vertical group. */
  textAlign: _.oneOf(pi($g, "justified")),
  /** Formats content to be aligned vertically. */
  vertical: _.bool
} : {};
function wC(r) {
  var o = r.children, c = r.className, i = r.content, d = Vt("description", c), m = zt(wC, r), v = Xt(wC, r);
  return /* @__PURE__ */ ae.createElement(v, Be({}, m, {
    className: d
  }), dn(o) ? i : o);
}
wC.handledProps = ["as", "children", "className", "content"];
wC.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
wC.create = lo(wC, function(r) {
  return {
    content: r
  };
});
function EC(r) {
  var o = r.children, c = r.className, i = r.content, d = Vt("title", c), m = zt(EC, r), v = Xt(EC, r);
  return /* @__PURE__ */ ae.createElement(v, Be({}, m, {
    className: d
  }), dn(o) ? i : o);
}
EC.handledProps = ["as", "children", "className", "content"];
EC.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
EC.create = lo(EC, function(r) {
  return {
    content: r
  };
});
function CC(r) {
  var o = r.children, c = r.className, i = r.content, d = r.description, m = r.title, v = Vt("content", c), g = zt(CC, r), C = Xt(CC, r);
  return dn(o) ? dn(i) ? /* @__PURE__ */ ae.createElement(C, Be({}, g, {
    className: v
  }), EC.create(m, {
    autoGenerateKey: !1
  }), wC.create(d, {
    autoGenerateKey: !1
  })) : /* @__PURE__ */ ae.createElement(C, Be({}, g, {
    className: v
  }), i) : /* @__PURE__ */ ae.createElement(C, Be({}, g, {
    className: v
  }), o);
}
CC.handledProps = ["as", "children", "className", "content", "description", "title"];
CC.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** Shorthand for StepDescription. */
  description: Vn,
  /** Shorthand for StepTitle. */
  title: Vn
} : {};
CC.create = lo(CC, function(r) {
  return {
    content: r
  };
});
var uOe = Object.getOwnPropertySymbols, dOe = uOe ? function(r) {
  for (var o = []; r; )
    pae(o, hae(r)), r = Sae(r);
  return o;
} : zpe;
const Uhe = dOe;
function fOe(r) {
  var o = [];
  if (r != null)
    for (var c in Object(r))
      o.push(c);
  return o;
}
var mOe = Object.prototype, pOe = mOe.hasOwnProperty;
function hOe(r) {
  if (!Fv(r))
    return fOe(r);
  var o = gj(r), c = [];
  for (var i in r)
    i == "constructor" && (o || !pOe.call(r, i)) || c.push(i);
  return c;
}
function Pae(r) {
  return JS(r) ? Mpe(r, !0) : hOe(r);
}
function Whe(r) {
  return Hpe(r, Pae, Uhe);
}
function gOe(r, o) {
  if (r == null)
    return {};
  var c = E1(Whe(r), function(i) {
    return [i];
  });
  return o = R1(o), ohe(r, c, function(i, d) {
    return o(i, d[0]);
  });
}
var ooe = process.env.NODE_ENV !== "production" ? gOe(tB, function(r, o) {
  return o <= 8;
}) : {};
function x$(r) {
  var o = r.attached, c = r.children, i = r.className, d = r.content, m = r.fluid, v = r.items, g = r.ordered, C = r.size, O = r.stackable, R = r.unstackable, I = r.vertical, L = r.widths, Z = Vt("ui", C, $e(m, "fluid"), $e(g, "ordered"), $e(R, "unstackable"), $e(I, "vertical"), mi(o, "attached"), _u(O, "stackable"), Kf(L), "steps", i), ne = zt(x$, r), se = Xt(x$, r);
  return dn(c) ? dn(d) ? /* @__PURE__ */ ae.createElement(se, Be({}, ne, {
    className: Z
  }), fi(v, function(Q) {
    return jhe.create(Q);
  })) : /* @__PURE__ */ ae.createElement(se, Be({}, ne, {
    className: Z
  }), d) : /* @__PURE__ */ ae.createElement(se, Be({}, ne, {
    className: Z
  }), c);
}
x$.handledProps = ["as", "attached", "children", "className", "content", "fluid", "items", "ordered", "size", "stackable", "unstackable", "vertical", "widths"];
x$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Steps can be attached to other elements. */
  attached: _.oneOfType([_.bool, _.oneOf(["top", "bottom"])]),
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** A fluid step takes up the width of its container. */
  fluid: _.bool,
  /** Shorthand array of props for Step. */
  items: Dh,
  /** A step can show a ordered sequence of steps. */
  ordered: _.bool,
  /** Steps can have different sizes. */
  size: _.oneOf(pi(mc, "medium")),
  /** A step can stack vertically only on smaller screens. */
  stackable: _.oneOf(["tablet"]),
  /** A step can prevent itself from stacking on mobile. */
  unstackable: _.bool,
  /** A step can be displayed stacked vertically. */
  vertical: _.bool,
  /** Steps can be divided evenly inside their parent. */
  widths: _.oneOf([].concat(Yf(ooe), Yf(ooe).map(Number), xj(ooe)))
} : {};
var xC = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.computeElementType = function() {
      var g = i.props.onClick;
      if (g)
        return "a";
    }, i.handleClick = function(g) {
      var C = i.props.disabled;
      C || xn(i.props, "onClick", g, i.props);
    }, i;
  }
  var c = o.prototype;
  return c.render = function() {
    var d = this.props, m = d.active, v = d.children, g = d.className, C = d.completed, O = d.content, R = d.description, I = d.disabled, L = d.href, Z = d.icon, ne = d.link, se = d.title, Q = Vt($e(m, "active"), $e(C, "completed"), $e(I, "disabled"), $e(ne, "link"), "step", g), he = zt(o, this.props), ue = Xt(o, this.props, this.computeElementType);
    return dn(v) ? dn(O) ? /* @__PURE__ */ ae.createElement(ue, Be({}, he, {
      className: Q,
      href: L,
      onClick: this.handleClick
    }), fc.create(Z, {
      autoGenerateKey: !1
    }), CC.create({
      description: R,
      title: se
    }, {
      autoGenerateKey: !1
    })) : /* @__PURE__ */ ae.createElement(ue, Be({}, he, {
      className: Q,
      href: L,
      onClick: this.handleClick
    }), O) : /* @__PURE__ */ ae.createElement(ue, Be({}, he, {
      className: Q,
      href: L,
      onClick: this.handleClick
    }), v);
  }, o;
}(Do);
xC.handledProps = ["active", "as", "children", "className", "completed", "content", "description", "disabled", "href", "icon", "link", "onClick", "ordered", "title"];
xC.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** A step can be highlighted as active. */
  active: _.bool,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** A step can show that a user has completed it. */
  completed: _.bool,
  /** Shorthand for primary content. */
  content: In,
  /** Shorthand for StepDescription. */
  description: Vn,
  /** Show that the Loader is inactive. */
  disabled: _.bool,
  /** Render as an `a` tag instead of a `div` and adds the href attribute. */
  href: _.string,
  /** Shorthand for Icon. */
  icon: Vn,
  /** A step can be link. */
  link: _.bool,
  /**
   * Called on click. When passed, the component will render as an `a`
   * tag by default instead of a `div`.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onClick: _.func,
  /** A step can show a ordered sequence of steps. Passed from StepGroup. */
  ordered: _.bool,
  /** Shorthand for StepTitle. */
  title: Vn
} : {};
xC.Content = CC;
xC.Description = wC;
xC.Group = x$;
xC.Title = EC;
xC.create = lo(xC, function(r) {
  return {
    content: r
  };
});
const jhe = xC;
var lk = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.handleClick = function(g) {
      return xn(i.props, "onClick", g, i.props);
    }, i;
  }
  var c = o.prototype;
  return c.render = function() {
    var d = this.props, m = d.active, v = d.children, g = d.className, C = d.content, O = d.icon, R = Vt($e(m, "active"), "title", g), I = zt(o, this.props), L = Xt(o, this.props), Z = ws(O) ? "dropdown" : O;
    return dn(v) ? /* @__PURE__ */ ae.createElement(L, Be({}, I, {
      className: R,
      onClick: this.handleClick
    }), fc.create(Z, {
      autoGenerateKey: !1
    }), C) : /* @__PURE__ */ ae.createElement(L, Be({}, I, {
      className: R,
      onClick: this.handleClick
    }), v);
  }, o;
}(Do);
lk.handledProps = ["active", "as", "children", "className", "content", "icon", "index", "onClick"];
lk.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Whether or not the title is in the open state. */
  active: _.bool,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** Shorthand for Icon. */
  icon: Vn,
  /** AccordionTitle index inside Accordion. */
  index: _.oneOfType([_.string, _.number]),
  /**
   * Called on click.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onClick: _.func
} : {};
lk.create = lo(lk, function(r) {
  return {
    content: r
  };
});
function TC(r) {
  var o = r.active, c = r.children, i = r.className, d = r.content, m = Vt("content", $e(o, "active"), i), v = zt(TC, r), g = Xt(TC, r);
  return /* @__PURE__ */ ae.createElement(g, Be({}, v, {
    className: m
  }), dn(c) ? d : c);
}
TC.handledProps = ["active", "as", "children", "className", "content"];
TC.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Whether or not the content is visible. */
  active: _.bool,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
TC.create = lo(TC, function(r) {
  return {
    content: r
  };
});
var _B = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.handleTitleOverrides = function(g) {
      return {
        onClick: function(O, R) {
          xn(g, "onClick", O, R), xn(i.props, "onTitleClick", O, R);
        }
      };
    }, i;
  }
  var c = o.prototype;
  return c.render = function() {
    var d = this.props, m = d.active, v = d.content, g = d.index, C = d.title;
    return /* @__PURE__ */ ae.createElement(ae.Fragment, null, lk.create(C, {
      autoGenerateKey: !1,
      defaultProps: {
        active: m,
        index: g
      },
      overrideProps: this.handleTitleOverrides
    }), TC.create(v, {
      autoGenerateKey: !1,
      defaultProps: {
        active: m
      }
    }));
  }, o;
}(Do);
_B.handledProps = ["active", "content", "index", "onTitleClick", "title"];
_B.propTypes = process.env.NODE_ENV !== "production" ? {
  /** Whether or not the title is in the open state. */
  active: _.bool,
  /** A shorthand for Accordion.Content. */
  content: Vn,
  /** A panel index. */
  index: _.oneOfType([_.number, _.string]),
  /**
   * Called when a panel title is clicked.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All item props.
   */
  onTitleClick: _.func,
  /** A shorthand for Accordion.Title. */
  title: Vn
} : {};
_B.create = lo(_B, null);
const Dae = _B;
var Que = function(o, c) {
  var i = o.exclusive, d = c.activeIndex;
  i && typeof d != "number" ? console.error("`activeIndex` must be a number if `exclusive` is true") : !i && !qc(d) && console.error("`activeIndex` must be an array if `exclusive` is false");
}, _C = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.computeNewIndex = function(g) {
      var C = i.props.exclusive, O = i.state.activeIndex;
      return C ? g === O ? -1 : g : Og(O, g) ? pi(O, g) : [].concat(O, [g]);
    }, i.handleTitleClick = function(g, C) {
      var O = C.index;
      i.setState({
        activeIndex: i.computeNewIndex(O)
      }), xn(i.props, "onTitleClick", g, C);
    }, i.isIndexActive = function(g) {
      var C = i.props.exclusive, O = i.state.activeIndex;
      return C ? O === g : Og(O, g);
    }, i;
  }
  var c = o.prototype;
  return c.getInitialAutoControlledState = function(d) {
    var m = d.exclusive;
    return {
      activeIndex: m ? -1 : []
    };
  }, c.componentDidMount = function() {
    process.env.NODE_ENV !== "production" && Que(this.props, this.state);
  }, c.componentDidUpdate = function() {
    process.env.NODE_ENV !== "production" && Que(this.props, this.state);
  }, c.render = function() {
    var d = this, m = this.props, v = m.className, g = m.children, C = m.panels, O = Vt("accordion", v), R = zt(o, this.props), I = Xt(o, this.props);
    return /* @__PURE__ */ ae.createElement(I, Be({}, R, {
      className: O
    }), dn(g) ? fi(C, function(L, Z) {
      return Dae.create(L, {
        defaultProps: {
          active: d.isIndexActive(Z),
          index: Z,
          onTitleClick: d.handleTitleClick
        }
      });
    }) : g);
  }, o;
}(P1);
_C.handledProps = ["activeIndex", "as", "children", "className", "defaultActiveIndex", "exclusive", "onTitleClick", "panels"];
_C.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Index of the currently active panel. */
  activeIndex: co([Go(["children"]), _.oneOfType([_.arrayOf(_.number), _.number])]),
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Initial activeIndex value. */
  defaultActiveIndex: co([Go(["children"]), _.oneOfType([_.arrayOf(_.number), _.number])]),
  /** Only allow one panel open at a time. */
  exclusive: _.bool,
  /**
   * Called when a panel title is clicked.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All item props.
   */
  onTitleClick: co([Go(["children"]), _.func]),
  /** Shorthand array of props for Accordion. */
  panels: co([Go(["children"]), _.arrayOf(_.shape({
    content: Vn,
    title: Vn
  }))])
} : {};
_C.defaultProps = {
  exclusive: !0
};
_C.autoControlledProps = ["activeIndex"];
_C.create = lo(_C, function(r) {
  return {
    content: r
  };
});
function R2(r) {
  var o = r.className, c = r.fluid, i = r.inverted, d = r.styled, m = Vt("ui", $e(c, "fluid"), $e(i, "inverted"), $e(d, "styled"), o), v = zt(R2, r);
  return /* @__PURE__ */ ae.createElement(_C, Be({}, v, {
    className: m
  }));
}
R2.handledProps = ["className", "fluid", "inverted", "styled"];
R2.propTypes = process.env.NODE_ENV !== "production" ? {
  /** Additional classes. */
  className: _.string,
  /** Format to take up the width of its container. */
  fluid: _.bool,
  /** Format for dark backgrounds. */
  inverted: _.bool,
  /** Adds some basic styling to accordion panels. */
  styled: _.bool
} : {};
R2.Accordion = _C;
R2.Content = TC;
R2.Panel = Dae;
R2.Title = lk;
var Pj = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.handleClick = function(g) {
      var C = i.props.onClick, O = i.state.active;
      C && C(g, Be({}, i.props, {
        active: !0
      })), O || i.setState({
        active: !0
      });
    }, i;
  }
  var c = o.prototype;
  return c.getSrc = function() {
    var d = this.props, m = d.autoplay, v = m === void 0 ? !0 : m, g = d.brandedUI, C = g === void 0 ? !1 : g, O = d.color, R = O === void 0 ? "#444444" : O, I = d.hd, L = I === void 0 ? !0 : I, Z = d.id, ne = d.source, se = d.url;
    return ne === "youtube" ? ["//www.youtube.com/embed/" + Z, "?autohide=true", "&amp;autoplay=" + v, "&amp;color=" + encodeURIComponent(R), "&amp;hq=" + L, "&amp;jsapi=false", "&amp;modestbranding=" + C, "&amp;rel=" + (C ? 0 : 1)].join("") : ne === "vimeo" ? ["//player.vimeo.com/video/" + Z, "?api=false", "&amp;autoplay=" + v, "&amp;byline=false", "&amp;color=" + encodeURIComponent(R), "&amp;portrait=false", "&amp;title=false"].join("") : se;
  }, c.render = function() {
    var d = this.props, m = d.aspectRatio, v = d.className, g = d.icon, C = d.placeholder, O = this.state.active, R = Vt("ui", m, $e(O, "active"), "embed", v), I = zt(o, this.props), L = Xt(o, this.props), Z = g !== void 0 ? g : "video play";
    return /* @__PURE__ */ ae.createElement(L, Be({}, I, {
      className: R,
      onClick: this.handleClick
    }), fc.create(Z, {
      autoGenerateKey: !1
    }), C && /* @__PURE__ */ ae.createElement("img", {
      className: "placeholder",
      src: C
    }), this.renderEmbed());
  }, c.renderEmbed = function() {
    var d = this.props, m = d.children, v = d.content, g = d.iframe, C = d.source, O = this.state.active;
    return O ? dn(m) ? dn(v) ? /* @__PURE__ */ ae.createElement("div", {
      className: "embed"
    }, qxe(dn(g) ? this.getSrc() : g, {
      defaultProps: {
        allowFullScreen: !1,
        frameBorder: 0,
        height: "100%",
        scrolling: "no",
        src: this.getSrc(),
        title: "Embedded content from " + C + ".",
        width: "100%"
      },
      autoGenerateKey: !1
    })) : /* @__PURE__ */ ae.createElement("div", {
      className: "embed"
    }, v) : /* @__PURE__ */ ae.createElement("div", {
      className: "embed"
    }, m) : null;
  }, o;
}(P1);
Pj.handledProps = ["active", "as", "aspectRatio", "autoplay", "brandedUI", "children", "className", "color", "content", "defaultActive", "hd", "icon", "id", "iframe", "onClick", "placeholder", "source", "url"];
Pj.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** An embed can be active. */
  active: _.bool,
  /** An embed can specify an alternative aspect ratio. */
  aspectRatio: _.oneOf(["4:3", "16:9", "21:9"]),
  /** Setting to true or false will force autoplay. */
  autoplay: co([_h(["source"]), _.bool]),
  /** Whether to show networks branded UI like title cards, or after video calls to action. */
  brandedUI: co([_h(["source"]), _.bool]),
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Specifies a default chrome color with Vimeo or YouTube. */
  color: co([_h(["source"]), _.string]),
  /** Shorthand for primary content. */
  content: In,
  /** Initial value of active. */
  defaultActive: _.bool,
  /** Whether to prefer HD content. */
  hd: co([_h(["source"]), _.bool]),
  /** Specifies an icon to use with placeholder content. */
  icon: Vn,
  /** Specifies an id for source. */
  id: co([_h(["source"]), _.string]),
  /** Shorthand for HTML iframe. */
  iframe: co([_h(["source"]), Vn]),
  /**
   * Called on click.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props and proposed value.
   */
  onClick: _.func,
  /** A placeholder image for embed. */
  placeholder: _.string,
  /** Specifies a source to use. */
  source: co([Go(["sourceUrl"]), _.oneOf(["youtube", "vimeo"])]),
  /** Specifies a url to use for embed. */
  url: co([Go(["source"]), _.string])
} : {};
Pj.autoControlledProps = ["active"];
function vOe(r) {
  return Nh(r) && r.nodeType === 1 && !y2(r);
}
var bOe = Ya.createContext();
Ya.createContext();
var yOe = function(o) {
  return Array.isArray(o) ? o[0] : o;
}, SOe = function(o) {
  if (typeof o == "function") {
    for (var c = arguments.length, i = new Array(c > 1 ? c - 1 : 0), d = 1; d < c; d++)
      i[d - 1] = arguments[d];
    return o.apply(void 0, i);
  }
}, wOe = function(o, c) {
  if (typeof o == "function")
    return SOe(o, c);
  o != null && (o.current = c);
}, Xue = function(o) {
  return o.reduce(function(c, i) {
    var d = i[0], m = i[1];
    return c[d] = m, c;
  }, {});
}, Jue = typeof window < "u" && window.document && window.document.createElement ? Ya.useLayoutEffect : Ya.useEffect, kg = "top", gy = "bottom", vy = "right", Ng = "left", $ae = "auto", jB = [kg, gy, vy, Ng], T$ = "start", OB = "end", EOe = "clippingParents", qhe = "viewport", BL = "popper", COe = "reference", ede = /* @__PURE__ */ jB.reduce(function(r, o) {
  return r.concat([o + "-" + T$, o + "-" + OB]);
}, []), Ghe = /* @__PURE__ */ [].concat(jB, [$ae]).reduce(function(r, o) {
  return r.concat([o, o + "-" + T$, o + "-" + OB]);
}, []), xOe = "beforeRead", TOe = "read", _Oe = "afterRead", OOe = "beforeMain", AOe = "main", kOe = "afterMain", NOe = "beforeWrite", ROe = "write", POe = "afterWrite", DOe = [xOe, TOe, _Oe, OOe, AOe, kOe, NOe, ROe, POe];
function KS(r) {
  return r ? (r.nodeName || "").toLowerCase() : null;
}
function Bv(r) {
  if (r == null)
    return window;
  if (r.toString() !== "[object Window]") {
    var o = r.ownerDocument;
    return o && o.defaultView || window;
  }
  return r;
}
function uk(r) {
  var o = Bv(r).Element;
  return r instanceof o || r instanceof Element;
}
function my(r) {
  var o = Bv(r).HTMLElement;
  return r instanceof o || r instanceof HTMLElement;
}
function Iae(r) {
  if (typeof ShadowRoot > "u")
    return !1;
  var o = Bv(r).ShadowRoot;
  return r instanceof o || r instanceof ShadowRoot;
}
function $Oe(r) {
  var o = r.state;
  Object.keys(o.elements).forEach(function(c) {
    var i = o.styles[c] || {}, d = o.attributes[c] || {}, m = o.elements[c];
    !my(m) || !KS(m) || (Object.assign(m.style, i), Object.keys(d).forEach(function(v) {
      var g = d[v];
      g === !1 ? m.removeAttribute(v) : m.setAttribute(v, g === !0 ? "" : g);
    }));
  });
}
function IOe(r) {
  var o = r.state, c = {
    popper: {
      position: o.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(o.elements.popper.style, c.popper), o.styles = c, o.elements.arrow && Object.assign(o.elements.arrow.style, c.arrow), function() {
    Object.keys(o.elements).forEach(function(i) {
      var d = o.elements[i], m = o.attributes[i] || {}, v = Object.keys(o.styles.hasOwnProperty(i) ? o.styles[i] : c[i]), g = v.reduce(function(C, O) {
        return C[O] = "", C;
      }, {});
      !my(d) || !KS(d) || (Object.assign(d.style, g), Object.keys(m).forEach(function(C) {
        d.removeAttribute(C);
      }));
    });
  };
}
const MOe = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: $Oe,
  effect: IOe,
  requires: ["computeStyles"]
};
function FS(r) {
  return r.split("-")[0];
}
var VA = Math.max, $W = Math.min, _$ = Math.round;
function bse() {
  var r = navigator.userAgentData;
  return r != null && r.brands && Array.isArray(r.brands) ? r.brands.map(function(o) {
    return o.brand + "/" + o.version;
  }).join(" ") : navigator.userAgent;
}
function Zhe() {
  return !/^((?!chrome|android).)*safari/i.test(bse());
}
function O$(r, o, c) {
  o === void 0 && (o = !1), c === void 0 && (c = !1);
  var i = r.getBoundingClientRect(), d = 1, m = 1;
  o && my(r) && (d = r.offsetWidth > 0 && _$(i.width) / r.offsetWidth || 1, m = r.offsetHeight > 0 && _$(i.height) / r.offsetHeight || 1);
  var v = uk(r) ? Bv(r) : window, g = v.visualViewport, C = !Zhe() && c, O = (i.left + (C && g ? g.offsetLeft : 0)) / d, R = (i.top + (C && g ? g.offsetTop : 0)) / m, I = i.width / d, L = i.height / m;
  return {
    width: I,
    height: L,
    top: R,
    right: O + I,
    bottom: R + L,
    left: O,
    x: O,
    y: R
  };
}
function Mae(r) {
  var o = O$(r), c = r.offsetWidth, i = r.offsetHeight;
  return Math.abs(o.width - c) <= 1 && (c = o.width), Math.abs(o.height - i) <= 1 && (i = o.height), {
    x: r.offsetLeft,
    y: r.offsetTop,
    width: c,
    height: i
  };
}
function Khe(r, o) {
  var c = o.getRootNode && o.getRootNode();
  if (r.contains(o))
    return !0;
  if (c && Iae(c)) {
    var i = o;
    do {
      if (i && r.isSameNode(i))
        return !0;
      i = i.parentNode || i.host;
    } while (i);
  }
  return !1;
}
function OC(r) {
  return Bv(r).getComputedStyle(r);
}
function FOe(r) {
  return ["table", "td", "th"].indexOf(KS(r)) >= 0;
}
function P2(r) {
  return ((uk(r) ? r.ownerDocument : (
    // $FlowFixMe[prop-missing]
    r.document
  )) || window.document).documentElement;
}
function Dj(r) {
  return KS(r) === "html" ? r : (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    r.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    r.parentNode || // DOM Element detected
    (Iae(r) ? r.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    P2(r)
  );
}
function tde(r) {
  return !my(r) || // https://github.com/popperjs/popper-core/issues/837
  OC(r).position === "fixed" ? null : r.offsetParent;
}
function LOe(r) {
  var o = /firefox/i.test(bse()), c = /Trident/i.test(bse());
  if (c && my(r)) {
    var i = OC(r);
    if (i.position === "fixed")
      return null;
  }
  var d = Dj(r);
  for (Iae(d) && (d = d.host); my(d) && ["html", "body"].indexOf(KS(d)) < 0; ) {
    var m = OC(d);
    if (m.transform !== "none" || m.perspective !== "none" || m.contain === "paint" || ["transform", "perspective"].indexOf(m.willChange) !== -1 || o && m.willChange === "filter" || o && m.filter && m.filter !== "none")
      return d;
    d = d.parentNode;
  }
  return null;
}
function qB(r) {
  for (var o = Bv(r), c = tde(r); c && FOe(c) && OC(c).position === "static"; )
    c = tde(c);
  return c && (KS(c) === "html" || KS(c) === "body" && OC(c).position === "static") ? o : c || LOe(r) || o;
}
function Fae(r) {
  return ["top", "bottom"].indexOf(r) >= 0 ? "x" : "y";
}
function nB(r, o, c) {
  return VA(r, $W(o, c));
}
function BOe(r, o, c) {
  var i = nB(r, o, c);
  return i > c ? c : i;
}
function Yhe() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function Qhe(r) {
  return Object.assign({}, Yhe(), r);
}
function Xhe(r, o) {
  return o.reduce(function(c, i) {
    return c[i] = r, c;
  }, {});
}
var HOe = function(o, c) {
  return o = typeof o == "function" ? o(Object.assign({}, c.rects, {
    placement: c.placement
  })) : o, Qhe(typeof o != "number" ? o : Xhe(o, jB));
};
function zOe(r) {
  var o, c = r.state, i = r.name, d = r.options, m = c.elements.arrow, v = c.modifiersData.popperOffsets, g = FS(c.placement), C = Fae(g), O = [Ng, vy].indexOf(g) >= 0, R = O ? "height" : "width";
  if (!(!m || !v)) {
    var I = HOe(d.padding, c), L = Mae(m), Z = C === "y" ? kg : Ng, ne = C === "y" ? gy : vy, se = c.rects.reference[R] + c.rects.reference[C] - v[C] - c.rects.popper[R], Q = v[C] - c.rects.reference[C], he = qB(m), ue = he ? C === "y" ? he.clientHeight || 0 : he.clientWidth || 0 : 0, G = se / 2 - Q / 2, me = I[Z], we = ue - L[R] - I[ne], be = ue / 2 - L[R] / 2 + G, q = nB(me, be, we), Te = C;
    c.modifiersData[i] = (o = {}, o[Te] = q, o.centerOffset = q - be, o);
  }
}
function VOe(r) {
  var o = r.state, c = r.options, i = c.element, d = i === void 0 ? "[data-popper-arrow]" : i;
  d != null && (typeof d == "string" && (d = o.elements.popper.querySelector(d), !d) || Khe(o.elements.popper, d) && (o.elements.arrow = d));
}
const UOe = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: zOe,
  effect: VOe,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function A$(r) {
  return r.split("-")[1];
}
var WOe = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function jOe(r, o) {
  var c = r.x, i = r.y, d = o.devicePixelRatio || 1;
  return {
    x: _$(c * d) / d || 0,
    y: _$(i * d) / d || 0
  };
}
function nde(r) {
  var o, c = r.popper, i = r.popperRect, d = r.placement, m = r.variation, v = r.offsets, g = r.position, C = r.gpuAcceleration, O = r.adaptive, R = r.roundOffsets, I = r.isFixed, L = v.x, Z = L === void 0 ? 0 : L, ne = v.y, se = ne === void 0 ? 0 : ne, Q = typeof R == "function" ? R({
    x: Z,
    y: se
  }) : {
    x: Z,
    y: se
  };
  Z = Q.x, se = Q.y;
  var he = v.hasOwnProperty("x"), ue = v.hasOwnProperty("y"), G = Ng, me = kg, we = window;
  if (O) {
    var be = qB(c), q = "clientHeight", Te = "clientWidth";
    if (be === Bv(c) && (be = P2(c), OC(be).position !== "static" && g === "absolute" && (q = "scrollHeight", Te = "scrollWidth")), be = be, d === kg || (d === Ng || d === vy) && m === OB) {
      me = gy;
      var Le = I && be === we && we.visualViewport ? we.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        be[q]
      );
      se -= Le - i.height, se *= C ? 1 : -1;
    }
    if (d === Ng || (d === kg || d === gy) && m === OB) {
      G = vy;
      var je = I && be === we && we.visualViewport ? we.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        be[Te]
      );
      Z -= je - i.width, Z *= C ? 1 : -1;
    }
  }
  var Ie = Object.assign({
    position: g
  }, O && WOe), Ce = R === !0 ? jOe({
    x: Z,
    y: se
  }, Bv(c)) : {
    x: Z,
    y: se
  };
  if (Z = Ce.x, se = Ce.y, C) {
    var pt;
    return Object.assign({}, Ie, (pt = {}, pt[me] = ue ? "0" : "", pt[G] = he ? "0" : "", pt.transform = (we.devicePixelRatio || 1) <= 1 ? "translate(" + Z + "px, " + se + "px)" : "translate3d(" + Z + "px, " + se + "px, 0)", pt));
  }
  return Object.assign({}, Ie, (o = {}, o[me] = ue ? se + "px" : "", o[G] = he ? Z + "px" : "", o.transform = "", o));
}
function qOe(r) {
  var o = r.state, c = r.options, i = c.gpuAcceleration, d = i === void 0 ? !0 : i, m = c.adaptive, v = m === void 0 ? !0 : m, g = c.roundOffsets, C = g === void 0 ? !0 : g, O = {
    placement: FS(o.placement),
    variation: A$(o.placement),
    popper: o.elements.popper,
    popperRect: o.rects.popper,
    gpuAcceleration: d,
    isFixed: o.options.strategy === "fixed"
  };
  o.modifiersData.popperOffsets != null && (o.styles.popper = Object.assign({}, o.styles.popper, nde(Object.assign({}, O, {
    offsets: o.modifiersData.popperOffsets,
    position: o.options.strategy,
    adaptive: v,
    roundOffsets: C
  })))), o.modifiersData.arrow != null && (o.styles.arrow = Object.assign({}, o.styles.arrow, nde(Object.assign({}, O, {
    offsets: o.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: C
  })))), o.attributes.popper = Object.assign({}, o.attributes.popper, {
    "data-popper-placement": o.placement
  });
}
const GOe = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: qOe,
  data: {}
};
var J9 = {
  passive: !0
};
function ZOe(r) {
  var o = r.state, c = r.instance, i = r.options, d = i.scroll, m = d === void 0 ? !0 : d, v = i.resize, g = v === void 0 ? !0 : v, C = Bv(o.elements.popper), O = [].concat(o.scrollParents.reference, o.scrollParents.popper);
  return m && O.forEach(function(R) {
    R.addEventListener("scroll", c.update, J9);
  }), g && C.addEventListener("resize", c.update, J9), function() {
    m && O.forEach(function(R) {
      R.removeEventListener("scroll", c.update, J9);
    }), g && C.removeEventListener("resize", c.update, J9);
  };
}
const KOe = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: ZOe,
  data: {}
};
var YOe = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function uW(r) {
  return r.replace(/left|right|bottom|top/g, function(o) {
    return YOe[o];
  });
}
var QOe = {
  start: "end",
  end: "start"
};
function rde(r) {
  return r.replace(/start|end/g, function(o) {
    return QOe[o];
  });
}
function Lae(r) {
  var o = Bv(r), c = o.pageXOffset, i = o.pageYOffset;
  return {
    scrollLeft: c,
    scrollTop: i
  };
}
function Bae(r) {
  return O$(P2(r)).left + Lae(r).scrollLeft;
}
function XOe(r, o) {
  var c = Bv(r), i = P2(r), d = c.visualViewport, m = i.clientWidth, v = i.clientHeight, g = 0, C = 0;
  if (d) {
    m = d.width, v = d.height;
    var O = Zhe();
    (O || !O && o === "fixed") && (g = d.offsetLeft, C = d.offsetTop);
  }
  return {
    width: m,
    height: v,
    x: g + Bae(r),
    y: C
  };
}
function JOe(r) {
  var o, c = P2(r), i = Lae(r), d = (o = r.ownerDocument) == null ? void 0 : o.body, m = VA(c.scrollWidth, c.clientWidth, d ? d.scrollWidth : 0, d ? d.clientWidth : 0), v = VA(c.scrollHeight, c.clientHeight, d ? d.scrollHeight : 0, d ? d.clientHeight : 0), g = -i.scrollLeft + Bae(r), C = -i.scrollTop;
  return OC(d || c).direction === "rtl" && (g += VA(c.clientWidth, d ? d.clientWidth : 0) - m), {
    width: m,
    height: v,
    x: g,
    y: C
  };
}
function Hae(r) {
  var o = OC(r), c = o.overflow, i = o.overflowX, d = o.overflowY;
  return /auto|scroll|overlay|hidden/.test(c + d + i);
}
function Jhe(r) {
  return ["html", "body", "#document"].indexOf(KS(r)) >= 0 ? r.ownerDocument.body : my(r) && Hae(r) ? r : Jhe(Dj(r));
}
function rB(r, o) {
  var c;
  o === void 0 && (o = []);
  var i = Jhe(r), d = i === ((c = r.ownerDocument) == null ? void 0 : c.body), m = Bv(i), v = d ? [m].concat(m.visualViewport || [], Hae(i) ? i : []) : i, g = o.concat(v);
  return d ? g : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    g.concat(rB(Dj(v)))
  );
}
function yse(r) {
  return Object.assign({}, r, {
    left: r.x,
    top: r.y,
    right: r.x + r.width,
    bottom: r.y + r.height
  });
}
function eAe(r, o) {
  var c = O$(r, !1, o === "fixed");
  return c.top = c.top + r.clientTop, c.left = c.left + r.clientLeft, c.bottom = c.top + r.clientHeight, c.right = c.left + r.clientWidth, c.width = r.clientWidth, c.height = r.clientHeight, c.x = c.left, c.y = c.top, c;
}
function ode(r, o, c) {
  return o === qhe ? yse(XOe(r, c)) : uk(o) ? eAe(o, c) : yse(JOe(P2(r)));
}
function tAe(r) {
  var o = rB(Dj(r)), c = ["absolute", "fixed"].indexOf(OC(r).position) >= 0, i = c && my(r) ? qB(r) : r;
  return uk(i) ? o.filter(function(d) {
    return uk(d) && Khe(d, i) && KS(d) !== "body";
  }) : [];
}
function nAe(r, o, c, i) {
  var d = o === "clippingParents" ? tAe(r) : [].concat(o), m = [].concat(d, [c]), v = m[0], g = m.reduce(function(C, O) {
    var R = ode(r, O, i);
    return C.top = VA(R.top, C.top), C.right = $W(R.right, C.right), C.bottom = $W(R.bottom, C.bottom), C.left = VA(R.left, C.left), C;
  }, ode(r, v, i));
  return g.width = g.right - g.left, g.height = g.bottom - g.top, g.x = g.left, g.y = g.top, g;
}
function ege(r) {
  var o = r.reference, c = r.element, i = r.placement, d = i ? FS(i) : null, m = i ? A$(i) : null, v = o.x + o.width / 2 - c.width / 2, g = o.y + o.height / 2 - c.height / 2, C;
  switch (d) {
    case kg:
      C = {
        x: v,
        y: o.y - c.height
      };
      break;
    case gy:
      C = {
        x: v,
        y: o.y + o.height
      };
      break;
    case vy:
      C = {
        x: o.x + o.width,
        y: g
      };
      break;
    case Ng:
      C = {
        x: o.x - c.width,
        y: g
      };
      break;
    default:
      C = {
        x: o.x,
        y: o.y
      };
  }
  var O = d ? Fae(d) : null;
  if (O != null) {
    var R = O === "y" ? "height" : "width";
    switch (m) {
      case T$:
        C[O] = C[O] - (o[R] / 2 - c[R] / 2);
        break;
      case OB:
        C[O] = C[O] + (o[R] / 2 - c[R] / 2);
        break;
    }
  }
  return C;
}
function AB(r, o) {
  o === void 0 && (o = {});
  var c = o, i = c.placement, d = i === void 0 ? r.placement : i, m = c.strategy, v = m === void 0 ? r.strategy : m, g = c.boundary, C = g === void 0 ? EOe : g, O = c.rootBoundary, R = O === void 0 ? qhe : O, I = c.elementContext, L = I === void 0 ? BL : I, Z = c.altBoundary, ne = Z === void 0 ? !1 : Z, se = c.padding, Q = se === void 0 ? 0 : se, he = Qhe(typeof Q != "number" ? Q : Xhe(Q, jB)), ue = L === BL ? COe : BL, G = r.rects.popper, me = r.elements[ne ? ue : L], we = nAe(uk(me) ? me : me.contextElement || P2(r.elements.popper), C, R, v), be = O$(r.elements.reference), q = ege({
    reference: be,
    element: G,
    strategy: "absolute",
    placement: d
  }), Te = yse(Object.assign({}, G, q)), Le = L === BL ? Te : be, je = {
    top: we.top - Le.top + he.top,
    bottom: Le.bottom - we.bottom + he.bottom,
    left: we.left - Le.left + he.left,
    right: Le.right - we.right + he.right
  }, Ie = r.modifiersData.offset;
  if (L === BL && Ie) {
    var Ce = Ie[d];
    Object.keys(je).forEach(function(pt) {
      var sn = [vy, gy].indexOf(pt) >= 0 ? 1 : -1, Lt = [kg, gy].indexOf(pt) >= 0 ? "y" : "x";
      je[pt] += Ce[Lt] * sn;
    });
  }
  return je;
}
function rAe(r, o) {
  o === void 0 && (o = {});
  var c = o, i = c.placement, d = c.boundary, m = c.rootBoundary, v = c.padding, g = c.flipVariations, C = c.allowedAutoPlacements, O = C === void 0 ? Ghe : C, R = A$(i), I = R ? g ? ede : ede.filter(function(ne) {
    return A$(ne) === R;
  }) : jB, L = I.filter(function(ne) {
    return O.indexOf(ne) >= 0;
  });
  L.length === 0 && (L = I);
  var Z = L.reduce(function(ne, se) {
    return ne[se] = AB(r, {
      placement: se,
      boundary: d,
      rootBoundary: m,
      padding: v
    })[FS(se)], ne;
  }, {});
  return Object.keys(Z).sort(function(ne, se) {
    return Z[ne] - Z[se];
  });
}
function oAe(r) {
  if (FS(r) === $ae)
    return [];
  var o = uW(r);
  return [rde(r), o, rde(o)];
}
function sAe(r) {
  var o = r.state, c = r.options, i = r.name;
  if (!o.modifiersData[i]._skip) {
    for (var d = c.mainAxis, m = d === void 0 ? !0 : d, v = c.altAxis, g = v === void 0 ? !0 : v, C = c.fallbackPlacements, O = c.padding, R = c.boundary, I = c.rootBoundary, L = c.altBoundary, Z = c.flipVariations, ne = Z === void 0 ? !0 : Z, se = c.allowedAutoPlacements, Q = o.options.placement, he = FS(Q), ue = he === Q, G = C || (ue || !ne ? [uW(Q)] : oAe(Q)), me = [Q].concat(G).reduce(function(xt, cn) {
      return xt.concat(FS(cn) === $ae ? rAe(o, {
        placement: cn,
        boundary: R,
        rootBoundary: I,
        padding: O,
        flipVariations: ne,
        allowedAutoPlacements: se
      }) : cn);
    }, []), we = o.rects.reference, be = o.rects.popper, q = /* @__PURE__ */ new Map(), Te = !0, Le = me[0], je = 0; je < me.length; je++) {
      var Ie = me[je], Ce = FS(Ie), pt = A$(Ie) === T$, sn = [kg, gy].indexOf(Ce) >= 0, Lt = sn ? "width" : "height", z = AB(o, {
        placement: Ie,
        boundary: R,
        rootBoundary: I,
        altBoundary: L,
        padding: O
      }), bt = sn ? pt ? vy : Ng : pt ? gy : kg;
      we[Lt] > be[Lt] && (bt = uW(bt));
      var at = uW(bt), _n = [];
      if (m && _n.push(z[Ce] <= 0), g && _n.push(z[bt] <= 0, z[at] <= 0), _n.every(function(xt) {
        return xt;
      })) {
        Le = Ie, Te = !1;
        break;
      }
      q.set(Ie, _n);
    }
    if (Te)
      for (var st = ne ? 3 : 1, Ne = function(cn) {
        var He = me.find(function(ut) {
          var oe = q.get(ut);
          if (oe)
            return oe.slice(0, cn).every(function(qn) {
              return qn;
            });
        });
        if (He)
          return Le = He, "break";
      }, vt = st; vt > 0; vt--) {
        var Gt = Ne(vt);
        if (Gt === "break")
          break;
      }
    o.placement !== Le && (o.modifiersData[i]._skip = !0, o.placement = Le, o.reset = !0);
  }
}
const aAe = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: sAe,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function sde(r, o, c) {
  return c === void 0 && (c = {
    x: 0,
    y: 0
  }), {
    top: r.top - o.height - c.y,
    right: r.right - o.width + c.x,
    bottom: r.bottom - o.height + c.y,
    left: r.left - o.width - c.x
  };
}
function ade(r) {
  return [kg, vy, gy, Ng].some(function(o) {
    return r[o] >= 0;
  });
}
function iAe(r) {
  var o = r.state, c = r.name, i = o.rects.reference, d = o.rects.popper, m = o.modifiersData.preventOverflow, v = AB(o, {
    elementContext: "reference"
  }), g = AB(o, {
    altBoundary: !0
  }), C = sde(v, i), O = sde(g, d, m), R = ade(C), I = ade(O);
  o.modifiersData[c] = {
    referenceClippingOffsets: C,
    popperEscapeOffsets: O,
    isReferenceHidden: R,
    hasPopperEscaped: I
  }, o.attributes.popper = Object.assign({}, o.attributes.popper, {
    "data-popper-reference-hidden": R,
    "data-popper-escaped": I
  });
}
const cAe = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: iAe
};
function lAe(r, o, c) {
  var i = FS(r), d = [Ng, kg].indexOf(i) >= 0 ? -1 : 1, m = typeof c == "function" ? c(Object.assign({}, o, {
    placement: r
  })) : c, v = m[0], g = m[1];
  return v = v || 0, g = (g || 0) * d, [Ng, vy].indexOf(i) >= 0 ? {
    x: g,
    y: v
  } : {
    x: v,
    y: g
  };
}
function uAe(r) {
  var o = r.state, c = r.options, i = r.name, d = c.offset, m = d === void 0 ? [0, 0] : d, v = Ghe.reduce(function(R, I) {
    return R[I] = lAe(I, o.rects, m), R;
  }, {}), g = v[o.placement], C = g.x, O = g.y;
  o.modifiersData.popperOffsets != null && (o.modifiersData.popperOffsets.x += C, o.modifiersData.popperOffsets.y += O), o.modifiersData[i] = v;
}
const dAe = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: uAe
};
function fAe(r) {
  var o = r.state, c = r.name;
  o.modifiersData[c] = ege({
    reference: o.rects.reference,
    element: o.rects.popper,
    strategy: "absolute",
    placement: o.placement
  });
}
const mAe = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: fAe,
  data: {}
};
function pAe(r) {
  return r === "x" ? "y" : "x";
}
function hAe(r) {
  var o = r.state, c = r.options, i = r.name, d = c.mainAxis, m = d === void 0 ? !0 : d, v = c.altAxis, g = v === void 0 ? !1 : v, C = c.boundary, O = c.rootBoundary, R = c.altBoundary, I = c.padding, L = c.tether, Z = L === void 0 ? !0 : L, ne = c.tetherOffset, se = ne === void 0 ? 0 : ne, Q = AB(o, {
    boundary: C,
    rootBoundary: O,
    padding: I,
    altBoundary: R
  }), he = FS(o.placement), ue = A$(o.placement), G = !ue, me = Fae(he), we = pAe(me), be = o.modifiersData.popperOffsets, q = o.rects.reference, Te = o.rects.popper, Le = typeof se == "function" ? se(Object.assign({}, o.rects, {
    placement: o.placement
  })) : se, je = typeof Le == "number" ? {
    mainAxis: Le,
    altAxis: Le
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, Le), Ie = o.modifiersData.offset ? o.modifiersData.offset[o.placement] : null, Ce = {
    x: 0,
    y: 0
  };
  if (be) {
    if (m) {
      var pt, sn = me === "y" ? kg : Ng, Lt = me === "y" ? gy : vy, z = me === "y" ? "height" : "width", bt = be[me], at = bt + Q[sn], _n = bt - Q[Lt], st = Z ? -Te[z] / 2 : 0, Ne = ue === T$ ? q[z] : Te[z], vt = ue === T$ ? -Te[z] : -q[z], Gt = o.elements.arrow, xt = Z && Gt ? Mae(Gt) : {
        width: 0,
        height: 0
      }, cn = o.modifiersData["arrow#persistent"] ? o.modifiersData["arrow#persistent"].padding : Yhe(), He = cn[sn], ut = cn[Lt], oe = nB(0, q[z], xt[z]), qn = G ? q[z] / 2 - st - oe - He - je.mainAxis : Ne - oe - He - je.mainAxis, Rn = G ? -q[z] / 2 + st + oe + ut + je.mainAxis : vt + oe + ut + je.mainAxis, Zt = o.elements.arrow && qB(o.elements.arrow), Jt = Zt ? me === "y" ? Zt.clientTop || 0 : Zt.clientLeft || 0 : 0, wo = (pt = Ie == null ? void 0 : Ie[me]) != null ? pt : 0, Ge = bt + qn - wo - Jt, qt = bt + Rn - wo, St = nB(Z ? $W(at, Ge) : at, bt, Z ? VA(_n, qt) : _n);
      be[me] = St, Ce[me] = St - bt;
    }
    if (g) {
      var ke, Ct = me === "x" ? kg : Ng, an = me === "x" ? gy : vy, ht = be[we], bn = we === "y" ? "height" : "width", Ye = ht + Q[Ct], nn = ht - Q[an], Bt = [kg, Ng].indexOf(he) !== -1, $n = (ke = Ie == null ? void 0 : Ie[we]) != null ? ke : 0, mr = Bt ? Ye : ht - q[bn] - Te[bn] - $n + je.altAxis, gr = Bt ? ht + q[bn] + Te[bn] - $n - je.altAxis : nn, Vr = Z && Bt ? BOe(mr, ht, gr) : nB(Z ? mr : Ye, ht, Z ? gr : nn);
      be[we] = Vr, Ce[we] = Vr - ht;
    }
    o.modifiersData[i] = Ce;
  }
}
const gAe = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: hAe,
  requiresIfExists: ["offset"]
};
function vAe(r) {
  return {
    scrollLeft: r.scrollLeft,
    scrollTop: r.scrollTop
  };
}
function bAe(r) {
  return r === Bv(r) || !my(r) ? Lae(r) : vAe(r);
}
function yAe(r) {
  var o = r.getBoundingClientRect(), c = _$(o.width) / r.offsetWidth || 1, i = _$(o.height) / r.offsetHeight || 1;
  return c !== 1 || i !== 1;
}
function SAe(r, o, c) {
  c === void 0 && (c = !1);
  var i = my(o), d = my(o) && yAe(o), m = P2(o), v = O$(r, d, c), g = {
    scrollLeft: 0,
    scrollTop: 0
  }, C = {
    x: 0,
    y: 0
  };
  return (i || !i && !c) && ((KS(o) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  Hae(m)) && (g = bAe(o)), my(o) ? (C = O$(o, !0), C.x += o.clientLeft, C.y += o.clientTop) : m && (C.x = Bae(m))), {
    x: v.left + g.scrollLeft - C.x,
    y: v.top + g.scrollTop - C.y,
    width: v.width,
    height: v.height
  };
}
function wAe(r) {
  var o = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Set(), i = [];
  r.forEach(function(m) {
    o.set(m.name, m);
  });
  function d(m) {
    c.add(m.name);
    var v = [].concat(m.requires || [], m.requiresIfExists || []);
    v.forEach(function(g) {
      if (!c.has(g)) {
        var C = o.get(g);
        C && d(C);
      }
    }), i.push(m);
  }
  return r.forEach(function(m) {
    c.has(m.name) || d(m);
  }), i;
}
function EAe(r) {
  var o = wAe(r);
  return DOe.reduce(function(c, i) {
    return c.concat(o.filter(function(d) {
      return d.phase === i;
    }));
  }, []);
}
function CAe(r) {
  var o;
  return function() {
    return o || (o = new Promise(function(c) {
      Promise.resolve().then(function() {
        o = void 0, c(r());
      });
    })), o;
  };
}
function xAe(r) {
  var o = r.reduce(function(c, i) {
    var d = c[i.name];
    return c[i.name] = d ? Object.assign({}, d, i, {
      options: Object.assign({}, d.options, i.options),
      data: Object.assign({}, d.data, i.data)
    }) : i, c;
  }, {});
  return Object.keys(o).map(function(c) {
    return o[c];
  });
}
var ide = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function cde() {
  for (var r = arguments.length, o = new Array(r), c = 0; c < r; c++)
    o[c] = arguments[c];
  return !o.some(function(i) {
    return !(i && typeof i.getBoundingClientRect == "function");
  });
}
function TAe(r) {
  r === void 0 && (r = {});
  var o = r, c = o.defaultModifiers, i = c === void 0 ? [] : c, d = o.defaultOptions, m = d === void 0 ? ide : d;
  return function(g, C, O) {
    O === void 0 && (O = m);
    var R = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, ide, m),
      modifiersData: {},
      elements: {
        reference: g,
        popper: C
      },
      attributes: {},
      styles: {}
    }, I = [], L = !1, Z = {
      state: R,
      setOptions: function(he) {
        var ue = typeof he == "function" ? he(R.options) : he;
        se(), R.options = Object.assign({}, m, R.options, ue), R.scrollParents = {
          reference: uk(g) ? rB(g) : g.contextElement ? rB(g.contextElement) : [],
          popper: rB(C)
        };
        var G = EAe(xAe([].concat(i, R.options.modifiers)));
        return R.orderedModifiers = G.filter(function(me) {
          return me.enabled;
        }), ne(), Z.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function() {
        if (!L) {
          var he = R.elements, ue = he.reference, G = he.popper;
          if (cde(ue, G)) {
            R.rects = {
              reference: SAe(ue, qB(G), R.options.strategy === "fixed"),
              popper: Mae(G)
            }, R.reset = !1, R.placement = R.options.placement, R.orderedModifiers.forEach(function(je) {
              return R.modifiersData[je.name] = Object.assign({}, je.data);
            });
            for (var me = 0; me < R.orderedModifiers.length; me++) {
              if (R.reset === !0) {
                R.reset = !1, me = -1;
                continue;
              }
              var we = R.orderedModifiers[me], be = we.fn, q = we.options, Te = q === void 0 ? {} : q, Le = we.name;
              typeof be == "function" && (R = be({
                state: R,
                options: Te,
                name: Le,
                instance: Z
              }) || R);
            }
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: CAe(function() {
        return new Promise(function(Q) {
          Z.forceUpdate(), Q(R);
        });
      }),
      destroy: function() {
        se(), L = !0;
      }
    };
    if (!cde(g, C))
      return Z;
    Z.setOptions(O).then(function(Q) {
      !L && O.onFirstUpdate && O.onFirstUpdate(Q);
    });
    function ne() {
      R.orderedModifiers.forEach(function(Q) {
        var he = Q.name, ue = Q.options, G = ue === void 0 ? {} : ue, me = Q.effect;
        if (typeof me == "function") {
          var we = me({
            state: R,
            name: he,
            instance: Z,
            options: G
          }), be = function() {
          };
          I.push(we || be);
        }
      });
    }
    function se() {
      I.forEach(function(Q) {
        return Q();
      }), I = [];
    }
    return Z;
  };
}
var _Ae = [KOe, mAe, GOe, MOe, dAe, aAe, gAe, UOe, cAe], OAe = /* @__PURE__ */ TAe({
  defaultModifiers: _Ae
}), AAe = typeof Element < "u", kAe = typeof Map == "function", NAe = typeof Set == "function", RAe = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView;
function dW(r, o) {
  if (r === o)
    return !0;
  if (r && o && typeof r == "object" && typeof o == "object") {
    if (r.constructor !== o.constructor)
      return !1;
    var c, i, d;
    if (Array.isArray(r)) {
      if (c = r.length, c != o.length)
        return !1;
      for (i = c; i-- !== 0; )
        if (!dW(r[i], o[i]))
          return !1;
      return !0;
    }
    var m;
    if (kAe && r instanceof Map && o instanceof Map) {
      if (r.size !== o.size)
        return !1;
      for (m = r.entries(); !(i = m.next()).done; )
        if (!o.has(i.value[0]))
          return !1;
      for (m = r.entries(); !(i = m.next()).done; )
        if (!dW(i.value[1], o.get(i.value[0])))
          return !1;
      return !0;
    }
    if (NAe && r instanceof Set && o instanceof Set) {
      if (r.size !== o.size)
        return !1;
      for (m = r.entries(); !(i = m.next()).done; )
        if (!o.has(i.value[0]))
          return !1;
      return !0;
    }
    if (RAe && ArrayBuffer.isView(r) && ArrayBuffer.isView(o)) {
      if (c = r.length, c != o.length)
        return !1;
      for (i = c; i-- !== 0; )
        if (r[i] !== o[i])
          return !1;
      return !0;
    }
    if (r.constructor === RegExp)
      return r.source === o.source && r.flags === o.flags;
    if (r.valueOf !== Object.prototype.valueOf && typeof r.valueOf == "function" && typeof o.valueOf == "function")
      return r.valueOf() === o.valueOf();
    if (r.toString !== Object.prototype.toString && typeof r.toString == "function" && typeof o.toString == "function")
      return r.toString() === o.toString();
    if (d = Object.keys(r), c = d.length, c !== Object.keys(o).length)
      return !1;
    for (i = c; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(o, d[i]))
        return !1;
    if (AAe && r instanceof Element)
      return !1;
    for (i = c; i-- !== 0; )
      if (!((d[i] === "_owner" || d[i] === "__v" || d[i] === "__o") && r.$$typeof) && !dW(r[d[i]], o[d[i]]))
        return !1;
    return !0;
  }
  return r !== r && o !== o;
}
var PAe = function(o, c) {
  try {
    return dW(o, c);
  } catch (i) {
    if ((i.message || "").match(/stack|recursion/i))
      return console.warn("react-fast-compare cannot handle circular refs"), !1;
    throw i;
  }
};
const DAe = /* @__PURE__ */ Ku(PAe);
var $Ae = [], IAe = function(o, c, i) {
  i === void 0 && (i = {});
  var d = Ya.useRef(null), m = {
    onFirstUpdate: i.onFirstUpdate,
    placement: i.placement || "bottom",
    strategy: i.strategy || "absolute",
    modifiers: i.modifiers || $Ae
  }, v = Ya.useState({
    styles: {
      popper: {
        position: m.strategy,
        left: "0",
        top: "0"
      },
      arrow: {
        position: "absolute"
      }
    },
    attributes: {}
  }), g = v[0], C = v[1], O = Ya.useMemo(function() {
    return {
      name: "updateState",
      enabled: !0,
      phase: "write",
      fn: function(Z) {
        var ne = Z.state, se = Object.keys(ne.elements);
        Joe.flushSync(function() {
          C({
            styles: Xue(se.map(function(Q) {
              return [Q, ne.styles[Q] || {}];
            })),
            attributes: Xue(se.map(function(Q) {
              return [Q, ne.attributes[Q]];
            }))
          });
        });
      },
      requires: ["computeStyles"]
    };
  }, []), R = Ya.useMemo(function() {
    var L = {
      onFirstUpdate: m.onFirstUpdate,
      placement: m.placement,
      strategy: m.strategy,
      modifiers: [].concat(m.modifiers, [O, {
        name: "applyStyles",
        enabled: !1
      }])
    };
    return DAe(d.current, L) ? d.current || L : (d.current = L, L);
  }, [m.onFirstUpdate, m.placement, m.strategy, m.modifiers, O]), I = Ya.useRef();
  return Jue(function() {
    I.current && I.current.setOptions(R);
  }, [R]), Jue(function() {
    if (!(o == null || c == null)) {
      var L = i.createPopper || OAe, Z = L(o, c, R);
      return I.current = Z, function() {
        Z.destroy(), I.current = null;
      };
    }
  }, [o, c, i.createPopper]), {
    state: I.current ? I.current.state : null,
    styles: g.styles,
    attributes: g.attributes,
    update: I.current ? I.current.update : null,
    forceUpdate: I.current ? I.current.forceUpdate : null
  };
}, MAe = function() {
}, FAe = function() {
  return Promise.resolve(null);
}, LAe = [];
function BAe(r) {
  var o = r.placement, c = o === void 0 ? "bottom" : o, i = r.strategy, d = i === void 0 ? "absolute" : i, m = r.modifiers, v = m === void 0 ? LAe : m, g = r.referenceElement, C = r.onFirstUpdate, O = r.innerRef, R = r.children, I = Ya.useContext(bOe), L = Ya.useState(null), Z = L[0], ne = L[1], se = Ya.useState(null), Q = se[0], he = se[1];
  Ya.useEffect(function() {
    wOe(O, Z);
  }, [O, Z]);
  var ue = Ya.useMemo(function() {
    return {
      placement: c,
      strategy: d,
      onFirstUpdate: C,
      modifiers: [].concat(v, [{
        name: "arrow",
        enabled: Q != null,
        options: {
          element: Q
        }
      }])
    };
  }, [c, d, C, v, Q]), G = IAe(g || I, Z, ue), me = G.state, we = G.styles, be = G.forceUpdate, q = G.update, Te = Ya.useMemo(function() {
    return {
      ref: ne,
      style: we.popper,
      placement: me ? me.placement : c,
      hasPopperEscaped: me && me.modifiersData.hide ? me.modifiersData.hide.hasPopperEscaped : null,
      isReferenceHidden: me && me.modifiersData.hide ? me.modifiersData.hide.isReferenceHidden : null,
      arrowProps: {
        style: we.arrow,
        ref: he
      },
      forceUpdate: be || MAe,
      update: q || FAe
    };
  }, [ne, he, c, me, we, q, be]);
  return yOe(R)(Te);
}
function HAe(r, o, c, i) {
  return fae(r, function(d, m, v) {
    o(i, c(d), m, v);
  }), i;
}
function zAe(r, o) {
  return function(c, i) {
    return HAe(c, r, o(i), {});
  };
}
var VAe = Object.prototype, UAe = VAe.toString, WAe = zAe(function(r, o, c) {
  o != null && typeof o.toString != "function" && (o = UAe.call(o)), r[o] = c;
}, Ope(zC));
const jAe = WAe;
var zae = {
  "top center": "top",
  "top left": "top-start",
  "top right": "top-end",
  "bottom center": "bottom",
  "bottom left": "bottom-start",
  "bottom right": "bottom-end",
  "right center": "right",
  "left center": "left"
}, qAe = Yf(zae), GAe = jAe(zae);
function kB(r) {
  "@babel/helpers - typeof";
  return kB = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o) {
    return typeof o;
  } : function(o) {
    return o && typeof Symbol == "function" && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, kB(r);
}
function ZAe(r, o) {
  if (kB(r) != "object" || !r)
    return r;
  var c = r[Symbol.toPrimitive];
  if (c !== void 0) {
    var i = c.call(r, o || "default");
    if (kB(i) != "object")
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (o === "string" ? String : Number)(r);
}
function tge(r) {
  var o = ZAe(r, "string");
  return kB(o) == "symbol" ? o : o + "";
}
function lde(r, o) {
  for (var c = 0; c < o.length; c++) {
    var i = o[c];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(r, tge(i.key), i);
  }
}
function KAe(r, o, c) {
  return o && lde(r.prototype, o), c && lde(r, c), Object.defineProperty(r, "prototype", {
    writable: !1
  }), r;
}
var YAe = /* @__PURE__ */ function() {
  function r(c) {
    this.ref = c;
  }
  var o = r.prototype;
  return o.getBoundingClientRect = function() {
    return xn(this.ref.current, "getBoundingClientRect") || {};
  }, KAe(r, [{
    key: "clientWidth",
    get: function() {
      return this.getBoundingClientRect().width;
    }
  }, {
    key: "clientHeight",
    get: function() {
      return this.getBoundingClientRect().height;
    }
  }, {
    key: "parentNode",
    get: function() {
      return this.ref.current ? this.ref.current.parentNode : void 0;
    }
  }, {
    key: "contextElement",
    get: function() {
      return this.ref.current;
    }
  }]), r;
}(), QAe = FB(function(r) {
  return new YAe(zA(r) ? r : {
    current: r
  });
});
const XAe = QAe;
function AC(r) {
  var o = r.children, c = r.className, i = r.content, d = Vt("content", c), m = zt(AC, r), v = Xt(AC, r);
  return /* @__PURE__ */ ae.createElement(v, Be({}, m, {
    className: d
  }), dn(o) ? i : o);
}
AC.handledProps = ["as", "children", "className", "content"];
AC.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** The content of the Popup */
  children: _.node,
  /** Classes to add to the Popup content className. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
AC.create = lo(AC, function(r) {
  return {
    children: r
  };
});
function kC(r) {
  var o = r.children, c = r.className, i = r.content, d = Vt("header", c), m = zt(kC, r), v = Xt(kC, r);
  return /* @__PURE__ */ ae.createElement(v, Be({}, m, {
    className: d
  }), dn(o) ? i : o);
}
kC.handledProps = ["as", "children", "className", "content"];
kC.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
kC.create = lo(kC, function(r) {
  return {
    children: r
  };
});
var K$ = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.state = {}, i.open = !1, i.zIndexWasSynced = !1, i.triggerRef = /* @__PURE__ */ ae.createRef(), i.elementRef = /* @__PURE__ */ ae.createRef(), i.getPortalProps = function() {
      var g = {}, C = i.props, O = C.on, R = C.hoverable, I = qc(O) ? O : [O];
      return R && (g.closeOnPortalMouseLeave = !0, g.mouseLeaveDelay = 300), Og(I, "hover") && (g.openOnTriggerClick = !1, g.closeOnTriggerClick = !1, g.openOnTriggerMouseEnter = !0, g.closeOnTriggerMouseLeave = !0, g.mouseLeaveDelay = 70, g.mouseEnterDelay = 50), Og(I, "click") && (g.openOnTriggerClick = !0, g.closeOnTriggerClick = !0, g.closeOnDocumentClick = !0), Og(I, "focus") && (g.openOnTriggerFocus = !0, g.closeOnTriggerBlur = !0), g;
    }, i.hideOnScroll = function(g) {
      vOe(g.target) && i.elementRef.current.contains(g.target) || (i.setState({
        closed: !0
      }), Ql.unsub("scroll", i.hideOnScroll, {
        target: window
      }), i.timeoutId = setTimeout(function() {
        i.setState({
          closed: !1
        });
      }, 50), i.handleClose(g));
    }, i.handleClose = function(g) {
      xn(i.props, "onClose", g, Be({}, i.props, {
        open: !1
      }));
    }, i.handleOpen = function(g) {
      xn(i.props, "onOpen", g, Be({}, i.props, {
        open: !0
      }));
    }, i.handlePortalMount = function(g) {
      xn(i.props, "onMount", g, i.props);
    }, i.handlePortalUnmount = function(g) {
      i.positionUpdate = null, xn(i.props, "onUnmount", g, i.props);
    }, i.renderContent = function(g) {
      var C = g.placement, O = g.ref, R = g.update, I = g.style, L = i.props, Z = L.basic, ne = L.children, se = L.className, Q = L.content, he = L.hideOnScroll, ue = L.flowing, G = L.header, me = L.inverted, we = L.popper, be = L.size, q = L.style, Te = L.wide, Le = i.state.contentRestProps;
      i.positionUpdate = R;
      var je = Vt("ui", GAe[C], be, mi(Te, "wide"), $e(Z, "basic"), $e(ue, "flowing"), $e(me, "inverted"), "popup transition visible", se), Ie = Xt(o, i.props), Ce = Be({
        // Heads up! We need default styles to get working correctly `flowing`
        left: "auto",
        right: "auto",
        // This is required to be properly positioned inside wrapping `div`
        position: "initial"
      }, q), pt = /* @__PURE__ */ ae.createElement(Ie, Be({}, Le, {
        className: je,
        style: Ce,
        ref: i.elementRef
      }), dn(ne) ? /* @__PURE__ */ ae.createElement(ae.Fragment, null, kC.create(G, {
        autoGenerateKey: !1
      }), AC.create(Q, {
        autoGenerateKey: !1
      })) : ne, he && /* @__PURE__ */ ae.createElement(rC, {
        on: i.hideOnScroll,
        name: "scroll",
        target: "window"
      }));
      return phe(we || {}, {
        overrideProps: {
          children: pt,
          ref: O,
          style: Be({
            // Fixes layout for floated elements
            // https://github.com/Semantic-Org/Semantic-UI-React/issues/4092
            display: "flex"
          }, I)
        }
      });
    }, i;
  }
  o.getDerivedStateFromProps = function(d, m) {
    if (m.closed || m.disabled)
      return {};
    var v = zt(o, d), g = _j(v, function(O, R, I) {
      return Og(m2.handledProps, I) || (O[I] = R), O;
    }, {}), C = wj(v, m2.handledProps);
    return {
      contentRestProps: g,
      portalRestProps: C
    };
  };
  var c = o.prototype;
  return c.componentDidUpdate = function(d) {
    var m = p2(this.props.popperDependencies, d.popperDependencies);
    m || this.handleUpdate();
  }, c.componentWillUnmount = function() {
    clearTimeout(this.timeoutId);
  }, c.handleUpdate = function() {
    this.positionUpdate && this.positionUpdate();
  }, c.render = function() {
    var d = this, m = this.props, v = m.context, g = m.disabled, C = m.eventsEnabled, O = m.offset, R = m.pinned, I = m.popper, L = m.popperModifiers, Z = m.position, ne = m.positionFixed, se = m.trigger, Q = this.state, he = Q.closed, ue = Q.portalRestProps;
    if (he || g)
      return se;
    var G = [{
      name: "arrow",
      enabled: !1
    }, {
      name: "eventListeners",
      options: {
        scroll: !!C,
        resize: !!C
      }
    }, {
      name: "flip",
      enabled: !R
    }, {
      name: "preventOverflow",
      enabled: !!O
    }, {
      name: "offset",
      enabled: !!O,
      options: {
        offset: O
      }
    }].concat(L, [
      // We are syncing zIndex from `.ui.popup.content` to avoid layering issues as in SUIR we are using an additional
      // `div` for Popper.js
      // https://github.com/Semantic-Org/Semantic-UI-React/issues/4083
      {
        name: "syncZIndex",
        enabled: !0,
        phase: "beforeRead",
        fn: function(q) {
          var Te, Le = q.state;
          if (!d.zIndexWasSynced) {
            var je = I == null || (Te = I.style) == null ? void 0 : Te.zIndex;
            xh(je) && (Le.elements.popper.style.zIndex = window.getComputedStyle(Le.elements.popper.firstChild).zIndex), d.zIndexWasSynced = !0;
          }
        },
        effect: function() {
          return function() {
            d.zIndexWasSynced = !1;
          };
        }
      }
    ]), me = XAe(ws(v) ? this.triggerRef : v), we = Be({}, this.getPortalProps(), ue);
    return /* @__PURE__ */ ae.createElement(m2, Be({}, we, {
      onClose: this.handleClose,
      onMount: this.handlePortalMount,
      onOpen: this.handleOpen,
      onUnmount: this.handlePortalUnmount,
      trigger: se,
      triggerRef: this.triggerRef
    }), /* @__PURE__ */ ae.createElement(BAe, {
      modifiers: G,
      placement: zae[Z],
      strategy: ne ? "fixed" : null,
      referenceElement: me
    }, this.renderContent));
  }, o;
}(Do);
K$.handledProps = ["as", "basic", "children", "className", "content", "context", "disabled", "eventsEnabled", "flowing", "header", "hideOnScroll", "hoverable", "inverted", "offset", "on", "onClose", "onMount", "onOpen", "onUnmount", "pinned", "popper", "popperDependencies", "popperModifiers", "position", "positionFixed", "size", "style", "trigger", "wide"];
K$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Display the popup without the pointing arrow. */
  basic: _.bool,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Simple text content for the popover. */
  content: Vn,
  /** Existing element the pop-up should be bound to. */
  context: _.oneOfType([_.object, yB]),
  /** A disabled popup only renders its trigger. */
  disabled: _.bool,
  /** Enables the Popper.js event listeners. */
  eventsEnabled: _.bool,
  /** A flowing Popup has no maximum width and continues to flow to fit its content. */
  flowing: _.bool,
  /** Takes up the entire width of its offset container. */
  // TODO: implement the Popup fluid layout
  // fluid: PropTypes.bool,
  /** Header displayed above the content in bold. */
  header: Vn,
  /** Hide the Popup when scrolling the window. */
  hideOnScroll: _.bool,
  /** Whether the popup should not close on hover. */
  hoverable: _.bool,
  /** Invert the colors of the Popup. */
  inverted: _.bool,
  /**
   * Offset values in px unit to apply to rendered popup. The basic offset accepts an
   * array with two numbers in the form [skidding, distance]:
   * - `skidding` displaces the Popup along the reference element
   * - `distance` displaces the Popup away from, or toward, the reference element in the direction of its placement. A positive number displaces it further away, while a negative number lets it overlap the reference.
   *
   * @see https://popper.js.org/docs/v2/modifiers/offset/
   */
  offset: _.oneOfType([_.func, _.arrayOf(_.number)]),
  /** Events triggering the popup. */
  on: _.oneOfType([_.oneOf(["hover", "click", "focus"]), _.arrayOf(_.oneOf(["hover", "click", "focus"]))]),
  /**
   * Called when a close event happens.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onClose: _.func,
  /**
   * Called when the portal is mounted on the DOM.
   *
   * @param {null}
   * @param {object} data - All props.
   */
  onMount: _.func,
  /**
   * Called when an open event happens.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onOpen: _.func,
  /**
   * Called when the portal is unmounted from the DOM.
   *
   * @param {null}
   * @param {object} data - All props.
   */
  onUnmount: _.func,
  /** Disables automatic repositioning of the component, it will always be placed according to the position value. */
  pinned: _.bool,
  /** Position for the popover. */
  position: _.oneOf(qAe),
  /** Tells `Popper.js` to use the `position: fixed` strategy to position the popover. */
  positionFixed: _.bool,
  /** A wrapping element for an actual content that will be used for positioning. */
  popper: Vn,
  /** An array containing custom settings for the Popper.js modifiers. */
  popperModifiers: _.array,
  /** A popup can have dependencies which update will schedule a position update. */
  popperDependencies: _.array,
  /** Popup size. */
  size: _.oneOf(pi(mc, "medium", "big", "massive")),
  /** Custom Popup style. */
  style: _.object,
  /** Element to be rendered in-place where the popup is defined. */
  trigger: _.node,
  /** Popup width. */
  wide: _.oneOfType([_.bool, _.oneOf(["very"])])
} : {};
K$.defaultProps = {
  disabled: !1,
  eventsEnabled: !0,
  on: ["click", "hover"],
  pinned: !1,
  popperModifiers: [],
  position: "top left"
};
K$.Content = AC;
K$.Header = kC;
var JAe = Ph.isFinite, eke = Math.min;
function tke(r) {
  var o = Math[r];
  return function(c, i) {
    if (c = UD(c), i = i == null ? 0 : eke(cC(i), 292), i && JAe(c)) {
      var d = (BS(c) + "e").split("e"), m = o(d[0] + "e" + (+d[1] + i));
      return d = (BS(m) + "e").split("e"), +(d[0] + "e" + (+d[1] - i));
    }
    return o(c);
  };
}
var nke = tke("round");
const rke = nke;
function oke(r, o, c) {
  return c === void 0 && (c = o, o = void 0), c !== void 0 && (c = UD(c), c = c === c ? c : 0), o !== void 0 && (o = UD(o), o = o === o ? o : 0), Npe(UD(r), o, c);
}
var Vae = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.calculatePercent = function() {
      var g = i.props, C = g.percent, O = g.total, R = g.value;
      if (!xh(C))
        return C;
      if (!xh(O) && !xh(R))
        return R / O * 100;
    }, i.computeValueText = function(g) {
      var C = i.props, O = C.progress, R = C.total, I = C.value;
      return O === "value" ? I : O === "ratio" ? I + "/" + R : g + "%";
    }, i.getPercent = function() {
      var g = i.props, C = g.precision, O = g.progress, R = g.total, I = g.value, L = oke(i.calculatePercent(), 0, 100);
      return !xh(R) && !xh(I) && O === "value" ? I / R * 100 : O === "value" ? I : xh(C) ? L : rke(L, C);
    }, i.isAutoSuccess = function() {
      var g = i.props, C = g.autoSuccess, O = g.percent, R = g.total, I = g.value;
      return C && (O >= 100 || I >= R);
    }, i.renderLabel = function() {
      var g = i.props, C = g.children, O = g.content, R = g.label;
      return dn(C) ? dn(O) ? phe(R, {
        autoGenerateKey: !1,
        defaultProps: {
          className: "label"
        }
      }) : /* @__PURE__ */ ae.createElement("div", {
        className: "label"
      }, O) : /* @__PURE__ */ ae.createElement("div", {
        className: "label"
      }, C);
    }, i.renderProgress = function(g) {
      var C = i.props, O = C.precision, R = C.progress;
      if (!(!R && xh(O)))
        return /* @__PURE__ */ ae.createElement("div", {
          className: "progress"
        }, i.computeValueText(g));
    }, i;
  }
  var c = o.prototype;
  return c.render = function() {
    var d = this.props, m = d.active, v = d.attached, g = d.className, C = d.color, O = d.disabled, R = d.error, I = d.indicating, L = d.inverted, Z = d.size, ne = d.success, se = d.warning, Q = Vt("ui", C, Z, $e(m || I, "active"), $e(O, "disabled"), $e(R, "error"), $e(I, "indicating"), $e(L, "inverted"), $e(ne || this.isAutoSuccess(), "success"), $e(se, "warning"), _u(v, "attached"), "progress", g), he = zt(o, this.props), ue = Xt(o, this.props), G = this.getPercent() || 0;
    return /* @__PURE__ */ ae.createElement(ue, Be({}, he, {
      className: Q,
      "data-percent": Math.floor(G)
    }), /* @__PURE__ */ ae.createElement("div", {
      className: "bar",
      style: {
        width: G + "%"
      }
    }, this.renderProgress(G)), this.renderLabel());
  }, o;
}(Do);
Vae.handledProps = ["active", "as", "attached", "autoSuccess", "children", "className", "color", "content", "disabled", "error", "indicating", "inverted", "label", "percent", "precision", "progress", "size", "success", "total", "value", "warning"];
Vae.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** A progress bar can show activity. */
  active: _.bool,
  /** A progress bar can attach to and show the progress of an element (i.e. Card or Segment). */
  attached: _.oneOf(["top", "bottom"]),
  /** Whether success state should automatically trigger when progress completes. */
  autoSuccess: _.bool,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** A progress bar can have different colors. */
  color: _.oneOf(Om),
  /** Shorthand for primary content. */
  content: In,
  /** A progress bar be disabled. */
  disabled: _.bool,
  /** A progress bar can show a error state. */
  error: _.bool,
  /** An indicating progress bar visually indicates the current level of progress of a task. */
  indicating: _.bool,
  /** A progress bar can have its colors inverted. */
  inverted: _.bool,
  /** Can be set to either to display progress as percent or ratio. */
  label: Vn,
  /** Current percent complete. */
  percent: co([Go(["total", "value"]), _.oneOfType([_.number, _.string])]),
  /** Decimal point precision for calculated progress. */
  precision: _.number,
  /** A progress bar can contain a text value indicating current progress. */
  progress: _.oneOfType([_.bool, _.oneOf(["percent", "ratio", "value"])]),
  /** A progress bar can vary in size. */
  size: _.oneOf(pi(mc, "mini", "huge", "massive")),
  /** A progress bar can show a success state. */
  success: _.bool,
  /** For use with value. Together, these will calculate the percent. Mutually excludes percent. */
  total: co([_h(["value"]), Go(["percent"]), _.oneOfType([_.number, _.string])]),
  /** For use with total. Together, these will calculate the percent. Mutually excludes percent. */
  value: co([Go(["percent"]), _.oneOfType([_.number, _.string])]),
  /** A progress bar can show a warning state. */
  warning: _.bool
} : {};
const ske = Vae;
var ake = 9007199254740991, soe = 4294967295, ike = Math.min;
function cke(r, o) {
  if (r = cC(r), r < 1 || r > ake)
    return [];
  var c = soe, i = ike(r, soe);
  o = Gpe(o), r -= soe;
  for (var d = Dpe(i, o); ++c < r; )
    o(c);
  return d;
}
var Y$ = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.handleClick = function(g) {
      xn(i.props, "onClick", g, i.props);
    }, i.handleKeyUp = function(g) {
      switch (xn(i.props, "onKeyUp", g, i.props), Di.getCode(g)) {
        case Di.Enter:
        case Di.Spacebar:
          g.preventDefault(), xn(i.props, "onClick", g, i.props);
          break;
      }
    }, i.handleMouseEnter = function(g) {
      xn(i.props, "onMouseEnter", g, i.props);
    }, i;
  }
  var c = o.prototype;
  return c.render = function() {
    var d = this.props, m = d.active, v = d.className, g = d.selected, C = Vt($e(m, "active"), $e(g, "selected"), "icon", v), O = zt(o, this.props), R = Xt(o, this.props);
    return /* @__PURE__ */ ae.createElement(R, Be({}, O, {
      className: C,
      onClick: this.handleClick,
      onKeyUp: this.handleKeyUp,
      onMouseEnter: this.handleMouseEnter,
      role: "radio"
    }));
  }, o;
}(Do);
Y$.handledProps = ["active", "as", "className", "index", "onClick", "onKeyUp", "onMouseEnter", "selected"];
Y$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Indicates activity of an icon. */
  active: _.bool,
  /** Additional classes. */
  className: _.string,
  /** An index of icon inside Rating. */
  index: _.number,
  /**
   * Called on click.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onClick: _.func,
  /**
   * Called on keyup.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onKeyUp: _.func,
  /**
   * Called on mouseenter.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onMouseEnter: _.func,
  /** Indicates selection of an icon. */
  selected: _.bool
} : {};
Y$.defaultProps = {
  as: "i"
};
var Q$ = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.handleIconClick = function(g, C) {
      var O = C.index, R = i.props, I = R.clearable, L = R.disabled, Z = R.maxRating, ne = R.onRate, se = i.state.rating;
      if (!L) {
        var Q = O + 1;
        I === "auto" && Z === 1 ? Q = +!se : I === !0 && Q === se && (Q = 0), i.setState({
          rating: Q,
          isSelecting: !1
        }), ne && ne(g, Be({}, i.props, {
          rating: Q
        }));
      }
    }, i.handleIconMouseEnter = function(g, C) {
      var O = C.index;
      i.props.disabled || i.setState({
        selectedIndex: O,
        isSelecting: !0
      });
    }, i.handleMouseLeave = function() {
      for (var g = arguments.length, C = new Array(g), O = 0; O < g; O++)
        C[O] = arguments[O];
      xn.apply(void 0, [i.props, "onMouseLeave"].concat(C)), !i.props.disabled && i.setState({
        selectedIndex: -1,
        isSelecting: !1
      });
    }, i;
  }
  var c = o.prototype;
  return c.render = function() {
    var d = this, m = this.props, v = m.className, g = m.disabled, C = m.icon, O = m.maxRating, R = m.size, I = this.state, L = I.rating, Z = I.selectedIndex, ne = I.isSelecting, se = Vt("ui", C, R, $e(g, "disabled"), $e(ne && !g && Z >= 0, "selected"), "rating", v), Q = zt(o, this.props), he = Xt(o, this.props);
    return /* @__PURE__ */ ae.createElement(he, Be({}, Q, {
      className: se,
      role: "radiogroup",
      onMouseLeave: this.handleMouseLeave,
      tabIndex: g ? 0 : -1
    }), cke(O, function(ue) {
      return /* @__PURE__ */ ae.createElement(Y$, {
        tabIndex: g ? -1 : 0,
        active: L >= ue + 1,
        "aria-checked": L === ue + 1,
        "aria-posinset": ue + 1,
        "aria-setsize": O,
        index: ue,
        key: ue,
        onClick: d.handleIconClick,
        onMouseEnter: d.handleIconMouseEnter,
        selected: Z >= ue && ne
      });
    }));
  }, o;
}(P1);
Q$.handledProps = ["as", "className", "clearable", "defaultRating", "disabled", "icon", "maxRating", "onRate", "rating", "size"];
Q$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Additional classes. */
  className: _.string,
  /**
   * You can clear the rating by clicking on the current start rating.
   * By default a rating will be only clearable if there is 1 icon.
   * Setting to `true`/`false` will allow or disallow a user to clear their rating.
   */
  clearable: _.oneOfType([_.bool, _.oneOf(["auto"])]),
  /** The initial rating value. */
  defaultRating: _.oneOfType([_.number, _.string]),
  /** You can disable or enable interactive rating.  Makes a read-only rating. */
  disabled: _.bool,
  /** A rating can use a set of star or heart icons. */
  icon: _.oneOf(["star", "heart"]),
  /** The total number of icons. */
  maxRating: _.oneOfType([_.number, _.string]),
  /**
   * Called after user selects a new rating.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props and proposed rating.
   */
  onRate: _.func,
  /** The current number of active icons. */
  rating: _.oneOfType([_.number, _.string]),
  /** A progress bar can vary in size. */
  size: _.oneOf(pi(mc, "medium", "big"))
} : {};
Q$.autoControlledProps = ["rating"];
Q$.defaultProps = {
  clearable: "auto",
  maxRating: 1
};
Q$.Icon = Y$;
var lke = gB && new gB();
const IW = lke;
var uke = IW ? function(r, o) {
  return IW.set(r, o), r;
} : zC;
const nge = uke;
function NB(r) {
  return function() {
    var o = arguments;
    switch (o.length) {
      case 0:
        return new r();
      case 1:
        return new r(o[0]);
      case 2:
        return new r(o[0], o[1]);
      case 3:
        return new r(o[0], o[1], o[2]);
      case 4:
        return new r(o[0], o[1], o[2], o[3]);
      case 5:
        return new r(o[0], o[1], o[2], o[3], o[4]);
      case 6:
        return new r(o[0], o[1], o[2], o[3], o[4], o[5]);
      case 7:
        return new r(o[0], o[1], o[2], o[3], o[4], o[5], o[6]);
    }
    var c = Tj(r.prototype), i = r.apply(c, o);
    return Fv(i) ? i : c;
  };
}
var dke = 1;
function fke(r, o, c) {
  var i = o & dke, d = NB(r);
  function m() {
    var v = this && this !== Ph && this instanceof m ? d : r;
    return v.apply(i ? c : this, arguments);
  }
  return m;
}
var mke = Math.max;
function rge(r, o, c, i) {
  for (var d = -1, m = r.length, v = c.length, g = -1, C = o.length, O = mke(m - v, 0), R = Array(C + O), I = !i; ++g < C; )
    R[g] = o[g];
  for (; ++d < v; )
    (I || d < m) && (R[c[d]] = r[d]);
  for (; O--; )
    R[g++] = r[d++];
  return R;
}
var pke = Math.max;
function oge(r, o, c, i) {
  for (var d = -1, m = r.length, v = -1, g = c.length, C = -1, O = o.length, R = pke(m - g, 0), I = Array(R + O), L = !i; ++d < R; )
    I[d] = r[d];
  for (var Z = d; ++C < O; )
    I[Z + C] = o[C];
  for (; ++v < g; )
    (L || d < m) && (I[Z + c[v]] = r[d++]);
  return I;
}
function hke(r, o) {
  for (var c = r.length, i = 0; c--; )
    r[c] === o && ++i;
  return i;
}
function Uae() {
}
var gke = 4294967295;
function k$(r) {
  this.__wrapped__ = r, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = gke, this.__views__ = [];
}
k$.prototype = Tj(Uae.prototype);
k$.prototype.constructor = k$;
var vke = IW ? function(r) {
  return IW.get(r);
} : Eae;
const sge = vke;
var bke = {};
const ude = bke;
var yke = Object.prototype, Ske = yke.hasOwnProperty;
function wke(r) {
  for (var o = r.name + "", c = ude[o], i = Ske.call(ude, o) ? c.length : 0; i--; ) {
    var d = c[i], m = d.func;
    if (m == null || m == r)
      return d.name;
  }
  return o;
}
function N$(r, o) {
  this.__wrapped__ = r, this.__actions__ = [], this.__chain__ = !!o, this.__index__ = 0, this.__values__ = void 0;
}
N$.prototype = Tj(Uae.prototype);
N$.prototype.constructor = N$;
function $j(r, o) {
  var c = -1, i = r.length;
  for (o || (o = Array(i)); ++c < i; )
    o[c] = r[c];
  return o;
}
function Eke(r) {
  if (r instanceof k$)
    return r.clone();
  var o = new N$(r.__wrapped__, r.__chain__);
  return o.__actions__ = $j(r.__actions__), o.__index__ = r.__index__, o.__values__ = r.__values__, o;
}
var Cke = Object.prototype, xke = Cke.hasOwnProperty;
function MW(r) {
  if (Nh(r) && !qc(r) && !(r instanceof k$)) {
    if (r instanceof N$)
      return r;
    if (xke.call(r, "__wrapped__"))
      return Eke(r);
  }
  return new N$(r);
}
MW.prototype = Uae.prototype;
MW.prototype.constructor = MW;
function Tke(r) {
  var o = wke(r), c = MW[o];
  if (typeof c != "function" || !(o in k$.prototype))
    return !1;
  if (r === c)
    return !0;
  var i = sge(c);
  return !!i && r === i[0];
}
var _ke = Ape(nge);
const age = _ke;
var Oke = /\{\n\/\* \[wrapped with (.+)\] \*/, Ake = /,? & /;
function kke(r) {
  var o = r.match(Oke);
  return o ? o[1].split(Ake) : [];
}
var Nke = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;
function Rke(r, o) {
  var c = o.length;
  if (!c)
    return r;
  var i = c - 1;
  return o[i] = (c > 1 ? "& " : "") + o[i], o = o.join(c > 2 ? ", " : " "), r.replace(Nke, `{
/* [wrapped with ` + o + `] */
`);
}
var Pke = 1, Dke = 2, $ke = 8, Ike = 16, Mke = 32, Fke = 64, Lke = 128, Bke = 256, Hke = 512, zke = [
  ["ary", Lke],
  ["bind", Pke],
  ["bindKey", Dke],
  ["curry", $ke],
  ["curryRight", Ike],
  ["flip", Hke],
  ["partial", Mke],
  ["partialRight", Fke],
  ["rearg", Bke]
];
function Vke(r, o) {
  return vae(zke, function(c) {
    var i = "_." + c[0];
    o & c[1] && !yj(r, i) && r.push(i);
  }), r.sort();
}
function ige(r, o, c) {
  var i = o + "";
  return cae(r, Rke(i, Vke(kke(i), c)));
}
var Uke = 1, Wke = 2, jke = 4, qke = 8, dde = 32, fde = 64;
function cge(r, o, c, i, d, m, v, g, C, O) {
  var R = o & qke, I = R ? v : void 0, L = R ? void 0 : v, Z = R ? m : void 0, ne = R ? void 0 : m;
  o |= R ? dde : fde, o &= ~(R ? fde : dde), o & jke || (o &= ~(Uke | Wke));
  var se = [
    r,
    o,
    d,
    Z,
    I,
    ne,
    L,
    g,
    C,
    O
  ], Q = c.apply(void 0, se);
  return Tke(r) && age(Q, se), Q.placeholder = i, ige(Q, r, o);
}
function Wae(r) {
  var o = r;
  return o.placeholder;
}
var Gke = Math.min;
function Zke(r, o) {
  for (var c = r.length, i = Gke(o.length, c), d = $j(r); i--; ) {
    var m = o[i];
    r[i] = BB(m, c) ? d[m] : void 0;
  }
  return r;
}
var mde = "__lodash_placeholder__";
function RB(r, o) {
  for (var c = -1, i = r.length, d = 0, m = []; ++c < i; ) {
    var v = r[c];
    (v === o || v === mde) && (r[c] = mde, m[d++] = c);
  }
  return m;
}
var Kke = 1, Yke = 2, Qke = 8, Xke = 16, Jke = 128, eNe = 512;
function jae(r, o, c, i, d, m, v, g, C, O) {
  var R = o & Jke, I = o & Kke, L = o & Yke, Z = o & (Qke | Xke), ne = o & eNe, se = L ? void 0 : NB(r);
  function Q() {
    for (var he = arguments.length, ue = Array(he), G = he; G--; )
      ue[G] = arguments[G];
    if (Z)
      var me = Wae(Q), we = hke(ue, me);
    if (i && (ue = rge(ue, i, d, Z)), m && (ue = oge(ue, m, v, Z)), he -= we, Z && he < O) {
      var be = RB(ue, me);
      return cge(
        r,
        o,
        jae,
        Q.placeholder,
        c,
        ue,
        be,
        g,
        C,
        O - he
      );
    }
    var q = I ? c : this, Te = L ? q[r] : r;
    return he = ue.length, g ? ue = Zke(ue, g) : ne && he > 1 && ue.reverse(), R && C < he && (ue.length = C), this && this !== Ph && this instanceof Q && (Te = se || NB(Te)), Te.apply(q, ue);
  }
  return Q;
}
function tNe(r, o, c) {
  var i = NB(r);
  function d() {
    for (var m = arguments.length, v = Array(m), g = m, C = Wae(d); g--; )
      v[g] = arguments[g];
    var O = m < 3 && v[0] !== C && v[m - 1] !== C ? [] : RB(v, C);
    if (m -= O.length, m < c)
      return cge(
        r,
        o,
        jae,
        d.placeholder,
        void 0,
        v,
        O,
        void 0,
        void 0,
        c - m
      );
    var R = this && this !== Ph && this instanceof d ? i : r;
    return pj(R, this, v);
  }
  return d;
}
var nNe = 1;
function rNe(r, o, c, i) {
  var d = o & nNe, m = NB(r);
  function v() {
    for (var g = -1, C = arguments.length, O = -1, R = i.length, I = Array(R + C), L = this && this !== Ph && this instanceof v ? m : r; ++O < R; )
      I[O] = i[O];
    for (; C--; )
      I[O++] = arguments[++g];
    return pj(L, d ? c : this, I);
  }
  return v;
}
var pde = "__lodash_placeholder__", aoe = 1, oNe = 2, sNe = 4, hde = 8, HL = 128, gde = 256, aNe = Math.min;
function iNe(r, o) {
  var c = r[1], i = o[1], d = c | i, m = d < (aoe | oNe | HL), v = i == HL && c == hde || i == HL && c == gde && r[7].length <= o[8] || i == (HL | gde) && o[7].length <= o[8] && c == hde;
  if (!(m || v))
    return r;
  i & aoe && (r[2] = o[2], d |= c & aoe ? 0 : sNe);
  var g = o[3];
  if (g) {
    var C = r[3];
    r[3] = C ? rge(C, g, o[4]) : g, r[4] = C ? RB(r[3], pde) : o[4];
  }
  return g = o[5], g && (C = r[5], r[5] = C ? oge(C, g, o[6]) : g, r[6] = C ? RB(r[5], pde) : o[6]), g = o[7], g && (r[7] = g), i & HL && (r[8] = r[8] == null ? o[8] : aNe(r[8], o[8])), r[9] == null && (r[9] = o[9]), r[0] = o[0], r[1] = d, r;
}
var cNe = "Expected a function", vde = 1, lNe = 2, ioe = 8, coe = 16, loe = 32, bde = 64, yde = Math.max;
function uNe(r, o, c, i, d, m, v, g) {
  var C = o & lNe;
  if (!C && typeof r != "function")
    throw new TypeError(cNe);
  var O = i ? i.length : 0;
  if (O || (o &= ~(loe | bde), i = d = void 0), v = v === void 0 ? v : yde(cC(v), 0), g = g === void 0 ? g : cC(g), O -= d ? d.length : 0, o & bde) {
    var R = i, I = d;
    i = d = void 0;
  }
  var L = C ? void 0 : sge(r), Z = [
    r,
    o,
    c,
    i,
    d,
    R,
    I,
    m,
    v,
    g
  ];
  if (L && iNe(Z, L), r = Z[0], o = Z[1], c = Z[2], i = Z[3], d = Z[4], g = Z[9] = Z[9] === void 0 ? C ? 0 : r.length : yde(Z[9] - O, 0), !g && o & (ioe | coe) && (o &= ~(ioe | coe)), !o || o == vde)
    var ne = fke(r, o, c);
  else
    o == ioe || o == coe ? ne = tNe(r, o, g) : (o == loe || o == (vde | loe)) && !d.length ? ne = rNe(r, o, c, i) : ne = jae.apply(void 0, Z);
  var se = L ? nge : age;
  return ige(se(ne, Z), r, o);
}
var dNe = 64, qae = Nk(function(r, o) {
  var c = RB(o, Wae(qae));
  return uNe(r, dNe, void 0, o, c);
});
qae.placeholder = {};
const fNe = qae;
function Gae(r) {
  var o = r.categoryContent, c = r.resultsContent;
  return /* @__PURE__ */ ae.createElement(ae.Fragment, null, /* @__PURE__ */ ae.createElement("div", {
    className: "name"
  }, o), /* @__PURE__ */ ae.createElement("div", {
    className: "results"
  }, c));
}
Gae.handledProps = ["categoryContent", "resultsContent"];
Gae.propTypes = process.env.NODE_ENV !== "production" ? {
  /** The rendered category content */
  categoryContent: _.element.isRequired,
  /** The rendered results content */
  resultsContent: _.element.isRequired
} : {};
function NC(r) {
  var o = r.active, c = r.children, i = r.className, d = r.content, m = r.layoutRenderer, v = r.renderer, g = Vt($e(o, "active"), "category", i), C = zt(NC, r), O = Xt(NC, r), R = v(r), I = dn(c) ? d : c;
  return /* @__PURE__ */ ae.createElement(O, Be({}, C, {
    className: g
  }), m({
    categoryContent: R,
    resultsContent: I
  }));
}
NC.handledProps = ["active", "as", "children", "className", "content", "layoutRenderer", "name", "renderer", "results"];
NC.defaultProps = {
  layoutRenderer: Gae,
  renderer: function(o) {
    var c = o.name;
    return c;
  }
};
NC.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** The item currently selected by keyboard shortcut. */
  active: _.bool,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** Display name. */
  name: _.string,
  /**
   * Renders the category layout contents.
   *
   * @param {object} props - The SearchCategoryLayout props object.
   * @returns {*} - Renderable category layout contents.
   */
  layoutRenderer: _.func,
  /**
   * Renders the category contents.
   *
   * @param {object} props - The SearchCategory props object.
   * @returns {*} - Renderable category contents.
   */
  renderer: _.func,
  /** Array of Search.Result props. */
  results: _.array
} : {};
var lge = function(o) {
  var c = o.image, i = o.price, d = o.title, m = o.description;
  return [c && /* @__PURE__ */ ae.createElement("div", {
    key: "image",
    className: "image"
  }, Cj(c, {
    autoGenerateKey: !1
  })), /* @__PURE__ */ ae.createElement("div", {
    key: "content",
    className: "content"
  }, i && /* @__PURE__ */ ae.createElement("div", {
    className: "price"
  }, i), d && /* @__PURE__ */ ae.createElement("div", {
    className: "title"
  }, d), m && /* @__PURE__ */ ae.createElement("div", {
    className: "description"
  }, m))];
};
lge.handledProps = [];
var Mk = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.handleClick = function(g) {
      var C = i.props.onClick;
      C && C(g, i.props);
    }, i;
  }
  var c = o.prototype;
  return c.render = function() {
    var d = this.props, m = d.active, v = d.className, g = d.renderer, C = Vt($e(m, "active"), "result", v), O = zt(o, this.props), R = Xt(o, this.props);
    return /* @__PURE__ */ ae.createElement(R, Be({}, O, {
      className: C,
      onClick: this.handleClick
    }), g(this.props));
  }, o;
}(Do);
Mk.handledProps = ["active", "as", "className", "content", "description", "id", "image", "onClick", "price", "renderer", "title"];
Mk.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** The item currently selected by keyboard shortcut. */
  active: _.bool,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** Additional text with less emphasis. */
  description: _.string,
  /** A unique identifier. */
  id: _.oneOfType([_.number, _.string]),
  /** Add an image to the item. */
  image: _.string,
  /**
   * Called on click.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onClick: _.func,
  /** Customized text for price. */
  price: _.string,
  /**
   * Renders the result contents.
   *
   * @param {object} props - The SearchResult props object.
   * @returns {*} - Renderable result contents.
   */
  renderer: _.func,
  /** Display title. */
  title: _.string.isRequired
} : {};
Mk.defaultProps = {
  renderer: lge
};
function dk(r) {
  var o = r.children, c = r.className, i = r.content, d = Vt("results transition", c), m = zt(dk, r), v = Xt(dk, r);
  return /* @__PURE__ */ ae.createElement(v, Be({}, m, {
    className: d
  }), dn(o) ? i : o);
}
dk.handledProps = ["as", "children", "className", "content"];
dk.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
var mNe = function(o) {
  var c = o.input;
  return xh(c) ? Be({}, o, {
    input: {
      className: "prompt"
    }
  }) : y2(c) ? Be({}, o, {
    input: Be({}, c, {
      className: Vt(c.className, "prompt")
    })
  }) : o;
}, D2 = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.handleResultSelect = function(g, C) {
      xn(i.props, "onResultSelect", g, Be({}, i.props, {
        result: C
      }));
    }, i.handleSelectionChange = function(g) {
      var C = i.getSelectedResult();
      xn(i.props, "onSelectionChange", g, Be({}, i.props, {
        result: C
      }));
    }, i.closeOnEscape = function(g) {
      Di.getCode(g) === Di.Escape && (g.preventDefault(), i.close());
    }, i.moveSelectionOnKeyDown = function(g) {
      switch (Di.getCode(g)) {
        case Di.ArrowDown:
          g.preventDefault(), i.moveSelectionBy(g, 1);
          break;
        case Di.ArrowUp:
          g.preventDefault(), i.moveSelectionBy(g, -1);
          break;
      }
    }, i.selectItemOnEnter = function(g) {
      if (Di.getCode(g) === Di.Enter) {
        var C = i.getSelectedResult();
        C && (g.preventDefault(), i.setValue(C.title), i.handleResultSelect(g, C), i.close());
      }
    }, i.closeOnDocumentClick = function(g) {
      i.close();
    }, i.handleMouseDown = function(g) {
      i.isMouseDown = !0, xn(i.props, "onMouseDown", g, i.props), Ql.sub("mouseup", i.handleDocumentMouseUp);
    }, i.handleDocumentMouseUp = function() {
      i.isMouseDown = !1, Ql.unsub("mouseup", i.handleDocumentMouseUp);
    }, i.handleInputClick = function(g) {
      g.nativeEvent.stopImmediatePropagation(), i.tryOpen();
    }, i.handleItemClick = function(g, C) {
      var O = C.id, R = i.getSelectedResult(O);
      g.nativeEvent.stopImmediatePropagation(), i.setValue(R.title), i.handleResultSelect(g, R), i.close();
    }, i.handleItemMouseDown = function(g) {
      g.preventDefault();
    }, i.handleFocus = function(g) {
      xn(i.props, "onFocus", g, i.props), i.setState({
        focus: !0
      });
    }, i.handleBlur = function(g) {
      xn(i.props, "onBlur", g, i.props), i.setState({
        focus: !1
      });
    }, i.handleSearchChange = function(g) {
      g.stopPropagation();
      var C = i.props.minCharacters, O = i.state.open, R = g.target.value;
      xn(i.props, "onSearchChange", g, Be({}, i.props, {
        value: R
      })), R.length < C ? i.close() : O || i.tryOpen(R), i.setValue(R);
    }, i.getFlattenedResults = function() {
      var g = i.props, C = g.category, O = g.results;
      return C ? _j(O, function(R, I) {
        return R.concat(I.results);
      }, []) : O;
    }, i.getSelectedResult = function(g) {
      g === void 0 && (g = i.state.selectedIndex);
      var C = i.getFlattenedResults();
      return Oh(C, g);
    }, i.setValue = function(g) {
      var C = i.props.selectFirstResult;
      i.setState({
        value: g,
        selectedIndex: C ? 0 : -1
      });
    }, i.moveSelectionBy = function(g, C) {
      var O = i.state.selectedIndex, R = i.getFlattenedResults(), I = R.length - 1, L = O + C;
      L > I ? L = 0 : L < 0 && (L = I), i.setState({
        selectedIndex: L
      }), i.scrollSelectedItemIntoView(), i.handleSelectionChange(g);
    }, i.scrollSelectedItemIntoView = function() {
      if ($v()) {
        var g = document.querySelector(".ui.search.active.visible .results.visible");
        if (g) {
          var C = g.querySelector(".result.active");
          if (C) {
            var O = C.offsetTop < g.scrollTop, R = C.offsetTop + C.clientHeight > g.scrollTop + g.clientHeight;
            O ? g.scrollTop = C.offsetTop : R && (g.scrollTop = C.offsetTop + C.clientHeight - g.clientHeight);
          }
        }
      }
    }, i.tryOpen = function(g) {
      g === void 0 && (g = i.state.value);
      var C = i.props.minCharacters;
      g.length < C || i.open();
    }, i.open = function() {
      i.setState({
        open: !0
      });
    }, i.close = function() {
      i.setState({
        open: !1
      });
    }, i.renderSearchInput = function(g) {
      var C = i.props, O = C.icon, R = C.input, I = C.placeholder, L = i.state.value;
      return WB.create(R, {
        autoGenerateKey: !1,
        defaultProps: Be({}, g, {
          autoComplete: "off",
          icon: O,
          onChange: i.handleSearchChange,
          onClick: i.handleInputClick,
          tabIndex: "0",
          value: L,
          placeholder: I
        }),
        // Nested shorthand props need special treatment to survive the shallow merge
        overrideProps: mNe
      });
    }, i.renderNoResults = function() {
      var g = i.props, C = g.noResultsDescription, O = g.noResultsMessage;
      return /* @__PURE__ */ ae.createElement("div", {
        className: "message empty"
      }, /* @__PURE__ */ ae.createElement("div", {
        className: "header"
      }, O), C && /* @__PURE__ */ ae.createElement("div", {
        className: "description"
      }, C));
    }, i.renderResult = function(g, C, O, R) {
      var I = g.childKey, L = O1(g, ["childKey"]);
      R === void 0 && (R = 0);
      var Z = i.props.resultRenderer, ne = i.state.selectedIndex, se = C + R;
      return /* @__PURE__ */ ae.createElement(Mk, Be({
        key: I ?? (L.id || L.title),
        active: ne === se,
        onClick: i.handleItemClick,
        onMouseDown: i.handleItemMouseDown,
        renderer: Z
      }, L, {
        id: se
        // Used to lookup the result on item click
      }));
    }, i.renderResults = function() {
      var g = i.props.results;
      return fi(g, i.renderResult);
    }, i.renderCategories = function() {
      var g = i.props, C = g.categoryLayoutRenderer, O = g.categoryRenderer, R = g.results, I = i.state.selectedIndex, L = 0;
      return fi(R, function(Z) {
        var ne = Z.childKey, se = O1(Z, ["childKey"]), Q = Be({
          key: ne ?? se.name,
          active: mse(I, L, L + se.results.length),
          layoutRenderer: C,
          renderer: O
        }, se), he = fNe(i.renderResult, L);
        return L += se.results.length, /* @__PURE__ */ ae.createElement(NC, Q, se.results.map(he));
      });
    }, i.renderMenuContent = function() {
      var g = i.props, C = g.category, O = g.showNoResults, R = g.results;
      return u2(R) ? O ? i.renderNoResults() : null : C ? i.renderCategories() : i.renderResults();
    }, i.renderResultsMenu = function() {
      var g = i.state.open, C = g ? "visible" : "", O = i.renderMenuContent();
      if (O)
        return /* @__PURE__ */ ae.createElement(dk, {
          className: C
        }, O);
    }, i;
  }
  o.getAutoControlledStateFromProps = function(d, m) {
    if (typeof m.prevValue < "u" && p2(m.prevValue, m.value))
      return {
        prevValue: m.value
      };
    var v = d.selectFirstResult ? 0 : -1;
    return {
      prevValue: m.value,
      selectedIndex: v
    };
  };
  var c = o.prototype;
  return c.shouldComponentUpdate = function(d, m) {
    return !p2(d, this.props) || !p2(m, this.state);
  }, c.componentDidUpdate = function(d, m) {
    !m.focus && this.state.focus ? (this.isMouseDown || this.tryOpen(), this.state.open && Ql.sub("keydown", [this.moveSelectionOnKeyDown, this.selectItemOnEnter])) : m.focus && !this.state.focus && (this.isMouseDown || this.close(), Ql.unsub("keydown", [this.moveSelectionOnKeyDown, this.selectItemOnEnter])), !m.open && this.state.open ? (this.open(), Ql.sub("click", this.closeOnDocumentClick), Ql.sub("keydown", [this.closeOnEscape, this.moveSelectionOnKeyDown, this.selectItemOnEnter])) : m.open && !this.state.open && (this.close(), Ql.unsub("click", this.closeOnDocumentClick), Ql.unsub("keydown", [this.closeOnEscape, this.moveSelectionOnKeyDown, this.selectItemOnEnter]));
  }, c.componentWillUnmount = function() {
    Ql.unsub("click", this.closeOnDocumentClick), Ql.unsub("keydown", [this.closeOnEscape, this.moveSelectionOnKeyDown, this.selectItemOnEnter]);
  }, c.render = function() {
    var d = this.state, m = d.searchClasses, v = d.focus, g = d.open, C = this.props, O = C.aligned, R = C.category, I = C.className, L = C.fluid, Z = C.loading, ne = C.size, se = Vt("ui", g && "active visible", ne, m, $e(R, "category"), $e(v, "focus"), $e(L, "fluid"), $e(Z, "loading"), _u(O, "aligned"), "search", I), Q = zt(o, this.props), he = Xt(o, this.props), ue = VB(Q, {
      htmlProps: xae
    }), G = ue[0], me = ue[1];
    return /* @__PURE__ */ ae.createElement(he, Be({}, me, {
      className: se,
      onBlur: this.handleBlur,
      onFocus: this.handleFocus,
      onMouseDown: this.handleMouseDown
    }), this.renderSearchInput(G), this.renderResultsMenu());
  }, o;
}(P1);
D2.handledProps = ["aligned", "as", "category", "categoryLayoutRenderer", "categoryRenderer", "className", "defaultOpen", "defaultValue", "fluid", "icon", "input", "loading", "minCharacters", "noResultsDescription", "noResultsMessage", "onBlur", "onFocus", "onMouseDown", "onResultSelect", "onSearchChange", "onSelectionChange", "open", "placeholder", "resultRenderer", "results", "selectFirstResult", "showNoResults", "size", "value"];
D2.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  // ------------------------------------
  // Behavior
  // ------------------------------------
  /** Initial value of open. */
  defaultOpen: _.bool,
  /** Initial value. */
  defaultValue: _.string,
  /** Shorthand for Icon. */
  icon: _.oneOfType([_.node, _.object]),
  /** Minimum characters to query for results */
  minCharacters: _.number,
  /** Additional text for "No Results" message with less emphasis. */
  noResultsDescription: _.node,
  /** Message to display when there are no results. */
  noResultsMessage: _.node,
  /** Controls whether or not the results menu is displayed. */
  open: _.bool,
  /**
   * One of:
   * - array of Search.Result props e.g. `{ title: '', description: '' }` or
   * - object of categories e.g. `{ name: '', results: [{ title: '', description: '' }]`
   */
  results: _.oneOfType([_.arrayOf(_.shape(Mk.propTypes)), _.shape(NC.propTypes)]),
  /** Whether the search should automatically select the first result after searching. */
  selectFirstResult: _.bool,
  /** Whether a "no results" message should be shown if no results are found. */
  showNoResults: _.bool,
  /** Current value of the search input. Creates a controlled component. */
  value: _.string,
  // ------------------------------------
  // Rendering
  // ------------------------------------
  /**
   * Renders the SearchCategory layout.
   *
   * @param {object} categoryContent - The Renderable SearchCategory contents.
   * @param {object} resultsContent - The Renderable SearchResult contents.
   * @returns {*} - Renderable SearchCategory layout.
   */
  categoryLayoutRenderer: _.func,
  /**
   * Renders the SearchCategory contents.
   *
   * @param {object} props - The SearchCategory props object.
   * @returns {*} - Renderable SearchCategory contents.
   */
  categoryRenderer: _.func,
  /**
   * Renders the SearchResult contents.
   *
   * @param {object} props - The SearchResult props object.
   * @returns {*} - Renderable SearchResult contents.
   */
  resultRenderer: _.func,
  // ------------------------------------
  // Callbacks
  // ------------------------------------
  /**
   * Called on blur.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onBlur: _.func,
  /**
   * Called on focus.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onFocus: _.func,
  /**
   * Called on mousedown.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onMouseDown: _.func,
  /**
   * Called when a result is selected.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onResultSelect: _.func,
  /**
   * Called on search input change.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props, includes current value of search input.
   */
  onSearchChange: _.func,
  /**
   * Called when the active selection index is changed.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onSelectionChange: _.func,
  // ------------------------------------
  // Style
  // ------------------------------------
  /** A search can have its results aligned to its left or right container edge. */
  aligned: _.string,
  /** A search can display results from remote content ordered by categories. */
  category: _.bool,
  /** Additional classes. */
  className: _.string,
  /** A search can have its results take up the width of its container. */
  fluid: _.bool,
  /** Shorthand for input element. */
  input: Vn,
  /** A search can show a loading indicator. */
  loading: _.bool,
  /** A search can have different sizes. */
  size: _.oneOf(pi(mc, "medium")),
  /** A search can show placeholder text when empty. */
  placeholder: _.string
} : {};
D2.defaultProps = {
  icon: "search",
  input: "text",
  minCharacters: 1,
  noResultsMessage: "No results found.",
  showNoResults: !0
};
D2.autoControlledProps = ["open", "value"];
D2.Category = NC;
D2.Result = Mk;
D2.Results = dk;
var pNe = function(o) {
  if (o) {
    var c, i, d;
    return typeof o.window == "object" && o.window === o ? o.event : (c = (i = o.ownerDocument) == null || (d = i.defaultView) == null ? void 0 : d.event) != null ? c : void 0;
  }
}, Sde = function(o, c) {
  return o ? !!o[c] : !1;
}, hNe = function(o) {
  var c = o.capture, i = o.listener, d = o.type, m = o.target, v = o.targetRef, g = Ya.useRef(i);
  g.current = i;
  var C = Ya.useCallback(function(R) {
    return g.current(R);
  }, []), O = Ya.useRef(void 0);
  process.env.NODE_ENV !== "production" && Ya.useEffect(function() {
    if (typeof m < "u" && typeof v < "u")
      throw new Error("`target` and `targetRef` props are mutually exclusive, please use one of them.");
    if (typeof m > "u" && typeof v > "u")
      throw new Error("`target` and `targetRef` props are `undefined`, it' required to use one of them.");
  }, [m, v]), Ya.useEffect(function() {
    var R = typeof v > "u" ? m : v.current, I = pNe(window), L = function(ne) {
      if (ne === I) {
        I = void 0;
        return;
      }
      C(ne);
    };
    if (Sde(R, "addEventListener"))
      R.addEventListener(d, L, c);
    else if (process.env.NODE_ENV !== "production")
      throw new Error("@fluentui/react-component-event-listener: Passed `element` is not valid or does not support `addEventListener()` method.");
    return O.current = setTimeout(function() {
      I = void 0;
    }, 1), function() {
      if (clearTimeout(O.current), I = void 0, Sde(R, "removeEventListener"))
        R.removeEventListener(d, L, c);
      else if (process.env.NODE_ENV !== "production")
        throw new Error("@fluentui/react-component-event-listener: Passed `element` is not valid or does not support `removeEventListener()` method.");
    };
  }, [c, C, m, v, d]);
}, gNe = /* @__PURE__ */ function() {
  function r(o) {
    return hNe(o), null;
  }
  return r.defaultProps = {
    capture: !1
  }, r;
}(), vNe = {
  current: typeof document > "u" ? null : document
};
function R$(r) {
  var o = r.className, c = r.children, i = r.content, d = Vt("pushable", o), m = zt(R$, r), v = Xt(R$, r);
  return /* @__PURE__ */ ae.createElement(v, Be({}, m, {
    className: d
  }), dn(c) ? i : c);
}
R$.handledProps = ["as", "children", "className", "content"];
R$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
function P$(r) {
  var o = r.className, c = r.dimmed, i = r.children, d = r.content, m = Vt("pusher", $e(c, "dimmed"), o), v = zt(P$, r), g = Xt(P$, r);
  return /* @__PURE__ */ ae.createElement(g, Be({}, v, {
    className: m
  }), dn(i) ? d : i);
}
P$.handledProps = ["as", "children", "className", "content", "dimmed"];
P$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** Controls whether or not the dim is displayed. */
  dimmed: _.bool
} : {};
var $2 = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o(i) {
    var d;
    return d = r.call(this, i) || this, d.ref = /* @__PURE__ */ bp(), d.handleAnimationStart = function() {
      var m = d.props.visible, v = m ? "onVisible" : "onHide";
      if (clearTimeout(d.animationTimer), d.animationTimer = setTimeout(d.handleAnimationEnd, o.animationDuration), d.skipNextCallback) {
        d.skipNextCallback = !1;
        return;
      }
      xn(d.props, v, null, d.props);
    }, d.handleAnimationEnd = function() {
      var m = d.props.visible, v = m ? "onShow" : "onHidden";
      d.setState({
        animationTick: 0
      }), xn(d.props, v, null, d.props);
    }, d.handleDocumentClick = function(m) {
      f2(d.ref.current, m) || (d.skipNextCallback = !0, xn(d.props, "onHide", m, Be({}, d.props, {
        visible: !1
      })));
    }, d.state = {
      animationTick: 0,
      visible: i.visible
    }, d;
  }
  o.getDerivedStateFromProps = function(d, m) {
    var v = !!d.visible == !!m.visible ? 0 : 1;
    return {
      animationTick: m.animationTick + v,
      visible: d.visible
    };
  };
  var c = o.prototype;
  return c.componentDidUpdate = function(d, m) {
    this.state.animationTick > m.animationTick && this.handleAnimationStart();
  }, c.componentWillUnmount = function() {
    clearTimeout(this.animationTimer);
  }, c.render = function() {
    var d = this.props, m = d.animation, v = d.className, g = d.children, C = d.content, O = d.direction, R = d.target, I = d.visible, L = d.width, Z = this.state.animationTick, ne = Vt("ui", m, O, L, $e(Z > 0, "animating"), $e(I, "visible"), "sidebar", v), se = zt(o, this.props), Q = Xt(o, this.props), he = zA(R) ? {
      targetRef: R
    } : {
      target: R
    };
    return /* @__PURE__ */ ae.createElement(ae.Fragment, null, /* @__PURE__ */ ae.createElement(yp, {
      innerRef: this.ref
    }, /* @__PURE__ */ ae.createElement(Q, Be({}, se, {
      className: ne
    }), dn(g) ? C : g)), I && /* @__PURE__ */ ae.createElement(gNe, Be({
      listener: this.handleDocumentClick,
      type: "click"
    }, he)));
  }, o;
}(Do);
$2.handledProps = ["animation", "as", "children", "className", "content", "direction", "onHidden", "onHide", "onShow", "onVisible", "target", "visible", "width"];
$2.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Animation style. */
  animation: _.oneOf(["overlay", "push", "scale down", "uncover", "slide out", "slide along"]),
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** Direction the sidebar should appear on. */
  direction: _.oneOf(["top", "right", "bottom", "left"]),
  /**
   * Called before a sidebar begins to animate out.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onHide: _.func,
  /**
   * Called after a sidebar has finished animating out.
   *
   * @param {null}
   * @param {object} data - All props.
   */
  onHidden: _.func,
  /**
   * Called when a sidebar has finished animating in.
   *
   * @param {null}
   * @param {object} data - All props.
   */
  onShow: _.func,
  /**
   * Called when a sidebar begins animating in.
   *
   * @param {null}
   * @param {object} data - All props.
   */
  onVisible: _.func,
  /** A sidebar can handle clicks on the passed element. */
  target: _.oneOfType([dse, yB]),
  /** Controls whether or not the sidebar is visible on the page. */
  visible: _.bool,
  /** Sidebar width. */
  width: _.oneOf(["very thin", "thin", "wide", "very wide"])
} : {};
$2.defaultProps = {
  direction: "left",
  target: vNe,
  visible: !1
};
$2.animationDuration = 500;
$2.autoControlledProps = ["visible"];
$2.Pushable = R$;
$2.Pusher = P$;
const bNe = $2;
var Ij = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.state = {
      active: !0,
      sticky: !1
    }, i.stickyRef = /* @__PURE__ */ bp(), i.triggerRef = /* @__PURE__ */ bp(), i.addListeners = function(g) {
      var C = zA(g) ? g.current : g;
      C && (Ql.sub("resize", i.handleUpdate, {
        target: C
      }), Ql.sub("scroll", i.handleUpdate, {
        target: C
      }));
    }, i.removeListeners = function(g) {
      var C = zA(g) ? g.current : g;
      C && (Ql.unsub("resize", i.handleUpdate, {
        target: C
      }), Ql.unsub("scroll", i.handleUpdate, {
        target: C
      }));
    }, i.update = function(g) {
      var C = i.state.pushing;
      if (i.ticking = !1, i.assignRects(), C)
        return i.didReachStartingPoint() ? i.stickToContextTop(g) : i.didTouchScreenBottom() ? i.stickToScreenBottom(g) : i.stickToContextBottom(g);
      if (i.isOversized()) {
        if (i.contextRect.top > 0)
          return i.stickToContextTop(g);
        if (i.contextRect.bottom < window.innerHeight)
          return i.stickToContextBottom(g);
      }
      return i.didTouchScreenTop() ? i.didReachContextBottom() ? i.stickToContextBottom(g) : i.stickToScreenTop(g) : i.stickToContextTop(g);
    }, i.handleUpdate = function(g) {
      i.ticking || (i.ticking = !0, i.frameId = requestAnimationFrame(function() {
        return i.update(g);
      }));
    }, i.assignRects = function() {
      var g = i.props.context, C = zA(g) ? g.current : g || document.body;
      i.triggerRect = i.triggerRef.current.getBoundingClientRect(), i.contextRect = C.getBoundingClientRect(), i.stickyRect = i.stickyRef.current.getBoundingClientRect();
    }, i.didReachContextBottom = function() {
      var g = i.props.offset;
      return i.stickyRect.height + g >= i.contextRect.bottom;
    }, i.didReachStartingPoint = function() {
      return i.stickyRect.top <= i.triggerRect.top;
    }, i.didTouchScreenTop = function() {
      return i.triggerRect.top < i.props.offset;
    }, i.didTouchScreenBottom = function() {
      var g = i.props.bottomOffset;
      return i.contextRect.bottom + g > window.innerHeight;
    }, i.isOversized = function() {
      return i.stickyRect.height > window.innerHeight;
    }, i.pushing = function(g) {
      var C = i.props.pushing;
      C && i.setState({
        pushing: g
      });
    }, i.stick = function(g, C) {
      i.setState({
        bound: C,
        sticky: !0
      }), xn(i.props, "onStick", g, i.props);
    }, i.unstick = function(g, C) {
      i.setState({
        bound: C,
        sticky: !1
      }), xn(i.props, "onUnstick", g, i.props);
    }, i.stickToContextBottom = function(g) {
      xn(i.props, "onBottom", g, i.props), i.stick(g, !0), i.pushing(!0);
    }, i.stickToContextTop = function(g) {
      xn(i.props, "onTop", g, i.props), i.unstick(g, !1), i.pushing(!1);
    }, i.stickToScreenBottom = function(g) {
      var C = i.props.bottomOffset;
      i.stick(g, !1), i.setState({
        bottom: C,
        top: null
      });
    }, i.stickToScreenTop = function(g) {
      var C = i.props.offset;
      i.stick(g, !1), i.setState({
        top: C,
        bottom: null
      });
    }, i;
  }
  var c = o.prototype;
  return c.componentDidMount = function() {
    if ($v()) {
      var d = this.state.active;
      d && (this.handleUpdate(), this.addListeners(this.props.scrollContext));
    }
  }, o.getDerivedStateFromProps = function(d, m) {
    return m.active !== d.active && !d.active ? {
      active: d.active,
      sticky: !1
    } : {
      active: d.active
    };
  }, c.componentDidUpdate = function(d, m) {
    if (m.active === this.state.active) {
      d.scrollContext !== this.props.scrollContext && (this.removeListeners(d.scrollContext), this.addListeners(this.props.scrollContext));
      return;
    }
    if (this.state.active) {
      this.handleUpdate(), this.addListeners(this.props.scrollContext);
      return;
    }
    this.removeListeners(d.scrollContext);
  }, c.componentWillUnmount = function() {
    if ($v()) {
      var d = this.state.active;
      d && (this.removeListeners(this.props.scrollContext), cancelAnimationFrame(this.frameId));
    }
  }, c.computeStyle = function() {
    var d = this.props.styleElement, m = this.state, v = m.bottom, g = m.bound, C = m.sticky, O = m.top;
    return C ? Be({
      bottom: g ? 0 : v,
      top: g ? void 0 : O,
      width: this.triggerRect.width
    }, d) : d;
  }, c.render = function() {
    var d = this.props, m = d.children, v = d.className, g = this.state, C = g.bottom, O = g.bound, R = g.sticky, I = zt(o, this.props), L = Xt(o, this.props), Z = Vt(R && "ui", R && "stuck-container", R && (O ? "bound-container" : "fixed-container"), v), ne = Vt("ui", R && (O ? "bound bottom" : "fixed"), R && !O && (C === null ? "top" : "bottom"), "sticky"), se = R && this.stickyRect ? {
      height: this.stickyRect.height
    } : {};
    return /* @__PURE__ */ ae.createElement(L, Be({}, I, {
      className: Z
    }), /* @__PURE__ */ ae.createElement("div", {
      ref: this.triggerRef,
      style: se
    }), /* @__PURE__ */ ae.createElement("div", {
      className: ne,
      ref: this.stickyRef,
      style: this.computeStyle()
    }, m));
  }, o;
}(Do);
Ij.handledProps = ["active", "as", "bottomOffset", "children", "className", "context", "offset", "onBottom", "onStick", "onTop", "onUnstick", "pushing", "scrollContext", "styleElement"];
Ij.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** A Sticky can be active. */
  active: _.bool,
  /** Offset in pixels from the bottom of the screen when fixing element to viewport. */
  bottomOffset: _.number,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Context which sticky element should stick to. */
  context: _.oneOfType([dse, yB]),
  /** Offset in pixels from the top of the screen when fixing element to viewport. */
  offset: _.number,
  /**
   * Callback when element is bound to bottom of parent container.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onBottom: _.func,
  /**
   * Callback when element is fixed to page.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onStick: _.func,
  /**
   * Callback when element is bound to top of parent container.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onTop: _.func,
  /**
   * Callback when element is unfixed from page.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onUnstick: _.func,
  /** Whether element should be "pushed" by the viewport, attaching to the bottom of the screen when scrolling up. */
  pushing: _.bool,
  /** Context which sticky should attach onscroll events. */
  scrollContext: _.oneOfType([dse, yB]),
  /** Custom style for sticky element. */
  styleElement: _.object
} : {};
Ij.defaultProps = {
  active: !0,
  bottomOffset: 0,
  offset: 0,
  scrollContext: $v() ? window : null
};
function YS(r) {
  var o = r.active, c = r.children, i = r.className, d = r.content, m = r.loading, v = Vt($e(o, "active"), $e(m, "loading"), "tab", i), g = zt(YS, r), C = Xt(YS, r), O = {};
  return C === ZS && (O.attached = "bottom"), /* @__PURE__ */ ae.createElement(C, Be({}, O, g, {
    className: v
  }), dn(c) ? d : c);
}
YS.handledProps = ["active", "as", "children", "className", "content", "loading"];
YS.defaultProps = {
  as: ZS,
  active: !0
};
YS.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** A tab pane can be active. */
  active: _.bool,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** A Tab.Pane can display a loading indicator. */
  loading: _.bool
} : {};
YS.create = lo(YS, function(r) {
  return {
    content: r
  };
});
var X$ = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.handleItemClick = function(g, C) {
      var O = C.index;
      xn(i.props, "onTabChange", g, Be({}, i.props, {
        activeIndex: O
      })), i.setState({
        activeIndex: O
      });
    }, i;
  }
  var c = o.prototype;
  return c.getInitialAutoControlledState = function() {
    return {
      activeIndex: 0
    };
  }, c.renderItems = function() {
    var d = this.props, m = d.panes, v = d.renderActiveOnly, g = this.state.activeIndex;
    return v ? xn(Oh(m, "[" + g + "]"), "render", this.props) : fi(m, function(C, O) {
      var R = C.pane;
      return YS.create(R, {
        overrideProps: {
          active: O === g
        }
      });
    });
  }, c.renderMenu = function() {
    var d = this.props, m = d.menu, v = d.panes, g = d.menuPosition, C = this.state.activeIndex;
    return m.tabular === !0 && g === "right" && (m.tabular = "right"), h2.create(m, {
      autoGenerateKey: !1,
      overrideProps: {
        items: fi(v, "menuItem"),
        onItemClick: this.handleItemClick,
        activeIndex: C
      }
    });
  }, c.renderVertical = function(d) {
    var m = this.props, v = m.grid, g = m.menuPosition, C = v.paneWidth, O = v.tabWidth, R = O1(v, ["paneWidth", "tabWidth"]), I = g || d.props.tabular === "right" && "right" || "left";
    return /* @__PURE__ */ ae.createElement(Pv, R, I === "left" && x1.create({
      width: O,
      children: d
    }, {
      autoGenerateKey: !1
    }), x1.create({
      width: C,
      children: this.renderItems(),
      stretched: !0
    }, {
      autoGenerateKey: !1
    }), I === "right" && x1.create({
      width: O,
      children: d
    }, {
      autoGenerateKey: !1
    }));
  }, c.render = function() {
    var d = this.renderMenu(), m = zt(o, this.props), v = Xt(o, this.props);
    return d.props.vertical ? /* @__PURE__ */ ae.createElement(v, m, this.renderVertical(d)) : /* @__PURE__ */ ae.createElement(v, m, d.props.attached !== "bottom" && d, this.renderItems(), d.props.attached === "bottom" && d);
  }, o;
}(P1);
X$.handledProps = ["activeIndex", "as", "defaultActiveIndex", "grid", "menu", "menuPosition", "onTabChange", "panes", "renderActiveOnly"];
X$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** The initial activeIndex. */
  defaultActiveIndex: _.oneOfType([_.number, _.string]),
  /** Index of the currently active tab. */
  activeIndex: _.oneOfType([_.number, _.string]),
  /**
   * Shorthand props for the Menu.
   * tabular, if true, will derive final value from `menuPosition`, otherwise set 'left' or 'right' explicitly.
   */
  menu: _.object,
  /** Align vertical menu */
  menuPosition: _.oneOf(["left", "right"]),
  /** Shorthand props for the Grid. Only applicable to vertical menus. */
  grid: _.object,
  /**
   * Called on tab change.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props and proposed new activeIndex.
   * @param {object} data.activeIndex - The new proposed activeIndex.
   */
  onTabChange: _.func,
  /**
   * Array of objects describing each Menu.Item and Tab.Pane:
   * { menuItem: 'Home', render: () => <Tab.Pane /> }
   * or
   * { menuItem: 'Home', pane: 'Welcome' }
   */
  panes: _.arrayOf(_.shape({
    menuItem: Vn,
    pane: Vn,
    render: _.func
  })),
  /** A Tab can render only active pane. */
  renderActiveOnly: _.bool
} : {};
X$.autoControlledProps = ["activeIndex"];
X$.defaultProps = {
  grid: {
    paneWidth: 12,
    tabWidth: 4
  },
  menu: {
    attached: !0,
    tabular: !0
  },
  renderActiveOnly: !0
};
X$.Pane = YS;
const yNe = X$;
function PB(r) {
  var o = r.centered, c = r.children, i = r.className, d = r.content, m = r.test, v = r.unit, g = Vt("ui", v, $e(o, "centered"), $e(m, "test"), "ad", i), C = zt(PB, r), O = Xt(PB, r);
  return /* @__PURE__ */ ae.createElement(O, Be({}, C, {
    className: g,
    "data-text": m
  }), dn(c) ? d : c);
}
PB.handledProps = ["as", "centered", "children", "className", "content", "test", "unit"];
PB.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Center the advertisement. */
  centered: _.bool,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** Text to be displayed on the advertisement. */
  test: _.oneOfType([_.bool, _.number, _.string]),
  /** Varies the size of the advertisement. */
  unit: _.oneOf(["medium rectangle", "large rectangle", "vertical rectangle", "small rectangle", "mobile banner", "banner", "vertical banner", "top banner", "half banner", "button", "square button", "small button", "skyscraper", "wide skyscraper", "leaderboard", "large leaderboard", "mobile leaderboard", "billboard", "panorama", "netboard", "half page", "square", "small square"]).isRequired
} : {};
function fk(r) {
  var o = r.children, c = r.className, i = r.content, d = r.textAlign, m = Vt(Dg(d), "description", c), v = zt(fk, r), g = Xt(fk, r);
  return /* @__PURE__ */ ae.createElement(g, Be({}, v, {
    className: m
  }), dn(o) ? i : o);
}
fk.handledProps = ["as", "children", "className", "content", "textAlign"];
fk.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** A card content can adjust its text alignment. */
  textAlign: _.oneOf(pi($g, "justified"))
} : {};
function mk(r) {
  var o = r.children, c = r.className, i = r.content, d = r.textAlign, m = Vt(Dg(d), "header", c), v = zt(mk, r), g = Xt(mk, r);
  return /* @__PURE__ */ ae.createElement(g, Be({}, v, {
    className: m
  }), dn(o) ? i : o);
}
mk.handledProps = ["as", "children", "className", "content", "textAlign"];
mk.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** A card header can adjust its text alignment. */
  textAlign: _.oneOf(pi($g, "justified"))
} : {};
function pk(r) {
  var o = r.children, c = r.className, i = r.content, d = r.textAlign, m = Vt(Dg(d), "meta", c), v = zt(pk, r), g = Xt(pk, r);
  return /* @__PURE__ */ ae.createElement(g, Be({}, v, {
    className: m
  }), dn(o) ? i : o);
}
pk.handledProps = ["as", "children", "className", "content", "textAlign"];
pk.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** A card meta can adjust its text alignment. */
  textAlign: _.oneOf(pi($g, "justified"))
} : {};
function x2(r) {
  var o = r.children, c = r.className, i = r.content, d = r.description, m = r.extra, v = r.header, g = r.meta, C = r.textAlign, O = Vt($e(m, "extra"), Dg(C), "content", c), R = zt(x2, r), I = Xt(x2, r);
  return dn(o) ? dn(i) ? /* @__PURE__ */ ae.createElement(I, Be({}, R, {
    className: O
  }), gp(mk, function(L) {
    return {
      content: L
    };
  }, v, {
    autoGenerateKey: !1
  }), gp(pk, function(L) {
    return {
      content: L
    };
  }, g, {
    autoGenerateKey: !1
  }), gp(fk, function(L) {
    return {
      content: L
    };
  }, d, {
    autoGenerateKey: !1
  })) : /* @__PURE__ */ ae.createElement(I, Be({}, R, {
    className: O
  }), i) : /* @__PURE__ */ ae.createElement(I, Be({}, R, {
    className: O
  }), o);
}
x2.handledProps = ["as", "children", "className", "content", "description", "extra", "header", "meta", "textAlign"];
x2.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** Shorthand for CardDescription. */
  description: Vn,
  /** A card can contain extra content meant to be formatted separately from the main content. */
  extra: _.bool,
  /** Shorthand for CardHeader. */
  header: Vn,
  /** Shorthand for CardMeta. */
  meta: Vn,
  /** A card content can adjust its text alignment. */
  textAlign: _.oneOf(pi($g, "justified"))
} : {};
function D$(r) {
  var o = r.centered, c = r.children, i = r.className, d = r.content, m = r.doubling, v = r.items, g = r.itemsPerRow, C = r.stackable, O = r.textAlign, R = Vt("ui", $e(o, "centered"), $e(m, "doubling"), $e(C, "stackable"), Dg(O), Kf(g), "cards", i), I = zt(D$, r), L = Xt(D$, r);
  if (!dn(c))
    return /* @__PURE__ */ ae.createElement(L, Be({}, I, {
      className: R
    }), c);
  if (!dn(d))
    return /* @__PURE__ */ ae.createElement(L, Be({}, I, {
      className: R
    }), d);
  var Z = fi(v, function(ne) {
    var se, Q = (se = ne.key) != null ? se : [ne.header, ne.description].join("-");
    return /* @__PURE__ */ ae.createElement(Tu, Be({
      key: Q
    }, ne));
  });
  return /* @__PURE__ */ ae.createElement(L, Be({}, I, {
    className: R
  }), Z);
}
D$.handledProps = ["as", "centered", "children", "className", "content", "doubling", "items", "itemsPerRow", "stackable", "textAlign"];
D$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** A group of cards can center itself inside its container. */
  centered: _.bool,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** A group of cards can double its column width for mobile. */
  doubling: _.bool,
  /** Shorthand array of props for Card. */
  items: Dh,
  /** A group of cards can set how many cards should exist in a row. */
  itemsPerRow: _.oneOf(hp),
  /** A group of cards can automatically stack rows to a single columns on mobile devices. */
  stackable: _.bool,
  /** A card group can adjust its text alignment. */
  textAlign: _.oneOf(pi($g, "justified"))
} : {};
var Tu = /* @__PURE__ */ function(r) {
  Zo(o, r);
  function o() {
    for (var i, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return i = r.call.apply(r, [this].concat(m)) || this, i.handleClick = function(g) {
      var C = i.props.onClick;
      C && C(g, i.props);
    }, i;
  }
  var c = o.prototype;
  return c.render = function() {
    var d = this.props, m = d.centered, v = d.children, g = d.className, C = d.color, O = d.content, R = d.description, I = d.extra, L = d.fluid, Z = d.header, ne = d.href, se = d.image, Q = d.link, he = d.meta, ue = d.onClick, G = d.raised, me = Vt("ui", C, $e(m, "centered"), $e(L, "fluid"), $e(Q, "link"), $e(G, "raised"), "card", g), we = zt(o, this.props), be = Xt(o, this.props, function() {
      if (ue)
        return "a";
    });
    return dn(v) ? dn(O) ? /* @__PURE__ */ ae.createElement(be, Be({}, we, {
      className: me,
      href: ne,
      onClick: this.handleClick
    }), Qf.create(se, {
      autoGenerateKey: !1,
      defaultProps: {
        ui: !1,
        wrapped: !0
      }
    }), (R || Z || he) && /* @__PURE__ */ ae.createElement(x2, {
      description: R,
      header: Z,
      meta: he
    }), I && /* @__PURE__ */ ae.createElement(x2, {
      extra: !0
    }, I)) : /* @__PURE__ */ ae.createElement(be, Be({}, we, {
      className: me,
      href: ne,
      onClick: this.handleClick
    }), O) : /* @__PURE__ */ ae.createElement(be, Be({}, we, {
      className: me,
      href: ne,
      onClick: this.handleClick
    }), v);
  }, o;
}(Do);
Tu.handledProps = ["as", "centered", "children", "className", "color", "content", "description", "extra", "fluid", "header", "href", "image", "link", "meta", "onClick", "raised"];
Tu.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** A Card can center itself inside its container. */
  centered: _.bool,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** A Card can be formatted to display different colors. */
  color: _.oneOf(Om),
  /** Shorthand for primary content. */
  content: In,
  /** Shorthand for CardDescription. */
  description: Vn,
  /** Shorthand for primary content of CardContent. */
  extra: In,
  /** A Card can be formatted to take up the width of its container. */
  fluid: _.bool,
  /** Shorthand for CardHeader. */
  header: Vn,
  /** Render as an `a` tag instead of a `div` and adds the href attribute. */
  href: _.string,
  /** A card can contain an Image component. */
  image: Vn,
  /** A card can be formatted to link to other content. */
  link: _.bool,
  /** Shorthand for CardMeta. */
  meta: Vn,
  /**
   * Called on click. When passed, the component renders as an `a`
   * tag by default instead of a `div`.
   *
   * @param {SyntheticEvent} event - React's original SyntheticEvent.
   * @param {object} data - All props.
   */
  onClick: _.func,
  /** A Card can be formatted to raise above the page. */
  raised: _.bool
} : {};
Tu.Content = x2;
Tu.Description = fk;
Tu.Group = D$;
Tu.Header = mk;
Tu.Meta = pk;
function hk(r) {
  var o = r.active, c = r.className, i = r.children, d = r.content, m = Vt($e(o, "active"), c), v = zt(hk, r), g = Xt(hk, r);
  return /* @__PURE__ */ ae.createElement(g, Be({}, v, {
    className: m
  }), dn(i) ? d : i);
}
hk.handledProps = ["active", "as", "children", "className", "content"];
hk.defaultProps = {
  as: "a"
};
hk.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Style as the currently active action. */
  active: _.bool,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
function $$(r) {
  var o = r.className, c = r.children, i = r.content, d = Vt("actions", o), m = zt($$, r), v = Xt($$, r);
  return /* @__PURE__ */ ae.createElement(v, Be({}, m, {
    className: d
  }), dn(c) ? i : c);
}
$$.handledProps = ["as", "children", "className", "content"];
$$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
function I$(r) {
  var o = r.className, c = r.children, i = r.content, d = Vt("author", o), m = zt(I$, r), v = Xt(I$, r);
  return /* @__PURE__ */ ae.createElement(v, Be({}, m, {
    className: d
  }), dn(c) ? i : c);
}
I$.handledProps = ["as", "children", "className", "content"];
I$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
function M$(r) {
  var o = r.className, c = r.src, i = Vt("avatar", o), d = zt(M$, r), m = VB(d, {
    htmlProps: hhe
  }), v = m[0], g = m[1], C = Xt(M$, r);
  return /* @__PURE__ */ ae.createElement(C, Be({}, g, {
    className: i
  }), Cj(c, {
    autoGenerateKey: !1,
    defaultProps: v
  }));
}
M$.handledProps = ["as", "className", "src"];
M$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Additional classes. */
  className: _.string,
  /** Specifies the URL of the image. */
  src: _.string
} : {};
function F$(r) {
  var o = r.className, c = r.children, i = r.content, d = Vt(o, "content"), m = zt(F$, r), v = Xt(F$, r);
  return /* @__PURE__ */ ae.createElement(v, Be({}, m, {
    className: d
  }), dn(c) ? i : c);
}
F$.handledProps = ["as", "children", "className", "content"];
F$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
function L$(r) {
  var o = r.className, c = r.children, i = r.collapsed, d = r.content, m = r.minimal, v = r.size, g = r.threaded, C = Vt("ui", v, $e(i, "collapsed"), $e(m, "minimal"), $e(g, "threaded"), "comments", o), O = zt(L$, r), R = Xt(L$, r);
  return /* @__PURE__ */ ae.createElement(R, Be({}, O, {
    className: C
  }), dn(c) ? d : c);
}
L$.handledProps = ["as", "children", "className", "collapsed", "content", "minimal", "size", "threaded"];
L$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Comments can be collapsed, or hidden from view. */
  collapsed: _.bool,
  /** Shorthand for primary content. */
  content: In,
  /** Comments can hide extra information unless a user shows intent to interact with a comment. */
  minimal: _.bool,
  /** Comments can have different sizes. */
  size: _.oneOf(pi(mc, "medium")),
  /** A comment list can be threaded to showing the relationship between conversations. */
  threaded: _.bool
} : {};
function B$(r) {
  var o = r.className, c = r.children, i = r.content, d = Vt("metadata", o), m = zt(B$, r), v = Xt(B$, r);
  return /* @__PURE__ */ ae.createElement(v, Be({}, m, {
    className: d
  }), dn(c) ? i : c);
}
B$.handledProps = ["as", "children", "className", "content"];
B$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
function H$(r) {
  var o = r.className, c = r.children, i = r.content, d = Vt(o, "text"), m = zt(H$, r), v = Xt(H$, r);
  return /* @__PURE__ */ ae.createElement(v, Be({}, m, {
    className: d
  }), dn(c) ? i : c);
}
H$.handledProps = ["as", "children", "className", "content"];
H$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
function Hv(r) {
  var o = r.className, c = r.children, i = r.collapsed, d = r.content, m = Vt($e(i, "collapsed"), "comment", o), v = zt(Hv, r), g = Xt(Hv, r);
  return /* @__PURE__ */ ae.createElement(g, Be({}, v, {
    className: m
  }), dn(c) ? d : c);
}
Hv.handledProps = ["as", "children", "className", "collapsed", "content"];
Hv.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Comment can be collapsed, or hidden from view. */
  collapsed: _.bool,
  /** Shorthand for primary content. */
  content: In
} : {};
Hv.Author = I$;
Hv.Action = hk;
Hv.Actions = $$;
Hv.Avatar = M$;
Hv.Content = F$;
Hv.Group = L$;
Hv.Metadata = B$;
Hv.Text = H$;
function T2(r) {
  var o = r.children, c = r.className, i = r.content, d = Vt("date", c), m = zt(T2, r), v = Xt(T2, r);
  return /* @__PURE__ */ ae.createElement(v, Be({}, m, {
    className: d
  }), dn(o) ? i : o);
}
T2.handledProps = ["as", "children", "className", "content"];
T2.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
function RC(r) {
  var o = r.children, c = r.className, i = r.content, d = r.images, m = r.text, v = Vt($e(d, "images"), $e(i || m, "text"), "extra", c), g = zt(RC, r), C = Xt(RC, r);
  if (!dn(o))
    return /* @__PURE__ */ ae.createElement(C, Be({}, g, {
      className: v
    }), o);
  var O = fi(d, function(R, I) {
    var L = [I, R].join("-");
    return Cj(R, {
      key: L
    });
  });
  return /* @__PURE__ */ ae.createElement(C, Be({}, g, {
    className: v
  }), i, O);
}
RC.handledProps = ["as", "children", "className", "content", "images", "text"];
RC.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** An event can contain additional information like a set of images. */
  images: co([Go(["text"]), _.oneOfType([_.bool, Dh])]),
  /** An event can contain additional text information. */
  text: _.bool
} : {};
function _2(r) {
  var o = r.children, c = r.className, i = r.content, d = r.icon, m = Vt("like", c), v = zt(_2, r), g = Xt(_2, r);
  return dn(o) ? /* @__PURE__ */ ae.createElement(g, Be({}, v, {
    className: m
  }), fc.create(d, {
    autoGenerateKey: !1
  }), i) : /* @__PURE__ */ ae.createElement(g, Be({}, v, {
    className: m
  }), o);
}
_2.handledProps = ["as", "children", "className", "content", "icon"];
_2.defaultProps = {
  as: "a"
};
_2.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** Shorthand for icon. Mutually exclusive with children. */
  icon: Vn
} : {};
function gk(r) {
  var o = r.children, c = r.className, i = r.content, d = r.like, m = Vt("meta", c), v = zt(gk, r), g = Xt(gk, r);
  return dn(o) ? /* @__PURE__ */ ae.createElement(g, Be({}, v, {
    className: m
  }), gp(_2, function(C) {
    return {
      content: C
    };
  }, d, {
    autoGenerateKey: !1
  }), i) : /* @__PURE__ */ ae.createElement(g, Be({}, v, {
    className: m
  }), o);
}
gk.handledProps = ["as", "children", "className", "content", "like"];
gk.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** Shorthand for FeedLike. */
  like: Vn
} : {};
function O2(r) {
  var o = r.children, c = r.className, i = r.content, d = Vt("user", c), m = zt(O2, r), v = Xt(O2, r);
  return /* @__PURE__ */ ae.createElement(v, Be({}, m, {
    className: d
  }), dn(o) ? i : o);
}
O2.handledProps = ["as", "children", "className", "content"];
O2.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
O2.defaultProps = {
  as: "a"
};
function vk(r) {
  var o = r.children, c = r.className, i = r.content, d = r.date, m = r.user, v = Vt("summary", c), g = zt(vk, r), C = Xt(vk, r);
  return dn(o) ? /* @__PURE__ */ ae.createElement(C, Be({}, g, {
    className: v
  }), gp(O2, function(O) {
    return {
      content: O
    };
  }, m, {
    autoGenerateKey: !1
  }), i && " ", i, i && " ", gp(T2, function(O) {
    return {
      content: O
    };
  }, d, {
    autoGenerateKey: !1
  })) : /* @__PURE__ */ ae.createElement(C, Be({}, g, {
    className: v
  }), o);
}
vk.handledProps = ["as", "children", "className", "content", "date", "user"];
vk.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** Shorthand for FeedDate. */
  date: Vn,
  /** Shorthand for FeedUser. */
  user: Vn
} : {};
function bk(r) {
  var o = r.children, c = r.className, i = r.content, d = r.extraImages, m = r.extraText, v = r.date, g = r.meta, C = r.summary, O = Vt("content", c), R = zt(bk, r), I = Xt(bk, r);
  return dn(o) ? /* @__PURE__ */ ae.createElement(I, Be({}, R, {
    className: O
  }), gp(T2, function(L) {
    return {
      content: L
    };
  }, v, {
    autoGenerateKey: !1
  }), gp(vk, function(L) {
    return {
      content: L
    };
  }, C, {
    autoGenerateKey: !1
  }), i, gp(RC, function(L) {
    return {
      text: !0,
      content: L
    };
  }, m, {
    autoGenerateKey: !1
  }), gp(RC, function(L) {
    return {
      images: L
    };
  }, d, {
    autoGenerateKey: !1
  }), gp(gk, function(L) {
    return {
      content: L
    };
  }, g, {
    autoGenerateKey: !1
  })) : /* @__PURE__ */ ae.createElement(I, Be({}, R, {
    className: O
  }), o);
}
bk.handledProps = ["as", "children", "className", "content", "date", "extraImages", "extraText", "meta", "summary"];
bk.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** An event can contain a date. */
  date: Vn,
  /** Shorthand for FeedExtra with images. */
  extraImages: RC.propTypes.images,
  /** Shorthand for FeedExtra with text. */
  extraText: Vn,
  /** Shorthand for FeedMeta. */
  meta: Vn,
  /** Shorthand for FeedSummary. */
  summary: Vn
} : {};
function A2(r) {
  var o = r.children, c = r.className, i = r.content, d = r.icon, m = r.image, v = Vt("label", c), g = zt(A2, r), C = Xt(A2, r);
  return dn(o) ? /* @__PURE__ */ ae.createElement(C, Be({}, g, {
    className: v
  }), i, fc.create(d, {
    autoGenerateKey: !1
  }), Cj(m)) : /* @__PURE__ */ ae.createElement(C, Be({}, g, {
    className: v
  }), o);
}
A2.handledProps = ["as", "children", "className", "content", "icon", "image"];
A2.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** An event can contain icon label. */
  icon: Vn,
  /** An event can contain image label. */
  image: Vn
} : {};
function yk(r) {
  var o = r.content, c = r.children, i = r.className, d = r.date, m = r.extraImages, v = r.extraText, g = r.image, C = r.icon, O = r.meta, R = r.summary, I = Vt("event", i), L = zt(yk, r), Z = Xt(yk, r), ne = o || d || m || v || O || R, se = {
    content: o,
    date: d,
    extraImages: m,
    extraText: v,
    meta: O,
    summary: R
  };
  return /* @__PURE__ */ ae.createElement(Z, Be({}, L, {
    className: I
  }), gp(A2, function(Q) {
    return {
      icon: Q
    };
  }, C, {
    autoGenerateKey: !1
  }), gp(A2, function(Q) {
    return {
      image: Q
    };
  }, g, {
    autoGenerateKey: !1
  }), ne && /* @__PURE__ */ ae.createElement(bk, se), c);
}
yk.handledProps = ["as", "children", "className", "content", "date", "extraImages", "extraText", "icon", "image", "meta", "summary"];
yk.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for FeedContent. */
  content: Vn,
  /** Shorthand for FeedDate. */
  date: Vn,
  /** Shorthand for FeedExtra with images. */
  extraImages: Vn,
  /** Shorthand for FeedExtra with content. */
  extraText: Vn,
  /** An event can contain icon label. */
  icon: Vn,
  /** An event can contain image label. */
  image: Vn,
  /** Shorthand for FeedMeta. */
  meta: Vn,
  /** Shorthand for FeedSummary. */
  summary: Vn
} : {};
function Pg(r) {
  var o = r.children, c = r.className, i = r.events, d = r.size, m = Vt("ui", d, "feed", c), v = zt(Pg, r), g = Xt(Pg, r);
  if (!dn(o))
    return /* @__PURE__ */ ae.createElement(g, Be({}, v, {
      className: m
    }), o);
  var C = fi(i, function(O) {
    var R = O.childKey, I = O.date, L = O.meta, Z = O.summary, ne = O1(O, ["childKey", "date", "meta", "summary"]), se = R ?? [I, L, Z].join("-");
    return /* @__PURE__ */ ae.createElement(yk, Be({
      date: I,
      key: se,
      meta: L,
      summary: Z
    }, ne));
  });
  return /* @__PURE__ */ ae.createElement(g, Be({}, v, {
    className: m
  }), C);
}
Pg.handledProps = ["as", "children", "className", "events", "size"];
Pg.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand array of props for FeedEvent. */
  events: Dh,
  /** A feed can have different sizes. */
  size: _.oneOf(pi(mc, "mini", "tiny", "medium", "big", "huge", "massive"))
} : {};
Pg.Content = bk;
Pg.Date = T2;
Pg.Event = yk;
Pg.Extra = RC;
Pg.Label = A2;
Pg.Like = _2;
Pg.Meta = gk;
Pg.Summary = vk;
Pg.User = O2;
function PC(r) {
  var o = r.children, c = r.className, i = r.content, d = Vt("header", c), m = zt(PC, r), v = Xt(PC, r);
  return /* @__PURE__ */ ae.createElement(v, Be({}, m, {
    className: d
  }), dn(o) ? i : o);
}
PC.handledProps = ["as", "children", "className", "content"];
PC.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
PC.create = lo(PC, function(r) {
  return {
    content: r
  };
});
function DC(r) {
  var o = r.children, c = r.className, i = r.content, d = Vt("description", c), m = zt(DC, r), v = Xt(DC, r);
  return /* @__PURE__ */ ae.createElement(v, Be({}, m, {
    className: d
  }), dn(o) ? i : o);
}
DC.handledProps = ["as", "children", "className", "content"];
DC.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
DC.create = lo(DC, function(r) {
  return {
    content: r
  };
});
function $C(r) {
  var o = r.children, c = r.className, i = r.content, d = Vt("extra", c), m = zt($C, r), v = Xt($C, r);
  return /* @__PURE__ */ ae.createElement(v, Be({}, m, {
    className: d
  }), dn(o) ? i : o);
}
$C.handledProps = ["as", "children", "className", "content"];
$C.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
$C.create = lo($C, function(r) {
  return {
    content: r
  };
});
function IC(r) {
  var o = r.children, c = r.className, i = r.content, d = Vt("meta", c), m = zt(IC, r), v = Xt(IC, r);
  return /* @__PURE__ */ ae.createElement(v, Be({}, m, {
    className: d
  }), dn(o) ? i : o);
}
IC.handledProps = ["as", "children", "className", "content"];
IC.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
IC.create = lo(IC, function(r) {
  return {
    content: r
  };
});
function Sk(r) {
  var o = r.children, c = r.className, i = r.content, d = r.description, m = r.extra, v = r.header, g = r.meta, C = r.verticalAlign, O = Vt(by(C), "content", c), R = zt(Sk, r), I = Xt(Sk, r);
  return dn(o) ? /* @__PURE__ */ ae.createElement(I, Be({}, R, {
    className: O
  }), PC.create(v, {
    autoGenerateKey: !1
  }), IC.create(g, {
    autoGenerateKey: !1
  }), DC.create(d, {
    autoGenerateKey: !1
  }), $C.create(m, {
    autoGenerateKey: !1
  }), i) : /* @__PURE__ */ ae.createElement(I, Be({}, R, {
    className: O
  }), o);
}
Sk.handledProps = ["as", "children", "className", "content", "description", "extra", "header", "meta", "verticalAlign"];
Sk.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** Shorthand for ItemDescription component. */
  description: Vn,
  /** Shorthand for ItemExtra component. */
  extra: Vn,
  /** Shorthand for ItemHeader component. */
  header: Vn,
  /** Shorthand for ItemMeta component. */
  meta: Vn,
  /** Content can specify its vertical alignment. */
  verticalAlign: _.oneOf(D1)
} : {};
function z$(r) {
  var o = r.children, c = r.className, i = r.content, d = r.divided, m = r.items, v = r.link, g = r.relaxed, C = r.unstackable, O = Vt("ui", $e(d, "divided"), $e(v, "link"), $e(C, "unstackable"), mi(g, "relaxed"), "items", c), R = zt(z$, r), I = Xt(z$, r);
  if (!dn(o))
    return /* @__PURE__ */ ae.createElement(I, Be({}, R, {
      className: O
    }), o);
  if (!dn(i))
    return /* @__PURE__ */ ae.createElement(I, Be({}, R, {
      className: O
    }), i);
  var L = fi(m, function(Z) {
    var ne = Z.childKey, se = O1(Z, ["childKey"]), Q = ne ?? [se.content, se.description, se.header, se.meta].join("-");
    return /* @__PURE__ */ ae.createElement(rf, Be({}, se, {
      key: Q
    }));
  });
  return /* @__PURE__ */ ae.createElement(I, Be({}, R, {
    className: O
  }), L);
}
z$.handledProps = ["as", "children", "className", "content", "divided", "items", "link", "relaxed", "unstackable"];
z$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** Items can be divided to better distinguish between grouped content. */
  divided: _.bool,
  /** Shorthand array of props for Item. */
  items: Dh,
  /** An item can be formatted so that the entire contents link to another page. */
  link: _.bool,
  /** A group of items can relax its padding to provide more negative space. */
  relaxed: _.oneOfType([_.bool, _.oneOf(["very"])]),
  /** Prevent items from stacking on mobile. */
  unstackable: _.bool
} : {};
function k2(r) {
  var o = r.size, c = zt(k2, r);
  return /* @__PURE__ */ ae.createElement(Qf, Be({}, c, {
    size: o,
    ui: !!o,
    wrapped: !0
  }));
}
k2.handledProps = ["size"];
k2.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An image may appear at different sizes. */
  size: Qf.propTypes.size
} : {};
k2.create = lo(k2, function(r) {
  return {
    src: r
  };
});
function rf(r) {
  var o = r.children, c = r.className, i = r.content, d = r.description, m = r.extra, v = r.header, g = r.image, C = r.meta, O = Vt("item", c), R = zt(rf, r), I = Xt(rf, r);
  return dn(o) ? /* @__PURE__ */ ae.createElement(I, Be({}, R, {
    className: O
  }), k2.create(g, {
    autoGenerateKey: !1
  }), /* @__PURE__ */ ae.createElement(Sk, {
    content: i,
    description: d,
    extra: m,
    header: v,
    meta: C
  })) : /* @__PURE__ */ ae.createElement(I, Be({}, R, {
    className: O
  }), o);
}
rf.handledProps = ["as", "children", "className", "content", "description", "extra", "header", "image", "meta"];
rf.Content = Sk;
rf.Description = DC;
rf.Extra = $C;
rf.Group = z$;
rf.Header = PC;
rf.Image = k2;
rf.Meta = IC;
rf.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for ItemContent component. */
  content: In,
  /** Shorthand for ItemDescription component. */
  description: Vn,
  /** Shorthand for ItemExtra component. */
  extra: Vn,
  /** Shorthand for ItemHeader component. */
  header: Vn,
  /** Shorthand for ItemImage component. */
  image: Vn,
  /** Shorthand for ItemMeta component. */
  meta: Vn
} : {};
function V$(r) {
  var o = r.children, c = r.className, i = r.color, d = r.content, m = r.horizontal, v = r.inverted, g = r.items, C = r.size, O = r.widths, R = Vt("ui", i, C, $e(m, "horizontal"), $e(v, "inverted"), Kf(O), "statistics", c), I = zt(V$, r), L = Xt(V$, r);
  return dn(o) ? dn(d) ? /* @__PURE__ */ ae.createElement(L, Be({}, I, {
    className: R
  }), fi(g, function(Z) {
    return A1.create(Z);
  })) : /* @__PURE__ */ ae.createElement(L, Be({}, I, {
    className: R
  }), d) : /* @__PURE__ */ ae.createElement(L, Be({}, I, {
    className: R
  }), o);
}
V$.handledProps = ["as", "children", "className", "color", "content", "horizontal", "inverted", "items", "size", "widths"];
V$.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** A statistic group can be formatted to be different colors. */
  color: _.oneOf(Om),
  /** Shorthand for primary content. */
  content: In,
  /** A statistic group can present its measurement horizontally. */
  horizontal: _.bool,
  /** A statistic group can be formatted to fit on a dark background. */
  inverted: _.bool,
  /** Array of props for Statistic. */
  items: Dh,
  /** A statistic group can vary in size. */
  size: _.oneOf(pi(mc, "big", "massive", "medium")),
  /** A statistic group can have its items divided evenly. */
  widths: _.oneOf(hp)
} : {};
function MC(r) {
  var o = r.children, c = r.className, i = r.content, d = Vt("label", c), m = zt(MC, r), v = Xt(MC, r);
  return /* @__PURE__ */ ae.createElement(v, Be({}, m, {
    className: d
  }), dn(o) ? i : o);
}
MC.handledProps = ["as", "children", "className", "content"];
MC.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In
} : {};
MC.create = lo(MC, function(r) {
  return {
    content: r
  };
});
function FC(r) {
  var o = r.children, c = r.className, i = r.content, d = r.text, m = Vt($e(d, "text"), "value", c), v = zt(FC, r), g = Xt(FC, r);
  return /* @__PURE__ */ ae.createElement(g, Be({}, v, {
    className: m
  }), dn(o) ? i : o);
}
FC.handledProps = ["as", "children", "className", "content", "text"];
FC.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** Shorthand for primary content. */
  content: In,
  /** Format the value with smaller font size to fit nicely beside number values. */
  text: _.bool
} : {};
FC.create = lo(FC, function(r) {
  return {
    content: r
  };
});
function A1(r) {
  var o = r.children, c = r.className, i = r.color, d = r.content, m = r.floated, v = r.horizontal, g = r.inverted, C = r.label, O = r.size, R = r.text, I = r.value, L = Vt("ui", i, O, _u(m, "floated"), $e(v, "horizontal"), $e(g, "inverted"), "statistic", c), Z = zt(A1, r), ne = Xt(A1, r);
  return dn(o) ? dn(d) ? /* @__PURE__ */ ae.createElement(ne, Be({}, Z, {
    className: L
  }), FC.create(I, {
    defaultProps: {
      text: R
    },
    autoGenerateKey: !1
  }), MC.create(C, {
    autoGenerateKey: !1
  })) : /* @__PURE__ */ ae.createElement(ne, Be({}, Z, {
    className: L
  }), d) : /* @__PURE__ */ ae.createElement(ne, Be({}, Z, {
    className: L
  }), o);
}
A1.handledProps = ["as", "children", "className", "color", "content", "floated", "horizontal", "inverted", "label", "size", "text", "value"];
A1.propTypes = process.env.NODE_ENV !== "production" ? {
  /** An element type to render as (string or function). */
  as: _.elementType,
  /** Primary content. */
  children: _.node,
  /** Additional classes. */
  className: _.string,
  /** A statistic can be formatted to be different colors. */
  color: _.oneOf(Om),
  /** Shorthand for primary content. */
  content: In,
  /** A statistic can sit to the left or right of other content. */
  floated: _.oneOf(ew),
  /** A statistic can present its measurement horizontally. */
  horizontal: _.bool,
  /** A statistic can be formatted to fit on a dark background. */
  inverted: _.bool,
  /** Label content of the Statistic. */
  label: In,
  /** A statistic can vary in size. */
  size: _.oneOf(pi(mc, "big", "massive", "medium")),
  /** Format the StatisticValue with smaller font size to fit nicely beside number values. */
  text: _.bool,
  /** Value content of the Statistic. */
  value: In
} : {};
A1.Group = V$;
A1.Label = MC;
A1.Value = FC;
A1.create = lo(A1, function(r) {
  return {
    content: r
  };
});
const SNe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Accordion: R2,
  AccordionAccordion: _C,
  AccordionContent: TC,
  AccordionPanel: Dae,
  AccordionTitle: lk,
  Advertisement: PB,
  Breadcrumb: JA,
  BreadcrumbDivider: hC,
  BreadcrumbSection: XA,
  Button: hy,
  ButtonContent: n$,
  ButtonGroup: r$,
  ButtonOr: o$,
  Card: Tu,
  CardContent: x2,
  CardDescription: fk,
  CardGroup: D$,
  CardHeader: mk,
  CardMeta: pk,
  Checkbox: Iv,
  Comment: Hv,
  CommentAction: hk,
  CommentActions: $$,
  CommentAuthor: I$,
  CommentAvatar: M$,
  CommentContent: F$,
  CommentGroup: L$,
  CommentMetadata: B$,
  CommentText: H$,
  Confirm: N2e,
  Container: EB,
  Dimmer: S2,
  DimmerDimmable: XD,
  DimmerInner: JD,
  Divider: CB,
  Dropdown: kl,
  DropdownDivider: l$,
  DropdownHeader: mC,
  DropdownItem: Aj,
  DropdownMenu: QA,
  DropdownSearchInput: kae,
  DropdownText: pC,
  Embed: Pj,
  Feed: Pg,
  FeedContent: bk,
  FeedDate: T2,
  FeedEvent: yk,
  FeedExtra: RC,
  FeedLabel: A2,
  FeedLike: _2,
  FeedMeta: gk,
  FeedSummary: vk,
  FeedUser: O2,
  Flag: Aae,
  Form: lOe,
  FormButton: ek,
  FormCheckbox: tk,
  FormDropdown: nk,
  FormField: kd,
  FormGroup: d$,
  FormInput: rk,
  FormRadio: ok,
  FormSelect: sk,
  FormTextArea: ak,
  Grid: Pv,
  GridColumn: x1,
  GridRow: m$,
  Header: yC,
  HeaderContent: ck,
  HeaderSubheader: bC,
  Icon: fc,
  IconGroup: KA,
  Image: Qf,
  ImageGroup: e$,
  Input: WB,
  Item: rf,
  ItemContent: Sk,
  ItemDescription: DC,
  ItemExtra: $C,
  ItemGroup: z$,
  ItemHeader: PC,
  ItemImage: k2,
  ItemMeta: IC,
  Label: Rh,
  LabelDetail: lC,
  LabelGroup: t$,
  List: Rae,
  ListContent: GS,
  ListDescription: jS,
  ListHeader: qS,
  ListIcon: C2,
  ListItem: Nae,
  ListList: p$,
  Loader: h$,
  Menu: h2,
  MenuHeader: a$,
  MenuItem: E2,
  MenuMenu: i$,
  Message: $k,
  MessageContent: ik,
  MessageHeader: gC,
  MessageItem: VS,
  MessageList: US,
  Modal: HD,
  ModalActions: w2,
  ModalContent: HS,
  ModalDescription: s$,
  ModalDimmer: dC,
  ModalHeader: zS,
  Pagination: Pk,
  PaginationItem: Oae,
  Placeholder: SC,
  PlaceholderHeader: g$,
  PlaceholderImage: v$,
  PlaceholderLine: b$,
  PlaceholderParagraph: y$,
  Popup: K$,
  PopupContent: AC,
  PopupHeader: kC,
  Portal: m2,
  PortalInner: _ae,
  Progress: ske,
  Radio: Dk,
  Rail: TB,
  Rating: Q$,
  RatingIcon: Y$,
  Ref: yp,
  Reveal: w$,
  RevealContent: S$,
  Search: D2,
  SearchCategory: NC,
  SearchResult: Mk,
  SearchResults: dk,
  Segment: ZS,
  SegmentGroup: E$,
  SegmentInline: C$,
  Select: N2,
  Sidebar: bNe,
  SidebarPushable: R$,
  SidebarPusher: P$,
  Statistic: A1,
  StatisticGroup: V$,
  StatisticLabel: MC,
  StatisticValue: FC,
  Step: jhe,
  StepContent: CC,
  StepDescription: wC,
  StepGroup: x$,
  StepTitle: EC,
  Sticky: Ij,
  Tab: yNe,
  TabPane: YS,
  Table: Lv,
  TableBody: vC,
  TableCell: nf,
  TableFooter: Ik,
  TableHeader: WS,
  TableHeaderCell: _g,
  TableRow: Ah,
  TextArea: Vhe,
  Transition: zv,
  TransitionGroup: UB,
  TransitionablePortal: Nj,
  Visibility: Rj
}, Symbol.toStringTag, { value: "Module" }));
function BA(r, o, c) {
  return (o = tge(o)) in r ? Object.defineProperty(r, o, {
    value: c,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : r[o] = c, r;
}
function Zae(r, o) {
  if (r == null)
    return {};
  var c, i, d = O1(r, o);
  if (Object.getOwnPropertySymbols) {
    var m = Object.getOwnPropertySymbols(r);
    for (i = 0; i < m.length; i++)
      c = m[i], o.indexOf(c) === -1 && {}.propertyIsEnumerable.call(r, c) && (d[c] = r[c]);
  }
  return d;
}
function wde(r, o) {
  var c = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(r);
    o && (i = i.filter(function(d) {
      return Object.getOwnPropertyDescriptor(r, d).enumerable;
    })), c.push.apply(c, i);
  }
  return c;
}
function FW(r) {
  for (var o = 1; o < arguments.length; o++) {
    var c = arguments[o] != null ? arguments[o] : {};
    o % 2 ? wde(Object(c), !0).forEach(function(i) {
      BA(r, i, c[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(c)) : wde(Object(c)).forEach(function(i) {
      Object.defineProperty(r, i, Object.getOwnPropertyDescriptor(c, i));
    });
  }
  return r;
}
const Mj = ae.createContext({});
function wNe(r, o) {
  const c = (d) => {
    typeof o == "function" && (o = o(d)), r.originalComponent && (r = r.originalComponent);
    const m = FW(FW({}, d), o), v = m.children, g = Zae(m, ["children"]);
    return ae.createElement(r, g, v);
  }, i = r.displayName || r.name;
  return c.displayName = "Parametrized(".concat(i, ")"), c;
}
function zo(r) {
  let o = r.id, c = r.children, i = Zae(r, ["id", "children"]);
  const d = Gc(Mj), m = c ? ae.Children.only(c) : null, v = m ? m.props : {};
  if (o in d) {
    const g = d[o];
    return ae.createElement(g, FW(FW({}, v), i));
  } else
    return m ? ae.cloneElement(m, v) : null;
}
zo.propTypes = {
  /** The children of the component */
  children: _.node,
  /** The id that the component will be bound to (normally component's name) */
  id: _.string
};
zo.defaultProps = {
  id: null,
  children: null
};
zo.component = (r, o) => {
  const c = (d) => {
    let m = d.children, v = Zae(d, ["children"]);
    const C = Gc(Mj)[r];
    return ae.createElement(C || o, v, m);
  };
  c.propTypes = {
    children: _.oneOfType([_.node, _.func])
  }, c.defaultProps = {
    children: null
  };
  const i = o.displayName || o.name;
  return c.displayName = "Overridable(".concat(i, ")"), c.originalComponent = o, c;
};
function Ede(r, o) {
  var c = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(r);
    o && (i = i.filter(function(d) {
      return Object.getOwnPropertyDescriptor(r, d).enumerable;
    })), c.push.apply(c, i);
  }
  return c;
}
function ENe(r) {
  for (var o = 1; o < arguments.length; o++) {
    var c = arguments[o] != null ? arguments[o] : {};
    o % 2 ? Ede(Object(c), !0).forEach(function(i) {
      BA(r, i, c[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(c)) : Ede(Object(c)).forEach(function(i) {
      Object.defineProperty(r, i, Object.getOwnPropertyDescriptor(c, i));
    });
  }
  return r;
}
class uge {
  constructor(o) {
    BA(this, "add", (c, i) => {
      this.components[c] = i;
    }), BA(this, "get", (c) => this.components[c]), BA(this, "getAll", () => ENe({}, this.components)), BA(this, "clear", () => {
      this.components = {};
    }), this.components = o || {};
  }
}
const CNe = new uge(), xNe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  OverridableContext: Mj,
  OverriddenComponentRepository: uge,
  default: zo,
  overrideStore: CNe,
  parametrize: wNe
}, Symbol.toStringTag, { value: "Module" }));
var TNe = Object.prototype;
function _Ne(r) {
  var o = r && r.constructor, c = typeof o == "function" && o.prototype || TNe;
  return r === c;
}
var Fj = _Ne;
function ONe(r, o) {
  return function(c) {
    return r(o(c));
  };
}
var dge = ONe, ANe = dge, kNe = ANe(Object.keys, Object), NNe = kNe, RNe = Fj, PNe = NNe, DNe = Object.prototype, $Ne = DNe.hasOwnProperty;
function INe(r) {
  if (!RNe(r))
    return PNe(r);
  var o = [];
  for (var c in Object(r))
    $Ne.call(r, c) && c != "constructor" && o.push(c);
  return o;
}
var fge = INe, MNe = typeof S1 == "object" && S1 && S1.Object === Object && S1, mge = MNe, FNe = mge, LNe = typeof self == "object" && self && self.Object === Object && self, BNe = FNe || LNe || Function("return this")(), $1 = BNe, HNe = $1, zNe = HNe.Symbol, J$ = zNe, Cde = J$, pge = Object.prototype, VNe = pge.hasOwnProperty, UNe = pge.toString, zL = Cde ? Cde.toStringTag : void 0;
function WNe(r) {
  var o = VNe.call(r, zL), c = r[zL];
  try {
    r[zL] = void 0;
    var i = !0;
  } catch {
  }
  var d = UNe.call(r);
  return i && (o ? r[zL] = c : delete r[zL]), d;
}
var jNe = WNe, qNe = Object.prototype, GNe = qNe.toString;
function ZNe(r) {
  return GNe.call(r);
}
var KNe = ZNe, xde = J$, YNe = jNe, QNe = KNe, XNe = "[object Null]", JNe = "[object Undefined]", Tde = xde ? xde.toStringTag : void 0;
function eRe(r) {
  return r == null ? r === void 0 ? JNe : XNe : Tde && Tde in Object(r) ? YNe(r) : QNe(r);
}
var UC = eRe;
function tRe(r) {
  var o = typeof r;
  return r != null && (o == "object" || o == "function");
}
var I1 = tRe;
const nRe = /* @__PURE__ */ Ku(I1);
var rRe = UC, oRe = I1, sRe = "[object AsyncFunction]", aRe = "[object Function]", iRe = "[object GeneratorFunction]", cRe = "[object Proxy]";
function lRe(r) {
  if (!oRe(r))
    return !1;
  var o = rRe(r);
  return o == aRe || o == iRe || o == sRe || o == cRe;
}
var hge = lRe, uRe = $1, dRe = uRe["__core-js_shared__"], fRe = dRe, uoe = fRe, _de = function() {
  var r = /[^.]+$/.exec(uoe && uoe.keys && uoe.keys.IE_PROTO || "");
  return r ? "Symbol(src)_1." + r : "";
}();
function mRe(r) {
  return !!_de && _de in r;
}
var pRe = mRe, hRe = Function.prototype, gRe = hRe.toString;
function vRe(r) {
  if (r != null) {
    try {
      return gRe.call(r);
    } catch {
    }
    try {
      return r + "";
    } catch {
    }
  }
  return "";
}
var gge = vRe, bRe = hge, yRe = pRe, SRe = I1, wRe = gge, ERe = /[\\^$.*+?()[\]{}|]/g, CRe = /^\[object .+?Constructor\]$/, xRe = Function.prototype, TRe = Object.prototype, _Re = xRe.toString, ORe = TRe.hasOwnProperty, ARe = RegExp(
  "^" + _Re.call(ORe).replace(ERe, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function kRe(r) {
  if (!SRe(r) || yRe(r))
    return !1;
  var o = bRe(r) ? ARe : CRe;
  return o.test(wRe(r));
}
var NRe = kRe;
function RRe(r, o) {
  return r == null ? void 0 : r[o];
}
var PRe = RRe, DRe = NRe, $Re = PRe;
function IRe(r, o) {
  var c = $Re(r, o);
  return DRe(c) ? c : void 0;
}
var Fk = IRe, MRe = Fk, FRe = $1, LRe = MRe(FRe, "DataView"), BRe = LRe, HRe = Fk, zRe = $1, VRe = HRe(zRe, "Map"), Kae = VRe, URe = Fk, WRe = $1, jRe = URe(WRe, "Promise"), qRe = jRe, GRe = Fk, ZRe = $1, KRe = GRe(ZRe, "Set"), vge = KRe, YRe = Fk, QRe = $1, XRe = YRe(QRe, "WeakMap"), JRe = XRe, Sse = BRe, wse = Kae, Ese = qRe, Cse = vge, xse = JRe, bge = UC, eI = gge, Ode = "[object Map]", ePe = "[object Object]", Ade = "[object Promise]", kde = "[object Set]", Nde = "[object WeakMap]", Rde = "[object DataView]", tPe = eI(Sse), nPe = eI(wse), rPe = eI(Ese), oPe = eI(Cse), sPe = eI(xse), PA = bge;
(Sse && PA(new Sse(new ArrayBuffer(1))) != Rde || wse && PA(new wse()) != Ode || Ese && PA(Ese.resolve()) != Ade || Cse && PA(new Cse()) != kde || xse && PA(new xse()) != Nde) && (PA = function(r) {
  var o = bge(r), c = o == ePe ? r.constructor : void 0, i = c ? eI(c) : "";
  if (i)
    switch (i) {
      case tPe:
        return Rde;
      case nPe:
        return Ode;
      case rPe:
        return Ade;
      case oPe:
        return kde;
      case sPe:
        return Nde;
    }
  return o;
});
var GB = PA;
function aPe(r) {
  return r != null && typeof r == "object";
}
var M1 = aPe, iPe = UC, cPe = M1, lPe = "[object Arguments]";
function uPe(r) {
  return cPe(r) && iPe(r) == lPe;
}
var dPe = uPe, Pde = dPe, fPe = M1, yge = Object.prototype, mPe = yge.hasOwnProperty, pPe = yge.propertyIsEnumerable, hPe = Pde(function() {
  return arguments;
}()) ? Pde : function(r) {
  return fPe(r) && mPe.call(r, "callee") && !pPe.call(r, "callee");
}, Lj = hPe, gPe = Array.isArray, $h = gPe;
const Sge = /* @__PURE__ */ Ku($h);
var vPe = 9007199254740991;
function bPe(r) {
  return typeof r == "number" && r > -1 && r % 1 == 0 && r <= vPe;
}
var Yae = bPe, yPe = hge, SPe = Yae;
function wPe(r) {
  return r != null && SPe(r.length) && !yPe(r);
}
var ZB = wPe, LW = { exports: {} };
function EPe() {
  return !1;
}
var CPe = EPe;
LW.exports;
(function(r, o) {
  var c = $1, i = CPe, d = o && !o.nodeType && o, m = d && !0 && r && !r.nodeType && r, v = m && m.exports === d, g = v ? c.Buffer : void 0, C = g ? g.isBuffer : void 0, O = C || i;
  r.exports = O;
})(LW, LW.exports);
var Bj = LW.exports, xPe = UC, TPe = Yae, _Pe = M1, OPe = "[object Arguments]", APe = "[object Array]", kPe = "[object Boolean]", NPe = "[object Date]", RPe = "[object Error]", PPe = "[object Function]", DPe = "[object Map]", $Pe = "[object Number]", IPe = "[object Object]", MPe = "[object RegExp]", FPe = "[object Set]", LPe = "[object String]", BPe = "[object WeakMap]", HPe = "[object ArrayBuffer]", zPe = "[object DataView]", VPe = "[object Float32Array]", UPe = "[object Float64Array]", WPe = "[object Int8Array]", jPe = "[object Int16Array]", qPe = "[object Int32Array]", GPe = "[object Uint8Array]", ZPe = "[object Uint8ClampedArray]", KPe = "[object Uint16Array]", YPe = "[object Uint32Array]", dl = {};
dl[VPe] = dl[UPe] = dl[WPe] = dl[jPe] = dl[qPe] = dl[GPe] = dl[ZPe] = dl[KPe] = dl[YPe] = !0;
dl[OPe] = dl[APe] = dl[HPe] = dl[kPe] = dl[zPe] = dl[NPe] = dl[RPe] = dl[PPe] = dl[DPe] = dl[$Pe] = dl[IPe] = dl[MPe] = dl[FPe] = dl[LPe] = dl[BPe] = !1;
function QPe(r) {
  return _Pe(r) && TPe(r.length) && !!dl[xPe(r)];
}
var XPe = QPe;
function JPe(r) {
  return function(o) {
    return r(o);
  };
}
var Qae = JPe, BW = { exports: {} };
BW.exports;
(function(r, o) {
  var c = mge, i = o && !o.nodeType && o, d = i && !0 && r && !r.nodeType && r, m = d && d.exports === i, v = m && c.process, g = function() {
    try {
      var C = d && d.require && d.require("util").types;
      return C || v && v.binding && v.binding("util");
    } catch {
    }
  }();
  r.exports = g;
})(BW, BW.exports);
var Xae = BW.exports, eDe = XPe, tDe = Qae, Dde = Xae, $de = Dde && Dde.isTypedArray, nDe = $de ? tDe($de) : eDe, Jae = nDe, rDe = fge, oDe = GB, sDe = Lj, aDe = $h, iDe = ZB, cDe = Bj, lDe = Fj, uDe = Jae, dDe = "[object Map]", fDe = "[object Set]", mDe = Object.prototype, pDe = mDe.hasOwnProperty;
function hDe(r) {
  if (r == null)
    return !0;
  if (iDe(r) && (aDe(r) || typeof r == "string" || typeof r.splice == "function" || cDe(r) || uDe(r) || sDe(r)))
    return !r.length;
  var o = oDe(r);
  if (o == dDe || o == fDe)
    return !r.size;
  if (lDe(r))
    return !rDe(r).length;
  for (var c in r)
    if (pDe.call(r, c))
      return !1;
  return !0;
}
var wge = hDe;
const nw = /* @__PURE__ */ Ku(wge);
function Ege(r, o) {
  return function() {
    return r.apply(o, arguments);
  };
}
const { toString: gDe } = Object.prototype, { getPrototypeOf: eie } = Object, { iterator: Hj, toStringTag: Cge } = Symbol, zj = ((r) => (o) => {
  const c = gDe.call(o);
  return r[c] || (r[c] = c.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), F1 = (r) => (r = r.toLowerCase(), (o) => zj(o) === r), Vj = (r) => (o) => typeof o === r, { isArray: tI } = Array, DB = Vj("undefined");
function vDe(r) {
  return r !== null && !DB(r) && r.constructor !== null && !DB(r.constructor) && Rg(r.constructor.isBuffer) && r.constructor.isBuffer(r);
}
const xge = F1("ArrayBuffer");
function bDe(r) {
  let o;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? o = ArrayBuffer.isView(r) : o = r && r.buffer && xge(r.buffer), o;
}
const yDe = Vj("string"), Rg = Vj("function"), Tge = Vj("number"), Uj = (r) => r !== null && typeof r == "object", SDe = (r) => r === !0 || r === !1, fW = (r) => {
  if (zj(r) !== "object")
    return !1;
  const o = eie(r);
  return (o === null || o === Object.prototype || Object.getPrototypeOf(o) === null) && !(Cge in r) && !(Hj in r);
}, wDe = F1("Date"), EDe = F1("File"), CDe = F1("Blob"), xDe = F1("FileList"), TDe = (r) => Uj(r) && Rg(r.pipe), _De = (r) => {
  let o;
  return r && (typeof FormData == "function" && r instanceof FormData || Rg(r.append) && ((o = zj(r)) === "formdata" || // detect form-data instance
  o === "object" && Rg(r.toString) && r.toString() === "[object FormData]"));
}, ODe = F1("URLSearchParams"), [ADe, kDe, NDe, RDe] = ["ReadableStream", "Request", "Response", "Headers"].map(F1), PDe = (r) => r.trim ? r.trim() : r.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function KB(r, o, { allOwnKeys: c = !1 } = {}) {
  if (r === null || typeof r > "u")
    return;
  let i, d;
  if (typeof r != "object" && (r = [r]), tI(r))
    for (i = 0, d = r.length; i < d; i++)
      o.call(null, r[i], i, r);
  else {
    const m = c ? Object.getOwnPropertyNames(r) : Object.keys(r), v = m.length;
    let g;
    for (i = 0; i < v; i++)
      g = m[i], o.call(null, r[g], g, r);
  }
}
function _ge(r, o) {
  o = o.toLowerCase();
  const c = Object.keys(r);
  let i = c.length, d;
  for (; i-- > 0; )
    if (d = c[i], o === d.toLowerCase())
      return d;
  return null;
}
const HA = (() => typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global)(), Oge = (r) => !DB(r) && r !== HA;
function Tse() {
  const { caseless: r } = Oge(this) && this || {}, o = {}, c = (i, d) => {
    const m = r && _ge(o, d) || d;
    fW(o[m]) && fW(i) ? o[m] = Tse(o[m], i) : fW(i) ? o[m] = Tse({}, i) : tI(i) ? o[m] = i.slice() : o[m] = i;
  };
  for (let i = 0, d = arguments.length; i < d; i++)
    arguments[i] && KB(arguments[i], c);
  return o;
}
const DDe = (r, o, c, { allOwnKeys: i } = {}) => (KB(o, (d, m) => {
  c && Rg(d) ? r[m] = Ege(d, c) : r[m] = d;
}, { allOwnKeys: i }), r), $De = (r) => (r.charCodeAt(0) === 65279 && (r = r.slice(1)), r), IDe = (r, o, c, i) => {
  r.prototype = Object.create(o.prototype, i), r.prototype.constructor = r, Object.defineProperty(r, "super", {
    value: o.prototype
  }), c && Object.assign(r.prototype, c);
}, MDe = (r, o, c, i) => {
  let d, m, v;
  const g = {};
  if (o = o || {}, r == null)
    return o;
  do {
    for (d = Object.getOwnPropertyNames(r), m = d.length; m-- > 0; )
      v = d[m], (!i || i(v, r, o)) && !g[v] && (o[v] = r[v], g[v] = !0);
    r = c !== !1 && eie(r);
  } while (r && (!c || c(r, o)) && r !== Object.prototype);
  return o;
}, FDe = (r, o, c) => {
  r = String(r), (c === void 0 || c > r.length) && (c = r.length), c -= o.length;
  const i = r.indexOf(o, c);
  return i !== -1 && i === c;
}, LDe = (r) => {
  if (!r)
    return null;
  if (tI(r))
    return r;
  let o = r.length;
  if (!Tge(o))
    return null;
  const c = new Array(o);
  for (; o-- > 0; )
    c[o] = r[o];
  return c;
}, BDe = ((r) => (o) => r && o instanceof r)(typeof Uint8Array < "u" && eie(Uint8Array)), HDe = (r, o) => {
  const i = (r && r[Hj]).call(r);
  let d;
  for (; (d = i.next()) && !d.done; ) {
    const m = d.value;
    o.call(r, m[0], m[1]);
  }
}, zDe = (r, o) => {
  let c;
  const i = [];
  for (; (c = r.exec(o)) !== null; )
    i.push(c);
  return i;
}, VDe = F1("HTMLFormElement"), UDe = (r) => r.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(c, i, d) {
    return i.toUpperCase() + d;
  }
), Ide = (({ hasOwnProperty: r }) => (o, c) => r.call(o, c))(Object.prototype), WDe = F1("RegExp"), Age = (r, o) => {
  const c = Object.getOwnPropertyDescriptors(r), i = {};
  KB(c, (d, m) => {
    let v;
    (v = o(d, m, r)) !== !1 && (i[m] = v || d);
  }), Object.defineProperties(r, i);
}, jDe = (r) => {
  Age(r, (o, c) => {
    if (Rg(r) && ["arguments", "caller", "callee"].indexOf(c) !== -1)
      return !1;
    const i = r[c];
    if (Rg(i)) {
      if (o.enumerable = !1, "writable" in o) {
        o.writable = !1;
        return;
      }
      o.set || (o.set = () => {
        throw Error("Can not rewrite read-only method '" + c + "'");
      });
    }
  });
}, qDe = (r, o) => {
  const c = {}, i = (d) => {
    d.forEach((m) => {
      c[m] = !0;
    });
  };
  return tI(r) ? i(r) : i(String(r).split(o)), c;
}, GDe = () => {
}, ZDe = (r, o) => r != null && Number.isFinite(r = +r) ? r : o;
function KDe(r) {
  return !!(r && Rg(r.append) && r[Cge] === "FormData" && r[Hj]);
}
const YDe = (r) => {
  const o = new Array(10), c = (i, d) => {
    if (Uj(i)) {
      if (o.indexOf(i) >= 0)
        return;
      if (!("toJSON" in i)) {
        o[d] = i;
        const m = tI(i) ? [] : {};
        return KB(i, (v, g) => {
          const C = c(v, d + 1);
          !DB(C) && (m[g] = C);
        }), o[d] = void 0, m;
      }
    }
    return i;
  };
  return c(r, 0);
}, QDe = F1("AsyncFunction"), XDe = (r) => r && (Uj(r) || Rg(r)) && Rg(r.then) && Rg(r.catch), kge = ((r, o) => r ? setImmediate : o ? ((c, i) => (HA.addEventListener("message", ({ source: d, data: m }) => {
  d === HA && m === c && i.length && i.shift()();
}, !1), (d) => {
  i.push(d), HA.postMessage(c, "*");
}))(`axios@${Math.random()}`, []) : (c) => setTimeout(c))(
  typeof setImmediate == "function",
  Rg(HA.postMessage)
), JDe = typeof queueMicrotask < "u" ? queueMicrotask.bind(HA) : typeof process < "u" && process.nextTick || kge, e$e = (r) => r != null && Rg(r[Hj]), on = {
  isArray: tI,
  isArrayBuffer: xge,
  isBuffer: vDe,
  isFormData: _De,
  isArrayBufferView: bDe,
  isString: yDe,
  isNumber: Tge,
  isBoolean: SDe,
  isObject: Uj,
  isPlainObject: fW,
  isReadableStream: ADe,
  isRequest: kDe,
  isResponse: NDe,
  isHeaders: RDe,
  isUndefined: DB,
  isDate: wDe,
  isFile: EDe,
  isBlob: CDe,
  isRegExp: WDe,
  isFunction: Rg,
  isStream: TDe,
  isURLSearchParams: ODe,
  isTypedArray: BDe,
  isFileList: xDe,
  forEach: KB,
  merge: Tse,
  extend: DDe,
  trim: PDe,
  stripBOM: $De,
  inherits: IDe,
  toFlatObject: MDe,
  kindOf: zj,
  kindOfTest: F1,
  endsWith: FDe,
  toArray: LDe,
  forEachEntry: HDe,
  matchAll: zDe,
  isHTMLForm: VDe,
  hasOwnProperty: Ide,
  hasOwnProp: Ide,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: Age,
  freezeMethods: jDe,
  toObjectSet: qDe,
  toCamelCase: UDe,
  noop: GDe,
  toFiniteNumber: ZDe,
  findKey: _ge,
  global: HA,
  isContextDefined: Oge,
  isSpecCompliantForm: KDe,
  toJSONObject: YDe,
  isAsyncFn: QDe,
  isThenable: XDe,
  setImmediate: kge,
  asap: JDe,
  isIterable: e$e
};
function Rs(r, o, c, i, d) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = r, this.name = "AxiosError", o && (this.code = o), c && (this.config = c), i && (this.request = i), d && (this.response = d, this.status = d.status ? d.status : null);
}
on.inherits(Rs, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: on.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const Nge = Rs.prototype, Rge = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((r) => {
  Rge[r] = { value: r };
});
Object.defineProperties(Rs, Rge);
Object.defineProperty(Nge, "isAxiosError", { value: !0 });
Rs.from = (r, o, c, i, d, m) => {
  const v = Object.create(Nge);
  return on.toFlatObject(r, v, function(C) {
    return C !== Error.prototype;
  }, (g) => g !== "isAxiosError"), Rs.call(v, r.message, o, c, i, d), v.cause = r, v.name = r.name, m && Object.assign(v, m), v;
};
const t$e = null;
function _se(r) {
  return on.isPlainObject(r) || on.isArray(r);
}
function Pge(r) {
  return on.endsWith(r, "[]") ? r.slice(0, -2) : r;
}
function Mde(r, o, c) {
  return r ? r.concat(o).map(function(d, m) {
    return d = Pge(d), !c && m ? "[" + d + "]" : d;
  }).join(c ? "." : "") : o;
}
function n$e(r) {
  return on.isArray(r) && !r.some(_se);
}
const r$e = on.toFlatObject(on, {}, null, function(o) {
  return /^is[A-Z]/.test(o);
});
function Wj(r, o, c) {
  if (!on.isObject(r))
    throw new TypeError("target must be an object");
  o = o || new FormData(), c = on.toFlatObject(c, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(se, Q) {
    return !on.isUndefined(Q[se]);
  });
  const i = c.metaTokens, d = c.visitor || R, m = c.dots, v = c.indexes, C = (c.Blob || typeof Blob < "u" && Blob) && on.isSpecCompliantForm(o);
  if (!on.isFunction(d))
    throw new TypeError("visitor must be a function");
  function O(ne) {
    if (ne === null)
      return "";
    if (on.isDate(ne))
      return ne.toISOString();
    if (on.isBoolean(ne))
      return ne.toString();
    if (!C && on.isBlob(ne))
      throw new Rs("Blob is not supported. Use a Buffer instead.");
    return on.isArrayBuffer(ne) || on.isTypedArray(ne) ? C && typeof Blob == "function" ? new Blob([ne]) : Buffer.from(ne) : ne;
  }
  function R(ne, se, Q) {
    let he = ne;
    if (ne && !Q && typeof ne == "object") {
      if (on.endsWith(se, "{}"))
        se = i ? se : se.slice(0, -2), ne = JSON.stringify(ne);
      else if (on.isArray(ne) && n$e(ne) || (on.isFileList(ne) || on.endsWith(se, "[]")) && (he = on.toArray(ne)))
        return se = Pge(se), he.forEach(function(G, me) {
          !(on.isUndefined(G) || G === null) && o.append(
            // eslint-disable-next-line no-nested-ternary
            v === !0 ? Mde([se], me, m) : v === null ? se : se + "[]",
            O(G)
          );
        }), !1;
    }
    return _se(ne) ? !0 : (o.append(Mde(Q, se, m), O(ne)), !1);
  }
  const I = [], L = Object.assign(r$e, {
    defaultVisitor: R,
    convertValue: O,
    isVisitable: _se
  });
  function Z(ne, se) {
    if (!on.isUndefined(ne)) {
      if (I.indexOf(ne) !== -1)
        throw Error("Circular reference detected in " + se.join("."));
      I.push(ne), on.forEach(ne, function(he, ue) {
        (!(on.isUndefined(he) || he === null) && d.call(
          o,
          he,
          on.isString(ue) ? ue.trim() : ue,
          se,
          L
        )) === !0 && Z(he, se ? se.concat(ue) : [ue]);
      }), I.pop();
    }
  }
  if (!on.isObject(r))
    throw new TypeError("data must be an object");
  return Z(r), o;
}
function Fde(r) {
  const o = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(r).replace(/[!'()~]|%20|%00/g, function(i) {
    return o[i];
  });
}
function tie(r, o) {
  this._pairs = [], r && Wj(r, this, o);
}
const Dge = tie.prototype;
Dge.append = function(o, c) {
  this._pairs.push([o, c]);
};
Dge.toString = function(o) {
  const c = o ? function(i) {
    return o.call(this, i, Fde);
  } : Fde;
  return this._pairs.map(function(d) {
    return c(d[0]) + "=" + c(d[1]);
  }, "").join("&");
};
function o$e(r) {
  return encodeURIComponent(r).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function $ge(r, o, c) {
  if (!o)
    return r;
  const i = c && c.encode || o$e;
  on.isFunction(c) && (c = {
    serialize: c
  });
  const d = c && c.serialize;
  let m;
  if (d ? m = d(o, c) : m = on.isURLSearchParams(o) ? o.toString() : new tie(o, c).toString(i), m) {
    const v = r.indexOf("#");
    v !== -1 && (r = r.slice(0, v)), r += (r.indexOf("?") === -1 ? "?" : "&") + m;
  }
  return r;
}
class s$e {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(o, c, i) {
    return this.handlers.push({
      fulfilled: o,
      rejected: c,
      synchronous: i ? i.synchronous : !1,
      runWhen: i ? i.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(o) {
    this.handlers[o] && (this.handlers[o] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(o) {
    on.forEach(this.handlers, function(i) {
      i !== null && o(i);
    });
  }
}
const Lde = s$e, Ige = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, a$e = typeof URLSearchParams < "u" ? URLSearchParams : tie, i$e = typeof FormData < "u" ? FormData : null, c$e = typeof Blob < "u" ? Blob : null, l$e = {
  isBrowser: !0,
  classes: {
    URLSearchParams: a$e,
    FormData: i$e,
    Blob: c$e
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, nie = typeof window < "u" && typeof document < "u", Ose = typeof navigator == "object" && navigator || void 0, u$e = nie && (!Ose || ["ReactNative", "NativeScript", "NS"].indexOf(Ose.product) < 0), d$e = (() => typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function")(), f$e = nie && window.location.href || "http://localhost", m$e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: nie,
  hasStandardBrowserEnv: u$e,
  hasStandardBrowserWebWorkerEnv: d$e,
  navigator: Ose,
  origin: f$e
}, Symbol.toStringTag, { value: "Module" })), vp = {
  ...m$e,
  ...l$e
};
function p$e(r, o) {
  return Wj(r, new vp.classes.URLSearchParams(), Object.assign({
    visitor: function(c, i, d, m) {
      return vp.isNode && on.isBuffer(c) ? (this.append(i, c.toString("base64")), !1) : m.defaultVisitor.apply(this, arguments);
    }
  }, o));
}
function h$e(r) {
  return on.matchAll(/\w+|\[(\w*)]/g, r).map((o) => o[0] === "[]" ? "" : o[1] || o[0]);
}
function g$e(r) {
  const o = {}, c = Object.keys(r);
  let i;
  const d = c.length;
  let m;
  for (i = 0; i < d; i++)
    m = c[i], o[m] = r[m];
  return o;
}
function Mge(r) {
  function o(c, i, d, m) {
    let v = c[m++];
    if (v === "__proto__")
      return !0;
    const g = Number.isFinite(+v), C = m >= c.length;
    return v = !v && on.isArray(d) ? d.length : v, C ? (on.hasOwnProp(d, v) ? d[v] = [d[v], i] : d[v] = i, !g) : ((!d[v] || !on.isObject(d[v])) && (d[v] = []), o(c, i, d[v], m) && on.isArray(d[v]) && (d[v] = g$e(d[v])), !g);
  }
  if (on.isFormData(r) && on.isFunction(r.entries)) {
    const c = {};
    return on.forEachEntry(r, (i, d) => {
      o(h$e(i), d, c, 0);
    }), c;
  }
  return null;
}
function v$e(r, o, c) {
  if (on.isString(r))
    try {
      return (o || JSON.parse)(r), on.trim(r);
    } catch (i) {
      if (i.name !== "SyntaxError")
        throw i;
    }
  return (c || JSON.stringify)(r);
}
const rie = {
  transitional: Ige,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(o, c) {
    const i = c.getContentType() || "", d = i.indexOf("application/json") > -1, m = on.isObject(o);
    if (m && on.isHTMLForm(o) && (o = new FormData(o)), on.isFormData(o))
      return d ? JSON.stringify(Mge(o)) : o;
    if (on.isArrayBuffer(o) || on.isBuffer(o) || on.isStream(o) || on.isFile(o) || on.isBlob(o) || on.isReadableStream(o))
      return o;
    if (on.isArrayBufferView(o))
      return o.buffer;
    if (on.isURLSearchParams(o))
      return c.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), o.toString();
    let g;
    if (m) {
      if (i.indexOf("application/x-www-form-urlencoded") > -1)
        return p$e(o, this.formSerializer).toString();
      if ((g = on.isFileList(o)) || i.indexOf("multipart/form-data") > -1) {
        const C = this.env && this.env.FormData;
        return Wj(
          g ? { "files[]": o } : o,
          C && new C(),
          this.formSerializer
        );
      }
    }
    return m || d ? (c.setContentType("application/json", !1), v$e(o)) : o;
  }],
  transformResponse: [function(o) {
    const c = this.transitional || rie.transitional, i = c && c.forcedJSONParsing, d = this.responseType === "json";
    if (on.isResponse(o) || on.isReadableStream(o))
      return o;
    if (o && on.isString(o) && (i && !this.responseType || d)) {
      const v = !(c && c.silentJSONParsing) && d;
      try {
        return JSON.parse(o);
      } catch (g) {
        if (v)
          throw g.name === "SyntaxError" ? Rs.from(g, Rs.ERR_BAD_RESPONSE, this, null, this.response) : g;
      }
    }
    return o;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: vp.classes.FormData,
    Blob: vp.classes.Blob
  },
  validateStatus: function(o) {
    return o >= 200 && o < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
on.forEach(["delete", "get", "head", "post", "put", "patch"], (r) => {
  rie.headers[r] = {};
});
const oie = rie, b$e = on.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), y$e = (r) => {
  const o = {};
  let c, i, d;
  return r && r.split(`
`).forEach(function(v) {
    d = v.indexOf(":"), c = v.substring(0, d).trim().toLowerCase(), i = v.substring(d + 1).trim(), !(!c || o[c] && b$e[c]) && (c === "set-cookie" ? o[c] ? o[c].push(i) : o[c] = [i] : o[c] = o[c] ? o[c] + ", " + i : i);
  }), o;
}, Bde = Symbol("internals");
function VL(r) {
  return r && String(r).trim().toLowerCase();
}
function mW(r) {
  return r === !1 || r == null ? r : on.isArray(r) ? r.map(mW) : String(r);
}
function S$e(r) {
  const o = /* @__PURE__ */ Object.create(null), c = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let i;
  for (; i = c.exec(r); )
    o[i[1]] = i[2];
  return o;
}
const w$e = (r) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(r.trim());
function doe(r, o, c, i, d) {
  if (on.isFunction(i))
    return i.call(this, o, c);
  if (d && (o = c), !!on.isString(o)) {
    if (on.isString(i))
      return o.indexOf(i) !== -1;
    if (on.isRegExp(i))
      return i.test(o);
  }
}
function E$e(r) {
  return r.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (o, c, i) => c.toUpperCase() + i);
}
function C$e(r, o) {
  const c = on.toCamelCase(" " + o);
  ["get", "set", "has"].forEach((i) => {
    Object.defineProperty(r, i + c, {
      value: function(d, m, v) {
        return this[i].call(this, o, d, m, v);
      },
      configurable: !0
    });
  });
}
let jj = class {
  constructor(o) {
    o && this.set(o);
  }
  set(o, c, i) {
    const d = this;
    function m(g, C, O) {
      const R = VL(C);
      if (!R)
        throw new Error("header name must be a non-empty string");
      const I = on.findKey(d, R);
      (!I || d[I] === void 0 || O === !0 || O === void 0 && d[I] !== !1) && (d[I || C] = mW(g));
    }
    const v = (g, C) => on.forEach(g, (O, R) => m(O, R, C));
    if (on.isPlainObject(o) || o instanceof this.constructor)
      v(o, c);
    else if (on.isString(o) && (o = o.trim()) && !w$e(o))
      v(y$e(o), c);
    else if (on.isObject(o) && on.isIterable(o)) {
      let g = {}, C, O;
      for (const R of o) {
        if (!on.isArray(R))
          throw TypeError("Object iterator must return a key-value pair");
        g[O = R[0]] = (C = g[O]) ? on.isArray(C) ? [...C, R[1]] : [C, R[1]] : R[1];
      }
      v(g, c);
    } else
      o != null && m(c, o, i);
    return this;
  }
  get(o, c) {
    if (o = VL(o), o) {
      const i = on.findKey(this, o);
      if (i) {
        const d = this[i];
        if (!c)
          return d;
        if (c === !0)
          return S$e(d);
        if (on.isFunction(c))
          return c.call(this, d, i);
        if (on.isRegExp(c))
          return c.exec(d);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(o, c) {
    if (o = VL(o), o) {
      const i = on.findKey(this, o);
      return !!(i && this[i] !== void 0 && (!c || doe(this, this[i], i, c)));
    }
    return !1;
  }
  delete(o, c) {
    const i = this;
    let d = !1;
    function m(v) {
      if (v = VL(v), v) {
        const g = on.findKey(i, v);
        g && (!c || doe(i, i[g], g, c)) && (delete i[g], d = !0);
      }
    }
    return on.isArray(o) ? o.forEach(m) : m(o), d;
  }
  clear(o) {
    const c = Object.keys(this);
    let i = c.length, d = !1;
    for (; i--; ) {
      const m = c[i];
      (!o || doe(this, this[m], m, o, !0)) && (delete this[m], d = !0);
    }
    return d;
  }
  normalize(o) {
    const c = this, i = {};
    return on.forEach(this, (d, m) => {
      const v = on.findKey(i, m);
      if (v) {
        c[v] = mW(d), delete c[m];
        return;
      }
      const g = o ? E$e(m) : String(m).trim();
      g !== m && delete c[m], c[g] = mW(d), i[g] = !0;
    }), this;
  }
  concat(...o) {
    return this.constructor.concat(this, ...o);
  }
  toJSON(o) {
    const c = /* @__PURE__ */ Object.create(null);
    return on.forEach(this, (i, d) => {
      i != null && i !== !1 && (c[d] = o && on.isArray(i) ? i.join(", ") : i);
    }), c;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([o, c]) => o + ": " + c).join(`
`);
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(o) {
    return o instanceof this ? o : new this(o);
  }
  static concat(o, ...c) {
    const i = new this(o);
    return c.forEach((d) => i.set(d)), i;
  }
  static accessor(o) {
    const i = (this[Bde] = this[Bde] = {
      accessors: {}
    }).accessors, d = this.prototype;
    function m(v) {
      const g = VL(v);
      i[g] || (C$e(d, v), i[g] = !0);
    }
    return on.isArray(o) ? o.forEach(m) : m(o), this;
  }
};
jj.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
on.reduceDescriptors(jj.prototype, ({ value: r }, o) => {
  let c = o[0].toUpperCase() + o.slice(1);
  return {
    get: () => r,
    set(i) {
      this[c] = i;
    }
  };
});
on.freezeMethods(jj);
const T1 = jj;
function foe(r, o) {
  const c = this || oie, i = o || c, d = T1.from(i.headers);
  let m = i.data;
  return on.forEach(r, function(g) {
    m = g.call(c, m, d.normalize(), o ? o.status : void 0);
  }), d.normalize(), m;
}
function Fge(r) {
  return !!(r && r.__CANCEL__);
}
function nI(r, o, c) {
  Rs.call(this, r ?? "canceled", Rs.ERR_CANCELED, o, c), this.name = "CanceledError";
}
on.inherits(nI, Rs, {
  __CANCEL__: !0
});
function Lge(r, o, c) {
  const i = c.config.validateStatus;
  !c.status || !i || i(c.status) ? r(c) : o(new Rs(
    "Request failed with status code " + c.status,
    [Rs.ERR_BAD_REQUEST, Rs.ERR_BAD_RESPONSE][Math.floor(c.status / 100) - 4],
    c.config,
    c.request,
    c
  ));
}
function x$e(r) {
  const o = /^([-+\w]{1,25})(:?\/\/|:)/.exec(r);
  return o && o[1] || "";
}
function T$e(r, o) {
  r = r || 10;
  const c = new Array(r), i = new Array(r);
  let d = 0, m = 0, v;
  return o = o !== void 0 ? o : 1e3, function(C) {
    const O = Date.now(), R = i[m];
    v || (v = O), c[d] = C, i[d] = O;
    let I = m, L = 0;
    for (; I !== d; )
      L += c[I++], I = I % r;
    if (d = (d + 1) % r, d === m && (m = (m + 1) % r), O - v < o)
      return;
    const Z = R && O - R;
    return Z ? Math.round(L * 1e3 / Z) : void 0;
  };
}
function _$e(r, o) {
  let c = 0, i = 1e3 / o, d, m;
  const v = (O, R = Date.now()) => {
    c = R, d = null, m && (clearTimeout(m), m = null), r.apply(null, O);
  };
  return [(...O) => {
    const R = Date.now(), I = R - c;
    I >= i ? v(O, R) : (d = O, m || (m = setTimeout(() => {
      m = null, v(d);
    }, i - I)));
  }, () => d && v(d)];
}
const HW = (r, o, c = 3) => {
  let i = 0;
  const d = T$e(50, 250);
  return _$e((m) => {
    const v = m.loaded, g = m.lengthComputable ? m.total : void 0, C = v - i, O = d(C), R = v <= g;
    i = v;
    const I = {
      loaded: v,
      total: g,
      progress: g ? v / g : void 0,
      bytes: C,
      rate: O || void 0,
      estimated: O && g && R ? (g - v) / O : void 0,
      event: m,
      lengthComputable: g != null,
      [o ? "download" : "upload"]: !0
    };
    r(I);
  }, c);
}, Hde = (r, o) => {
  const c = r != null;
  return [(i) => o[0]({
    lengthComputable: c,
    total: r,
    loaded: i
  }), o[1]];
}, zde = (r) => (...o) => on.asap(() => r(...o)), O$e = vp.hasStandardBrowserEnv ? ((r, o) => (c) => (c = new URL(c, vp.origin), r.protocol === c.protocol && r.host === c.host && (o || r.port === c.port)))(
  new URL(vp.origin),
  vp.navigator && /(msie|trident)/i.test(vp.navigator.userAgent)
) : () => !0, A$e = vp.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(r, o, c, i, d, m) {
      const v = [r + "=" + encodeURIComponent(o)];
      on.isNumber(c) && v.push("expires=" + new Date(c).toGMTString()), on.isString(i) && v.push("path=" + i), on.isString(d) && v.push("domain=" + d), m === !0 && v.push("secure"), document.cookie = v.join("; ");
    },
    read(r) {
      const o = document.cookie.match(new RegExp("(^|;\\s*)(" + r + ")=([^;]*)"));
      return o ? decodeURIComponent(o[3]) : null;
    },
    remove(r) {
      this.write(r, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function k$e(r) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(r);
}
function N$e(r, o) {
  return o ? r.replace(/\/?\/$/, "") + "/" + o.replace(/^\/+/, "") : r;
}
function Bge(r, o, c) {
  let i = !k$e(o);
  return r && (i || c == !1) ? N$e(r, o) : o;
}
const Vde = (r) => r instanceof T1 ? { ...r } : r;
function wk(r, o) {
  o = o || {};
  const c = {};
  function i(O, R, I, L) {
    return on.isPlainObject(O) && on.isPlainObject(R) ? on.merge.call({ caseless: L }, O, R) : on.isPlainObject(R) ? on.merge({}, R) : on.isArray(R) ? R.slice() : R;
  }
  function d(O, R, I, L) {
    if (on.isUndefined(R)) {
      if (!on.isUndefined(O))
        return i(void 0, O, I, L);
    } else
      return i(O, R, I, L);
  }
  function m(O, R) {
    if (!on.isUndefined(R))
      return i(void 0, R);
  }
  function v(O, R) {
    if (on.isUndefined(R)) {
      if (!on.isUndefined(O))
        return i(void 0, O);
    } else
      return i(void 0, R);
  }
  function g(O, R, I) {
    if (I in o)
      return i(O, R);
    if (I in r)
      return i(void 0, O);
  }
  const C = {
    url: m,
    method: m,
    data: m,
    baseURL: v,
    transformRequest: v,
    transformResponse: v,
    paramsSerializer: v,
    timeout: v,
    timeoutMessage: v,
    withCredentials: v,
    withXSRFToken: v,
    adapter: v,
    responseType: v,
    xsrfCookieName: v,
    xsrfHeaderName: v,
    onUploadProgress: v,
    onDownloadProgress: v,
    decompress: v,
    maxContentLength: v,
    maxBodyLength: v,
    beforeRedirect: v,
    transport: v,
    httpAgent: v,
    httpsAgent: v,
    cancelToken: v,
    socketPath: v,
    responseEncoding: v,
    validateStatus: g,
    headers: (O, R, I) => d(Vde(O), Vde(R), I, !0)
  };
  return on.forEach(Object.keys(Object.assign({}, r, o)), function(R) {
    const I = C[R] || d, L = I(r[R], o[R], R);
    on.isUndefined(L) && I !== g || (c[R] = L);
  }), c;
}
const Hge = (r) => {
  const o = wk({}, r);
  let { data: c, withXSRFToken: i, xsrfHeaderName: d, xsrfCookieName: m, headers: v, auth: g } = o;
  o.headers = v = T1.from(v), o.url = $ge(Bge(o.baseURL, o.url, o.allowAbsoluteUrls), r.params, r.paramsSerializer), g && v.set(
    "Authorization",
    "Basic " + btoa((g.username || "") + ":" + (g.password ? unescape(encodeURIComponent(g.password)) : ""))
  );
  let C;
  if (on.isFormData(c)) {
    if (vp.hasStandardBrowserEnv || vp.hasStandardBrowserWebWorkerEnv)
      v.setContentType(void 0);
    else if ((C = v.getContentType()) !== !1) {
      const [O, ...R] = C ? C.split(";").map((I) => I.trim()).filter(Boolean) : [];
      v.setContentType([O || "multipart/form-data", ...R].join("; "));
    }
  }
  if (vp.hasStandardBrowserEnv && (i && on.isFunction(i) && (i = i(o)), i || i !== !1 && O$e(o.url))) {
    const O = d && m && A$e.read(m);
    O && v.set(d, O);
  }
  return o;
}, R$e = typeof XMLHttpRequest < "u", P$e = R$e && function(r) {
  return new Promise(function(c, i) {
    const d = Hge(r);
    let m = d.data;
    const v = T1.from(d.headers).normalize();
    let { responseType: g, onUploadProgress: C, onDownloadProgress: O } = d, R, I, L, Z, ne;
    function se() {
      Z && Z(), ne && ne(), d.cancelToken && d.cancelToken.unsubscribe(R), d.signal && d.signal.removeEventListener("abort", R);
    }
    let Q = new XMLHttpRequest();
    Q.open(d.method.toUpperCase(), d.url, !0), Q.timeout = d.timeout;
    function he() {
      if (!Q)
        return;
      const G = T1.from(
        "getAllResponseHeaders" in Q && Q.getAllResponseHeaders()
      ), we = {
        data: !g || g === "text" || g === "json" ? Q.responseText : Q.response,
        status: Q.status,
        statusText: Q.statusText,
        headers: G,
        config: r,
        request: Q
      };
      Lge(function(q) {
        c(q), se();
      }, function(q) {
        i(q), se();
      }, we), Q = null;
    }
    "onloadend" in Q ? Q.onloadend = he : Q.onreadystatechange = function() {
      !Q || Q.readyState !== 4 || Q.status === 0 && !(Q.responseURL && Q.responseURL.indexOf("file:") === 0) || setTimeout(he);
    }, Q.onabort = function() {
      Q && (i(new Rs("Request aborted", Rs.ECONNABORTED, r, Q)), Q = null);
    }, Q.onerror = function() {
      i(new Rs("Network Error", Rs.ERR_NETWORK, r, Q)), Q = null;
    }, Q.ontimeout = function() {
      let me = d.timeout ? "timeout of " + d.timeout + "ms exceeded" : "timeout exceeded";
      const we = d.transitional || Ige;
      d.timeoutErrorMessage && (me = d.timeoutErrorMessage), i(new Rs(
        me,
        we.clarifyTimeoutError ? Rs.ETIMEDOUT : Rs.ECONNABORTED,
        r,
        Q
      )), Q = null;
    }, m === void 0 && v.setContentType(null), "setRequestHeader" in Q && on.forEach(v.toJSON(), function(me, we) {
      Q.setRequestHeader(we, me);
    }), on.isUndefined(d.withCredentials) || (Q.withCredentials = !!d.withCredentials), g && g !== "json" && (Q.responseType = d.responseType), O && ([L, ne] = HW(O, !0), Q.addEventListener("progress", L)), C && Q.upload && ([I, Z] = HW(C), Q.upload.addEventListener("progress", I), Q.upload.addEventListener("loadend", Z)), (d.cancelToken || d.signal) && (R = (G) => {
      Q && (i(!G || G.type ? new nI(null, r, Q) : G), Q.abort(), Q = null);
    }, d.cancelToken && d.cancelToken.subscribe(R), d.signal && (d.signal.aborted ? R() : d.signal.addEventListener("abort", R)));
    const ue = x$e(d.url);
    if (ue && vp.protocols.indexOf(ue) === -1) {
      i(new Rs("Unsupported protocol " + ue + ":", Rs.ERR_BAD_REQUEST, r));
      return;
    }
    Q.send(m || null);
  });
}, D$e = (r, o) => {
  const { length: c } = r = r ? r.filter(Boolean) : [];
  if (o || c) {
    let i = new AbortController(), d;
    const m = function(O) {
      if (!d) {
        d = !0, g();
        const R = O instanceof Error ? O : this.reason;
        i.abort(R instanceof Rs ? R : new nI(R instanceof Error ? R.message : R));
      }
    };
    let v = o && setTimeout(() => {
      v = null, m(new Rs(`timeout ${o} of ms exceeded`, Rs.ETIMEDOUT));
    }, o);
    const g = () => {
      r && (v && clearTimeout(v), v = null, r.forEach((O) => {
        O.unsubscribe ? O.unsubscribe(m) : O.removeEventListener("abort", m);
      }), r = null);
    };
    r.forEach((O) => O.addEventListener("abort", m));
    const { signal: C } = i;
    return C.unsubscribe = () => on.asap(g), C;
  }
}, $$e = D$e, I$e = function* (r, o) {
  let c = r.byteLength;
  if (!o || c < o) {
    yield r;
    return;
  }
  let i = 0, d;
  for (; i < c; )
    d = i + o, yield r.slice(i, d), i = d;
}, M$e = async function* (r, o) {
  for await (const c of F$e(r))
    yield* I$e(c, o);
}, F$e = async function* (r) {
  if (r[Symbol.asyncIterator]) {
    yield* r;
    return;
  }
  const o = r.getReader();
  try {
    for (; ; ) {
      const { done: c, value: i } = await o.read();
      if (c)
        break;
      yield i;
    }
  } finally {
    await o.cancel();
  }
}, Ude = (r, o, c, i) => {
  const d = M$e(r, o);
  let m = 0, v, g = (C) => {
    v || (v = !0, i && i(C));
  };
  return new ReadableStream({
    async pull(C) {
      try {
        const { done: O, value: R } = await d.next();
        if (O) {
          g(), C.close();
          return;
        }
        let I = R.byteLength;
        if (c) {
          let L = m += I;
          c(L);
        }
        C.enqueue(new Uint8Array(R));
      } catch (O) {
        throw g(O), O;
      }
    },
    cancel(C) {
      return g(C), d.return();
    }
  }, {
    highWaterMark: 2
  });
}, qj = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", zge = qj && typeof ReadableStream == "function", L$e = qj && (typeof TextEncoder == "function" ? ((r) => (o) => r.encode(o))(new TextEncoder()) : async (r) => new Uint8Array(await new Response(r).arrayBuffer())), Vge = (r, ...o) => {
  try {
    return !!r(...o);
  } catch {
    return !1;
  }
}, B$e = zge && Vge(() => {
  let r = !1;
  const o = new Request(vp.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return r = !0, "half";
    }
  }).headers.has("Content-Type");
  return r && !o;
}), Wde = 64 * 1024, Ase = zge && Vge(() => on.isReadableStream(new Response("").body)), zW = {
  stream: Ase && ((r) => r.body)
};
qj && ((r) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((o) => {
    !zW[o] && (zW[o] = on.isFunction(r[o]) ? (c) => c[o]() : (c, i) => {
      throw new Rs(`Response type '${o}' is not supported`, Rs.ERR_NOT_SUPPORT, i);
    });
  });
})(new Response());
const H$e = async (r) => {
  if (r == null)
    return 0;
  if (on.isBlob(r))
    return r.size;
  if (on.isSpecCompliantForm(r))
    return (await new Request(vp.origin, {
      method: "POST",
      body: r
    }).arrayBuffer()).byteLength;
  if (on.isArrayBufferView(r) || on.isArrayBuffer(r))
    return r.byteLength;
  if (on.isURLSearchParams(r) && (r = r + ""), on.isString(r))
    return (await L$e(r)).byteLength;
}, z$e = async (r, o) => {
  const c = on.toFiniteNumber(r.getContentLength());
  return c ?? H$e(o);
}, V$e = qj && (async (r) => {
  let {
    url: o,
    method: c,
    data: i,
    signal: d,
    cancelToken: m,
    timeout: v,
    onDownloadProgress: g,
    onUploadProgress: C,
    responseType: O,
    headers: R,
    withCredentials: I = "same-origin",
    fetchOptions: L
  } = Hge(r);
  O = O ? (O + "").toLowerCase() : "text";
  let Z = $$e([d, m && m.toAbortSignal()], v), ne;
  const se = Z && Z.unsubscribe && (() => {
    Z.unsubscribe();
  });
  let Q;
  try {
    if (C && B$e && c !== "get" && c !== "head" && (Q = await z$e(R, i)) !== 0) {
      let we = new Request(o, {
        method: "POST",
        body: i,
        duplex: "half"
      }), be;
      if (on.isFormData(i) && (be = we.headers.get("content-type")) && R.setContentType(be), we.body) {
        const [q, Te] = Hde(
          Q,
          HW(zde(C))
        );
        i = Ude(we.body, Wde, q, Te);
      }
    }
    on.isString(I) || (I = I ? "include" : "omit");
    const he = "credentials" in Request.prototype;
    ne = new Request(o, {
      ...L,
      signal: Z,
      method: c.toUpperCase(),
      headers: R.normalize().toJSON(),
      body: i,
      duplex: "half",
      credentials: he ? I : void 0
    });
    let ue = await fetch(ne, L);
    const G = Ase && (O === "stream" || O === "response");
    if (Ase && (g || G && se)) {
      const we = {};
      ["status", "statusText", "headers"].forEach((Le) => {
        we[Le] = ue[Le];
      });
      const be = on.toFiniteNumber(ue.headers.get("content-length")), [q, Te] = g && Hde(
        be,
        HW(zde(g), !0)
      ) || [];
      ue = new Response(
        Ude(ue.body, Wde, q, () => {
          Te && Te(), se && se();
        }),
        we
      );
    }
    O = O || "text";
    let me = await zW[on.findKey(zW, O) || "text"](ue, r);
    return !G && se && se(), await new Promise((we, be) => {
      Lge(we, be, {
        data: me,
        headers: T1.from(ue.headers),
        status: ue.status,
        statusText: ue.statusText,
        config: r,
        request: ne
      });
    });
  } catch (he) {
    throw se && se(), he && he.name === "TypeError" && /Load failed|fetch/i.test(he.message) ? Object.assign(
      new Rs("Network Error", Rs.ERR_NETWORK, r, ne),
      {
        cause: he.cause || he
      }
    ) : Rs.from(he, he && he.code, r, ne);
  }
}), kse = {
  http: t$e,
  xhr: P$e,
  fetch: V$e
};
on.forEach(kse, (r, o) => {
  if (r) {
    try {
      Object.defineProperty(r, "name", { value: o });
    } catch {
    }
    Object.defineProperty(r, "adapterName", { value: o });
  }
});
const jde = (r) => `- ${r}`, U$e = (r) => on.isFunction(r) || r === null || r === !1, Uge = {
  getAdapter: (r) => {
    r = on.isArray(r) ? r : [r];
    const { length: o } = r;
    let c, i;
    const d = {};
    for (let m = 0; m < o; m++) {
      c = r[m];
      let v;
      if (i = c, !U$e(c) && (i = kse[(v = String(c)).toLowerCase()], i === void 0))
        throw new Rs(`Unknown adapter '${v}'`);
      if (i)
        break;
      d[v || "#" + m] = i;
    }
    if (!i) {
      const m = Object.entries(d).map(
        ([g, C]) => `adapter ${g} ` + (C === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let v = o ? m.length > 1 ? `since :
` + m.map(jde).join(`
`) : " " + jde(m[0]) : "as no adapter specified";
      throw new Rs(
        "There is no suitable adapter to dispatch the request " + v,
        "ERR_NOT_SUPPORT"
      );
    }
    return i;
  },
  adapters: kse
};
function moe(r) {
  if (r.cancelToken && r.cancelToken.throwIfRequested(), r.signal && r.signal.aborted)
    throw new nI(null, r);
}
function qde(r) {
  return moe(r), r.headers = T1.from(r.headers), r.data = foe.call(
    r,
    r.transformRequest
  ), ["post", "put", "patch"].indexOf(r.method) !== -1 && r.headers.setContentType("application/x-www-form-urlencoded", !1), Uge.getAdapter(r.adapter || oie.adapter)(r).then(function(i) {
    return moe(r), i.data = foe.call(
      r,
      r.transformResponse,
      i
    ), i.headers = T1.from(i.headers), i;
  }, function(i) {
    return Fge(i) || (moe(r), i && i.response && (i.response.data = foe.call(
      r,
      r.transformResponse,
      i.response
    ), i.response.headers = T1.from(i.response.headers))), Promise.reject(i);
  });
}
const Wge = "1.10.0", Gj = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((r, o) => {
  Gj[r] = function(i) {
    return typeof i === r || "a" + (o < 1 ? "n " : " ") + r;
  };
});
const Gde = {};
Gj.transitional = function(o, c, i) {
  function d(m, v) {
    return "[Axios v" + Wge + "] Transitional option '" + m + "'" + v + (i ? ". " + i : "");
  }
  return (m, v, g) => {
    if (o === !1)
      throw new Rs(
        d(v, " has been removed" + (c ? " in " + c : "")),
        Rs.ERR_DEPRECATED
      );
    return c && !Gde[v] && (Gde[v] = !0, console.warn(
      d(
        v,
        " has been deprecated since v" + c + " and will be removed in the near future"
      )
    )), o ? o(m, v, g) : !0;
  };
};
Gj.spelling = function(o) {
  return (c, i) => (console.warn(`${i} is likely a misspelling of ${o}`), !0);
};
function W$e(r, o, c) {
  if (typeof r != "object")
    throw new Rs("options must be an object", Rs.ERR_BAD_OPTION_VALUE);
  const i = Object.keys(r);
  let d = i.length;
  for (; d-- > 0; ) {
    const m = i[d], v = o[m];
    if (v) {
      const g = r[m], C = g === void 0 || v(g, m, r);
      if (C !== !0)
        throw new Rs("option " + m + " must be " + C, Rs.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (c !== !0)
      throw new Rs("Unknown option " + m, Rs.ERR_BAD_OPTION);
  }
}
const pW = {
  assertOptions: W$e,
  validators: Gj
}, kS = pW.validators;
let VW = class {
  constructor(o) {
    this.defaults = o || {}, this.interceptors = {
      request: new Lde(),
      response: new Lde()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(o, c) {
    try {
      return await this._request(o, c);
    } catch (i) {
      if (i instanceof Error) {
        let d = {};
        Error.captureStackTrace ? Error.captureStackTrace(d) : d = new Error();
        const m = d.stack ? d.stack.replace(/^.+\n/, "") : "";
        try {
          i.stack ? m && !String(i.stack).endsWith(m.replace(/^.+\n.+\n/, "")) && (i.stack += `
` + m) : i.stack = m;
        } catch {
        }
      }
      throw i;
    }
  }
  _request(o, c) {
    typeof o == "string" ? (c = c || {}, c.url = o) : c = o || {}, c = wk(this.defaults, c);
    const { transitional: i, paramsSerializer: d, headers: m } = c;
    i !== void 0 && pW.assertOptions(i, {
      silentJSONParsing: kS.transitional(kS.boolean),
      forcedJSONParsing: kS.transitional(kS.boolean),
      clarifyTimeoutError: kS.transitional(kS.boolean)
    }, !1), d != null && (on.isFunction(d) ? c.paramsSerializer = {
      serialize: d
    } : pW.assertOptions(d, {
      encode: kS.function,
      serialize: kS.function
    }, !0)), c.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? c.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : c.allowAbsoluteUrls = !0), pW.assertOptions(c, {
      baseUrl: kS.spelling("baseURL"),
      withXsrfToken: kS.spelling("withXSRFToken")
    }, !0), c.method = (c.method || this.defaults.method || "get").toLowerCase();
    let v = m && on.merge(
      m.common,
      m[c.method]
    );
    m && on.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (ne) => {
        delete m[ne];
      }
    ), c.headers = T1.concat(v, m);
    const g = [];
    let C = !0;
    this.interceptors.request.forEach(function(se) {
      typeof se.runWhen == "function" && se.runWhen(c) === !1 || (C = C && se.synchronous, g.unshift(se.fulfilled, se.rejected));
    });
    const O = [];
    this.interceptors.response.forEach(function(se) {
      O.push(se.fulfilled, se.rejected);
    });
    let R, I = 0, L;
    if (!C) {
      const ne = [qde.bind(this), void 0];
      for (ne.unshift.apply(ne, g), ne.push.apply(ne, O), L = ne.length, R = Promise.resolve(c); I < L; )
        R = R.then(ne[I++], ne[I++]);
      return R;
    }
    L = g.length;
    let Z = c;
    for (I = 0; I < L; ) {
      const ne = g[I++], se = g[I++];
      try {
        Z = ne(Z);
      } catch (Q) {
        se.call(this, Q);
        break;
      }
    }
    try {
      R = qde.call(this, Z);
    } catch (ne) {
      return Promise.reject(ne);
    }
    for (I = 0, L = O.length; I < L; )
      R = R.then(O[I++], O[I++]);
    return R;
  }
  getUri(o) {
    o = wk(this.defaults, o);
    const c = Bge(o.baseURL, o.url, o.allowAbsoluteUrls);
    return $ge(c, o.params, o.paramsSerializer);
  }
};
on.forEach(["delete", "get", "head", "options"], function(o) {
  VW.prototype[o] = function(c, i) {
    return this.request(wk(i || {}, {
      method: o,
      url: c,
      data: (i || {}).data
    }));
  };
});
on.forEach(["post", "put", "patch"], function(o) {
  function c(i) {
    return function(m, v, g) {
      return this.request(wk(g || {}, {
        method: o,
        headers: i ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: m,
        data: v
      }));
    };
  }
  VW.prototype[o] = c(), VW.prototype[o + "Form"] = c(!0);
});
const hW = VW;
let j$e = class jge {
  constructor(o) {
    if (typeof o != "function")
      throw new TypeError("executor must be a function.");
    let c;
    this.promise = new Promise(function(m) {
      c = m;
    });
    const i = this;
    this.promise.then((d) => {
      if (!i._listeners)
        return;
      let m = i._listeners.length;
      for (; m-- > 0; )
        i._listeners[m](d);
      i._listeners = null;
    }), this.promise.then = (d) => {
      let m;
      const v = new Promise((g) => {
        i.subscribe(g), m = g;
      }).then(d);
      return v.cancel = function() {
        i.unsubscribe(m);
      }, v;
    }, o(function(m, v, g) {
      i.reason || (i.reason = new nI(m, v, g), c(i.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(o) {
    if (this.reason) {
      o(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(o) : this._listeners = [o];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(o) {
    if (!this._listeners)
      return;
    const c = this._listeners.indexOf(o);
    c !== -1 && this._listeners.splice(c, 1);
  }
  toAbortSignal() {
    const o = new AbortController(), c = (i) => {
      o.abort(i);
    };
    return this.subscribe(c), o.signal.unsubscribe = () => this.unsubscribe(c), o.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let o;
    return {
      token: new jge(function(d) {
        o = d;
      }),
      cancel: o
    };
  }
};
const q$e = j$e;
function G$e(r) {
  return function(c) {
    return r.apply(null, c);
  };
}
function Z$e(r) {
  return on.isObject(r) && r.isAxiosError === !0;
}
const Nse = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(Nse).forEach(([r, o]) => {
  Nse[o] = r;
});
const K$e = Nse;
function qge(r) {
  const o = new hW(r), c = Ege(hW.prototype.request, o);
  return on.extend(c, hW.prototype, o, { allOwnKeys: !0 }), on.extend(c, o, null, { allOwnKeys: !0 }), c.create = function(d) {
    return qge(wk(r, d));
  }, c;
}
const Nd = qge(oie);
Nd.Axios = hW;
Nd.CanceledError = nI;
Nd.CancelToken = q$e;
Nd.isCancel = Fge;
Nd.VERSION = Wge;
Nd.toFormData = Wj;
Nd.AxiosError = Rs;
Nd.Cancel = Nd.CanceledError;
Nd.all = function(o) {
  return Promise.all(o);
};
Nd.spread = G$e;
Nd.isAxiosError = Z$e;
Nd.mergeConfig = wk;
Nd.AxiosHeaders = T1;
Nd.formToJSON = (r) => Mge(on.isHTMLForm(r) ? new FormData(r) : r);
Nd.getAdapter = Uge.getAdapter;
Nd.HttpStatusCode = K$e;
Nd.default = Nd;
const oB = Nd, {
  Axios: Y$e,
  AxiosError: Q$e,
  CanceledError: X$e,
  isCancel: J$e,
  CancelToken: eIe,
  VERSION: tIe,
  all: nIe,
  Cancel: rIe,
  isAxiosError: oIe,
  spread: sIe,
  toFormData: aIe,
  AxiosHeaders: iIe,
  HttpStatusCode: cIe,
  formToJSON: lIe,
  getAdapter: uIe,
  mergeConfig: dIe
} = oB, fIe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Axios: Y$e,
  AxiosError: Q$e,
  AxiosHeaders: iIe,
  Cancel: rIe,
  CancelToken: eIe,
  CanceledError: X$e,
  HttpStatusCode: cIe,
  VERSION: tIe,
  all: nIe,
  default: oB,
  formToJSON: lIe,
  getAdapter: uIe,
  isAxiosError: oIe,
  isCancel: J$e,
  mergeConfig: dIe,
  spread: sIe,
  toFormData: aIe
}, Symbol.toStringTag, { value: "Module" }));
var mIe = UC, pIe = M1, hIe = "[object Symbol]";
function gIe(r) {
  return typeof r == "symbol" || pIe(r) && mIe(r) == hIe;
}
var Zj = gIe, vIe = $h, bIe = Zj, yIe = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, SIe = /^\w*$/;
function wIe(r, o) {
  if (vIe(r))
    return !1;
  var c = typeof r;
  return c == "number" || c == "symbol" || c == "boolean" || r == null || bIe(r) ? !0 : SIe.test(r) || !yIe.test(r) || o != null && r in Object(o);
}
var sie = wIe, EIe = Fk, CIe = EIe(Object, "create"), Kj = CIe, Zde = Kj;
function xIe() {
  this.__data__ = Zde ? Zde(null) : {}, this.size = 0;
}
var TIe = xIe;
function _Ie(r) {
  var o = this.has(r) && delete this.__data__[r];
  return this.size -= o ? 1 : 0, o;
}
var OIe = _Ie, AIe = Kj, kIe = "__lodash_hash_undefined__", NIe = Object.prototype, RIe = NIe.hasOwnProperty;
function PIe(r) {
  var o = this.__data__;
  if (AIe) {
    var c = o[r];
    return c === kIe ? void 0 : c;
  }
  return RIe.call(o, r) ? o[r] : void 0;
}
var DIe = PIe, $Ie = Kj, IIe = Object.prototype, MIe = IIe.hasOwnProperty;
function FIe(r) {
  var o = this.__data__;
  return $Ie ? o[r] !== void 0 : MIe.call(o, r);
}
var LIe = FIe, BIe = Kj, HIe = "__lodash_hash_undefined__";
function zIe(r, o) {
  var c = this.__data__;
  return this.size += this.has(r) ? 0 : 1, c[r] = BIe && o === void 0 ? HIe : o, this;
}
var VIe = zIe, UIe = TIe, WIe = OIe, jIe = DIe, qIe = LIe, GIe = VIe;
function rI(r) {
  var o = -1, c = r == null ? 0 : r.length;
  for (this.clear(); ++o < c; ) {
    var i = r[o];
    this.set(i[0], i[1]);
  }
}
rI.prototype.clear = UIe;
rI.prototype.delete = WIe;
rI.prototype.get = jIe;
rI.prototype.has = qIe;
rI.prototype.set = GIe;
var ZIe = rI;
function KIe() {
  this.__data__ = [], this.size = 0;
}
var YIe = KIe;
function QIe(r, o) {
  return r === o || r !== r && o !== o;
}
var Yj = QIe, XIe = Yj;
function JIe(r, o) {
  for (var c = r.length; c--; )
    if (XIe(r[c][0], o))
      return c;
  return -1;
}
var Qj = JIe, eMe = Qj, tMe = Array.prototype, nMe = tMe.splice;
function rMe(r) {
  var o = this.__data__, c = eMe(o, r);
  if (c < 0)
    return !1;
  var i = o.length - 1;
  return c == i ? o.pop() : nMe.call(o, c, 1), --this.size, !0;
}
var oMe = rMe, sMe = Qj;
function aMe(r) {
  var o = this.__data__, c = sMe(o, r);
  return c < 0 ? void 0 : o[c][1];
}
var iMe = aMe, cMe = Qj;
function lMe(r) {
  return cMe(this.__data__, r) > -1;
}
var uMe = lMe, dMe = Qj;
function fMe(r, o) {
  var c = this.__data__, i = dMe(c, r);
  return i < 0 ? (++this.size, c.push([r, o])) : c[i][1] = o, this;
}
var mMe = fMe, pMe = YIe, hMe = oMe, gMe = iMe, vMe = uMe, bMe = mMe;
function oI(r) {
  var o = -1, c = r == null ? 0 : r.length;
  for (this.clear(); ++o < c; ) {
    var i = r[o];
    this.set(i[0], i[1]);
  }
}
oI.prototype.clear = pMe;
oI.prototype.delete = hMe;
oI.prototype.get = gMe;
oI.prototype.has = vMe;
oI.prototype.set = bMe;
var Xj = oI, Kde = ZIe, yMe = Xj, SMe = Kae;
function wMe() {
  this.size = 0, this.__data__ = {
    hash: new Kde(),
    map: new (SMe || yMe)(),
    string: new Kde()
  };
}
var EMe = wMe;
function CMe(r) {
  var o = typeof r;
  return o == "string" || o == "number" || o == "symbol" || o == "boolean" ? r !== "__proto__" : r === null;
}
var xMe = CMe, TMe = xMe;
function _Me(r, o) {
  var c = r.__data__;
  return TMe(o) ? c[typeof o == "string" ? "string" : "hash"] : c.map;
}
var Jj = _Me, OMe = Jj;
function AMe(r) {
  var o = OMe(this, r).delete(r);
  return this.size -= o ? 1 : 0, o;
}
var kMe = AMe, NMe = Jj;
function RMe(r) {
  return NMe(this, r).get(r);
}
var PMe = RMe, DMe = Jj;
function $Me(r) {
  return DMe(this, r).has(r);
}
var IMe = $Me, MMe = Jj;
function FMe(r, o) {
  var c = MMe(this, r), i = c.size;
  return c.set(r, o), this.size += c.size == i ? 0 : 1, this;
}
var LMe = FMe, BMe = EMe, HMe = kMe, zMe = PMe, VMe = IMe, UMe = LMe;
function sI(r) {
  var o = -1, c = r == null ? 0 : r.length;
  for (this.clear(); ++o < c; ) {
    var i = r[o];
    this.set(i[0], i[1]);
  }
}
sI.prototype.clear = BMe;
sI.prototype.delete = HMe;
sI.prototype.get = zMe;
sI.prototype.has = VMe;
sI.prototype.set = UMe;
var aie = sI, Gge = aie, WMe = "Expected a function";
function iie(r, o) {
  if (typeof r != "function" || o != null && typeof o != "function")
    throw new TypeError(WMe);
  var c = function() {
    var i = arguments, d = o ? o.apply(this, i) : i[0], m = c.cache;
    if (m.has(d))
      return m.get(d);
    var v = r.apply(this, i);
    return c.cache = m.set(d, v) || m, v;
  };
  return c.cache = new (iie.Cache || Gge)(), c;
}
iie.Cache = Gge;
var jMe = iie, qMe = jMe, GMe = 500;
function ZMe(r) {
  var o = qMe(r, function(i) {
    return c.size === GMe && c.clear(), i;
  }), c = o.cache;
  return o;
}
var KMe = ZMe, YMe = KMe, QMe = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, XMe = /\\(\\)?/g, JMe = YMe(function(r) {
  var o = [];
  return r.charCodeAt(0) === 46 && o.push(""), r.replace(QMe, function(c, i, d, m) {
    o.push(d ? m.replace(XMe, "$1") : i || c);
  }), o;
}), eFe = JMe;
function tFe(r, o) {
  for (var c = -1, i = r == null ? 0 : r.length, d = Array(i); ++c < i; )
    d[c] = o(r[c], c, r);
  return d;
}
var cie = tFe, Yde = J$, nFe = cie, rFe = $h, oFe = Zj, sFe = 1 / 0, Qde = Yde ? Yde.prototype : void 0, Xde = Qde ? Qde.toString : void 0;
function Zge(r) {
  if (typeof r == "string")
    return r;
  if (rFe(r))
    return nFe(r, Zge) + "";
  if (oFe(r))
    return Xde ? Xde.call(r) : "";
  var o = r + "";
  return o == "0" && 1 / r == -sFe ? "-0" : o;
}
var aFe = Zge, iFe = aFe;
function cFe(r) {
  return r == null ? "" : iFe(r);
}
var lFe = cFe, uFe = $h, dFe = sie, fFe = eFe, mFe = lFe;
function pFe(r, o) {
  return uFe(r) ? r : dFe(r, o) ? [r] : fFe(mFe(r));
}
var aI = pFe, hFe = Zj, gFe = 1 / 0;
function vFe(r) {
  if (typeof r == "string" || hFe(r))
    return r;
  var o = r + "";
  return o == "0" && 1 / r == -gFe ? "-0" : o;
}
var iI = vFe, bFe = aI, yFe = iI;
function SFe(r, o) {
  o = bFe(o, r);
  for (var c = 0, i = o.length; r != null && c < i; )
    r = r[yFe(o[c++])];
  return c && c == i ? r : void 0;
}
var eq = SFe, wFe = eq;
function EFe(r, o, c) {
  var i = r == null ? void 0 : wFe(r, o);
  return i === void 0 ? c : i;
}
var lie = EFe;
const KL = /* @__PURE__ */ Ku(lie);
function CFe(r, o) {
  return r != null && o in Object(r);
}
var xFe = CFe, TFe = 9007199254740991, _Fe = /^(?:0|[1-9]\d*)$/;
function OFe(r, o) {
  var c = typeof r;
  return o = o ?? TFe, !!o && (c == "number" || c != "symbol" && _Fe.test(r)) && r > -1 && r % 1 == 0 && r < o;
}
var tq = OFe, AFe = aI, kFe = Lj, NFe = $h, RFe = tq, PFe = Yae, DFe = iI;
function $Fe(r, o, c) {
  o = AFe(o, r);
  for (var i = -1, d = o.length, m = !1; ++i < d; ) {
    var v = DFe(o[i]);
    if (!(m = r != null && c(r, v)))
      break;
    r = r[v];
  }
  return m || ++i != d ? m : (d = r == null ? 0 : r.length, !!d && PFe(d) && RFe(v, d) && (NFe(r) || kFe(r)));
}
var IFe = $Fe, MFe = xFe, FFe = IFe;
function LFe(r, o) {
  return r != null && FFe(r, o, MFe);
}
var nq = LFe;
const BFe = /* @__PURE__ */ Ku(nq);
var cI = TypeError;
const HFe = {}, zFe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: HFe
}, Symbol.toStringTag, { value: "Module" })), VFe = /* @__PURE__ */ q$(zFe);
var uie = typeof Map == "function" && Map.prototype, poe = Object.getOwnPropertyDescriptor && uie ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, UW = uie && poe && typeof poe.get == "function" ? poe.get : null, Jde = uie && Map.prototype.forEach, die = typeof Set == "function" && Set.prototype, hoe = Object.getOwnPropertyDescriptor && die ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, WW = die && hoe && typeof hoe.get == "function" ? hoe.get : null, efe = die && Set.prototype.forEach, UFe = typeof WeakMap == "function" && WeakMap.prototype, sB = UFe ? WeakMap.prototype.has : null, WFe = typeof WeakSet == "function" && WeakSet.prototype, aB = WFe ? WeakSet.prototype.has : null, jFe = typeof WeakRef == "function" && WeakRef.prototype, tfe = jFe ? WeakRef.prototype.deref : null, qFe = Boolean.prototype.valueOf, GFe = Object.prototype.toString, ZFe = Function.prototype.toString, KFe = String.prototype.match, fie = String.prototype.slice, d2 = String.prototype.replace, YFe = String.prototype.toUpperCase, nfe = String.prototype.toLowerCase, Kge = RegExp.prototype.test, rfe = Array.prototype.concat, DS = Array.prototype.join, QFe = Array.prototype.slice, ofe = Math.floor, Rse = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, goe = Object.getOwnPropertySymbols, Pse = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, U$ = typeof Symbol == "function" && typeof Symbol.iterator == "object", iB = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === U$ || "symbol") ? Symbol.toStringTag : null, Yge = Object.prototype.propertyIsEnumerable, sfe = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(r) {
  return r.__proto__;
} : null);
function afe(r, o) {
  if (r === 1 / 0 || r === -1 / 0 || r !== r || r && r > -1e3 && r < 1e3 || Kge.call(/e/, o))
    return o;
  var c = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof r == "number") {
    var i = r < 0 ? -ofe(-r) : ofe(r);
    if (i !== r) {
      var d = String(i), m = fie.call(o, d.length + 1);
      return d2.call(d, c, "$&_") + "." + d2.call(d2.call(m, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return d2.call(o, c, "$&_");
}
var Dse = VFe, ife = Dse.custom, cfe = Jge(ife) ? ife : null, Qge = {
  __proto__: null,
  double: '"',
  single: "'"
}, XFe = {
  __proto__: null,
  double: /(["\\])/g,
  single: /(['\\])/g
}, rq = function r(o, c, i, d) {
  var m = c || {};
  if (nC(m, "quoteStyle") && !nC(Qge, m.quoteStyle))
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  if (nC(m, "maxStringLength") && (typeof m.maxStringLength == "number" ? m.maxStringLength < 0 && m.maxStringLength !== 1 / 0 : m.maxStringLength !== null))
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  var v = nC(m, "customInspect") ? m.customInspect : !0;
  if (typeof v != "boolean" && v !== "symbol")
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  if (nC(m, "indent") && m.indent !== null && m.indent !== "	" && !(parseInt(m.indent, 10) === m.indent && m.indent > 0))
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  if (nC(m, "numericSeparator") && typeof m.numericSeparator != "boolean")
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  var g = m.numericSeparator;
  if (typeof o > "u")
    return "undefined";
  if (o === null)
    return "null";
  if (typeof o == "boolean")
    return o ? "true" : "false";
  if (typeof o == "string")
    return tve(o, m);
  if (typeof o == "number") {
    if (o === 0)
      return 1 / 0 / o > 0 ? "0" : "-0";
    var C = String(o);
    return g ? afe(o, C) : C;
  }
  if (typeof o == "bigint") {
    var O = String(o) + "n";
    return g ? afe(o, O) : O;
  }
  var R = typeof m.depth > "u" ? 5 : m.depth;
  if (typeof i > "u" && (i = 0), i >= R && R > 0 && typeof o == "object")
    return $se(o) ? "[Array]" : "[Object]";
  var I = g3e(m, i);
  if (typeof d > "u")
    d = [];
  else if (eve(d, o) >= 0)
    return "[Circular]";
  function L(pt, sn, Lt) {
    if (sn && (d = QFe.call(d), d.push(sn)), Lt) {
      var z = {
        depth: m.depth
      };
      return nC(m, "quoteStyle") && (z.quoteStyle = m.quoteStyle), r(pt, z, i + 1, d);
    }
    return r(pt, m, i + 1, d);
  }
  if (typeof o == "function" && !lfe(o)) {
    var Z = i3e(o), ne = eW(o, L);
    return "[Function" + (Z ? ": " + Z : " (anonymous)") + "]" + (ne.length > 0 ? " { " + DS.call(ne, ", ") + " }" : "");
  }
  if (Jge(o)) {
    var se = U$ ? d2.call(String(o), /^(Symbol\(.*\))_[^)]*$/, "$1") : Pse.call(o);
    return typeof o == "object" && !U$ ? UL(se) : se;
  }
  if (m3e(o)) {
    for (var Q = "<" + nfe.call(String(o.nodeName)), he = o.attributes || [], ue = 0; ue < he.length; ue++)
      Q += " " + he[ue].name + "=" + Xge(JFe(he[ue].value), "double", m);
    return Q += ">", o.childNodes && o.childNodes.length && (Q += "..."), Q += "</" + nfe.call(String(o.nodeName)) + ">", Q;
  }
  if ($se(o)) {
    if (o.length === 0)
      return "[]";
    var G = eW(o, L);
    return I && !h3e(G) ? "[" + Ise(G, I) + "]" : "[ " + DS.call(G, ", ") + " ]";
  }
  if (t3e(o)) {
    var me = eW(o, L);
    return !("cause" in Error.prototype) && "cause" in o && !Yge.call(o, "cause") ? "{ [" + String(o) + "] " + DS.call(rfe.call("[cause]: " + L(o.cause), me), ", ") + " }" : me.length === 0 ? "[" + String(o) + "]" : "{ [" + String(o) + "] " + DS.call(me, ", ") + " }";
  }
  if (typeof o == "object" && v) {
    if (cfe && typeof o[cfe] == "function" && Dse)
      return Dse(o, { depth: R - i });
    if (v !== "symbol" && typeof o.inspect == "function")
      return o.inspect();
  }
  if (c3e(o)) {
    var we = [];
    return Jde && Jde.call(o, function(pt, sn) {
      we.push(L(sn, o, !0) + " => " + L(pt, o));
    }), ufe("Map", UW.call(o), we, I);
  }
  if (d3e(o)) {
    var be = [];
    return efe && efe.call(o, function(pt) {
      be.push(L(pt, o));
    }), ufe("Set", WW.call(o), be, I);
  }
  if (l3e(o))
    return voe("WeakMap");
  if (f3e(o))
    return voe("WeakSet");
  if (u3e(o))
    return voe("WeakRef");
  if (r3e(o))
    return UL(L(Number(o)));
  if (s3e(o))
    return UL(L(Rse.call(o)));
  if (o3e(o))
    return UL(qFe.call(o));
  if (n3e(o))
    return UL(L(String(o)));
  if (typeof window < "u" && o === window)
    return "{ [object Window] }";
  if (typeof globalThis < "u" && o === globalThis || typeof S1 < "u" && o === S1)
    return "{ [object globalThis] }";
  if (!e3e(o) && !lfe(o)) {
    var q = eW(o, L), Te = sfe ? sfe(o) === Object.prototype : o instanceof Object || o.constructor === Object, Le = o instanceof Object ? "" : "null prototype", je = !Te && iB && Object(o) === o && iB in o ? fie.call(I2(o), 8, -1) : Le ? "Object" : "", Ie = Te || typeof o.constructor != "function" ? "" : o.constructor.name ? o.constructor.name + " " : "", Ce = Ie + (je || Le ? "[" + DS.call(rfe.call([], je || [], Le || []), ": ") + "] " : "");
    return q.length === 0 ? Ce + "{}" : I ? Ce + "{" + Ise(q, I) + "}" : Ce + "{ " + DS.call(q, ", ") + " }";
  }
  return String(o);
};
function Xge(r, o, c) {
  var i = c.quoteStyle || o, d = Qge[i];
  return d + r + d;
}
function JFe(r) {
  return d2.call(String(r), /"/g, "&quot;");
}
function Lk(r) {
  return !iB || !(typeof r == "object" && (iB in r || typeof r[iB] < "u"));
}
function $se(r) {
  return I2(r) === "[object Array]" && Lk(r);
}
function e3e(r) {
  return I2(r) === "[object Date]" && Lk(r);
}
function lfe(r) {
  return I2(r) === "[object RegExp]" && Lk(r);
}
function t3e(r) {
  return I2(r) === "[object Error]" && Lk(r);
}
function n3e(r) {
  return I2(r) === "[object String]" && Lk(r);
}
function r3e(r) {
  return I2(r) === "[object Number]" && Lk(r);
}
function o3e(r) {
  return I2(r) === "[object Boolean]" && Lk(r);
}
function Jge(r) {
  if (U$)
    return r && typeof r == "object" && r instanceof Symbol;
  if (typeof r == "symbol")
    return !0;
  if (!r || typeof r != "object" || !Pse)
    return !1;
  try {
    return Pse.call(r), !0;
  } catch {
  }
  return !1;
}
function s3e(r) {
  if (!r || typeof r != "object" || !Rse)
    return !1;
  try {
    return Rse.call(r), !0;
  } catch {
  }
  return !1;
}
var a3e = Object.prototype.hasOwnProperty || function(r) {
  return r in this;
};
function nC(r, o) {
  return a3e.call(r, o);
}
function I2(r) {
  return GFe.call(r);
}
function i3e(r) {
  if (r.name)
    return r.name;
  var o = KFe.call(ZFe.call(r), /^function\s*([\w$]+)/);
  return o ? o[1] : null;
}
function eve(r, o) {
  if (r.indexOf)
    return r.indexOf(o);
  for (var c = 0, i = r.length; c < i; c++)
    if (r[c] === o)
      return c;
  return -1;
}
function c3e(r) {
  if (!UW || !r || typeof r != "object")
    return !1;
  try {
    UW.call(r);
    try {
      WW.call(r);
    } catch {
      return !0;
    }
    return r instanceof Map;
  } catch {
  }
  return !1;
}
function l3e(r) {
  if (!sB || !r || typeof r != "object")
    return !1;
  try {
    sB.call(r, sB);
    try {
      aB.call(r, aB);
    } catch {
      return !0;
    }
    return r instanceof WeakMap;
  } catch {
  }
  return !1;
}
function u3e(r) {
  if (!tfe || !r || typeof r != "object")
    return !1;
  try {
    return tfe.call(r), !0;
  } catch {
  }
  return !1;
}
function d3e(r) {
  if (!WW || !r || typeof r != "object")
    return !1;
  try {
    WW.call(r);
    try {
      UW.call(r);
    } catch {
      return !0;
    }
    return r instanceof Set;
  } catch {
  }
  return !1;
}
function f3e(r) {
  if (!aB || !r || typeof r != "object")
    return !1;
  try {
    aB.call(r, aB);
    try {
      sB.call(r, sB);
    } catch {
      return !0;
    }
    return r instanceof WeakSet;
  } catch {
  }
  return !1;
}
function m3e(r) {
  return !r || typeof r != "object" ? !1 : typeof HTMLElement < "u" && r instanceof HTMLElement ? !0 : typeof r.nodeName == "string" && typeof r.getAttribute == "function";
}
function tve(r, o) {
  if (r.length > o.maxStringLength) {
    var c = r.length - o.maxStringLength, i = "... " + c + " more character" + (c > 1 ? "s" : "");
    return tve(fie.call(r, 0, o.maxStringLength), o) + i;
  }
  var d = XFe[o.quoteStyle || "single"];
  d.lastIndex = 0;
  var m = d2.call(d2.call(r, d, "\\$1"), /[\x00-\x1f]/g, p3e);
  return Xge(m, "single", o);
}
function p3e(r) {
  var o = r.charCodeAt(0), c = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[o];
  return c ? "\\" + c : "\\x" + (o < 16 ? "0" : "") + YFe.call(o.toString(16));
}
function UL(r) {
  return "Object(" + r + ")";
}
function voe(r) {
  return r + " { ? }";
}
function ufe(r, o, c, i) {
  var d = i ? Ise(c, i) : DS.call(c, ", ");
  return r + " (" + o + ") {" + d + "}";
}
function h3e(r) {
  for (var o = 0; o < r.length; o++)
    if (eve(r[o], `
`) >= 0)
      return !1;
  return !0;
}
function g3e(r, o) {
  var c;
  if (r.indent === "	")
    c = "	";
  else if (typeof r.indent == "number" && r.indent > 0)
    c = DS.call(Array(r.indent + 1), " ");
  else
    return null;
  return {
    base: c,
    prev: DS.call(Array(o + 1), c)
  };
}
function Ise(r, o) {
  if (r.length === 0)
    return "";
  var c = `
` + o.prev + o.base;
  return c + DS.call(r, "," + c) + `
` + o.prev;
}
function eW(r, o) {
  var c = $se(r), i = [];
  if (c) {
    i.length = r.length;
    for (var d = 0; d < r.length; d++)
      i[d] = nC(r, d) ? o(r[d], r) : "";
  }
  var m = typeof goe == "function" ? goe(r) : [], v;
  if (U$) {
    v = {};
    for (var g = 0; g < m.length; g++)
      v["$" + m[g]] = m[g];
  }
  for (var C in r)
    nC(r, C) && (c && String(Number(C)) === C && C < r.length || U$ && v["$" + C] instanceof Symbol || (Kge.call(/[^\w$]/, C) ? i.push(o(C, r) + ": " + o(r[C], r)) : i.push(C + ": " + o(r[C], r))));
  if (typeof goe == "function")
    for (var O = 0; O < m.length; O++)
      Yge.call(r, m[O]) && i.push("[" + o(m[O]) + "]: " + o(r[m[O]], r));
  return i;
}
var v3e = rq, b3e = cI, oq = function(r, o, c) {
  for (var i = r, d; (d = i.next) != null; i = d)
    if (d.key === o)
      return i.next = d.next, c || (d.next = /** @type {NonNullable<typeof list.next>} */
      r.next, r.next = d), d;
}, y3e = function(r, o) {
  if (r) {
    var c = oq(r, o);
    return c && c.value;
  }
}, S3e = function(r, o, c) {
  var i = oq(r, o);
  i ? i.value = c : r.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */
  {
    // eslint-disable-line no-param-reassign, no-extra-parens
    key: o,
    next: r.next,
    value: c
  };
}, w3e = function(r, o) {
  return r ? !!oq(r, o) : !1;
}, E3e = function(r, o) {
  if (r)
    return oq(r, o, !0);
}, C3e = function() {
  var o, c = {
    assert: function(i) {
      if (!c.has(i))
        throw new b3e("Side channel does not contain " + v3e(i));
    },
    delete: function(i) {
      var d = o && o.next, m = E3e(o, i);
      return m && d && d === m && (o = void 0), !!m;
    },
    get: function(i) {
      return y3e(o, i);
    },
    has: function(i) {
      return w3e(o, i);
    },
    set: function(i, d) {
      o || (o = {
        next: void 0
      }), S3e(
        /** @type {NonNullable<typeof $o>} */
        o,
        i,
        d
      );
    }
  };
  return c;
}, nve = Object, x3e = Error, T3e = EvalError, _3e = RangeError, O3e = ReferenceError, A3e = SyntaxError, k3e = URIError, N3e = Math.abs, R3e = Math.floor, P3e = Math.max, D3e = Math.min, $3e = Math.pow, I3e = Math.round, M3e = Number.isNaN || function(o) {
  return o !== o;
}, F3e = M3e, L3e = function(o) {
  return F3e(o) || o === 0 ? o : o < 0 ? -1 : 1;
}, B3e = Object.getOwnPropertyDescriptor, gW = B3e;
if (gW)
  try {
    gW([], "length");
  } catch {
    gW = null;
  }
var rve = gW, vW = Object.defineProperty || !1;
if (vW)
  try {
    vW({}, "a", { value: 1 });
  } catch {
    vW = !1;
  }
var H3e = vW, boe, dfe;
function z3e() {
  return dfe || (dfe = 1, boe = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var o = {}, c = Symbol("test"), i = Object(c);
    if (typeof c == "string" || Object.prototype.toString.call(c) !== "[object Symbol]" || Object.prototype.toString.call(i) !== "[object Symbol]")
      return !1;
    var d = 42;
    o[c] = d;
    for (var m in o)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(o).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(o).length !== 0)
      return !1;
    var v = Object.getOwnPropertySymbols(o);
    if (v.length !== 1 || v[0] !== c || !Object.prototype.propertyIsEnumerable.call(o, c))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var g = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(o, c)
      );
      if (g.value !== d || g.enumerable !== !0)
        return !1;
    }
    return !0;
  }), boe;
}
var yoe, ffe;
function V3e() {
  if (ffe)
    return yoe;
  ffe = 1;
  var r = typeof Symbol < "u" && Symbol, o = z3e();
  return yoe = function() {
    return typeof r != "function" || typeof Symbol != "function" || typeof r("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : o();
  }, yoe;
}
var Soe, mfe;
function ove() {
  return mfe || (mfe = 1, Soe = typeof Reflect < "u" && Reflect.getPrototypeOf || null), Soe;
}
var woe, pfe;
function sve() {
  if (pfe)
    return woe;
  pfe = 1;
  var r = nve;
  return woe = r.getPrototypeOf || null, woe;
}
var Eoe, hfe;
function U3e() {
  if (hfe)
    return Eoe;
  hfe = 1;
  var r = "Function.prototype.bind called on incompatible ", o = Object.prototype.toString, c = Math.max, i = "[object Function]", d = function(C, O) {
    for (var R = [], I = 0; I < C.length; I += 1)
      R[I] = C[I];
    for (var L = 0; L < O.length; L += 1)
      R[L + C.length] = O[L];
    return R;
  }, m = function(C, O) {
    for (var R = [], I = O || 0, L = 0; I < C.length; I += 1, L += 1)
      R[L] = C[I];
    return R;
  }, v = function(g, C) {
    for (var O = "", R = 0; R < g.length; R += 1)
      O += g[R], R + 1 < g.length && (O += C);
    return O;
  };
  return Eoe = function(C) {
    var O = this;
    if (typeof O != "function" || o.apply(O) !== i)
      throw new TypeError(r + O);
    for (var R = m(arguments, 1), I, L = function() {
      if (this instanceof I) {
        var he = O.apply(
          this,
          d(R, arguments)
        );
        return Object(he) === he ? he : this;
      }
      return O.apply(
        C,
        d(R, arguments)
      );
    }, Z = c(0, O.length - R.length), ne = [], se = 0; se < Z; se++)
      ne[se] = "$" + se;
    if (I = Function("binder", "return function (" + v(ne, ",") + "){ return binder.apply(this,arguments); }")(L), O.prototype) {
      var Q = function() {
      };
      Q.prototype = O.prototype, I.prototype = new Q(), Q.prototype = null;
    }
    return I;
  }, Eoe;
}
var Coe, gfe;
function sq() {
  if (gfe)
    return Coe;
  gfe = 1;
  var r = U3e();
  return Coe = Function.prototype.bind || r, Coe;
}
var xoe, vfe;
function mie() {
  return vfe || (vfe = 1, xoe = Function.prototype.call), xoe;
}
var Toe, bfe;
function ave() {
  return bfe || (bfe = 1, Toe = Function.prototype.apply), Toe;
}
var W3e = typeof Reflect < "u" && Reflect && Reflect.apply, j3e = sq(), q3e = ave(), G3e = mie(), Z3e = W3e, K3e = Z3e || j3e.call(G3e, q3e), Y3e = sq(), Q3e = cI, X3e = mie(), J3e = K3e, ive = function(o) {
  if (o.length < 1 || typeof o[0] != "function")
    throw new Q3e("a function is required");
  return J3e(Y3e, X3e, o);
}, _oe, yfe;
function e4e() {
  if (yfe)
    return _oe;
  yfe = 1;
  var r = ive, o = rve, c;
  try {
    c = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (v) {
    if (!v || typeof v != "object" || !("code" in v) || v.code !== "ERR_PROTO_ACCESS")
      throw v;
  }
  var i = !!c && o && o(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  ), d = Object, m = d.getPrototypeOf;
  return _oe = i && typeof i.get == "function" ? r([i.get]) : typeof m == "function" ? (
    /** @type {import('./get')} */
    function(g) {
      return m(g == null ? g : d(g));
    }
  ) : !1, _oe;
}
var Ooe, Sfe;
function t4e() {
  if (Sfe)
    return Ooe;
  Sfe = 1;
  var r = ove(), o = sve(), c = e4e();
  return Ooe = r ? function(d) {
    return r(d);
  } : o ? function(d) {
    if (!d || typeof d != "object" && typeof d != "function")
      throw new TypeError("getProto: not an object");
    return o(d);
  } : c ? function(d) {
    return c(d);
  } : null, Ooe;
}
var Aoe, wfe;
function n4e() {
  if (wfe)
    return Aoe;
  wfe = 1;
  var r = Function.prototype.call, o = Object.prototype.hasOwnProperty, c = sq();
  return Aoe = c.call(r, o), Aoe;
}
var fa, r4e = nve, o4e = x3e, s4e = T3e, a4e = _3e, i4e = O3e, W$ = A3e, GD = cI, c4e = k3e, l4e = N3e, u4e = R3e, d4e = P3e, f4e = D3e, m4e = $3e, p4e = I3e, h4e = L3e, cve = Function, koe = function(r) {
  try {
    return cve('"use strict"; return (' + r + ").constructor;")();
  } catch {
  }
}, $B = rve, g4e = H3e, Noe = function() {
  throw new GD();
}, v4e = $B ? function() {
  try {
    return arguments.callee, Noe;
  } catch {
    try {
      return $B(arguments, "callee").get;
    } catch {
      return Noe;
    }
  }
}() : Noe, DD = V3e()(), Gf = t4e(), b4e = sve(), y4e = ove(), lve = ave(), YB = mie(), FD = {}, S4e = typeof Uint8Array > "u" || !Gf ? fa : Gf(Uint8Array), UA = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? fa : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? fa : ArrayBuffer,
  "%ArrayIteratorPrototype%": DD && Gf ? Gf([][Symbol.iterator]()) : fa,
  "%AsyncFromSyncIteratorPrototype%": fa,
  "%AsyncFunction%": FD,
  "%AsyncGenerator%": FD,
  "%AsyncGeneratorFunction%": FD,
  "%AsyncIteratorPrototype%": FD,
  "%Atomics%": typeof Atomics > "u" ? fa : Atomics,
  "%BigInt%": typeof BigInt > "u" ? fa : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? fa : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? fa : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? fa : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": o4e,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": s4e,
  "%Float16Array%": typeof Float16Array > "u" ? fa : Float16Array,
  "%Float32Array%": typeof Float32Array > "u" ? fa : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? fa : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? fa : FinalizationRegistry,
  "%Function%": cve,
  "%GeneratorFunction%": FD,
  "%Int8Array%": typeof Int8Array > "u" ? fa : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? fa : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? fa : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": DD && Gf ? Gf(Gf([][Symbol.iterator]())) : fa,
  "%JSON%": typeof JSON == "object" ? JSON : fa,
  "%Map%": typeof Map > "u" ? fa : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !DD || !Gf ? fa : Gf((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": r4e,
  "%Object.getOwnPropertyDescriptor%": $B,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? fa : Promise,
  "%Proxy%": typeof Proxy > "u" ? fa : Proxy,
  "%RangeError%": a4e,
  "%ReferenceError%": i4e,
  "%Reflect%": typeof Reflect > "u" ? fa : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? fa : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !DD || !Gf ? fa : Gf((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? fa : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": DD && Gf ? Gf(""[Symbol.iterator]()) : fa,
  "%Symbol%": DD ? Symbol : fa,
  "%SyntaxError%": W$,
  "%ThrowTypeError%": v4e,
  "%TypedArray%": S4e,
  "%TypeError%": GD,
  "%Uint8Array%": typeof Uint8Array > "u" ? fa : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? fa : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? fa : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? fa : Uint32Array,
  "%URIError%": c4e,
  "%WeakMap%": typeof WeakMap > "u" ? fa : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? fa : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? fa : WeakSet,
  "%Function.prototype.call%": YB,
  "%Function.prototype.apply%": lve,
  "%Object.defineProperty%": g4e,
  "%Object.getPrototypeOf%": b4e,
  "%Math.abs%": l4e,
  "%Math.floor%": u4e,
  "%Math.max%": d4e,
  "%Math.min%": f4e,
  "%Math.pow%": m4e,
  "%Math.round%": p4e,
  "%Math.sign%": h4e,
  "%Reflect.getPrototypeOf%": y4e
};
if (Gf)
  try {
    null.error;
  } catch (r) {
    var w4e = Gf(Gf(r));
    UA["%Error.prototype%"] = w4e;
  }
var E4e = function r(o) {
  var c;
  if (o === "%AsyncFunction%")
    c = koe("async function () {}");
  else if (o === "%GeneratorFunction%")
    c = koe("function* () {}");
  else if (o === "%AsyncGeneratorFunction%")
    c = koe("async function* () {}");
  else if (o === "%AsyncGenerator%") {
    var i = r("%AsyncGeneratorFunction%");
    i && (c = i.prototype);
  } else if (o === "%AsyncIteratorPrototype%") {
    var d = r("%AsyncGenerator%");
    d && Gf && (c = Gf(d.prototype));
  }
  return UA[o] = c, c;
}, Efe = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, QB = sq(), jW = n4e(), C4e = QB.call(YB, Array.prototype.concat), x4e = QB.call(lve, Array.prototype.splice), Cfe = QB.call(YB, String.prototype.replace), qW = QB.call(YB, String.prototype.slice), T4e = QB.call(YB, RegExp.prototype.exec), _4e = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, O4e = /\\(\\)?/g, A4e = function(o) {
  var c = qW(o, 0, 1), i = qW(o, -1);
  if (c === "%" && i !== "%")
    throw new W$("invalid intrinsic syntax, expected closing `%`");
  if (i === "%" && c !== "%")
    throw new W$("invalid intrinsic syntax, expected opening `%`");
  var d = [];
  return Cfe(o, _4e, function(m, v, g, C) {
    d[d.length] = g ? Cfe(C, O4e, "$1") : v || m;
  }), d;
}, k4e = function(o, c) {
  var i = o, d;
  if (jW(Efe, i) && (d = Efe[i], i = "%" + d[0] + "%"), jW(UA, i)) {
    var m = UA[i];
    if (m === FD && (m = E4e(i)), typeof m > "u" && !c)
      throw new GD("intrinsic " + o + " exists, but is not available. Please file an issue!");
    return {
      alias: d,
      name: i,
      value: m
    };
  }
  throw new W$("intrinsic " + o + " does not exist!");
}, pie = function(o, c) {
  if (typeof o != "string" || o.length === 0)
    throw new GD("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof c != "boolean")
    throw new GD('"allowMissing" argument must be a boolean');
  if (T4e(/^%?[^%]*%?$/, o) === null)
    throw new W$("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var i = A4e(o), d = i.length > 0 ? i[0] : "", m = k4e("%" + d + "%", c), v = m.name, g = m.value, C = !1, O = m.alias;
  O && (d = O[0], x4e(i, C4e([0, 1], O)));
  for (var R = 1, I = !0; R < i.length; R += 1) {
    var L = i[R], Z = qW(L, 0, 1), ne = qW(L, -1);
    if ((Z === '"' || Z === "'" || Z === "`" || ne === '"' || ne === "'" || ne === "`") && Z !== ne)
      throw new W$("property names with quotes must have matching quotes");
    if ((L === "constructor" || !I) && (C = !0), d += "." + L, v = "%" + d + "%", jW(UA, v))
      g = UA[v];
    else if (g != null) {
      if (!(L in g)) {
        if (!c)
          throw new GD("base intrinsic for " + o + " exists, but the property is not available.");
        return;
      }
      if ($B && R + 1 >= i.length) {
        var se = $B(g, L);
        I = !!se, I && "get" in se && !("originalValue" in se.get) ? g = se.get : g = g[L];
      } else
        I = jW(g, L), g = g[L];
      I && !C && (UA[v] = g);
    }
  }
  return g;
}, uve = pie, dve = ive, N4e = dve([uve("%String.prototype.indexOf%")]), fve = function(o, c) {
  var i = (
    /** @type {(this: unknown, ...args: unknown[]) => unknown} */
    uve(o, !!c)
  );
  return typeof i == "function" && N4e(o, ".prototype.") > -1 ? dve(
    /** @type {const} */
    [i]
  ) : i;
}, R4e = pie, XB = fve, P4e = rq, D4e = cI, xfe = R4e("%Map%", !0), $4e = XB("Map.prototype.get", !0), I4e = XB("Map.prototype.set", !0), M4e = XB("Map.prototype.has", !0), F4e = XB("Map.prototype.delete", !0), L4e = XB("Map.prototype.size", !0), mve = !!xfe && /** @type {Exclude<import('.'), false>} */
function() {
  var o, c = {
    assert: function(i) {
      if (!c.has(i))
        throw new D4e("Side channel does not contain " + P4e(i));
    },
    delete: function(i) {
      if (o) {
        var d = F4e(o, i);
        return L4e(o) === 0 && (o = void 0), d;
      }
      return !1;
    },
    get: function(i) {
      if (o)
        return $4e(o, i);
    },
    has: function(i) {
      return o ? M4e(o, i) : !1;
    },
    set: function(i, d) {
      o || (o = new xfe()), I4e(o, i, d);
    }
  };
  return c;
}, B4e = pie, aq = fve, H4e = rq, tW = mve, z4e = cI, $D = B4e("%WeakMap%", !0), V4e = aq("WeakMap.prototype.get", !0), U4e = aq("WeakMap.prototype.set", !0), W4e = aq("WeakMap.prototype.has", !0), j4e = aq("WeakMap.prototype.delete", !0), q4e = $D ? (
  /** @type {Exclude<import('.'), false>} */
  function() {
    var o, c, i = {
      assert: function(d) {
        if (!i.has(d))
          throw new z4e("Side channel does not contain " + H4e(d));
      },
      delete: function(d) {
        if ($D && d && (typeof d == "object" || typeof d == "function")) {
          if (o)
            return j4e(o, d);
        } else if (tW && c)
          return c.delete(d);
        return !1;
      },
      get: function(d) {
        return $D && d && (typeof d == "object" || typeof d == "function") && o ? V4e(o, d) : c && c.get(d);
      },
      has: function(d) {
        return $D && d && (typeof d == "object" || typeof d == "function") && o ? W4e(o, d) : !!c && c.has(d);
      },
      set: function(d, m) {
        $D && d && (typeof d == "object" || typeof d == "function") ? (o || (o = new $D()), U4e(o, d, m)) : tW && (c || (c = tW()), c.set(d, m));
      }
    };
    return i;
  }
) : tW, G4e = cI, Z4e = rq, K4e = C3e, Y4e = mve, Q4e = q4e, X4e = Q4e || Y4e || K4e, J4e = function() {
  var o, c = {
    assert: function(i) {
      if (!c.has(i))
        throw new G4e("Side channel does not contain " + Z4e(i));
    },
    delete: function(i) {
      return !!o && o.delete(i);
    },
    get: function(i) {
      return o && o.get(i);
    },
    has: function(i) {
      return !!o && o.has(i);
    },
    set: function(i, d) {
      o || (o = X4e()), o.set(i, d);
    }
  };
  return c;
}, eLe = String.prototype.replace, tLe = /%20/g, Roe = {
  RFC1738: "RFC1738",
  RFC3986: "RFC3986"
}, hie = {
  default: Roe.RFC3986,
  formatters: {
    RFC1738: function(r) {
      return eLe.call(r, tLe, "+");
    },
    RFC3986: function(r) {
      return String(r);
    }
  },
  RFC1738: Roe.RFC1738,
  RFC3986: Roe.RFC3986
}, nLe = hie, Poe = Object.prototype.hasOwnProperty, MA = Array.isArray, NS = function() {
  for (var r = [], o = 0; o < 256; ++o)
    r.push("%" + ((o < 16 ? "0" : "") + o.toString(16)).toUpperCase());
  return r;
}(), rLe = function(o) {
  for (; o.length > 1; ) {
    var c = o.pop(), i = c.obj[c.prop];
    if (MA(i)) {
      for (var d = [], m = 0; m < i.length; ++m)
        typeof i[m] < "u" && d.push(i[m]);
      c.obj[c.prop] = d;
    }
  }
}, pve = function(o, c) {
  for (var i = c && c.plainObjects ? { __proto__: null } : {}, d = 0; d < o.length; ++d)
    typeof o[d] < "u" && (i[d] = o[d]);
  return i;
}, oLe = function r(o, c, i) {
  if (!c)
    return o;
  if (typeof c != "object" && typeof c != "function") {
    if (MA(o))
      o.push(c);
    else if (o && typeof o == "object")
      (i && (i.plainObjects || i.allowPrototypes) || !Poe.call(Object.prototype, c)) && (o[c] = !0);
    else
      return [o, c];
    return o;
  }
  if (!o || typeof o != "object")
    return [o].concat(c);
  var d = o;
  return MA(o) && !MA(c) && (d = pve(o, i)), MA(o) && MA(c) ? (c.forEach(function(m, v) {
    if (Poe.call(o, v)) {
      var g = o[v];
      g && typeof g == "object" && m && typeof m == "object" ? o[v] = r(g, m, i) : o.push(m);
    } else
      o[v] = m;
  }), o) : Object.keys(c).reduce(function(m, v) {
    var g = c[v];
    return Poe.call(m, v) ? m[v] = r(m[v], g, i) : m[v] = g, m;
  }, d);
}, sLe = function(o, c) {
  return Object.keys(c).reduce(function(i, d) {
    return i[d] = c[d], i;
  }, o);
}, aLe = function(r, o, c) {
  var i = r.replace(/\+/g, " ");
  if (c === "iso-8859-1")
    return i.replace(/%[0-9a-f]{2}/gi, unescape);
  try {
    return decodeURIComponent(i);
  } catch {
    return i;
  }
}, Doe = 1024, iLe = function(o, c, i, d, m) {
  if (o.length === 0)
    return o;
  var v = o;
  if (typeof o == "symbol" ? v = Symbol.prototype.toString.call(o) : typeof o != "string" && (v = String(o)), i === "iso-8859-1")
    return escape(v).replace(/%u[0-9a-f]{4}/gi, function(Z) {
      return "%26%23" + parseInt(Z.slice(2), 16) + "%3B";
    });
  for (var g = "", C = 0; C < v.length; C += Doe) {
    for (var O = v.length >= Doe ? v.slice(C, C + Doe) : v, R = [], I = 0; I < O.length; ++I) {
      var L = O.charCodeAt(I);
      if (L === 45 || L === 46 || L === 95 || L === 126 || L >= 48 && L <= 57 || L >= 65 && L <= 90 || L >= 97 && L <= 122 || m === nLe.RFC1738 && (L === 40 || L === 41)) {
        R[R.length] = O.charAt(I);
        continue;
      }
      if (L < 128) {
        R[R.length] = NS[L];
        continue;
      }
      if (L < 2048) {
        R[R.length] = NS[192 | L >> 6] + NS[128 | L & 63];
        continue;
      }
      if (L < 55296 || L >= 57344) {
        R[R.length] = NS[224 | L >> 12] + NS[128 | L >> 6 & 63] + NS[128 | L & 63];
        continue;
      }
      I += 1, L = 65536 + ((L & 1023) << 10 | O.charCodeAt(I) & 1023), R[R.length] = NS[240 | L >> 18] + NS[128 | L >> 12 & 63] + NS[128 | L >> 6 & 63] + NS[128 | L & 63];
    }
    g += R.join("");
  }
  return g;
}, cLe = function(o) {
  for (var c = [{ obj: { o }, prop: "o" }], i = [], d = 0; d < c.length; ++d)
    for (var m = c[d], v = m.obj[m.prop], g = Object.keys(v), C = 0; C < g.length; ++C) {
      var O = g[C], R = v[O];
      typeof R == "object" && R !== null && i.indexOf(R) === -1 && (c.push({ obj: v, prop: O }), i.push(R));
    }
  return rLe(c), o;
}, lLe = function(o) {
  return Object.prototype.toString.call(o) === "[object RegExp]";
}, uLe = function(o) {
  return !o || typeof o != "object" ? !1 : !!(o.constructor && o.constructor.isBuffer && o.constructor.isBuffer(o));
}, dLe = function(o, c) {
  return [].concat(o, c);
}, fLe = function(o, c) {
  if (MA(o)) {
    for (var i = [], d = 0; d < o.length; d += 1)
      i.push(c(o[d]));
    return i;
  }
  return c(o);
}, hve = {
  arrayToObject: pve,
  assign: sLe,
  combine: dLe,
  compact: cLe,
  decode: aLe,
  encode: iLe,
  isBuffer: uLe,
  isRegExp: lLe,
  maybeMap: fLe,
  merge: oLe
}, gve = J4e, bW = hve, cB = hie, mLe = Object.prototype.hasOwnProperty, vve = {
  brackets: function(o) {
    return o + "[]";
  },
  comma: "comma",
  indices: function(o, c) {
    return o + "[" + c + "]";
  },
  repeat: function(o) {
    return o;
  }
}, PS = Array.isArray, pLe = Array.prototype.push, bve = function(r, o) {
  pLe.apply(r, PS(o) ? o : [o]);
}, hLe = Date.prototype.toISOString, Tfe = cB.default, tf = {
  addQueryPrefix: !1,
  allowDots: !1,
  allowEmptyArrays: !1,
  arrayFormat: "indices",
  charset: "utf-8",
  charsetSentinel: !1,
  commaRoundTrip: !1,
  delimiter: "&",
  encode: !0,
  encodeDotInKeys: !1,
  encoder: bW.encode,
  encodeValuesOnly: !1,
  filter: void 0,
  format: Tfe,
  formatter: cB.formatters[Tfe],
  // deprecated
  indices: !1,
  serializeDate: function(o) {
    return hLe.call(o);
  },
  skipNulls: !1,
  strictNullHandling: !1
}, gLe = function(o) {
  return typeof o == "string" || typeof o == "number" || typeof o == "boolean" || typeof o == "symbol" || typeof o == "bigint";
}, $oe = {}, vLe = function r(o, c, i, d, m, v, g, C, O, R, I, L, Z, ne, se, Q, he, ue) {
  for (var G = o, me = ue, we = 0, be = !1; (me = me.get($oe)) !== void 0 && !be; ) {
    var q = me.get(o);
    if (we += 1, typeof q < "u") {
      if (q === we)
        throw new RangeError("Cyclic object value");
      be = !0;
    }
    typeof me.get($oe) > "u" && (we = 0);
  }
  if (typeof R == "function" ? G = R(c, G) : G instanceof Date ? G = Z(G) : i === "comma" && PS(G) && (G = bW.maybeMap(G, function(st) {
    return st instanceof Date ? Z(st) : st;
  })), G === null) {
    if (v)
      return O && !Q ? O(c, tf.encoder, he, "key", ne) : c;
    G = "";
  }
  if (gLe(G) || bW.isBuffer(G)) {
    if (O) {
      var Te = Q ? c : O(c, tf.encoder, he, "key", ne);
      return [se(Te) + "=" + se(O(G, tf.encoder, he, "value", ne))];
    }
    return [se(c) + "=" + se(String(G))];
  }
  var Le = [];
  if (typeof G > "u")
    return Le;
  var je;
  if (i === "comma" && PS(G))
    Q && O && (G = bW.maybeMap(G, O)), je = [{ value: G.length > 0 ? G.join(",") || null : void 0 }];
  else if (PS(R))
    je = R;
  else {
    var Ie = Object.keys(G);
    je = I ? Ie.sort(I) : Ie;
  }
  var Ce = C ? String(c).replace(/\./g, "%2E") : String(c), pt = d && PS(G) && G.length === 1 ? Ce + "[]" : Ce;
  if (m && PS(G) && G.length === 0)
    return pt + "[]";
  for (var sn = 0; sn < je.length; ++sn) {
    var Lt = je[sn], z = typeof Lt == "object" && Lt && typeof Lt.value < "u" ? Lt.value : G[Lt];
    if (!(g && z === null)) {
      var bt = L && C ? String(Lt).replace(/\./g, "%2E") : String(Lt), at = PS(G) ? typeof i == "function" ? i(pt, bt) : pt : pt + (L ? "." + bt : "[" + bt + "]");
      ue.set(o, we);
      var _n = gve();
      _n.set($oe, ue), bve(Le, r(
        z,
        at,
        i,
        d,
        m,
        v,
        g,
        C,
        i === "comma" && Q && PS(G) ? null : O,
        R,
        I,
        L,
        Z,
        ne,
        se,
        Q,
        he,
        _n
      ));
    }
  }
  return Le;
}, bLe = function(o) {
  if (!o)
    return tf;
  if (typeof o.allowEmptyArrays < "u" && typeof o.allowEmptyArrays != "boolean")
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  if (typeof o.encodeDotInKeys < "u" && typeof o.encodeDotInKeys != "boolean")
    throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
  if (o.encoder !== null && typeof o.encoder < "u" && typeof o.encoder != "function")
    throw new TypeError("Encoder has to be a function.");
  var c = o.charset || tf.charset;
  if (typeof o.charset < "u" && o.charset !== "utf-8" && o.charset !== "iso-8859-1")
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  var i = cB.default;
  if (typeof o.format < "u") {
    if (!mLe.call(cB.formatters, o.format))
      throw new TypeError("Unknown format option provided.");
    i = o.format;
  }
  var d = cB.formatters[i], m = tf.filter;
  (typeof o.filter == "function" || PS(o.filter)) && (m = o.filter);
  var v;
  if (o.arrayFormat in vve ? v = o.arrayFormat : "indices" in o ? v = o.indices ? "indices" : "repeat" : v = tf.arrayFormat, "commaRoundTrip" in o && typeof o.commaRoundTrip != "boolean")
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  var g = typeof o.allowDots > "u" ? o.encodeDotInKeys === !0 ? !0 : tf.allowDots : !!o.allowDots;
  return {
    addQueryPrefix: typeof o.addQueryPrefix == "boolean" ? o.addQueryPrefix : tf.addQueryPrefix,
    allowDots: g,
    allowEmptyArrays: typeof o.allowEmptyArrays == "boolean" ? !!o.allowEmptyArrays : tf.allowEmptyArrays,
    arrayFormat: v,
    charset: c,
    charsetSentinel: typeof o.charsetSentinel == "boolean" ? o.charsetSentinel : tf.charsetSentinel,
    commaRoundTrip: !!o.commaRoundTrip,
    delimiter: typeof o.delimiter > "u" ? tf.delimiter : o.delimiter,
    encode: typeof o.encode == "boolean" ? o.encode : tf.encode,
    encodeDotInKeys: typeof o.encodeDotInKeys == "boolean" ? o.encodeDotInKeys : tf.encodeDotInKeys,
    encoder: typeof o.encoder == "function" ? o.encoder : tf.encoder,
    encodeValuesOnly: typeof o.encodeValuesOnly == "boolean" ? o.encodeValuesOnly : tf.encodeValuesOnly,
    filter: m,
    format: i,
    formatter: d,
    serializeDate: typeof o.serializeDate == "function" ? o.serializeDate : tf.serializeDate,
    skipNulls: typeof o.skipNulls == "boolean" ? o.skipNulls : tf.skipNulls,
    sort: typeof o.sort == "function" ? o.sort : null,
    strictNullHandling: typeof o.strictNullHandling == "boolean" ? o.strictNullHandling : tf.strictNullHandling
  };
}, yLe = function(r, o) {
  var c = r, i = bLe(o), d, m;
  typeof i.filter == "function" ? (m = i.filter, c = m("", c)) : PS(i.filter) && (m = i.filter, d = m);
  var v = [];
  if (typeof c != "object" || c === null)
    return "";
  var g = vve[i.arrayFormat], C = g === "comma" && i.commaRoundTrip;
  d || (d = Object.keys(c)), i.sort && d.sort(i.sort);
  for (var O = gve(), R = 0; R < d.length; ++R) {
    var I = d[R], L = c[I];
    i.skipNulls && L === null || bve(v, vLe(
      L,
      I,
      g,
      C,
      i.allowEmptyArrays,
      i.strictNullHandling,
      i.skipNulls,
      i.encodeDotInKeys,
      i.encode ? i.encoder : null,
      i.filter,
      i.sort,
      i.allowDots,
      i.serializeDate,
      i.format,
      i.formatter,
      i.encodeValuesOnly,
      i.charset,
      O
    ));
  }
  var Z = v.join(i.delimiter), ne = i.addQueryPrefix === !0 ? "?" : "";
  return i.charsetSentinel && (i.charset === "iso-8859-1" ? ne += "utf8=%26%2310003%3B&" : ne += "utf8=%E2%9C%93&"), Z.length > 0 ? ne + Z : "";
}, Ek = hve, Mse = Object.prototype.hasOwnProperty, _fe = Array.isArray, xu = {
  allowDots: !1,
  allowEmptyArrays: !1,
  allowPrototypes: !1,
  allowSparse: !1,
  arrayLimit: 20,
  charset: "utf-8",
  charsetSentinel: !1,
  comma: !1,
  decodeDotInKeys: !1,
  decoder: Ek.decode,
  delimiter: "&",
  depth: 5,
  duplicates: "combine",
  ignoreQueryPrefix: !1,
  interpretNumericEntities: !1,
  parameterLimit: 1e3,
  parseArrays: !0,
  plainObjects: !1,
  strictDepth: !1,
  strictNullHandling: !1,
  throwOnLimitExceeded: !1
}, SLe = function(r) {
  return r.replace(/&#(\d+);/g, function(o, c) {
    return String.fromCharCode(parseInt(c, 10));
  });
}, yve = function(r, o, c) {
  if (r && typeof r == "string" && o.comma && r.indexOf(",") > -1)
    return r.split(",");
  if (o.throwOnLimitExceeded && c >= o.arrayLimit)
    throw new RangeError("Array limit exceeded. Only " + o.arrayLimit + " element" + (o.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
  return r;
}, wLe = "utf8=%26%2310003%3B", ELe = "utf8=%E2%9C%93", CLe = function(o, c) {
  var i = { __proto__: null }, d = c.ignoreQueryPrefix ? o.replace(/^\?/, "") : o;
  d = d.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  var m = c.parameterLimit === 1 / 0 ? void 0 : c.parameterLimit, v = d.split(
    c.delimiter,
    c.throwOnLimitExceeded ? m + 1 : m
  );
  if (c.throwOnLimitExceeded && v.length > m)
    throw new RangeError("Parameter limit exceeded. Only " + m + " parameter" + (m === 1 ? "" : "s") + " allowed.");
  var g = -1, C, O = c.charset;
  if (c.charsetSentinel)
    for (C = 0; C < v.length; ++C)
      v[C].indexOf("utf8=") === 0 && (v[C] === ELe ? O = "utf-8" : v[C] === wLe && (O = "iso-8859-1"), g = C, C = v.length);
  for (C = 0; C < v.length; ++C)
    if (C !== g) {
      var R = v[C], I = R.indexOf("]="), L = I === -1 ? R.indexOf("=") : I + 1, Z, ne;
      L === -1 ? (Z = c.decoder(R, xu.decoder, O, "key"), ne = c.strictNullHandling ? null : "") : (Z = c.decoder(R.slice(0, L), xu.decoder, O, "key"), ne = Ek.maybeMap(
        yve(
          R.slice(L + 1),
          c,
          _fe(i[Z]) ? i[Z].length : 0
        ),
        function(Q) {
          return c.decoder(Q, xu.decoder, O, "value");
        }
      )), ne && c.interpretNumericEntities && O === "iso-8859-1" && (ne = SLe(String(ne))), R.indexOf("[]=") > -1 && (ne = _fe(ne) ? [ne] : ne);
      var se = Mse.call(i, Z);
      se && c.duplicates === "combine" ? i[Z] = Ek.combine(i[Z], ne) : (!se || c.duplicates === "last") && (i[Z] = ne);
    }
  return i;
}, xLe = function(r, o, c, i) {
  var d = 0;
  if (r.length > 0 && r[r.length - 1] === "[]") {
    var m = r.slice(0, -1).join("");
    d = Array.isArray(o) && o[m] ? o[m].length : 0;
  }
  for (var v = i ? o : yve(o, c, d), g = r.length - 1; g >= 0; --g) {
    var C, O = r[g];
    if (O === "[]" && c.parseArrays)
      C = c.allowEmptyArrays && (v === "" || c.strictNullHandling && v === null) ? [] : Ek.combine([], v);
    else {
      C = c.plainObjects ? { __proto__: null } : {};
      var R = O.charAt(0) === "[" && O.charAt(O.length - 1) === "]" ? O.slice(1, -1) : O, I = c.decodeDotInKeys ? R.replace(/%2E/g, ".") : R, L = parseInt(I, 10);
      !c.parseArrays && I === "" ? C = { 0: v } : !isNaN(L) && O !== I && String(L) === I && L >= 0 && c.parseArrays && L <= c.arrayLimit ? (C = [], C[L] = v) : I !== "__proto__" && (C[I] = v);
    }
    v = C;
  }
  return v;
}, TLe = function(o, c, i, d) {
  if (o) {
    var m = i.allowDots ? o.replace(/\.([^.[]+)/g, "[$1]") : o, v = /(\[[^[\]]*])/, g = /(\[[^[\]]*])/g, C = i.depth > 0 && v.exec(m), O = C ? m.slice(0, C.index) : m, R = [];
    if (O) {
      if (!i.plainObjects && Mse.call(Object.prototype, O) && !i.allowPrototypes)
        return;
      R.push(O);
    }
    for (var I = 0; i.depth > 0 && (C = g.exec(m)) !== null && I < i.depth; ) {
      if (I += 1, !i.plainObjects && Mse.call(Object.prototype, C[1].slice(1, -1)) && !i.allowPrototypes)
        return;
      R.push(C[1]);
    }
    if (C) {
      if (i.strictDepth === !0)
        throw new RangeError("Input depth exceeded depth option of " + i.depth + " and strictDepth is true");
      R.push("[" + m.slice(C.index) + "]");
    }
    return xLe(R, c, i, d);
  }
}, _Le = function(o) {
  if (!o)
    return xu;
  if (typeof o.allowEmptyArrays < "u" && typeof o.allowEmptyArrays != "boolean")
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  if (typeof o.decodeDotInKeys < "u" && typeof o.decodeDotInKeys != "boolean")
    throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
  if (o.decoder !== null && typeof o.decoder < "u" && typeof o.decoder != "function")
    throw new TypeError("Decoder has to be a function.");
  if (typeof o.charset < "u" && o.charset !== "utf-8" && o.charset !== "iso-8859-1")
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  if (typeof o.throwOnLimitExceeded < "u" && typeof o.throwOnLimitExceeded != "boolean")
    throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
  var c = typeof o.charset > "u" ? xu.charset : o.charset, i = typeof o.duplicates > "u" ? xu.duplicates : o.duplicates;
  if (i !== "combine" && i !== "first" && i !== "last")
    throw new TypeError("The duplicates option must be either combine, first, or last");
  var d = typeof o.allowDots > "u" ? o.decodeDotInKeys === !0 ? !0 : xu.allowDots : !!o.allowDots;
  return {
    allowDots: d,
    allowEmptyArrays: typeof o.allowEmptyArrays == "boolean" ? !!o.allowEmptyArrays : xu.allowEmptyArrays,
    allowPrototypes: typeof o.allowPrototypes == "boolean" ? o.allowPrototypes : xu.allowPrototypes,
    allowSparse: typeof o.allowSparse == "boolean" ? o.allowSparse : xu.allowSparse,
    arrayLimit: typeof o.arrayLimit == "number" ? o.arrayLimit : xu.arrayLimit,
    charset: c,
    charsetSentinel: typeof o.charsetSentinel == "boolean" ? o.charsetSentinel : xu.charsetSentinel,
    comma: typeof o.comma == "boolean" ? o.comma : xu.comma,
    decodeDotInKeys: typeof o.decodeDotInKeys == "boolean" ? o.decodeDotInKeys : xu.decodeDotInKeys,
    decoder: typeof o.decoder == "function" ? o.decoder : xu.decoder,
    delimiter: typeof o.delimiter == "string" || Ek.isRegExp(o.delimiter) ? o.delimiter : xu.delimiter,
    // eslint-disable-next-line no-implicit-coercion, no-extra-parens
    depth: typeof o.depth == "number" || o.depth === !1 ? +o.depth : xu.depth,
    duplicates: i,
    ignoreQueryPrefix: o.ignoreQueryPrefix === !0,
    interpretNumericEntities: typeof o.interpretNumericEntities == "boolean" ? o.interpretNumericEntities : xu.interpretNumericEntities,
    parameterLimit: typeof o.parameterLimit == "number" ? o.parameterLimit : xu.parameterLimit,
    parseArrays: o.parseArrays !== !1,
    plainObjects: typeof o.plainObjects == "boolean" ? o.plainObjects : xu.plainObjects,
    strictDepth: typeof o.strictDepth == "boolean" ? !!o.strictDepth : xu.strictDepth,
    strictNullHandling: typeof o.strictNullHandling == "boolean" ? o.strictNullHandling : xu.strictNullHandling,
    throwOnLimitExceeded: typeof o.throwOnLimitExceeded == "boolean" ? o.throwOnLimitExceeded : !1
  };
}, OLe = function(r, o) {
  var c = _Le(o);
  if (r === "" || r === null || typeof r > "u")
    return c.plainObjects ? { __proto__: null } : {};
  for (var i = typeof r == "string" ? CLe(r, c) : r, d = c.plainObjects ? { __proto__: null } : {}, m = Object.keys(i), v = 0; v < m.length; ++v) {
    var g = m[v], C = TLe(g, i[g], c, typeof r == "string");
    d = Ek.merge(d, C, c);
  }
  return c.allowSparse === !0 ? d : Ek.compact(d);
}, ALe = yLe, kLe = OLe, NLe = hie, RLe = {
  formats: NLe,
  parse: kLe,
  stringify: ALe
};
const lI = /* @__PURE__ */ Ku(RLe);
var PLe = Fk, DLe = function() {
  try {
    var r = PLe(Object, "defineProperty");
    return r({}, "", {}), r;
  } catch {
  }
}(), Sve = DLe, Ofe = Sve;
function $Le(r, o, c) {
  o == "__proto__" && Ofe ? Ofe(r, o, {
    configurable: !0,
    enumerable: !0,
    value: c,
    writable: !0
  }) : r[o] = c;
}
var wve = $Le, ILe = wve, MLe = Yj, FLe = Object.prototype, LLe = FLe.hasOwnProperty;
function BLe(r, o, c) {
  var i = r[o];
  (!(LLe.call(r, o) && MLe(i, c)) || c === void 0 && !(o in r)) && ILe(r, o, c);
}
var gie = BLe, HLe = gie, zLe = wve;
function VLe(r, o, c, i) {
  var d = !c;
  c || (c = {});
  for (var m = -1, v = o.length; ++m < v; ) {
    var g = o[m], C = i ? i(c[g], r[g], g, c, r) : void 0;
    C === void 0 && (C = r[g]), d ? zLe(c, g, C) : HLe(c, g, C);
  }
  return c;
}
var uI = VLe;
function ULe(r) {
  return r;
}
var vie = ULe;
function WLe(r, o, c) {
  switch (c.length) {
    case 0:
      return r.call(o);
    case 1:
      return r.call(o, c[0]);
    case 2:
      return r.call(o, c[0], c[1]);
    case 3:
      return r.call(o, c[0], c[1], c[2]);
  }
  return r.apply(o, c);
}
var jLe = WLe, qLe = jLe, Afe = Math.max;
function GLe(r, o, c) {
  return o = Afe(o === void 0 ? r.length - 1 : o, 0), function() {
    for (var i = arguments, d = -1, m = Afe(i.length - o, 0), v = Array(m); ++d < m; )
      v[d] = i[o + d];
    d = -1;
    for (var g = Array(o + 1); ++d < o; )
      g[d] = i[d];
    return g[o] = c(v), qLe(r, this, g);
  };
}
var Eve = GLe;
function ZLe(r) {
  return function() {
    return r;
  };
}
var KLe = ZLe, YLe = KLe, kfe = Sve, QLe = vie, XLe = kfe ? function(r, o) {
  return kfe(r, "toString", {
    configurable: !0,
    enumerable: !1,
    value: YLe(o),
    writable: !0
  });
} : QLe, JLe = XLe, eBe = 800, tBe = 16, nBe = Date.now;
function rBe(r) {
  var o = 0, c = 0;
  return function() {
    var i = nBe(), d = tBe - (i - c);
    if (c = i, d > 0) {
      if (++o >= eBe)
        return arguments[0];
    } else
      o = 0;
    return r.apply(void 0, arguments);
  };
}
var oBe = rBe, sBe = JLe, aBe = oBe, iBe = aBe(sBe), Cve = iBe, cBe = vie, lBe = Eve, uBe = Cve;
function dBe(r, o) {
  return uBe(lBe(r, o, cBe), r + "");
}
var fBe = dBe, mBe = Yj, pBe = ZB, hBe = tq, gBe = I1;
function vBe(r, o, c) {
  if (!gBe(c))
    return !1;
  var i = typeof o;
  return (i == "number" ? pBe(c) && hBe(o, c.length) : i == "string" && o in c) ? mBe(c[o], r) : !1;
}
var bBe = vBe, yBe = fBe, SBe = bBe;
function wBe(r) {
  return yBe(function(o, c) {
    var i = -1, d = c.length, m = d > 1 ? c[d - 1] : void 0, v = d > 2 ? c[2] : void 0;
    for (m = r.length > 3 && typeof m == "function" ? (d--, m) : void 0, v && SBe(c[0], c[1], v) && (m = d < 3 ? void 0 : m, d = 1), o = Object(o); ++i < d; ) {
      var g = c[i];
      g && r(o, g, i, m);
    }
    return o;
  });
}
var EBe = wBe;
function CBe(r, o) {
  for (var c = -1, i = Array(r); ++c < r; )
    i[c] = o(c);
  return i;
}
var xBe = CBe, TBe = xBe, _Be = Lj, OBe = $h, ABe = Bj, kBe = tq, NBe = Jae, RBe = Object.prototype, PBe = RBe.hasOwnProperty;
function DBe(r, o) {
  var c = OBe(r), i = !c && _Be(r), d = !c && !i && ABe(r), m = !c && !i && !d && NBe(r), v = c || i || d || m, g = v ? TBe(r.length, String) : [], C = g.length;
  for (var O in r)
    (o || PBe.call(r, O)) && !(v && // Safari 9 has enumerable `arguments.length` in strict mode.
    (O == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    d && (O == "offset" || O == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    m && (O == "buffer" || O == "byteLength" || O == "byteOffset") || // Skip index properties.
    kBe(O, C))) && g.push(O);
  return g;
}
var xve = DBe;
function $Be(r) {
  var o = [];
  if (r != null)
    for (var c in Object(r))
      o.push(c);
  return o;
}
var IBe = $Be, MBe = I1, FBe = Fj, LBe = IBe, BBe = Object.prototype, HBe = BBe.hasOwnProperty;
function zBe(r) {
  if (!MBe(r))
    return LBe(r);
  var o = FBe(r), c = [];
  for (var i in r)
    i == "constructor" && (o || !HBe.call(r, i)) || c.push(i);
  return c;
}
var VBe = zBe, UBe = xve, WBe = VBe, jBe = ZB;
function qBe(r) {
  return jBe(r) ? UBe(r, !0) : WBe(r);
}
var iq = qBe, GBe = uI, ZBe = EBe, KBe = iq, YBe = ZBe(function(r, o) {
  GBe(o, KBe(o), r);
}), QBe = YBe, XBe = QBe;
const GW = /* @__PURE__ */ Ku(XBe);
function JBe(r) {
  return r && r.length ? r[0] : void 0;
}
var e5e = JBe;
const t5e = /* @__PURE__ */ Ku(e5e);
var n5e = gie, r5e = aI, o5e = tq, Nfe = I1, s5e = iI;
function a5e(r, o, c, i) {
  if (!Nfe(r))
    return r;
  o = r5e(o, r);
  for (var d = -1, m = o.length, v = m - 1, g = r; g != null && ++d < m; ) {
    var C = s5e(o[d]), O = c;
    if (C === "__proto__" || C === "constructor" || C === "prototype")
      return r;
    if (d != v) {
      var R = g[C];
      O = i ? i(R, C, g) : void 0, O === void 0 && (O = Nfe(R) ? R : o5e(o[d + 1]) ? [] : {});
    }
    n5e(g, C, O), g = g[C];
  }
  return r;
}
var i5e = a5e, c5e = eq, l5e = i5e, u5e = aI;
function d5e(r, o, c) {
  for (var i = -1, d = o.length, m = {}; ++i < d; ) {
    var v = o[i], g = c5e(r, v);
    c(g, v) && l5e(m, u5e(v, r), g);
  }
  return m;
}
var Tve = d5e, f5e = Tve, m5e = nq;
function p5e(r, o) {
  return f5e(r, o, function(c, i) {
    return m5e(r, i);
  });
}
var h5e = p5e;
function g5e(r, o) {
  for (var c = -1, i = o.length, d = r.length; ++c < i; )
    r[d + c] = o[c];
  return r;
}
var bie = g5e, Rfe = J$, v5e = Lj, b5e = $h, Pfe = Rfe ? Rfe.isConcatSpreadable : void 0;
function y5e(r) {
  return b5e(r) || v5e(r) || !!(Pfe && r && r[Pfe]);
}
var S5e = y5e, w5e = bie, E5e = S5e;
function _ve(r, o, c, i, d) {
  var m = -1, v = r.length;
  for (c || (c = E5e), d || (d = []); ++m < v; ) {
    var g = r[m];
    o > 0 && c(g) ? o > 1 ? _ve(g, o - 1, c, i, d) : w5e(d, g) : i || (d[d.length] = g);
  }
  return d;
}
var C5e = _ve, x5e = C5e;
function T5e(r) {
  var o = r == null ? 0 : r.length;
  return o ? x5e(r, 1) : [];
}
var _5e = T5e, O5e = _5e, A5e = Eve, k5e = Cve;
function N5e(r) {
  return k5e(A5e(r, void 0, O5e), r + "");
}
var Ove = N5e, R5e = h5e, P5e = Ove, D5e = P5e(function(r, o) {
  return r == null ? {} : R5e(r, o);
}), $5e = D5e;
const I5e = /* @__PURE__ */ Ku($5e);
var M5e = Xj;
function F5e() {
  this.__data__ = new M5e(), this.size = 0;
}
var L5e = F5e;
function B5e(r) {
  var o = this.__data__, c = o.delete(r);
  return this.size = o.size, c;
}
var H5e = B5e;
function z5e(r) {
  return this.__data__.get(r);
}
var V5e = z5e;
function U5e(r) {
  return this.__data__.has(r);
}
var W5e = U5e, j5e = Xj, q5e = Kae, G5e = aie, Z5e = 200;
function K5e(r, o) {
  var c = this.__data__;
  if (c instanceof j5e) {
    var i = c.__data__;
    if (!q5e || i.length < Z5e - 1)
      return i.push([r, o]), this.size = ++c.size, this;
    c = this.__data__ = new G5e(i);
  }
  return c.set(r, o), this.size = c.size, this;
}
var Y5e = K5e, Q5e = Xj, X5e = L5e, J5e = H5e, e6e = V5e, t6e = W5e, n6e = Y5e;
function dI(r) {
  var o = this.__data__ = new Q5e(r);
  this.size = o.size;
}
dI.prototype.clear = X5e;
dI.prototype.delete = J5e;
dI.prototype.get = e6e;
dI.prototype.has = t6e;
dI.prototype.set = n6e;
var yie = dI;
function r6e(r, o) {
  for (var c = -1, i = r == null ? 0 : r.length; ++c < i && o(r[c], c, r) !== !1; )
    ;
  return r;
}
var o6e = r6e, s6e = xve, a6e = fge, i6e = ZB;
function c6e(r) {
  return i6e(r) ? s6e(r) : a6e(r);
}
var JB = c6e, l6e = uI, u6e = JB;
function d6e(r, o) {
  return r && l6e(o, u6e(o), r);
}
var f6e = d6e, m6e = uI, p6e = iq;
function h6e(r, o) {
  return r && m6e(o, p6e(o), r);
}
var g6e = h6e, ZW = { exports: {} };
ZW.exports;
(function(r, o) {
  var c = $1, i = o && !o.nodeType && o, d = i && !0 && r && !r.nodeType && r, m = d && d.exports === i, v = m ? c.Buffer : void 0, g = v ? v.allocUnsafe : void 0;
  function C(O, R) {
    if (R)
      return O.slice();
    var I = O.length, L = g ? g(I) : new O.constructor(I);
    return O.copy(L), L;
  }
  r.exports = C;
})(ZW, ZW.exports);
var v6e = ZW.exports;
function b6e(r, o) {
  var c = -1, i = r.length;
  for (o || (o = Array(i)); ++c < i; )
    o[c] = r[c];
  return o;
}
var y6e = b6e;
function S6e(r, o) {
  for (var c = -1, i = r == null ? 0 : r.length, d = 0, m = []; ++c < i; ) {
    var v = r[c];
    o(v, c, r) && (m[d++] = v);
  }
  return m;
}
var Ave = S6e;
function w6e() {
  return [];
}
var kve = w6e, E6e = Ave, C6e = kve, x6e = Object.prototype, T6e = x6e.propertyIsEnumerable, Dfe = Object.getOwnPropertySymbols, _6e = Dfe ? function(r) {
  return r == null ? [] : (r = Object(r), E6e(Dfe(r), function(o) {
    return T6e.call(r, o);
  }));
} : C6e, Sie = _6e, O6e = uI, A6e = Sie;
function k6e(r, o) {
  return O6e(r, A6e(r), o);
}
var N6e = k6e, R6e = dge, P6e = R6e(Object.getPrototypeOf, Object), wie = P6e, D6e = bie, $6e = wie, I6e = Sie, M6e = kve, F6e = Object.getOwnPropertySymbols, L6e = F6e ? function(r) {
  for (var o = []; r; )
    D6e(o, I6e(r)), r = $6e(r);
  return o;
} : M6e, Nve = L6e, B6e = uI, H6e = Nve;
function z6e(r, o) {
  return B6e(r, H6e(r), o);
}
var V6e = z6e, U6e = bie, W6e = $h;
function j6e(r, o, c) {
  var i = o(r);
  return W6e(r) ? i : U6e(i, c(r));
}
var Rve = j6e, q6e = Rve, G6e = Sie, Z6e = JB;
function K6e(r) {
  return q6e(r, Z6e, G6e);
}
var Pve = K6e, Y6e = Rve, Q6e = Nve, X6e = iq;
function J6e(r) {
  return Y6e(r, X6e, Q6e);
}
var Eie = J6e, e8e = Object.prototype, t8e = e8e.hasOwnProperty;
function n8e(r) {
  var o = r.length, c = new r.constructor(o);
  return o && typeof r[0] == "string" && t8e.call(r, "index") && (c.index = r.index, c.input = r.input), c;
}
var r8e = n8e, o8e = $1, s8e = o8e.Uint8Array, Dve = s8e, $fe = Dve;
function a8e(r) {
  var o = new r.constructor(r.byteLength);
  return new $fe(o).set(new $fe(r)), o;
}
var Cie = a8e, i8e = Cie;
function c8e(r, o) {
  var c = o ? i8e(r.buffer) : r.buffer;
  return new r.constructor(c, r.byteOffset, r.byteLength);
}
var l8e = c8e, u8e = /\w*$/;
function d8e(r) {
  var o = new r.constructor(r.source, u8e.exec(r));
  return o.lastIndex = r.lastIndex, o;
}
var f8e = d8e, Ife = J$, Mfe = Ife ? Ife.prototype : void 0, Ffe = Mfe ? Mfe.valueOf : void 0;
function m8e(r) {
  return Ffe ? Object(Ffe.call(r)) : {};
}
var p8e = m8e, h8e = Cie;
function g8e(r, o) {
  var c = o ? h8e(r.buffer) : r.buffer;
  return new r.constructor(c, r.byteOffset, r.length);
}
var v8e = g8e, b8e = Cie, y8e = l8e, S8e = f8e, w8e = p8e, E8e = v8e, C8e = "[object Boolean]", x8e = "[object Date]", T8e = "[object Map]", _8e = "[object Number]", O8e = "[object RegExp]", A8e = "[object Set]", k8e = "[object String]", N8e = "[object Symbol]", R8e = "[object ArrayBuffer]", P8e = "[object DataView]", D8e = "[object Float32Array]", $8e = "[object Float64Array]", I8e = "[object Int8Array]", M8e = "[object Int16Array]", F8e = "[object Int32Array]", L8e = "[object Uint8Array]", B8e = "[object Uint8ClampedArray]", H8e = "[object Uint16Array]", z8e = "[object Uint32Array]";
function V8e(r, o, c) {
  var i = r.constructor;
  switch (o) {
    case R8e:
      return b8e(r);
    case C8e:
    case x8e:
      return new i(+r);
    case P8e:
      return y8e(r, c);
    case D8e:
    case $8e:
    case I8e:
    case M8e:
    case F8e:
    case L8e:
    case B8e:
    case H8e:
    case z8e:
      return E8e(r, c);
    case T8e:
      return new i();
    case _8e:
    case k8e:
      return new i(r);
    case O8e:
      return S8e(r);
    case A8e:
      return new i();
    case N8e:
      return w8e(r);
  }
}
var U8e = V8e, W8e = I1, Lfe = Object.create, j8e = function() {
  function r() {
  }
  return function(o) {
    if (!W8e(o))
      return {};
    if (Lfe)
      return Lfe(o);
    r.prototype = o;
    var c = new r();
    return r.prototype = void 0, c;
  };
}(), q8e = j8e, G8e = q8e, Z8e = wie, K8e = Fj;
function Y8e(r) {
  return typeof r.constructor == "function" && !K8e(r) ? G8e(Z8e(r)) : {};
}
var Q8e = Y8e, X8e = GB, J8e = M1, eHe = "[object Map]";
function tHe(r) {
  return J8e(r) && X8e(r) == eHe;
}
var nHe = tHe, rHe = nHe, oHe = Qae, Bfe = Xae, Hfe = Bfe && Bfe.isMap, sHe = Hfe ? oHe(Hfe) : rHe, aHe = sHe, iHe = GB, cHe = M1, lHe = "[object Set]";
function uHe(r) {
  return cHe(r) && iHe(r) == lHe;
}
var dHe = uHe, fHe = dHe, mHe = Qae, zfe = Xae, Vfe = zfe && zfe.isSet, pHe = Vfe ? mHe(Vfe) : fHe, hHe = pHe, gHe = yie, vHe = o6e, bHe = gie, yHe = f6e, SHe = g6e, wHe = v6e, EHe = y6e, CHe = N6e, xHe = V6e, THe = Pve, _He = Eie, OHe = GB, AHe = r8e, kHe = U8e, NHe = Q8e, RHe = $h, PHe = Bj, DHe = aHe, $He = I1, IHe = hHe, MHe = JB, FHe = iq, LHe = 1, BHe = 2, HHe = 4, $ve = "[object Arguments]", zHe = "[object Array]", VHe = "[object Boolean]", UHe = "[object Date]", WHe = "[object Error]", Ive = "[object Function]", jHe = "[object GeneratorFunction]", qHe = "[object Map]", GHe = "[object Number]", Mve = "[object Object]", ZHe = "[object RegExp]", KHe = "[object Set]", YHe = "[object String]", QHe = "[object Symbol]", XHe = "[object WeakMap]", JHe = "[object ArrayBuffer]", e7e = "[object DataView]", t7e = "[object Float32Array]", n7e = "[object Float64Array]", r7e = "[object Int8Array]", o7e = "[object Int16Array]", s7e = "[object Int32Array]", a7e = "[object Uint8Array]", i7e = "[object Uint8ClampedArray]", c7e = "[object Uint16Array]", l7e = "[object Uint32Array]", Wc = {};
Wc[$ve] = Wc[zHe] = Wc[JHe] = Wc[e7e] = Wc[VHe] = Wc[UHe] = Wc[t7e] = Wc[n7e] = Wc[r7e] = Wc[o7e] = Wc[s7e] = Wc[qHe] = Wc[GHe] = Wc[Mve] = Wc[ZHe] = Wc[KHe] = Wc[YHe] = Wc[QHe] = Wc[a7e] = Wc[i7e] = Wc[c7e] = Wc[l7e] = !0;
Wc[WHe] = Wc[Ive] = Wc[XHe] = !1;
function yW(r, o, c, i, d, m) {
  var v, g = o & LHe, C = o & BHe, O = o & HHe;
  if (c && (v = d ? c(r, i, d, m) : c(r)), v !== void 0)
    return v;
  if (!$He(r))
    return r;
  var R = RHe(r);
  if (R) {
    if (v = AHe(r), !g)
      return EHe(r, v);
  } else {
    var I = OHe(r), L = I == Ive || I == jHe;
    if (PHe(r))
      return wHe(r, g);
    if (I == Mve || I == $ve || L && !d) {
      if (v = C || L ? {} : NHe(r), !g)
        return C ? xHe(r, SHe(v, r)) : CHe(r, yHe(v, r));
    } else {
      if (!Wc[I])
        return d ? r : {};
      v = kHe(r, I, g);
    }
  }
  m || (m = new gHe());
  var Z = m.get(r);
  if (Z)
    return Z;
  m.set(r, v), IHe(r) ? r.forEach(function(Q) {
    v.add(yW(Q, o, c, Q, r, m));
  }) : DHe(r) && r.forEach(function(Q, he) {
    v.set(he, yW(Q, o, c, he, r, m));
  });
  var ne = O ? C ? _He : THe : C ? FHe : MHe, se = R ? void 0 : ne(r);
  return vHe(se || r, function(Q, he) {
    se && (he = Q, Q = r[he]), bHe(v, he, yW(Q, o, c, he, r, m));
  }), v;
}
var xie = yW, u7e = xie, d7e = 1, f7e = 4;
function m7e(r) {
  return u7e(r, d7e | f7e);
}
var p7e = m7e;
const ZD = /* @__PURE__ */ Ku(p7e);
var h7e = UC, g7e = M1, v7e = "[object Boolean]";
function b7e(r) {
  return r === !0 || r === !1 || g7e(r) && h7e(r) == v7e;
}
var y7e = b7e;
const S7e = /* @__PURE__ */ Ku(y7e);
var w7e = UC, E7e = $h, C7e = M1, x7e = "[object String]";
function T7e(r) {
  return typeof r == "string" || !E7e(r) && C7e(r) && w7e(r) == x7e;
}
var _7e = T7e;
const O7e = /* @__PURE__ */ Ku(_7e);
var A7e = UC, k7e = M1, N7e = "[object Number]";
function R7e(r) {
  return typeof r == "number" || k7e(r) && A7e(r) == N7e;
}
var Fve = R7e;
const P7e = /* @__PURE__ */ Ku(Fve);
var Tie = /* @__PURE__ */ ae.createContext(null);
process.env.NODE_ENV !== "production" && (Tie.displayName = "ReactRedux");
function D7e(r) {
  r();
}
var Lve = D7e, $7e = function(o) {
  return Lve = o;
}, I7e = function() {
  return Lve;
};
function M7e() {
  var r = I7e(), o = null, c = null;
  return {
    clear: function() {
      o = null, c = null;
    },
    notify: function() {
      r(function() {
        for (var d = o; d; )
          d.callback(), d = d.next;
      });
    },
    get: function() {
      for (var d = [], m = o; m; )
        d.push(m), m = m.next;
      return d;
    },
    subscribe: function(d) {
      var m = !0, v = c = {
        callback: d,
        next: null,
        prev: c
      };
      return v.prev ? v.prev.next = v : o = v, function() {
        !m || o === null || (m = !1, v.next ? v.next.prev = v.prev : c = v.prev, v.prev ? v.prev.next = v.next : o = v.next);
      };
    }
  };
}
var Ufe = {
  notify: function() {
  },
  get: function() {
    return [];
  }
};
function Bve(r, o) {
  var c, i = Ufe;
  function d(I) {
    return C(), i.subscribe(I);
  }
  function m() {
    i.notify();
  }
  function v() {
    R.onStateChange && R.onStateChange();
  }
  function g() {
    return !!c;
  }
  function C() {
    c || (c = o ? o.addNestedSub(v) : r.subscribe(v), i = M7e());
  }
  function O() {
    c && (c(), c = void 0, i.clear(), i = Ufe);
  }
  var R = {
    addNestedSub: d,
    notifyNestedSubs: m,
    handleChangeWrapper: v,
    isSubscribed: g,
    trySubscribe: C,
    tryUnsubscribe: O,
    getListeners: function() {
      return i;
    }
  };
  return R;
}
var Hve = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? ype : Ch;
function zve(r) {
  var o = r.store, c = r.context, i = r.children, d = Rv(function() {
    var g = Bve(o);
    return {
      store: o,
      subscription: g
    };
  }, [o]), m = Rv(function() {
    return o.getState();
  }, [o]);
  Hve(function() {
    var g = d.subscription;
    return g.onStateChange = g.notifyNestedSubs, g.trySubscribe(), m !== o.getState() && g.notifyNestedSubs(), function() {
      g.tryUnsubscribe(), g.onStateChange = null;
    };
  }, [d, m]);
  var v = c || Tie;
  return /* @__PURE__ */ ae.createElement(v.Provider, {
    value: d
  }, i);
}
process.env.NODE_ENV !== "production" && (zve.propTypes = {
  store: _.shape({
    subscribe: _.func.isRequired,
    dispatch: _.func.isRequired,
    getState: _.func.isRequired
  }),
  context: _.object,
  children: _.any
});
var _ie = cj(), F7e = {
  childContextTypes: !0,
  contextType: !0,
  contextTypes: !0,
  defaultProps: !0,
  displayName: !0,
  getDefaultProps: !0,
  getDerivedStateFromError: !0,
  getDerivedStateFromProps: !0,
  mixins: !0,
  propTypes: !0,
  type: !0
}, L7e = {
  name: !0,
  length: !0,
  prototype: !0,
  caller: !0,
  callee: !0,
  arguments: !0,
  arity: !0
}, B7e = {
  $$typeof: !0,
  render: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0
}, Vve = {
  $$typeof: !0,
  compare: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0,
  type: !0
}, Oie = {};
Oie[_ie.ForwardRef] = B7e;
Oie[_ie.Memo] = Vve;
function Wfe(r) {
  return _ie.isMemo(r) ? Vve : Oie[r.$$typeof] || F7e;
}
var H7e = Object.defineProperty, z7e = Object.getOwnPropertyNames, jfe = Object.getOwnPropertySymbols, V7e = Object.getOwnPropertyDescriptor, U7e = Object.getPrototypeOf, qfe = Object.prototype;
function Uve(r, o, c) {
  if (typeof o != "string") {
    if (qfe) {
      var i = U7e(o);
      i && i !== qfe && Uve(r, i, c);
    }
    var d = z7e(o);
    jfe && (d = d.concat(jfe(o)));
    for (var m = Wfe(r), v = Wfe(o), g = 0; g < d.length; ++g) {
      var C = d[g];
      if (!L7e[C] && !(c && c[C]) && !(v && v[C]) && !(m && m[C])) {
        var O = V7e(o, C);
        try {
          H7e(r, C, O);
        } catch {
        }
      }
    }
  }
  return r;
}
var W7e = Uve;
const KW = /* @__PURE__ */ Ku(W7e);
var Fse = { exports: {} }, uc = {};
/** @license React v17.0.2
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Gfe;
function j7e() {
  if (Gfe)
    return uc;
  Gfe = 1;
  var r = 60103, o = 60106, c = 60107, i = 60108, d = 60114, m = 60109, v = 60110, g = 60112, C = 60113, O = 60120, R = 60115, I = 60116, L = 60121, Z = 60122, ne = 60117, se = 60129, Q = 60131;
  if (typeof Symbol == "function" && Symbol.for) {
    var he = Symbol.for;
    r = he("react.element"), o = he("react.portal"), c = he("react.fragment"), i = he("react.strict_mode"), d = he("react.profiler"), m = he("react.provider"), v = he("react.context"), g = he("react.forward_ref"), C = he("react.suspense"), O = he("react.suspense_list"), R = he("react.memo"), I = he("react.lazy"), L = he("react.block"), Z = he("react.server.block"), ne = he("react.fundamental"), se = he("react.debug_trace_mode"), Q = he("react.legacy_hidden");
  }
  function ue(pt) {
    if (typeof pt == "object" && pt !== null) {
      var sn = pt.$$typeof;
      switch (sn) {
        case r:
          switch (pt = pt.type, pt) {
            case c:
            case d:
            case i:
            case C:
            case O:
              return pt;
            default:
              switch (pt = pt && pt.$$typeof, pt) {
                case v:
                case g:
                case I:
                case R:
                case m:
                  return pt;
                default:
                  return sn;
              }
          }
        case o:
          return sn;
      }
    }
  }
  var G = m, me = r, we = g, be = c, q = I, Te = R, Le = o, je = d, Ie = i, Ce = C;
  return uc.ContextConsumer = v, uc.ContextProvider = G, uc.Element = me, uc.ForwardRef = we, uc.Fragment = be, uc.Lazy = q, uc.Memo = Te, uc.Portal = Le, uc.Profiler = je, uc.StrictMode = Ie, uc.Suspense = Ce, uc.isAsyncMode = function() {
    return !1;
  }, uc.isConcurrentMode = function() {
    return !1;
  }, uc.isContextConsumer = function(pt) {
    return ue(pt) === v;
  }, uc.isContextProvider = function(pt) {
    return ue(pt) === m;
  }, uc.isElement = function(pt) {
    return typeof pt == "object" && pt !== null && pt.$$typeof === r;
  }, uc.isForwardRef = function(pt) {
    return ue(pt) === g;
  }, uc.isFragment = function(pt) {
    return ue(pt) === c;
  }, uc.isLazy = function(pt) {
    return ue(pt) === I;
  }, uc.isMemo = function(pt) {
    return ue(pt) === R;
  }, uc.isPortal = function(pt) {
    return ue(pt) === o;
  }, uc.isProfiler = function(pt) {
    return ue(pt) === d;
  }, uc.isStrictMode = function(pt) {
    return ue(pt) === i;
  }, uc.isSuspense = function(pt) {
    return ue(pt) === C;
  }, uc.isValidElementType = function(pt) {
    return typeof pt == "string" || typeof pt == "function" || pt === c || pt === d || pt === se || pt === i || pt === C || pt === O || pt === Q || typeof pt == "object" && pt !== null && (pt.$$typeof === I || pt.$$typeof === R || pt.$$typeof === m || pt.$$typeof === v || pt.$$typeof === g || pt.$$typeof === ne || pt.$$typeof === L || pt[0] === Z);
  }, uc.typeOf = ue, uc;
}
var dc = {};
/** @license React v17.0.2
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Zfe;
function q7e() {
  return Zfe || (Zfe = 1, process.env.NODE_ENV !== "production" && function() {
    var r = 60103, o = 60106, c = 60107, i = 60108, d = 60114, m = 60109, v = 60110, g = 60112, C = 60113, O = 60120, R = 60115, I = 60116, L = 60121, Z = 60122, ne = 60117, se = 60129, Q = 60131;
    if (typeof Symbol == "function" && Symbol.for) {
      var he = Symbol.for;
      r = he("react.element"), o = he("react.portal"), c = he("react.fragment"), i = he("react.strict_mode"), d = he("react.profiler"), m = he("react.provider"), v = he("react.context"), g = he("react.forward_ref"), C = he("react.suspense"), O = he("react.suspense_list"), R = he("react.memo"), I = he("react.lazy"), L = he("react.block"), Z = he("react.server.block"), ne = he("react.fundamental"), he("react.scope"), he("react.opaque.id"), se = he("react.debug_trace_mode"), he("react.offscreen"), Q = he("react.legacy_hidden");
    }
    var ue = !1;
    function G(Zt) {
      return !!(typeof Zt == "string" || typeof Zt == "function" || Zt === c || Zt === d || Zt === se || Zt === i || Zt === C || Zt === O || Zt === Q || ue || typeof Zt == "object" && Zt !== null && (Zt.$$typeof === I || Zt.$$typeof === R || Zt.$$typeof === m || Zt.$$typeof === v || Zt.$$typeof === g || Zt.$$typeof === ne || Zt.$$typeof === L || Zt[0] === Z));
    }
    function me(Zt) {
      if (typeof Zt == "object" && Zt !== null) {
        var Jt = Zt.$$typeof;
        switch (Jt) {
          case r:
            var wo = Zt.type;
            switch (wo) {
              case c:
              case d:
              case i:
              case C:
              case O:
                return wo;
              default:
                var Ge = wo && wo.$$typeof;
                switch (Ge) {
                  case v:
                  case g:
                  case I:
                  case R:
                  case m:
                    return Ge;
                  default:
                    return Jt;
                }
            }
          case o:
            return Jt;
        }
      }
    }
    var we = v, be = m, q = r, Te = g, Le = c, je = I, Ie = R, Ce = o, pt = d, sn = i, Lt = C, z = !1, bt = !1;
    function at(Zt) {
      return z || (z = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function _n(Zt) {
      return bt || (bt = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function st(Zt) {
      return me(Zt) === v;
    }
    function Ne(Zt) {
      return me(Zt) === m;
    }
    function vt(Zt) {
      return typeof Zt == "object" && Zt !== null && Zt.$$typeof === r;
    }
    function Gt(Zt) {
      return me(Zt) === g;
    }
    function xt(Zt) {
      return me(Zt) === c;
    }
    function cn(Zt) {
      return me(Zt) === I;
    }
    function He(Zt) {
      return me(Zt) === R;
    }
    function ut(Zt) {
      return me(Zt) === o;
    }
    function oe(Zt) {
      return me(Zt) === d;
    }
    function qn(Zt) {
      return me(Zt) === i;
    }
    function Rn(Zt) {
      return me(Zt) === C;
    }
    dc.ContextConsumer = we, dc.ContextProvider = be, dc.Element = q, dc.ForwardRef = Te, dc.Fragment = Le, dc.Lazy = je, dc.Memo = Ie, dc.Portal = Ce, dc.Profiler = pt, dc.StrictMode = sn, dc.Suspense = Lt, dc.isAsyncMode = at, dc.isConcurrentMode = _n, dc.isContextConsumer = st, dc.isContextProvider = Ne, dc.isElement = vt, dc.isForwardRef = Gt, dc.isFragment = xt, dc.isLazy = cn, dc.isMemo = He, dc.isPortal = ut, dc.isProfiler = oe, dc.isStrictMode = qn, dc.isSuspense = Rn, dc.isValidElementType = G, dc.typeOf = me;
  }()), dc;
}
process.env.NODE_ENV === "production" ? Fse.exports = j7e() : Fse.exports = q7e();
var Kfe = Fse.exports, G7e = ["getDisplayName", "methodName", "renderCountProp", "shouldHandleStateChanges", "storeKey", "withRef", "forwardRef", "context"], Z7e = ["reactReduxForwardedRef"], K7e = [], Y7e = [null, null], Q7e = function(o) {
  try {
    return JSON.stringify(o);
  } catch {
    return String(o);
  }
};
function X7e(r, o) {
  var c = r[1];
  return [o.payload, c + 1];
}
function Yfe(r, o, c) {
  Hve(function() {
    return r.apply(void 0, o);
  }, c);
}
function J7e(r, o, c, i, d, m, v) {
  r.current = i, o.current = d, c.current = !1, m.current && (m.current = null, v());
}
function eze(r, o, c, i, d, m, v, g, C, O) {
  if (r) {
    var R = !1, I = null, L = function() {
      if (!R) {
        var se = o.getState(), Q, he;
        try {
          Q = i(se, d.current);
        } catch (ue) {
          he = ue, I = ue;
        }
        he || (I = null), Q === m.current ? v.current || C() : (m.current = Q, g.current = Q, v.current = !0, O({
          type: "STORE_UPDATED",
          payload: {
            error: he
          }
        }));
      }
    };
    c.onStateChange = L, c.trySubscribe(), L();
    var Z = function() {
      if (R = !0, c.tryUnsubscribe(), c.onStateChange = null, I)
        throw I;
    };
    return Z;
  }
}
var tze = function() {
  return [null, 0];
};
function nze(r, o) {
  o === void 0 && (o = {});
  var c = o, i = c.getDisplayName, d = i === void 0 ? function(be) {
    return "ConnectAdvanced(" + be + ")";
  } : i, m = c.methodName, v = m === void 0 ? "connectAdvanced" : m, g = c.renderCountProp, C = g === void 0 ? void 0 : g, O = c.shouldHandleStateChanges, R = O === void 0 ? !0 : O, I = c.storeKey, L = I === void 0 ? "store" : I, Z = c.withRef, ne = Z === void 0 ? !1 : Z, se = c.forwardRef, Q = se === void 0 ? !1 : se, he = c.context, ue = he === void 0 ? Tie : he, G = O1(c, G7e);
  if (process.env.NODE_ENV !== "production") {
    if (C !== void 0)
      throw new Error("renderCountProp is removed. render counting is built into the latest React Dev Tools profiling extension");
    if (ne)
      throw new Error("withRef is removed. To access the wrapped instance, use a ref on the connected component");
    var me = "To use a custom Redux store for specific components, create a custom React context with React.createContext(), and pass the context object to React Redux's Provider and specific components like: <Provider context={MyContext}><ConnectedComponent context={MyContext} /></Provider>. You may also pass a {context : MyContext} option to connect";
    if (L !== "store")
      throw new Error("storeKey has been removed and does not do anything. " + me);
  }
  var we = ue;
  return function(q) {
    if (process.env.NODE_ENV !== "production" && !Kfe.isValidElementType(q))
      throw new Error("You must pass a component to the function returned by " + (v + ". Instead received " + Q7e(q)));
    var Te = q.displayName || q.name || "Component", Le = d(Te), je = Be({}, G, {
      getDisplayName: d,
      methodName: v,
      renderCountProp: C,
      shouldHandleStateChanges: R,
      storeKey: L,
      displayName: Le,
      wrappedComponentName: Te,
      WrappedComponent: q
    }), Ie = G.pure;
    function Ce(bt) {
      return r(bt.dispatch, je);
    }
    var pt = Ie ? Rv : function(bt) {
      return bt();
    };
    function sn(bt) {
      var at = Rv(function() {
        var nn = bt.reactReduxForwardedRef, Bt = O1(bt, Z7e);
        return [bt.context, nn, Bt];
      }, [bt]), _n = at[0], st = at[1], Ne = at[2], vt = Rv(function() {
        return _n && _n.Consumer && Kfe.isContextConsumer(/* @__PURE__ */ ae.createElement(_n.Consumer, null)) ? _n : we;
      }, [_n, we]), Gt = Gc(vt), xt = !!bt.store && !!bt.store.getState && !!bt.store.dispatch, cn = !!Gt && !!Gt.store;
      if (process.env.NODE_ENV !== "production" && !xt && !cn)
        throw new Error('Could not find "store" in the context of ' + ('"' + Le + '". Either wrap the root component in a <Provider>, ') + "or pass a custom React context provider to <Provider> and the corresponding " + ("React context consumer to " + Le + " in connect options."));
      var He = xt ? bt.store : Gt.store, ut = Rv(function() {
        return Ce(He);
      }, [He]), oe = Rv(function() {
        if (!R)
          return Y7e;
        var nn = Bve(He, xt ? null : Gt.subscription), Bt = nn.notifyNestedSubs.bind(nn);
        return [nn, Bt];
      }, [He, xt, Gt]), qn = oe[0], Rn = oe[1], Zt = Rv(function() {
        return xt ? Gt : Be({}, Gt, {
          subscription: qn
        });
      }, [xt, Gt, qn]), Jt = v0e(X7e, K7e, tze), wo = Jt[0], Ge = wo[0], qt = Jt[1];
      if (Ge && Ge.error)
        throw Ge.error;
      var St = uy(), ke = uy(Ne), Ct = uy(), an = uy(!1), ht = pt(function() {
        return Ct.current && Ne === ke.current ? Ct.current : ut(He.getState(), Ne);
      }, [He, Ge, Ne]);
      Yfe(J7e, [ke, St, an, Ne, ht, Ct, Rn]), Yfe(eze, [R, He, qn, ut, ke, St, an, Ct, Rn, qt], [He, qn, ut]);
      var bn = Rv(function() {
        return /* @__PURE__ */ ae.createElement(q, Be({}, ht, {
          ref: st
        }));
      }, [st, q, ht]), Ye = Rv(function() {
        return R ? /* @__PURE__ */ ae.createElement(vt.Provider, {
          value: Zt
        }, bn) : bn;
      }, [vt, bn, Zt]);
      return Ye;
    }
    var Lt = Ie ? ae.memo(sn) : sn;
    if (Lt.WrappedComponent = q, Lt.displayName = sn.displayName = Le, Q) {
      var z = ae.forwardRef(function(at, _n) {
        return /* @__PURE__ */ ae.createElement(Lt, Be({}, at, {
          reactReduxForwardedRef: _n
        }));
      });
      return z.displayName = Le, z.WrappedComponent = q, KW(z, q);
    }
    return KW(Lt, q);
  };
}
function Qfe(r, o) {
  return r === o ? r !== 0 || o !== 0 || 1 / r === 1 / o : r !== r && o !== o;
}
function Ioe(r, o) {
  if (Qfe(r, o))
    return !0;
  if (typeof r != "object" || r === null || typeof o != "object" || o === null)
    return !1;
  var c = Object.keys(r), i = Object.keys(o);
  if (c.length !== i.length)
    return !1;
  for (var d = 0; d < c.length; d++)
    if (!Object.prototype.hasOwnProperty.call(o, c[d]) || !Qfe(r[c[d]], o[c[d]]))
      return !1;
  return !0;
}
function rze(r, o) {
  var c = {}, i = function(v) {
    var g = r[v];
    typeof g == "function" && (c[v] = function() {
      return o(g.apply(void 0, arguments));
    });
  };
  for (var d in r)
    i(d);
  return c;
}
function oze(r) {
  if (typeof r != "object" || r === null)
    return !1;
  var o = Object.getPrototypeOf(r);
  if (o === null)
    return !0;
  for (var c = o; Object.getPrototypeOf(c) !== null; )
    c = Object.getPrototypeOf(c);
  return o === c;
}
function Wve(r) {
  typeof console < "u" && typeof console.error == "function" && console.error(r);
  try {
    throw new Error(r);
  } catch {
  }
}
function jve(r, o, c) {
  oze(r) || Wve(c + "() in " + o + " must return a plain object. Instead received " + r + ".");
}
function Aie(r) {
  return function(c, i) {
    var d = r(c, i);
    function m() {
      return d;
    }
    return m.dependsOnOwnProps = !1, m;
  };
}
function Xfe(r) {
  return r.dependsOnOwnProps !== null && r.dependsOnOwnProps !== void 0 ? !!r.dependsOnOwnProps : r.length !== 1;
}
function qve(r, o) {
  return function(i, d) {
    var m = d.displayName, v = function(C, O) {
      return v.dependsOnOwnProps ? v.mapToProps(C, O) : v.mapToProps(C);
    };
    return v.dependsOnOwnProps = !0, v.mapToProps = function(C, O) {
      v.mapToProps = r, v.dependsOnOwnProps = Xfe(r);
      var R = v(C, O);
      return typeof R == "function" && (v.mapToProps = R, v.dependsOnOwnProps = Xfe(R), R = v(C, O)), process.env.NODE_ENV !== "production" && jve(R, m, o), R;
    }, v;
  };
}
function sze(r) {
  return typeof r == "function" ? qve(r, "mapDispatchToProps") : void 0;
}
function aze(r) {
  return r ? void 0 : Aie(function(o) {
    return {
      dispatch: o
    };
  });
}
function ize(r) {
  return r && typeof r == "object" ? Aie(function(o) {
    return rze(r, o);
  }) : void 0;
}
const cze = [sze, aze, ize];
function lze(r) {
  return typeof r == "function" ? qve(r, "mapStateToProps") : void 0;
}
function uze(r) {
  return r ? void 0 : Aie(function() {
    return {};
  });
}
const dze = [lze, uze];
function fze(r, o, c) {
  return Be({}, c, r, o);
}
function mze(r) {
  return function(c, i) {
    var d = i.displayName, m = i.pure, v = i.areMergedPropsEqual, g = !1, C;
    return function(R, I, L) {
      var Z = r(R, I, L);
      return g ? (!m || !v(Z, C)) && (C = Z) : (g = !0, C = Z, process.env.NODE_ENV !== "production" && jve(C, d, "mergeProps")), C;
    };
  };
}
function pze(r) {
  return typeof r == "function" ? mze(r) : void 0;
}
function hze(r) {
  return r ? void 0 : function() {
    return fze;
  };
}
const gze = [pze, hze];
function Moe(r, o, c) {
  if (r)
    (o === "mapStateToProps" || o === "mapDispatchToProps") && (Object.prototype.hasOwnProperty.call(r, "dependsOnOwnProps") || Wve("The selector for " + o + " of " + c + " did not specify a value for dependsOnOwnProps."));
  else
    throw new Error("Unexpected value for " + o + " in " + c + ".");
}
function vze(r, o, c, i) {
  Moe(r, "mapStateToProps", i), Moe(o, "mapDispatchToProps", i), Moe(c, "mergeProps", i);
}
var bze = ["initMapStateToProps", "initMapDispatchToProps", "initMergeProps"];
function yze(r, o, c, i) {
  return function(m, v) {
    return c(r(m, v), o(i, v), v);
  };
}
function Sze(r, o, c, i, d) {
  var m = d.areStatesEqual, v = d.areOwnPropsEqual, g = d.areStatePropsEqual, C = !1, O, R, I, L, Z;
  function ne(G, me) {
    return O = G, R = me, I = r(O, R), L = o(i, R), Z = c(I, L, R), C = !0, Z;
  }
  function se() {
    return I = r(O, R), o.dependsOnOwnProps && (L = o(i, R)), Z = c(I, L, R), Z;
  }
  function Q() {
    return r.dependsOnOwnProps && (I = r(O, R)), o.dependsOnOwnProps && (L = o(i, R)), Z = c(I, L, R), Z;
  }
  function he() {
    var G = r(O, R), me = !g(G, I);
    return I = G, me && (Z = c(I, L, R)), Z;
  }
  function ue(G, me) {
    var we = !v(me, R), be = !m(G, O, me, R);
    return O = G, R = me, we && be ? se() : we ? Q() : be ? he() : Z;
  }
  return function(me, we) {
    return C ? ue(me, we) : ne(me, we);
  };
}
function wze(r, o) {
  var c = o.initMapStateToProps, i = o.initMapDispatchToProps, d = o.initMergeProps, m = O1(o, bze), v = c(r, m), g = i(r, m), C = d(r, m);
  process.env.NODE_ENV !== "production" && vze(v, g, C, m.displayName);
  var O = m.pure ? Sze : yze;
  return O(v, g, C, r, m);
}
var Eze = ["pure", "areStatesEqual", "areOwnPropsEqual", "areStatePropsEqual", "areMergedPropsEqual"];
function Foe(r, o, c) {
  for (var i = o.length - 1; i >= 0; i--) {
    var d = o[i](r);
    if (d)
      return d;
  }
  return function(m, v) {
    throw new Error("Invalid value of type " + typeof r + " for " + c + " argument when connecting component " + v.wrappedComponentName + ".");
  };
}
function Cze(r, o) {
  return r === o;
}
function xze(r) {
  var o = r === void 0 ? {} : r, c = o.connectHOC, i = c === void 0 ? nze : c, d = o.mapStateToPropsFactories, m = d === void 0 ? dze : d, v = o.mapDispatchToPropsFactories, g = v === void 0 ? cze : v, C = o.mergePropsFactories, O = C === void 0 ? gze : C, R = o.selectorFactory, I = R === void 0 ? wze : R;
  return function(Z, ne, se, Q) {
    Q === void 0 && (Q = {});
    var he = Q, ue = he.pure, G = ue === void 0 ? !0 : ue, me = he.areStatesEqual, we = me === void 0 ? Cze : me, be = he.areOwnPropsEqual, q = be === void 0 ? Ioe : be, Te = he.areStatePropsEqual, Le = Te === void 0 ? Ioe : Te, je = he.areMergedPropsEqual, Ie = je === void 0 ? Ioe : je, Ce = O1(he, Eze), pt = Foe(Z, m, "mapStateToProps"), sn = Foe(ne, g, "mapDispatchToProps"), Lt = Foe(se, O, "mergeProps");
    return i(I, Be({
      // used in error messages
      methodName: "connect",
      // used to compute Connect's displayName from the wrapped component's displayName.
      getDisplayName: function(bt) {
        return "Connect(" + bt + ")";
      },
      // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes
      shouldHandleStateChanges: !!Z,
      // passed through to selectorFactory
      initMapStateToProps: pt,
      initMapDispatchToProps: sn,
      initMergeProps: Lt,
      pure: G,
      areStatesEqual: we,
      areOwnPropsEqual: q,
      areStatePropsEqual: Le,
      areMergedPropsEqual: Ie
    }, Ce));
  };
}
const Rd = /* @__PURE__ */ xze();
$7e(E0e);
function Jfe(r, o) {
  var c = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(r);
    o && (i = i.filter(function(d) {
      return Object.getOwnPropertyDescriptor(r, d).enumerable;
    })), c.push.apply(c, i);
  }
  return c;
}
function eme(r) {
  for (var o = 1; o < arguments.length; o++) {
    var c = arguments[o] != null ? arguments[o] : {};
    o % 2 ? Jfe(Object(c), !0).forEach(function(i) {
      BA(r, i, c[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(c)) : Jfe(Object(c)).forEach(function(i) {
      Object.defineProperty(r, i, Object.getOwnPropertyDescriptor(c, i));
    });
  }
  return r;
}
function pp(r) {
  return "Minified Redux error #" + r + "; visit https://redux.js.org/Errors?code=" + r + " for the full message or use the non-minified dev environment for full errors. ";
}
var tme = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}(), Loe = function() {
  return Math.random().toString(36).substring(7).split("").join(".");
}, WA = {
  INIT: "@@redux/INIT" + Loe(),
  REPLACE: "@@redux/REPLACE" + Loe(),
  PROBE_UNKNOWN_ACTION: function() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + Loe();
  }
};
function Gve(r) {
  if (typeof r != "object" || r === null)
    return !1;
  for (var o = r; Object.getPrototypeOf(o) !== null; )
    o = Object.getPrototypeOf(o);
  return Object.getPrototypeOf(r) === o;
}
function Tze(r) {
  if (r === void 0)
    return "undefined";
  if (r === null)
    return "null";
  var o = typeof r;
  switch (o) {
    case "boolean":
    case "string":
    case "number":
    case "symbol":
    case "function":
      return o;
  }
  if (Array.isArray(r))
    return "array";
  if (Aze(r))
    return "date";
  if (Oze(r))
    return "error";
  var c = _ze(r);
  switch (c) {
    case "Symbol":
    case "Promise":
    case "WeakMap":
    case "WeakSet":
    case "Map":
    case "Set":
      return c;
  }
  return o.slice(8, -1).toLowerCase().replace(/\s/g, "");
}
function _ze(r) {
  return typeof r.constructor == "function" ? r.constructor.name : null;
}
function Oze(r) {
  return r instanceof Error || typeof r.message == "string" && r.constructor && typeof r.constructor.stackTraceLimit == "number";
}
function Aze(r) {
  return r instanceof Date ? !0 : typeof r.toDateString == "function" && typeof r.getDate == "function" && typeof r.setDate == "function";
}
function DA(r) {
  var o = typeof r;
  return process.env.NODE_ENV !== "production" && (o = Tze(r)), o;
}
function Zve(r, o, c) {
  var i;
  if (typeof o == "function" && typeof c == "function" || typeof c == "function" && typeof arguments[3] == "function")
    throw new Error(process.env.NODE_ENV === "production" ? pp(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
  if (typeof o == "function" && typeof c > "u" && (c = o, o = void 0), typeof c < "u") {
    if (typeof c != "function")
      throw new Error(process.env.NODE_ENV === "production" ? pp(1) : "Expected the enhancer to be a function. Instead, received: '" + DA(c) + "'");
    return c(Zve)(r, o);
  }
  if (typeof r != "function")
    throw new Error(process.env.NODE_ENV === "production" ? pp(2) : "Expected the root reducer to be a function. Instead, received: '" + DA(r) + "'");
  var d = r, m = o, v = [], g = v, C = !1;
  function O() {
    g === v && (g = v.slice());
  }
  function R() {
    if (C)
      throw new Error(process.env.NODE_ENV === "production" ? pp(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
    return m;
  }
  function I(se) {
    if (typeof se != "function")
      throw new Error(process.env.NODE_ENV === "production" ? pp(4) : "Expected the listener to be a function. Instead, received: '" + DA(se) + "'");
    if (C)
      throw new Error(process.env.NODE_ENV === "production" ? pp(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
    var Q = !0;
    return O(), g.push(se), function() {
      if (Q) {
        if (C)
          throw new Error(process.env.NODE_ENV === "production" ? pp(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
        Q = !1, O();
        var ue = g.indexOf(se);
        g.splice(ue, 1), v = null;
      }
    };
  }
  function L(se) {
    if (!Gve(se))
      throw new Error(process.env.NODE_ENV === "production" ? pp(7) : "Actions must be plain objects. Instead, the actual type was: '" + DA(se) + "'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.");
    if (typeof se.type > "u")
      throw new Error(process.env.NODE_ENV === "production" ? pp(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
    if (C)
      throw new Error(process.env.NODE_ENV === "production" ? pp(9) : "Reducers may not dispatch actions.");
    try {
      C = !0, m = d(m, se);
    } finally {
      C = !1;
    }
    for (var Q = v = g, he = 0; he < Q.length; he++) {
      var ue = Q[he];
      ue();
    }
    return se;
  }
  function Z(se) {
    if (typeof se != "function")
      throw new Error(process.env.NODE_ENV === "production" ? pp(10) : "Expected the nextReducer to be a function. Instead, received: '" + DA(se));
    d = se, L({
      type: WA.REPLACE
    });
  }
  function ne() {
    var se, Q = I;
    return se = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function(ue) {
        if (typeof ue != "object" || ue === null)
          throw new Error(process.env.NODE_ENV === "production" ? pp(11) : "Expected the observer to be an object. Instead, received: '" + DA(ue) + "'");
        function G() {
          ue.next && ue.next(R());
        }
        G();
        var me = Q(G);
        return {
          unsubscribe: me
        };
      }
    }, se[tme] = function() {
      return this;
    }, se;
  }
  return L({
    type: WA.INIT
  }), i = {
    dispatch: L,
    subscribe: I,
    getState: R,
    replaceReducer: Z
  }, i[tme] = ne, i;
}
function nme(r) {
  typeof console < "u" && typeof console.error == "function" && console.error(r);
  try {
    throw new Error(r);
  } catch {
  }
}
function kze(r, o, c, i) {
  var d = Object.keys(o), m = c && c.type === WA.INIT ? "preloadedState argument passed to createStore" : "previous state received by the reducer";
  if (d.length === 0)
    return "Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";
  if (!Gve(r))
    return "The " + m + ' has unexpected type of "' + DA(r) + '". Expected argument to be an object with the following ' + ('keys: "' + d.join('", "') + '"');
  var v = Object.keys(r).filter(function(g) {
    return !o.hasOwnProperty(g) && !i[g];
  });
  if (v.forEach(function(g) {
    i[g] = !0;
  }), !(c && c.type === WA.REPLACE) && v.length > 0)
    return "Unexpected " + (v.length > 1 ? "keys" : "key") + " " + ('"' + v.join('", "') + '" found in ' + m + ". ") + "Expected to find one of the known reducer keys instead: " + ('"' + d.join('", "') + '". Unexpected keys will be ignored.');
}
function Nze(r) {
  Object.keys(r).forEach(function(o) {
    var c = r[o], i = c(void 0, {
      type: WA.INIT
    });
    if (typeof i > "u")
      throw new Error(process.env.NODE_ENV === "production" ? pp(12) : 'The slice reducer for key "' + o + `" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);
    if (typeof c(void 0, {
      type: WA.PROBE_UNKNOWN_ACTION()
    }) > "u")
      throw new Error(process.env.NODE_ENV === "production" ? pp(13) : 'The slice reducer for key "' + o + '" returned undefined when probed with a random type. ' + ("Don't try to handle '" + WA.INIT + `' or other actions in "redux/*" `) + "namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.");
  });
}
function Rze(r) {
  for (var o = Object.keys(r), c = {}, i = 0; i < o.length; i++) {
    var d = o[i];
    process.env.NODE_ENV !== "production" && typeof r[d] > "u" && nme('No reducer provided for key "' + d + '"'), typeof r[d] == "function" && (c[d] = r[d]);
  }
  var m = Object.keys(c), v;
  process.env.NODE_ENV !== "production" && (v = {});
  var g;
  try {
    Nze(c);
  } catch (C) {
    g = C;
  }
  return function(O, R) {
    if (O === void 0 && (O = {}), g)
      throw g;
    if (process.env.NODE_ENV !== "production") {
      var I = kze(O, c, R, v);
      I && nme(I);
    }
    for (var L = !1, Z = {}, ne = 0; ne < m.length; ne++) {
      var se = m[ne], Q = c[se], he = O[se], ue = Q(he, R);
      if (typeof ue > "u") {
        var G = R && R.type;
        throw new Error(process.env.NODE_ENV === "production" ? pp(14) : "When called with an action of type " + (G ? '"' + String(G) + '"' : "(unknown type)") + ', the slice reducer for key "' + se + '" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.');
      }
      Z[se] = ue, L = L || ue !== he;
    }
    return L = L || m.length !== Object.keys(O).length, L ? Z : O;
  };
}
function Pze() {
  for (var r = arguments.length, o = new Array(r), c = 0; c < r; c++)
    o[c] = arguments[c];
  return o.length === 0 ? function(i) {
    return i;
  } : o.length === 1 ? o[0] : o.reduce(function(i, d) {
    return function() {
      return i(d.apply(void 0, arguments));
    };
  });
}
function Dze() {
  for (var r = arguments.length, o = new Array(r), c = 0; c < r; c++)
    o[c] = arguments[c];
  return function(i) {
    return function() {
      var d = i.apply(void 0, arguments), m = function() {
        throw new Error(process.env.NODE_ENV === "production" ? pp(15) : "Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.");
      }, v = {
        getState: d.getState,
        dispatch: function() {
          return m.apply(void 0, arguments);
        }
      }, g = o.map(function(C) {
        return C(v);
      });
      return m = Pze.apply(void 0, g)(d.dispatch), eme(eme({}, d), {}, {
        dispatch: m
      });
    };
  };
}
function Kve(r) {
  var o = function(i) {
    var d = i.dispatch, m = i.getState;
    return function(v) {
      return function(g) {
        return typeof g == "function" ? g(d, m, r) : v(g);
      };
    };
  };
  return o;
}
var Yve = Kve();
Yve.withExtraArgument = Kve;
const $ze = Yve;
var YW = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
YW.exports;
(function(r, o) {
  (function() {
    var c, i = "4.17.21", d = 200, m = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", v = "Expected a function", g = "Invalid `variable` option passed into `_.template`", C = "__lodash_hash_undefined__", O = 500, R = "__lodash_placeholder__", I = 1, L = 2, Z = 4, ne = 1, se = 2, Q = 1, he = 2, ue = 4, G = 8, me = 16, we = 32, be = 64, q = 128, Te = 256, Le = 512, je = 30, Ie = "...", Ce = 800, pt = 16, sn = 1, Lt = 2, z = 3, bt = 1 / 0, at = 9007199254740991, _n = 17976931348623157e292, st = 0 / 0, Ne = 4294967295, vt = Ne - 1, Gt = Ne >>> 1, xt = [
      ["ary", q],
      ["bind", Q],
      ["bindKey", he],
      ["curry", G],
      ["curryRight", me],
      ["flip", Le],
      ["partial", we],
      ["partialRight", be],
      ["rearg", Te]
    ], cn = "[object Arguments]", He = "[object Array]", ut = "[object AsyncFunction]", oe = "[object Boolean]", qn = "[object Date]", Rn = "[object DOMException]", Zt = "[object Error]", Jt = "[object Function]", wo = "[object GeneratorFunction]", Ge = "[object Map]", qt = "[object Number]", St = "[object Null]", ke = "[object Object]", Ct = "[object Promise]", an = "[object Proxy]", ht = "[object RegExp]", bn = "[object Set]", Ye = "[object String]", nn = "[object Symbol]", Bt = "[object Undefined]", $n = "[object WeakMap]", mr = "[object WeakSet]", gr = "[object ArrayBuffer]", Vr = "[object DataView]", Xr = "[object Float32Array]", pc = "[object Float64Array]", Eo = "[object Int8Array]", uo = "[object Int16Array]", Es = "[object Int32Array]", br = "[object Uint8Array]", hs = "[object Uint8ClampedArray]", Ps = "[object Uint16Array]", qo = "[object Uint32Array]", hc = /\b__p \+= '';/g, Co = /\b(__p \+=) '' \+/g, fl = /(__e\(.*?\)|\b__t\)) \+\n'';/g, fn = /&(?:amp|lt|gt|quot|#39);/g, Yr = /[&<>"']/g, xa = RegExp(fn.source), $i = RegExp(Yr.source), Kc = /<%-([\s\S]+?)%>/g, wi = /<%([\s\S]+?)%>/g, es = /<%=([\s\S]+?)%>/g, gc = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Xl = /^\w*$/, gs = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, lr = /[\\^$.*+?()[\]{}|]/g, Ei = RegExp(lr.source), Jl = /^\s+/, Pd = /\s/, Xf = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, Qa = /\{\n\/\* \[wrapped with (.+)\] \*/, Xa = /,? & /, ia = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, Nl = /[()=,{}\[\]\/\s]/, Sp = /\\(\\)?/g, Yu = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, vc = /\w*$/, ea = /^[-+]0x[0-9a-f]+$/i, bc = /^0b[01]+$/i, Qu = /^\[object .+?Constructor\]$/, wp = /^0o[0-7]+$/i, of = /^(?:0|[1-9]\d*)$/, Ou = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Au = /($^)/, nt = /['\n\r\u2028\u2029\\]/g, Ja = "\\ud800-\\udfff", eu = "\\u0300-\\u036f", Ep = "\\ufe20-\\ufe2f", Jf = "\\u20d0-\\u20ff", os = eu + Ep + Jf, Cp = "\\u2700-\\u27bf", Am = "a-z\\xdf-\\xf6\\xf8-\\xff", tu = "\\xac\\xb1\\xd7\\xf7", em = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", Hs = "\\u2000-\\u206f", Gs = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", Ac = "A-Z\\xc0-\\xd6\\xd8-\\xde", kc = "\\ufe0e\\ufe0f", Xu = tu + em + Hs + Gs, Ju = "[']", ed = "[" + Ja + "]", $o = "[" + Xu + "]", ei = "[" + os + "]", Rl = "\\d+", td = "[" + Cp + "]", Xi = "[" + Am + "]", Zs = "[^" + Ja + Xu + Rl + Cp + Am + Ac + "]", ss = "\\ud83c[\\udffb-\\udfff]", yc = "(?:" + ei + "|" + ss + ")", tm = "[^" + Ja + "]", Io = "(?:\\ud83c[\\udde6-\\uddff]){2}", za = "[\\ud800-\\udbff][\\udc00-\\udfff]", ti = "[" + Ac + "]", Ra = "\\u200d", Pl = "(?:" + Xi + "|" + Zs + ")", nu = "(?:" + ti + "|" + Zs + ")", Ii = "(?:" + Ju + "(?:d|ll|m|re|s|t|ve))?", Dl = "(?:" + Ju + "(?:D|LL|M|RE|S|T|VE))?", $l = yc + "?", km = "[" + kc + "]?", Il = "(?:" + Ra + "(?:" + [tm, Io, za].join("|") + ")" + km + $l + ")*", xp = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Nc = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", ku = km + $l + Il, sf = "(?:" + [td, Io, za].join("|") + ")" + ku, Nm = "(?:" + [tm + ei + "?", ei, Io, za, ed].join("|") + ")", Tp = RegExp(Ju, "g"), Se = RegExp(ei, "g"), Ve = RegExp(ss + "(?=" + ss + ")|" + Nm + ku, "g"), tt = RegExp([
      ti + "?" + Xi + "+" + Ii + "(?=" + [$o, ti, "$"].join("|") + ")",
      nu + "+" + Dl + "(?=" + [$o, ti + Pl, "$"].join("|") + ")",
      ti + "?" + Pl + "+" + Ii,
      ti + "+" + Dl,
      Nc,
      xp,
      Rl,
      sf
    ].join("|"), "g"), wt = RegExp("[" + Ra + Ja + os + kc + "]"), en = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, ur = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], Yo = -1, Lr = {};
    Lr[Xr] = Lr[pc] = Lr[Eo] = Lr[uo] = Lr[Es] = Lr[br] = Lr[hs] = Lr[Ps] = Lr[qo] = !0, Lr[cn] = Lr[He] = Lr[gr] = Lr[oe] = Lr[Vr] = Lr[qn] = Lr[Zt] = Lr[Jt] = Lr[Ge] = Lr[qt] = Lr[ke] = Lr[ht] = Lr[bn] = Lr[Ye] = Lr[$n] = !1;
    var Nr = {};
    Nr[cn] = Nr[He] = Nr[gr] = Nr[Vr] = Nr[oe] = Nr[qn] = Nr[Xr] = Nr[pc] = Nr[Eo] = Nr[uo] = Nr[Es] = Nr[Ge] = Nr[qt] = Nr[ke] = Nr[ht] = Nr[bn] = Nr[Ye] = Nr[nn] = Nr[br] = Nr[hs] = Nr[Ps] = Nr[qo] = !0, Nr[Zt] = Nr[Jt] = Nr[$n] = !1;
    var Ks = {
      // Latin-1 Supplement block.
      : "A",
      : "A",
      : "A",
      : "A",
      : "A",
      : "A",
      : "a",
      : "a",
      : "a",
      : "a",
      : "a",
      : "a",
      : "C",
      : "c",
      : "D",
      : "d",
      : "E",
      : "E",
      : "E",
      : "E",
      : "e",
      : "e",
      : "e",
      : "e",
      : "I",
      : "I",
      : "I",
      : "I",
      : "i",
      : "i",
      : "i",
      : "i",
      : "N",
      : "n",
      : "O",
      : "O",
      : "O",
      : "O",
      : "O",
      : "O",
      : "o",
      : "o",
      : "o",
      : "o",
      : "o",
      : "o",
      : "U",
      : "U",
      : "U",
      : "U",
      : "u",
      : "u",
      : "u",
      : "u",
      : "Y",
      : "y",
      : "y",
      : "Ae",
      : "ae",
      : "Th",
      : "th",
      : "ss",
      // Latin Extended-A block.
      : "A",
      : "A",
      : "A",
      : "a",
      : "a",
      : "a",
      : "C",
      : "C",
      : "C",
      : "C",
      : "c",
      : "c",
      : "c",
      : "c",
      : "D",
      : "D",
      : "d",
      : "d",
      : "E",
      : "E",
      : "E",
      : "E",
      : "E",
      : "e",
      : "e",
      : "e",
      : "e",
      : "e",
      : "G",
      : "G",
      : "G",
      : "G",
      : "g",
      : "g",
      : "g",
      : "g",
      : "H",
      : "H",
      : "h",
      : "h",
      : "I",
      : "I",
      : "I",
      : "I",
      : "I",
      : "i",
      : "i",
      : "i",
      : "i",
      : "i",
      : "J",
      : "j",
      : "K",
      : "k",
      : "k",
      : "L",
      : "L",
      : "L",
      : "L",
      : "L",
      : "l",
      : "l",
      : "l",
      : "l",
      : "l",
      : "N",
      : "N",
      : "N",
      : "N",
      : "n",
      : "n",
      : "n",
      : "n",
      : "O",
      : "O",
      : "O",
      : "o",
      : "o",
      : "o",
      : "R",
      : "R",
      : "R",
      : "r",
      : "r",
      : "r",
      : "S",
      : "S",
      : "S",
      : "S",
      : "s",
      : "s",
      : "s",
      : "s",
      : "T",
      : "T",
      : "T",
      : "t",
      : "t",
      : "t",
      : "U",
      : "U",
      : "U",
      : "U",
      : "U",
      : "U",
      : "u",
      : "u",
      : "u",
      : "u",
      : "u",
      : "u",
      : "W",
      : "w",
      : "Y",
      : "y",
      : "Y",
      : "Z",
      : "Z",
      : "Z",
      : "z",
      : "z",
      : "z",
      : "IJ",
      : "ij",
      : "Oe",
      : "oe",
      : "'n",
      : "s"
    }, fo = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, ta = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, Yc = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, Rm = parseFloat, kn = parseInt, Pm = typeof S1 == "object" && S1 && S1.Object === Object && S1, ca = typeof self == "object" && self && self.Object === Object && self, as = Pm || ca || Function("return this")(), _p = o && !o.nodeType && o, vs = _p && !0 && r && !r.nodeType && r, Wv = vs && vs.exports === _p, Va = Wv && Pm.process, Sc = function() {
      try {
        var Je = vs && vs.require && vs.require("util").types;
        return Je || Va && Va.binding && Va.binding("util");
      } catch {
      }
    }(), Sr = Sc && Sc.isArrayBuffer, Rc = Sc && Sc.isDate, rn = Sc && Sc.isMap, na = Sc && Sc.isRegExp, Dm = Sc && Sc.isSet, Ta = Sc && Sc.isTypedArray;
    function bs(Je, Wt, Ft) {
      switch (Ft.length) {
        case 0:
          return Je.call(Wt);
        case 1:
          return Je.call(Wt, Ft[0]);
        case 2:
          return Je.call(Wt, Ft[0], Ft[1]);
        case 3:
          return Je.call(Wt, Ft[0], Ft[1], Ft[2]);
      }
      return Je.apply(Wt, Ft);
    }
    function Dd(Je, Wt, Ft, er) {
      for (var Qr = -1, No = Je == null ? 0 : Je.length; ++Qr < No; ) {
        var Qo = Je[Qr];
        Wt(er, Qo, Ft(Qo), Je);
      }
      return er;
    }
    function Ur(Je, Wt) {
      for (var Ft = -1, er = Je == null ? 0 : Je.length; ++Ft < er && Wt(Je[Ft], Ft, Je) !== !1; )
        ;
      return Je;
    }
    function Qc(Je, Wt) {
      for (var Ft = Je == null ? 0 : Je.length; Ft-- && Wt(Je[Ft], Ft, Je) !== !1; )
        ;
      return Je;
    }
    function ni(Je, Wt) {
      for (var Ft = -1, er = Je == null ? 0 : Je.length; ++Ft < er; )
        if (!Wt(Je[Ft], Ft, Je))
          return !1;
      return !0;
    }
    function Xc(Je, Wt) {
      for (var Ft = -1, er = Je == null ? 0 : Je.length, Qr = 0, No = []; ++Ft < er; ) {
        var Qo = Je[Ft];
        Wt(Qo, Ft, Je) && (No[Qr++] = Qo);
      }
      return No;
    }
    function Ds(Je, Wt) {
      var Ft = Je == null ? 0 : Je.length;
      return !!Ft && Pa(Je, Wt, 0) > -1;
    }
    function af(Je, Wt, Ft) {
      for (var er = -1, Qr = Je == null ? 0 : Je.length; ++er < Qr; )
        if (Ft(Wt, Je[er]))
          return !0;
      return !1;
    }
    function _a(Je, Wt) {
      for (var Ft = -1, er = Je == null ? 0 : Je.length, Qr = Array(er); ++Ft < er; )
        Qr[Ft] = Wt(Je[Ft], Ft, Je);
      return Qr;
    }
    function $d(Je, Wt) {
      for (var Ft = -1, er = Wt.length, Qr = Je.length; ++Ft < er; )
        Je[Qr + Ft] = Wt[Ft];
      return Je;
    }
    function Oo(Je, Wt, Ft, er) {
      var Qr = -1, No = Je == null ? 0 : Je.length;
      for (er && No && (Ft = Je[++Qr]); ++Qr < No; )
        Ft = Wt(Ft, Je[Qr], Qr, Je);
      return Ft;
    }
    function Nu(Je, Wt, Ft, er) {
      var Qr = Je == null ? 0 : Je.length;
      for (er && Qr && (Ft = Je[--Qr]); Qr--; )
        Ft = Wt(Ft, Je[Qr], Qr, Je);
      return Ft;
    }
    function Ru(Je, Wt) {
      for (var Ft = -1, er = Je == null ? 0 : Je.length; ++Ft < er; )
        if (Wt(Je[Ft], Ft, Je))
          return !0;
      return !1;
    }
    var Jc = hi("length");
    function Ml(Je) {
      return Je.split("");
    }
    function Op(Je) {
      return Je.match(ia) || [];
    }
    function no(Je, Wt, Ft) {
      var er;
      return Ft(Je, function(Qr, No, Qo) {
        if (Wt(Qr, No, Qo))
          return er = No, !1;
      }), er;
    }
    function Oa(Je, Wt, Ft, er) {
      for (var Qr = Je.length, No = Ft + (er ? 1 : -1); er ? No-- : ++No < Qr; )
        if (Wt(Je[No], No, Je))
          return No;
      return -1;
    }
    function Pa(Je, Wt, Ft) {
      return Wt === Wt ? Ig(Je, Wt, Ft) : Oa(Je, zs, Ft);
    }
    function jv(Je, Wt, Ft, er) {
      for (var Qr = Ft - 1, No = Je.length; ++Qr < No; )
        if (er(Je[Qr], Wt))
          return Qr;
      return -1;
    }
    function zs(Je) {
      return Je !== Je;
    }
    function Mi(Je, Wt) {
      var Ft = Je == null ? 0 : Je.length;
      return Ft ? $m(Je, Wt) / Ft : st;
    }
    function hi(Je) {
      return function(Wt) {
        return Wt == null ? c : Wt[Je];
      };
    }
    function Fh(Je) {
      return function(Wt) {
        return Je == null ? c : Je[Wt];
      };
    }
    function Lh(Je, Wt, Ft, er, Qr) {
      return Qr(Je, function(No, Qo, Xo) {
        Ft = er ? (er = !1, No) : Wt(Ft, No, Qo, Xo);
      }), Ft;
    }
    function Fl(Je, Wt) {
      var Ft = Je.length;
      for (Je.sort(Wt); Ft--; )
        Je[Ft] = Je[Ft].value;
      return Je;
    }
    function $m(Je, Wt) {
      for (var Ft, er = -1, Qr = Je.length; ++er < Qr; ) {
        var No = Wt(Je[er]);
        No !== c && (Ft = Ft === c ? No : Ft + No);
      }
      return Ft;
    }
    function is(Je, Wt) {
      for (var Ft = -1, er = Array(Je); ++Ft < Je; )
        er[Ft] = Wt(Ft);
      return er;
    }
    function ru(Je, Wt) {
      return _a(Wt, function(Ft) {
        return [Ft, Je[Ft]];
      });
    }
    function Ji(Je) {
      return Je && Je.slice(0, Fg(Je) + 1).replace(Jl, "");
    }
    function ri(Je) {
      return function(Wt) {
        return Je(Wt);
      };
    }
    function Da(Je, Wt) {
      return _a(Wt, function(Ft) {
        return Je[Ft];
      });
    }
    function Vs(Je, Wt) {
      return Je.has(Wt);
    }
    function Ll(Je, Wt) {
      for (var Ft = -1, er = Je.length; ++Ft < er && Pa(Wt, Je[Ft], 0) > -1; )
        ;
      return Ft;
    }
    function cf(Je, Wt) {
      for (var Ft = Je.length; Ft-- && Pa(Wt, Je[Ft], 0) > -1; )
        ;
      return Ft;
    }
    function nm(Je, Wt) {
      for (var Ft = Je.length, er = 0; Ft--; )
        Je[Ft] === Wt && ++er;
      return er;
    }
    var Bh = Fh(Ks), Ap = Fh(fo);
    function Pc(Je) {
      return "\\" + Yc[Je];
    }
    function kp(Je, Wt) {
      return Je == null ? c : Je[Wt];
    }
    function gi(Je) {
      return wt.test(Je);
    }
    function Pu(Je) {
      return en.test(Je);
    }
    function Np(Je) {
      for (var Wt, Ft = []; !(Wt = Je.next()).done; )
        Ft.push(Wt.value);
      return Ft;
    }
    function nd(Je) {
      var Wt = -1, Ft = Array(Je.size);
      return Je.forEach(function(er, Qr) {
        Ft[++Wt] = [Qr, er];
      }), Ft;
    }
    function Im(Je, Wt) {
      return function(Ft) {
        return Je(Wt(Ft));
      };
    }
    function wc(Je, Wt) {
      for (var Ft = -1, er = Je.length, Qr = 0, No = []; ++Ft < er; ) {
        var Qo = Je[Ft];
        (Qo === Wt || Qo === R) && (Je[Ft] = R, No[Qr++] = Ft);
      }
      return No;
    }
    function Mm(Je) {
      var Wt = -1, Ft = Array(Je.size);
      return Je.forEach(function(er) {
        Ft[++Wt] = er;
      }), Ft;
    }
    function Id(Je) {
      var Wt = -1, Ft = Array(Je.size);
      return Je.forEach(function(er) {
        Ft[++Wt] = [er, er];
      }), Ft;
    }
    function Ig(Je, Wt, Ft) {
      for (var er = Ft - 1, Qr = Je.length; ++er < Qr; )
        if (Je[er] === Wt)
          return er;
      return -1;
    }
    function Mg(Je, Wt, Ft) {
      for (var er = Ft + 1; er--; )
        if (Je[er] === Wt)
          return er;
      return er;
    }
    function lf(Je) {
      return gi(Je) ? uf(Je) : Jc(Je);
    }
    function Ec(Je) {
      return gi(Je) ? Bl(Je) : Ml(Je);
    }
    function Fg(Je) {
      for (var Wt = Je.length; Wt-- && Pd.test(Je.charAt(Wt)); )
        ;
      return Wt;
    }
    var Fe = Fh(ta);
    function uf(Je) {
      for (var Wt = Ve.lastIndex = 0; Ve.test(Je); )
        ++Wt;
      return Wt;
    }
    function Bl(Je) {
      return Je.match(Ve) || [];
    }
    function Fm(Je) {
      return Je.match(tt) || [];
    }
    var Lg = function Je(Wt) {
      Wt = Wt == null ? as : Lm.defaults(as.Object(), Wt, Lm.pick(as, ur));
      var Ft = Wt.Array, er = Wt.Date, Qr = Wt.Error, No = Wt.Function, Qo = Wt.Math, Xo = Wt.Object, Rp = Wt.RegExp, qv = Wt.String, $a = Wt.TypeError, Hl = Ft.prototype, Bg = No.prototype, oi = Xo.prototype, ga = Wt["__core-js_shared__"], Du = Bg.toString, ys = oi.hasOwnProperty, ou = 0, ec = function() {
        var S = /[^.]+$/.exec(ga && ga.keys && ga.keys.IE_PROTO || "");
        return S ? "Symbol(src)_1." + S : "";
      }(), Bm = oi.toString, Gv = Du.call(Xo), Pp = as._, Hh = Rp(
        "^" + Du.call(ys).replace(lr, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), Md = Wv ? Wt.Buffer : c, Cc = Wt.Symbol, Dp = Wt.Uint8Array, wy = Md ? Md.allocUnsafe : c, Hm = Im(Xo.getPrototypeOf, Xo), zh = Xo.create, df = oi.propertyIsEnumerable, ff = Hl.splice, rm = Cc ? Cc.isConcatSpreadable : c, cs = Cc ? Cc.iterator : c, Ss = Cc ? Cc.toStringTag : c, Fi = function() {
        try {
          var S = Gh(Xo, "defineProperty");
          return S({}, "", {}), S;
        } catch {
        }
      }(), Hg = Wt.clearTimeout !== as.clearTimeout && Wt.clearTimeout, Zv = er && er.now !== as.Date.now && er.now, Ci = Wt.setTimeout !== as.setTimeout && Wt.setTimeout, su = Qo.ceil, Li = Qo.floor, au = Xo.getOwnPropertySymbols, Vh = Md ? Md.isBuffer : c, Rr = Wt.isFinite, el = Hl.join, mf = Im(Xo.keys, Xo), Ia = Qo.max, Bi = Qo.min, Kv = er.now, Hi = Wt.parseInt, va = Qo.random, ml = Hl.reverse, Aa = Gh(Wt, "DataView"), rd = Gh(Wt, "Map"), Fd = Gh(Wt, "Promise"), $s = Gh(Wt, "Set"), ba = Gh(Wt, "WeakMap"), tl = Gh(Xo, "create"), od = ba && new ba(), Ys = {}, zg = qm(Aa), Yv = qm(rd), Vo = qm(Fd), $u = qm($s), mo = qm(ba), zi = Cc ? Cc.prototype : c, iu = zi ? zi.valueOf : c, sd = zi ? zi.toString : c;
      function ye(S) {
        if (Gi(S) && !Br(S) && !(S instanceof ts)) {
          if (S instanceof pl)
            return S;
          if (ys.call(S, "__wrapped__"))
            return KC(S);
        }
        return new pl(S);
      }
      var cu = function() {
        function S() {
        }
        return function(T) {
          if (!li(T))
            return {};
          if (zh)
            return zh(T);
          S.prototype = T;
          var F = new S();
          return S.prototype = c, F;
        };
      }();
      function zm() {
      }
      function pl(S, T) {
        this.__wrapped__ = S, this.__actions__ = [], this.__chain__ = !!T, this.__index__ = 0, this.__values__ = c;
      }
      ye.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        escape: Kc,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        evaluate: wi,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        interpolate: es,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        variable: "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        imports: {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          _: ye
        }
      }, ye.prototype = zm.prototype, ye.prototype.constructor = ye, pl.prototype = cu(zm.prototype), pl.prototype.constructor = pl;
      function ts(S) {
        this.__wrapped__ = S, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = Ne, this.__views__ = [];
      }
      function Qv() {
        var S = new ts(this.__wrapped__);
        return S.__actions__ = yl(this.__actions__), S.__dir__ = this.__dir__, S.__filtered__ = this.__filtered__, S.__iteratees__ = yl(this.__iteratees__), S.__takeCount__ = this.__takeCount__, S.__views__ = yl(this.__views__), S;
      }
      function Uh() {
        if (this.__filtered__) {
          var S = new ts(this);
          S.__dir__ = -1, S.__filtered__ = !0;
        } else
          S = this.clone(), S.__dir__ *= -1;
        return S;
      }
      function Vg() {
        var S = this.__wrapped__.value(), T = this.__dir__, F = Br(S), ee = T < 0, ge = F ? S.length : 0, De = Wm(0, ge, this.__views__), Qe = De.start, it = De.end, At = it - Qe, vn = ee ? it : Qe - 1, gn = this.__iteratees__, Nn = gn.length, ir = 0, Dr = Bi(At, this.__takeCount__);
        if (!F || !ee && ge == At && Dr == At)
          return Gg(S, this.__actions__);
        var io = [];
        e:
          for (; At-- && ir < Dr; ) {
            vn += T;
            for (var Bo = -1, eo = S[vn]; ++Bo < Nn; ) {
              var fs = gn[Bo], As = fs.iteratee, Lc = fs.type, xl = As(eo);
              if (Lc == Lt)
                eo = xl;
              else if (!xl) {
                if (Lc == sn)
                  continue e;
                break e;
              }
            }
            io[ir++] = eo;
          }
        return io;
      }
      ts.prototype = cu(zm.prototype), ts.prototype.constructor = ts;
      function Iu(S) {
        var T = -1, F = S == null ? 0 : S.length;
        for (this.clear(); ++T < F; ) {
          var ee = S[T];
          this.set(ee[0], ee[1]);
        }
      }
      function H() {
        this.__data__ = tl ? tl(null) : {}, this.size = 0;
      }
      function X(S) {
        var T = this.has(S) && delete this.__data__[S];
        return this.size -= T ? 1 : 0, T;
      }
      function fe(S) {
        var T = this.__data__;
        if (tl) {
          var F = T[S];
          return F === C ? c : F;
        }
        return ys.call(T, S) ? T[S] : c;
      }
      function Me(S) {
        var T = this.__data__;
        return tl ? T[S] !== c : ys.call(T, S);
      }
      function We(S, T) {
        var F = this.__data__;
        return this.size += this.has(S) ? 0 : 1, F[S] = tl && T === c ? C : T, this;
      }
      Iu.prototype.clear = H, Iu.prototype.delete = X, Iu.prototype.get = fe, Iu.prototype.has = Me, Iu.prototype.set = We;
      function Ut(S) {
        var T = -1, F = S == null ? 0 : S.length;
        for (this.clear(); ++T < F; ) {
          var ee = S[T];
          this.set(ee[0], ee[1]);
        }
      }
      function Wn() {
        this.__data__ = [], this.size = 0;
      }
      function xr(S) {
        var T = this.__data__, F = Qt(T, S);
        if (F < 0)
          return !1;
        var ee = T.length - 1;
        return F == ee ? T.pop() : ff.call(T, F, 1), --this.size, !0;
      }
      function wr(S) {
        var T = this.__data__, F = Qt(T, S);
        return F < 0 ? c : T[F][1];
      }
      function pr(S) {
        return Qt(this.__data__, S) > -1;
      }
      function Us(S, T) {
        var F = this.__data__, ee = Qt(F, S);
        return ee < 0 ? (++this.size, F.push([S, T])) : F[ee][1] = T, this;
      }
      Ut.prototype.clear = Wn, Ut.prototype.delete = xr, Ut.prototype.get = wr, Ut.prototype.has = pr, Ut.prototype.set = Us;
      function ra(S) {
        var T = -1, F = S == null ? 0 : S.length;
        for (this.clear(); ++T < F; ) {
          var ee = S[T];
          this.set(ee[0], ee[1]);
        }
      }
      function hl() {
        this.size = 0, this.__data__ = {
          hash: new Iu(),
          map: new (rd || Ut)(),
          string: new Iu()
        };
      }
      function Ld(S) {
        var T = lb(this, S).delete(S);
        return this.size -= T ? 1 : 0, T;
      }
      function Vi(S) {
        return lb(this, S).get(S);
      }
      function rw(S) {
        return lb(this, S).has(S);
      }
      function xs(S, T) {
        var F = lb(this, S), ee = F.size;
        return F.set(S, T), this.size += F.size == ee ? 0 : 1, this;
      }
      ra.prototype.clear = hl, ra.prototype.delete = Ld, ra.prototype.get = Vi, ra.prototype.has = rw, ra.prototype.set = xs;
      function jn(S) {
        var T = -1, F = S == null ? 0 : S.length;
        for (this.__data__ = new ra(); ++T < F; )
          this.add(S[T]);
      }
      function pf(S) {
        return this.__data__.set(S, C), this;
      }
      function Un(S) {
        return this.__data__.has(S);
      }
      jn.prototype.add = jn.prototype.push = pf, jn.prototype.has = Un;
      function Ui(S) {
        var T = this.__data__ = new Ut(S);
        this.size = T.size;
      }
      function B1() {
        this.__data__ = new Ut(), this.size = 0;
      }
      function hf(S) {
        var T = this.__data__, F = T.delete(S);
        return this.size = T.size, F;
      }
      function Ua(S) {
        return this.__data__.get(S);
      }
      function om(S) {
        return this.__data__.has(S);
      }
      function Ug(S, T) {
        var F = this.__data__;
        if (F instanceof Ut) {
          var ee = F.__data__;
          if (!rd || ee.length < d - 1)
            return ee.push([S, T]), this.size = ++F.size, this;
          F = this.__data__ = new ra(ee);
        }
        return F.set(S, T), this.size = F.size, this;
      }
      Ui.prototype.clear = B1, Ui.prototype.delete = hf, Ui.prototype.get = Ua, Ui.prototype.has = om, Ui.prototype.set = Ug;
      function xi(S, T) {
        var F = Br(S), ee = !F && ji(S), ge = !F && !ee && Ym(S), De = !F && !ee && !ge && gm(S), Qe = F || ee || ge || De, it = Qe ? is(S.length, qv) : [], At = it.length;
        for (var vn in S)
          (T || ys.call(S, vn)) && !(Qe && // Safari 9 has enumerable `arguments.length` in strict mode.
          (vn == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          ge && (vn == "offset" || vn == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          De && (vn == "buffer" || vn == "byteLength" || vn == "byteOffset") || // Skip index properties.
          Yp(vn, At))) && it.push(vn);
        return it;
      }
      function ad(S) {
        var T = S.length;
        return T ? S[bf(0, T - 1)] : c;
      }
      function Xv(S, T) {
        return hb(yl(S), Mo(T, 0, S.length));
      }
      function gf(S) {
        return hb(yl(S));
      }
      function Jv(S, T, F) {
        (F !== c && !Ga(S[T], F) || F === c && !(T in S)) && Mu(S, T, F);
      }
      function sm(S, T, F) {
        var ee = S[T];
        (!(ys.call(S, T) && Ga(ee, F)) || F === c && !(T in S)) && Mu(S, T, F);
      }
      function Qt(S, T) {
        for (var F = S.length; F--; )
          if (Ga(S[F][0], T))
            return F;
        return -1;
      }
      function H1(S, T, F, ee) {
        return Ts(S, function(ge, De, Qe) {
          T(ee, ge, F(ge), Qe);
        }), ee;
      }
      function am(S, T) {
        return S && zd(T, Fc(T), S);
      }
      function im(S, T) {
        return S && zd(T, bu(T), S);
      }
      function Mu(S, T, F) {
        T == "__proto__" && Fi ? Fi(S, T, {
          configurable: !0,
          enumerable: !0,
          value: F,
          writable: !0
        }) : S[T] = F;
      }
      function Ws(S, T) {
        for (var F = -1, ee = T.length, ge = Ft(ee), De = S == null; ++F < ee; )
          ge[F] = De ? c : $w(S, T[F]);
        return ge;
      }
      function Mo(S, T, F) {
        return S === S && (F !== c && (S = S <= F ? S : F), T !== c && (S = S >= T ? S : T)), S;
      }
      function ya(S, T, F, ee, ge, De) {
        var Qe, it = T & I, At = T & L, vn = T & Z;
        if (F && (Qe = ge ? F(S, ee, ge, De) : F(S)), Qe !== c)
          return Qe;
        if (!li(S))
          return S;
        var gn = Br(S);
        if (gn) {
          if (Qe = Yg(S), !it)
            return yl(S, Qe);
        } else {
          var Nn = Sl(S), ir = Nn == Jt || Nn == wo;
          if (Ym(S))
            return Vp(S, it);
          if (Nn == ke || Nn == cn || ir && !ge) {
            if (Qe = At || ir ? {} : xc(S), !it)
              return At ? dm(S, im(Qe, S)) : Um(S, am(Qe, S));
          } else {
            if (!Nr[Nn])
              return ge ? S : {};
            Qe = Hn(S, Nn, it);
          }
        }
        De || (De = new Ui());
        var Dr = De.get(S);
        if (Dr)
          return Dr;
        De.set(S, Qe), ux(S) ? S.forEach(function(eo) {
          Qe.add(ya(eo, T, F, eo, S, De));
        }) : Q2(S) && S.forEach(function(eo, fs) {
          Qe.set(fs, ya(eo, T, F, fs, S, De));
        });
        var io = vn ? At ? us : xf : At ? bu : Fc, Bo = gn ? c : io(S);
        return Ur(Bo || S, function(eo, fs) {
          Bo && (fs = eo, eo = S[fs]), sm(Qe, fs, ya(eo, T, F, fs, S, De));
        }), Qe;
      }
      function Dc(S) {
        var T = Fc(S);
        return function(F) {
          return ro(F, S, T);
        };
      }
      function ro(S, T, F) {
        var ee = F.length;
        if (S == null)
          return !ee;
        for (S = Xo(S); ee--; ) {
          var ge = F[ee], De = T[ge], Qe = S[ge];
          if (Qe === c && !(ge in S) || !De(Qe))
            return !1;
        }
        return !0;
      }
      function $p(S, T, F) {
        if (typeof S != "function")
          throw new $a(v);
        return ol(function() {
          S.apply(c, F);
        }, T);
      }
      function si(S, T, F, ee) {
        var ge = -1, De = Ds, Qe = !0, it = S.length, At = [], vn = T.length;
        if (!it)
          return At;
        F && (T = _a(T, ri(F))), ee ? (De = af, Qe = !1) : T.length >= d && (De = Vs, Qe = !1, T = new jn(T));
        e:
          for (; ++ge < it; ) {
            var gn = S[ge], Nn = F == null ? gn : F(gn);
            if (gn = ee || gn !== 0 ? gn : 0, Qe && Nn === Nn) {
              for (var ir = vn; ir--; )
                if (T[ir] === Nn)
                  continue e;
              At.push(gn);
            } else
              De(T, Nn, ee) || At.push(gn);
          }
        return At;
      }
      var Ts = jp(cd), Wg = jp(lu, !0);
      function Mt(S, T) {
        var F = !0;
        return Ts(S, function(ee, ge, De) {
          return F = !!T(ee, ge, De), F;
        }), F;
      }
      function $c(S, T, F) {
        for (var ee = -1, ge = S.length; ++ee < ge; ) {
          var De = S[ee], Qe = T(De);
          if (Qe != null && (it === c ? Qe === Qe && !Fa(Qe) : F(Qe, it)))
            var it = Qe, At = De;
        }
        return At;
      }
      function jg(S, T, F, ee) {
        var ge = S.length;
        for (F = Uo(F), F < 0 && (F = -F > ge ? 0 : ge + F), ee = ee === c || ee > ge ? ge : Uo(ee), ee < 0 && (ee += ge), ee = F > ee ? 0 : Nw(ee); F < ee; )
          S[F++] = T;
        return S;
      }
      function xo(S, T) {
        var F = [];
        return Ts(S, function(ee, ge, De) {
          T(ee, ge, De) && F.push(ee);
        }), F;
      }
      function ka(S, T, F, ee, ge) {
        var De = -1, Qe = S.length;
        for (F || (F = iw), ge || (ge = []); ++De < Qe; ) {
          var it = S[De];
          T > 0 && F(it) ? T > 1 ? ka(it, T - 1, F, ee, ge) : $d(ge, it) : ee || (ge[ge.length] = it);
        }
        return ge;
      }
      var eb = ow(), id = ow(!0);
      function cd(S, T) {
        return S && eb(S, T, Fc);
      }
      function lu(S, T) {
        return S && id(S, T, Fc);
      }
      function Wh(S, T) {
        return Xc(T, function(F) {
          return Qm(S[F]);
        });
      }
      function tc(S, T) {
        T = zp(T, S);
        for (var F = 0, ee = T.length; S != null && F < ee; )
          S = S[Bu(T[F++])];
        return F && F == ee ? S : c;
      }
      function Fo(S, T, F) {
        var ee = T(S);
        return Br(S) ? ee : $d(ee, F(S));
      }
      function ai(S) {
        return S == null ? S === c ? Bt : St : Ss && Ss in Xo(S) ? q1(S) : mb(S);
      }
      function cm(S, T) {
        return S > T;
      }
      function nc(S, T) {
        return S != null && ys.call(S, T);
      }
      function Ey(S, T) {
        return S != null && T in Xo(S);
      }
      function Ip(S, T, F) {
        return S >= Bi(T, F) && S < Ia(T, F);
      }
      function lm(S, T, F) {
        for (var ee = F ? af : Ds, ge = S[0].length, De = S.length, Qe = De, it = Ft(De), At = 1 / 0, vn = []; Qe--; ) {
          var gn = S[Qe];
          Qe && T && (gn = _a(gn, ri(T))), At = Bi(gn.length, At), it[Qe] = !F && (T || ge >= 120 && gn.length >= 120) ? new jn(Qe && gn) : c;
        }
        gn = S[0];
        var Nn = -1, ir = it[0];
        e:
          for (; ++Nn < ge && vn.length < At; ) {
            var Dr = gn[Nn], io = T ? T(Dr) : Dr;
            if (Dr = F || Dr !== 0 ? Dr : 0, !(ir ? Vs(ir, io) : ee(vn, io, F))) {
              for (Qe = De; --Qe; ) {
                var Bo = it[Qe];
                if (!(Bo ? Vs(Bo, io) : ee(S[Qe], io, F)))
                  continue e;
              }
              ir && ir.push(io), vn.push(Dr);
            }
          }
        return vn;
      }
      function nl(S, T, F, ee) {
        return cd(S, function(ge, De, Qe) {
          T(ee, F(ge), De, Qe);
        }), ee;
      }
      function ld(S, T, F) {
        T = zp(T, S), S = ZC(S, T);
        var ee = S == null ? S : S[Bu(Of(T))];
        return ee == null ? c : bs(ee, S, F);
      }
      function lt(S) {
        return Gi(S) && ai(S) == cn;
      }
      function gl(S) {
        return Gi(S) && ai(S) == gr;
      }
      function Fu(S) {
        return Gi(S) && ai(S) == qn;
      }
      function rl(S, T, F, ee, ge) {
        return S === T ? !0 : S == null || T == null || !Gi(S) && !Gi(T) ? S !== S && T !== T : vl(S, T, F, ee, rl, ge);
      }
      function vl(S, T, F, ee, ge, De) {
        var Qe = Br(S), it = Br(T), At = Qe ? He : Sl(S), vn = it ? He : Sl(T);
        At = At == cn ? ke : At, vn = vn == cn ? ke : vn;
        var gn = At == ke, Nn = vn == ke, ir = At == vn;
        if (ir && Ym(S)) {
          if (!Ym(T))
            return !1;
          Qe = !0, gn = !1;
        }
        if (ir && !gn)
          return De || (De = new Ui()), Qe || gm(S) ? Kg(S, T, F, ee, ge, De) : aw(S, T, At, F, ee, ge, De);
        if (!(F & ne)) {
          var Dr = gn && ys.call(S, "__wrapped__"), io = Nn && ys.call(T, "__wrapped__");
          if (Dr || io) {
            var Bo = Dr ? S.value() : S, eo = io ? T.value() : T;
            return De || (De = new Ui()), ge(Bo, eo, F, ee, De);
          }
        }
        return ir ? (De || (De = new Ui()), Gp(S, T, F, ee, ge, De)) : !1;
      }
      function vi(S) {
        return Gi(S) && Sl(S) == Ge;
      }
      function ii(S, T, F, ee) {
        var ge = F.length, De = ge, Qe = !ee;
        if (S == null)
          return !De;
        for (S = Xo(S); ge--; ) {
          var it = F[ge];
          if (Qe && it[2] ? it[1] !== S[it[0]] : !(it[0] in S))
            return !1;
        }
        for (; ++ge < De; ) {
          it = F[ge];
          var At = it[0], vn = S[At], gn = it[1];
          if (Qe && it[2]) {
            if (vn === c && !(At in S))
              return !1;
          } else {
            var Nn = new Ui();
            if (ee)
              var ir = ee(vn, gn, At, S, T, Nn);
            if (!(ir === c ? rl(gn, vn, ne | se, ee, Nn) : ir))
              return !1;
          }
        }
        return !0;
      }
      function Cy(S) {
        if (!li(S) || db(S))
          return !1;
        var T = Qm(S) ? Hh : Qu;
        return T.test(qm(S));
      }
      function bl(S) {
        return Gi(S) && ai(S) == ht;
      }
      function vf(S) {
        return Gi(S) && Sl(S) == bn;
      }
      function sr(S) {
        return Gi(S) && oh(S.length) && !!Lr[ai(S)];
      }
      function M(S) {
        return typeof S == "function" ? S : S == null ? hd : typeof S == "object" ? Br(S) ? tn(S[0], S[1]) : kt(S) : qw(S);
      }
      function W(S) {
        if (!Ud(S))
          return mf(S);
        var T = [];
        for (var F in Xo(S))
          ys.call(S, F) && F != "constructor" && T.push(F);
        return T;
      }
      function de(S) {
        if (!li(S))
          return GC(S);
        var T = Ud(S), F = [];
        for (var ee in S)
          ee == "constructor" && (T || !ys.call(S, ee)) || F.push(ee);
        return F;
      }
      function Ee(S, T) {
        return S < T;
      }
      function qe(S, T) {
        var F = -1, ee = Os(S) ? Ft(S.length) : [];
        return Ts(S, function(ge, De, Qe) {
          ee[++F] = T(ge, De, Qe);
        }), ee;
      }
      function kt(S) {
        var T = Kp(S);
        return T.length == 1 && T[0][2] ? fb(T[0][0], T[0][1]) : function(F) {
          return F === S || ii(F, S, T);
        };
      }
      function tn(S, T) {
        return Qp(S) && _f(T) ? fb(Bu(S), T) : function(F) {
          var ee = $w(F, S);
          return ee === c && ee === T ? Gr(F, S) : rl(T, ee, ne | se);
        };
      }
      function Sn(S, T, F, ee, ge) {
        S !== T && eb(T, function(De, Qe) {
          if (ge || (ge = new Ui()), li(De))
            Xn(S, T, Qe, F, Sn, ee, ge);
          else {
            var it = ee ? ee(Xp(S, Qe), De, Qe + "", S, T, ge) : c;
            it === c && (it = De), Jv(S, Qe, it);
          }
        }, bu);
      }
      function Xn(S, T, F, ee, ge, De, Qe) {
        var it = Xp(S, F), At = Xp(T, F), vn = Qe.get(At);
        if (vn) {
          Jv(S, F, vn);
          return;
        }
        var gn = De ? De(it, At, F + "", S, T, Qe) : c, Nn = gn === c;
        if (Nn) {
          var ir = Br(At), Dr = !ir && Ym(At), io = !ir && !Dr && gm(At);
          gn = At, ir || Dr || io ? Br(it) ? gn = it : qi(it) ? gn = yl(it) : Dr ? (Nn = !1, gn = Vp(At, !0)) : io ? (Nn = !1, gn = wf(At, !0)) : gn = [] : tg(At) || ji(At) ? (gn = it, ji(it) ? gn = p0(it) : (!li(it) || Qm(it)) && (gn = xc(At))) : Nn = !1;
        }
        Nn && (Qe.set(At, gn), ge(gn, At, ee, De, Qe), Qe.delete(At)), Jv(S, F, gn);
      }
      function Pr(S, T) {
        var F = S.length;
        if (F)
          return T += T < 0 ? F : 0, Yp(T, F) ? S[T] : c;
      }
      function la(S, T, F) {
        T.length ? T = _a(T, function(De) {
          return Br(De) ? function(Qe) {
            return tc(Qe, De.length === 1 ? De[0] : De);
          } : De;
        }) : T = [hd];
        var ee = -1;
        T = _a(T, ri(Wr()));
        var ge = qe(S, function(De, Qe, it) {
          var At = _a(T, function(vn) {
            return vn(De);
          });
          return { criteria: At, index: ++ee, value: De };
        });
        return Fl(ge, function(De, Qe) {
          return Ty(De, Qe, F);
        });
      }
      function Lo(S, T) {
        return _s(S, T, function(F, ee) {
          return Gr(S, ee);
        });
      }
      function _s(S, T, F) {
        for (var ee = -1, ge = T.length, De = {}; ++ee < ge; ) {
          var Qe = T[ee], it = tc(S, Qe);
          F(it, Qe) && Sa(De, zp(Qe, S), it);
        }
        return De;
      }
      function zl(S) {
        return function(T) {
          return tc(T, S);
        };
      }
      function Ic(S, T, F, ee) {
        var ge = ee ? jv : Pa, De = -1, Qe = T.length, it = S;
        for (S === T && (T = yl(T)), F && (it = _a(S, ri(F))); ++De < Qe; )
          for (var At = 0, vn = T[De], gn = F ? F(vn) : vn; (At = ge(it, gn, At, ee)) > -1; )
            it !== S && ff.call(it, At, 1), ff.call(S, At, 1);
        return S;
      }
      function uu(S, T) {
        for (var F = S ? T.length : 0, ee = F - 1; F--; ) {
          var ge = T[F];
          if (F == ee || ge !== De) {
            var De = ge;
            Yp(ge) ? ff.call(S, ge, 1) : ud(S, ge);
          }
        }
        return S;
      }
      function bf(S, T) {
        return S + Li(va() * (T - S + 1));
      }
      function Bd(S, T, F, ee) {
        for (var ge = -1, De = Ia(su((T - S) / (F || 1)), 0), Qe = Ft(De); De--; )
          Qe[ee ? De : ++ge] = S, S += F;
        return Qe;
      }
      function Mp(S, T) {
        var F = "";
        if (!S || T < 1 || T > at)
          return F;
        do
          T % 2 && (F += S), T = Li(T / 2), T && (S += S);
        while (T);
        return F;
      }
      function Ro(S, T) {
        return cw(jm(S, T, hd), S + "");
      }
      function Fp(S) {
        return ad(vm(S));
      }
      function qg(S, T) {
        var F = vm(S);
        return hb(F, Mo(T, 0, F.length));
      }
      function Sa(S, T, F, ee) {
        if (!li(S))
          return S;
        T = zp(T, S);
        for (var ge = -1, De = T.length, Qe = De - 1, it = S; it != null && ++ge < De; ) {
          var At = Bu(T[ge]), vn = F;
          if (At === "__proto__" || At === "constructor" || At === "prototype")
            return S;
          if (ge != Qe) {
            var gn = it[At];
            vn = ee ? ee(gn, At, it) : c, vn === c && (vn = li(gn) ? gn : Yp(T[ge + 1]) ? [] : {});
          }
          sm(it, At, vn), it = it[At];
        }
        return S;
      }
      var du = od ? function(S, T) {
        return od.set(S, T), S;
      } : hd, jh = Fi ? function(S, T) {
        return Fi(S, "toString", {
          configurable: !0,
          enumerable: !1,
          value: jy(T),
          writable: !0
        });
      } : hd;
      function Lp(S) {
        return hb(vm(S));
      }
      function qr(S, T, F) {
        var ee = -1, ge = S.length;
        T < 0 && (T = -T > ge ? 0 : ge + T), F = F > ge ? ge : F, F < 0 && (F += ge), ge = T > F ? 0 : F - T >>> 0, T >>>= 0;
        for (var De = Ft(ge); ++ee < ge; )
          De[ee] = S[ee + T];
        return De;
      }
      function oo(S, T) {
        var F;
        return Ts(S, function(ee, ge, De) {
          return F = T(ee, ge, De), !F;
        }), !!F;
      }
      function ci(S, T, F) {
        var ee = 0, ge = S == null ? ee : S.length;
        if (typeof T == "number" && T === T && ge <= Gt) {
          for (; ee < ge; ) {
            var De = ee + ge >>> 1, Qe = S[De];
            Qe !== null && !Fa(Qe) && (F ? Qe <= T : Qe < T) ? ee = De + 1 : ge = De;
          }
          return ge;
        }
        return rc(S, T, hd, F);
      }
      function rc(S, T, F, ee) {
        var ge = 0, De = S == null ? 0 : S.length;
        if (De === 0)
          return 0;
        T = F(T);
        for (var Qe = T !== T, it = T === null, At = Fa(T), vn = T === c; ge < De; ) {
          var gn = Li((ge + De) / 2), Nn = F(S[gn]), ir = Nn !== c, Dr = Nn === null, io = Nn === Nn, Bo = Fa(Nn);
          if (Qe)
            var eo = ee || io;
          else
            vn ? eo = io && (ee || ir) : it ? eo = io && ir && (ee || !Dr) : At ? eo = io && ir && !Dr && (ee || !Bo) : Dr || Bo ? eo = !1 : eo = ee ? Nn <= T : Nn < T;
          eo ? ge = gn + 1 : De = gn;
        }
        return Bi(De, vt);
      }
      function tb(S, T) {
        for (var F = -1, ee = S.length, ge = 0, De = []; ++F < ee; ) {
          var Qe = S[F], it = T ? T(Qe) : Qe;
          if (!F || !Ga(it, At)) {
            var At = it;
            De[ge++] = Qe === 0 ? 0 : Qe;
          }
        }
        return De;
      }
      function yf(S) {
        return typeof S == "number" ? S : Fa(S) ? st : +S;
      }
      function oa(S) {
        if (typeof S == "string")
          return S;
        if (Br(S))
          return _a(S, oa) + "";
        if (Fa(S))
          return sd ? sd.call(S) : "";
        var T = S + "";
        return T == "0" && 1 / S == -bt ? "-0" : T;
      }
      function fu(S, T, F) {
        var ee = -1, ge = Ds, De = S.length, Qe = !0, it = [], At = it;
        if (F)
          Qe = !1, ge = af;
        else if (De >= d) {
          var vn = T ? null : sw(S);
          if (vn)
            return Mm(vn);
          Qe = !1, ge = Vs, At = new jn();
        } else
          At = T ? [] : it;
        e:
          for (; ++ee < De; ) {
            var gn = S[ee], Nn = T ? T(gn) : gn;
            if (gn = F || gn !== 0 ? gn : 0, Qe && Nn === Nn) {
              for (var ir = At.length; ir--; )
                if (At[ir] === Nn)
                  continue e;
              T && At.push(Nn), it.push(gn);
            } else
              ge(At, Nn, F) || (At !== it && At.push(Nn), it.push(gn));
          }
        return it;
      }
      function ud(S, T) {
        return T = zp(T, S), S = ZC(S, T), S == null || delete S[Bu(Of(T))];
      }
      function Bp(S, T, F, ee) {
        return Sa(S, T, F(tc(S, T)), ee);
      }
      function Vm(S, T, F, ee) {
        for (var ge = S.length, De = ee ? ge : -1; (ee ? De-- : ++De < ge) && T(S[De], De, S); )
          ;
        return F ? qr(S, ee ? 0 : De, ee ? De + 1 : ge) : qr(S, ee ? De + 1 : 0, ee ? ge : De);
      }
      function Gg(S, T) {
        var F = S;
        return F instanceof ts && (F = F.value()), Oo(T, function(ee, ge) {
          return ge.func.apply(ge.thisArg, $d([ee], ge.args));
        }, F);
      }
      function um(S, T, F) {
        var ee = S.length;
        if (ee < 2)
          return ee ? fu(S[0]) : [];
        for (var ge = -1, De = Ft(ee); ++ge < ee; )
          for (var Qe = S[ge], it = -1; ++it < ee; )
            it != ge && (De[ge] = si(De[ge] || Qe, S[it], T, F));
        return fu(ka(De, 1), T, F);
      }
      function WC(S, T, F) {
        for (var ee = -1, ge = S.length, De = T.length, Qe = {}; ++ee < ge; ) {
          var it = ee < De ? T[ee] : c;
          F(Qe, S[ee], it);
        }
        return Qe;
      }
      function Hp(S) {
        return qi(S) ? S : [];
      }
      function xy(S) {
        return typeof S == "function" ? S : hd;
      }
      function zp(S, T) {
        return Br(S) ? S : Qp(S, T) ? [S] : pu(aa(S));
      }
      var Wa = Ro;
      function Hd(S, T, F) {
        var ee = S.length;
        return F = F === c ? ee : F, !T && F >= ee ? S : qr(S, T, F);
      }
      var Sf = Hg || function(S) {
        return as.clearTimeout(S);
      };
      function Vp(S, T) {
        if (T)
          return S.slice();
        var F = S.length, ee = wy ? wy(F) : new S.constructor(F);
        return S.copy(ee), ee;
      }
      function Up(S) {
        var T = new S.constructor(S.byteLength);
        return new Dp(T).set(new Dp(S)), T;
      }
      function Zg(S, T) {
        var F = T ? Up(S.buffer) : S.buffer;
        return new S.constructor(F, S.byteOffset, S.byteLength);
      }
      function Lu(S) {
        var T = new S.constructor(S.source, vc.exec(S));
        return T.lastIndex = S.lastIndex, T;
      }
      function Na(S) {
        return iu ? Xo(iu.call(S)) : {};
      }
      function wf(S, T) {
        var F = T ? Up(S.buffer) : S.buffer;
        return new S.constructor(F, S.byteOffset, S.length);
      }
      function z1(S, T) {
        if (S !== T) {
          var F = S !== c, ee = S === null, ge = S === S, De = Fa(S), Qe = T !== c, it = T === null, At = T === T, vn = Fa(T);
          if (!it && !vn && !De && S > T || De && Qe && At && !it && !vn || ee && Qe && At || !F && At || !ge)
            return 1;
          if (!ee && !De && !vn && S < T || vn && F && ge && !ee && !De || it && F && ge || !Qe && ge || !At)
            return -1;
        }
        return 0;
      }
      function Ty(S, T, F) {
        for (var ee = -1, ge = S.criteria, De = T.criteria, Qe = ge.length, it = F.length; ++ee < Qe; ) {
          var At = z1(ge[ee], De[ee]);
          if (At) {
            if (ee >= it)
              return At;
            var vn = F[ee];
            return At * (vn == "desc" ? -1 : 1);
          }
        }
        return S.index - T.index;
      }
      function _y(S, T, F, ee) {
        for (var ge = -1, De = S.length, Qe = F.length, it = -1, At = T.length, vn = Ia(De - Qe, 0), gn = Ft(At + vn), Nn = !ee; ++it < At; )
          gn[it] = T[it];
        for (; ++ge < Qe; )
          (Nn || ge < De) && (gn[F[ge]] = S[ge]);
        for (; vn--; )
          gn[it++] = S[ge++];
        return gn;
      }
      function Wp(S, T, F, ee) {
        for (var ge = -1, De = S.length, Qe = -1, it = F.length, At = -1, vn = T.length, gn = Ia(De - it, 0), Nn = Ft(gn + vn), ir = !ee; ++ge < gn; )
          Nn[ge] = S[ge];
        for (var Dr = ge; ++At < vn; )
          Nn[Dr + At] = T[At];
        for (; ++Qe < it; )
          (ir || ge < De) && (Nn[Dr + F[Qe]] = S[ge++]);
        return Nn;
      }
      function yl(S, T) {
        var F = -1, ee = S.length;
        for (T || (T = Ft(ee)); ++F < ee; )
          T[F] = S[F];
        return T;
      }
      function zd(S, T, F, ee) {
        var ge = !F;
        F || (F = {});
        for (var De = -1, Qe = T.length; ++De < Qe; ) {
          var it = T[De], At = ee ? ee(F[it], S[it], it, F, S) : c;
          At === c && (At = S[it]), ge ? Mu(F, it, At) : sm(F, it, At);
        }
        return F;
      }
      function Um(S, T) {
        return zd(S, Ay(S), T);
      }
      function dm(S, T) {
        return zd(S, qC(S), T);
      }
      function Vl(S, T) {
        return function(F, ee) {
          var ge = Br(F) ? Dd : H1, De = T ? T() : {};
          return ge(F, S, Wr(ee, 2), De);
        };
      }
      function Vd(S) {
        return Ro(function(T, F) {
          var ee = -1, ge = F.length, De = ge > 1 ? F[ge - 1] : c, Qe = ge > 2 ? F[2] : c;
          for (De = S.length > 3 && typeof De == "function" ? (ge--, De) : c, Qe && mu(F[0], F[1], Qe) && (De = ge < 3 ? c : De, ge = 1), T = Xo(T); ++ee < ge; ) {
            var it = F[ee];
            it && S(T, it, ee, De);
          }
          return T;
        });
      }
      function jp(S, T) {
        return function(F, ee) {
          if (F == null)
            return F;
          if (!Os(F))
            return S(F, ee);
          for (var ge = F.length, De = T ? ge : -1, Qe = Xo(F); (T ? De-- : ++De < ge) && ee(Qe[De], De, Qe) !== !1; )
            ;
          return F;
        };
      }
      function ow(S) {
        return function(T, F, ee) {
          for (var ge = -1, De = Xo(T), Qe = ee(T), it = Qe.length; it--; ) {
            var At = Qe[S ? it : ++ge];
            if (F(De[At], At, De) === !1)
              break;
          }
          return T;
        };
      }
      function V1(S, T, F) {
        var ee = T & Q, ge = rb(S);
        function De() {
          var Qe = this && this !== as && this instanceof De ? ge : S;
          return Qe.apply(ee ? F : this, arguments);
        }
        return De;
      }
      function nb(S) {
        return function(T) {
          T = aa(T);
          var F = gi(T) ? Ec(T) : c, ee = F ? F[0] : T.charAt(0), ge = F ? Hd(F, 1).join("") : T.slice(1);
          return ee[S]() + ge;
        };
      }
      function qp(S) {
        return function(T) {
          return Oo(E0(Db(T).replace(Tp, "")), S, "");
        };
      }
      function rb(S) {
        return function() {
          var T = arguments;
          switch (T.length) {
            case 0:
              return new S();
            case 1:
              return new S(T[0]);
            case 2:
              return new S(T[0], T[1]);
            case 3:
              return new S(T[0], T[1], T[2]);
            case 4:
              return new S(T[0], T[1], T[2], T[3]);
            case 5:
              return new S(T[0], T[1], T[2], T[3], T[4]);
            case 6:
              return new S(T[0], T[1], T[2], T[3], T[4], T[5]);
            case 7:
              return new S(T[0], T[1], T[2], T[3], T[4], T[5], T[6]);
          }
          var F = cu(S.prototype), ee = S.apply(F, T);
          return li(ee) ? ee : F;
        };
      }
      function U1(S, T, F) {
        var ee = rb(S);
        function ge() {
          for (var De = arguments.length, Qe = Ft(De), it = De, At = Ul(ge); it--; )
            Qe[it] = arguments[it];
          var vn = De < 3 && Qe[0] !== At && Qe[De - 1] !== At ? [] : wc(Qe, At);
          if (De -= vn.length, De < F)
            return j1(
              S,
              T,
              Jr,
              ge.placeholder,
              c,
              Qe,
              vn,
              c,
              c,
              F - De
            );
          var gn = this && this !== as && this instanceof ge ? ee : S;
          return bs(gn, this, Qe);
        }
        return ge;
      }
      function ob(S) {
        return function(T, F, ee) {
          var ge = Xo(T);
          if (!Os(T)) {
            var De = Wr(F, 3);
            T = Fc(T), F = function(it) {
              return De(ge[it], it, ge);
            };
          }
          var Qe = S(T, F, ee);
          return Qe > -1 ? ge[De ? T[Qe] : Qe] : c;
        };
      }
      function sb(S) {
        return Zp(function(T) {
          var F = T.length, ee = F, ge = pl.prototype.thru;
          for (S && T.reverse(); ee--; ) {
            var De = T[ee];
            if (typeof De != "function")
              throw new $a(v);
            if (ge && !Qe && cb(De) == "wrapper")
              var Qe = new pl([], !0);
          }
          for (ee = Qe ? ee : F; ++ee < F; ) {
            De = T[ee];
            var it = cb(De), At = it == "wrapper" ? Tf(De) : c;
            At && Qg(At[0]) && At[1] == (q | G | we | Te) && !At[4].length && At[9] == 1 ? Qe = Qe[cb(At[0])].apply(Qe, At[3]) : Qe = De.length == 1 && Qg(De) ? Qe[it]() : Qe.thru(De);
          }
          return function() {
            var vn = arguments, gn = vn[0];
            if (Qe && vn.length == 1 && Br(gn))
              return Qe.plant(gn).value();
            for (var Nn = 0, ir = F ? T[Nn].apply(this, vn) : gn; ++Nn < F; )
              ir = T[Nn].call(this, ir);
            return ir;
          };
        });
      }
      function Jr(S, T, F, ee, ge, De, Qe, it, At, vn) {
        var gn = T & q, Nn = T & Q, ir = T & he, Dr = T & (G | me), io = T & Le, Bo = ir ? c : rb(S);
        function eo() {
          for (var fs = arguments.length, As = Ft(fs), Lc = fs; Lc--; )
            As[Lc] = arguments[Lc];
          if (Dr)
            var xl = Ul(eo), Zd = nm(As, xl);
          if (ee && (As = _y(As, ee, ge, Dr)), De && (As = Wp(As, De, Qe, Dr)), fs -= Zd, Dr && fs < vn) {
            var sc = wc(As, xl);
            return j1(
              S,
              T,
              Jr,
              eo.placeholder,
              F,
              As,
              sc,
              it,
              At,
              vn - fs
            );
          }
          var Kd = Nn ? F : this, Ms = ir ? Kd[S] : S;
          return fs = As.length, it ? As = pb(As, it) : io && fs > 1 && As.reverse(), gn && At < fs && (As.length = At), this && this !== as && this instanceof eo && (Ms = Bo || rb(Ms)), Ms.apply(Kd, As);
        }
        return eo;
      }
      function nr(S, T) {
        return function(F, ee) {
          return nl(F, S, T(ee), {});
        };
      }
      function Ef(S, T) {
        return function(F, ee) {
          var ge;
          if (F === c && ee === c)
            return T;
          if (F !== c && (ge = F), ee !== c) {
            if (ge === c)
              return ee;
            typeof F == "string" || typeof ee == "string" ? (F = oa(F), ee = oa(ee)) : (F = yf(F), ee = yf(ee)), ge = S(F, ee);
          }
          return ge;
        };
      }
      function ab(S) {
        return Zp(function(T) {
          return T = _a(T, ri(Wr())), Ro(function(F) {
            var ee = this;
            return S(T, function(ge) {
              return bs(ge, ee, F);
            });
          });
        });
      }
      function qh(S, T) {
        T = T === c ? " " : oa(T);
        var F = T.length;
        if (F < 2)
          return F ? Mp(T, S) : T;
        var ee = Mp(T, su(S / lf(T)));
        return gi(T) ? Hd(Ec(ee), 0, S).join("") : ee.slice(0, S);
      }
      function M2(S, T, F, ee) {
        var ge = T & Q, De = rb(S);
        function Qe() {
          for (var it = -1, At = arguments.length, vn = -1, gn = ee.length, Nn = Ft(gn + At), ir = this && this !== as && this instanceof Qe ? De : S; ++vn < gn; )
            Nn[vn] = ee[vn];
          for (; At--; )
            Nn[vn++] = arguments[++it];
          return bs(ir, ge ? F : this, Nn);
        }
        return Qe;
      }
      function W1(S) {
        return function(T, F, ee) {
          return ee && typeof ee != "number" && mu(T, F, ee) && (F = ee = c), T = Jm(T), F === c ? (F = T, T = 0) : F = Jm(F), ee = ee === c ? T < F ? 1 : -1 : Jm(ee), Bd(T, F, ee, S);
        };
      }
      function ls(S) {
        return function(T, F) {
          return typeof T == "string" && typeof F == "string" || (T = pd(T), F = pd(F)), S(T, F);
        };
      }
      function j1(S, T, F, ee, ge, De, Qe, it, At, vn) {
        var gn = T & G, Nn = gn ? Qe : c, ir = gn ? c : Qe, Dr = gn ? De : c, io = gn ? c : De;
        T |= gn ? we : be, T &= ~(gn ? be : we), T & ue || (T &= ~(Q | he));
        var Bo = [
          S,
          T,
          ge,
          Dr,
          Nn,
          io,
          ir,
          it,
          At,
          vn
        ], eo = F.apply(c, Bo);
        return Qg(S) && jd(eo, Bo), eo.placeholder = ee, lw(eo, S, T);
      }
      function Oy(S) {
        var T = Qo[S];
        return function(F, ee) {
          if (F = pd(F), ee = ee == null ? 0 : Bi(Uo(ee), 292), ee && Rr(F)) {
            var ge = (aa(F) + "e").split("e"), De = T(ge[0] + "e" + (+ge[1] + ee));
            return ge = (aa(De) + "e").split("e"), +(ge[0] + "e" + (+ge[1] - ee));
          }
          return T(F);
        };
      }
      var sw = $s && 1 / Mm(new $s([, -0]))[1] == bt ? function(S) {
        return new $s(S);
      } : jw;
      function Pt(S) {
        return function(T) {
          var F = Sl(T);
          return F == Ge ? nd(T) : F == bn ? Id(T) : ru(T, S(T));
        };
      }
      function Cf(S, T, F, ee, ge, De, Qe, it) {
        var At = T & he;
        if (!At && typeof S != "function")
          throw new $a(v);
        var vn = ee ? ee.length : 0;
        if (vn || (T &= ~(we | be), ee = ge = c), Qe = Qe === c ? Qe : Ia(Uo(Qe), 0), it = it === c ? it : Uo(it), vn -= ge ? ge.length : 0, T & be) {
          var gn = ee, Nn = ge;
          ee = ge = c;
        }
        var ir = At ? c : Tf(S), Dr = [
          S,
          T,
          F,
          ee,
          ge,
          gn,
          Nn,
          De,
          Qe,
          it
        ];
        if (ir && K1(Dr, ir), S = Dr[0], T = Dr[1], F = Dr[2], ee = Dr[3], ge = Dr[4], it = Dr[9] = Dr[9] === c ? At ? 0 : S.length : Ia(Dr[9] - vn, 0), !it && T & (G | me) && (T &= ~(G | me)), !T || T == Q)
          var io = V1(S, T, F);
        else
          T == G || T == me ? io = U1(S, T, it) : (T == we || T == (Q | we)) && !ge.length ? io = M2(S, T, F, ee) : io = Jr.apply(c, Dr);
        var Bo = ir ? du : jd;
        return lw(Bo(io, Dr), S, T);
      }
      function jC(S, T, F, ee) {
        return S === c || Ga(S, oi[F]) && !ys.call(ee, F) ? T : S;
      }
      function ib(S, T, F, ee, ge, De) {
        return li(S) && li(T) && (De.set(T, S), Sn(S, T, c, ib, De), De.delete(T)), S;
      }
      function F2(S) {
        return tg(S) ? c : S;
      }
      function Kg(S, T, F, ee, ge, De) {
        var Qe = F & ne, it = S.length, At = T.length;
        if (it != At && !(Qe && At > it))
          return !1;
        var vn = De.get(S), gn = De.get(T);
        if (vn && gn)
          return vn == T && gn == S;
        var Nn = -1, ir = !0, Dr = F & se ? new jn() : c;
        for (De.set(S, T), De.set(T, S); ++Nn < it; ) {
          var io = S[Nn], Bo = T[Nn];
          if (ee)
            var eo = Qe ? ee(Bo, io, Nn, T, S, De) : ee(io, Bo, Nn, S, T, De);
          if (eo !== c) {
            if (eo)
              continue;
            ir = !1;
            break;
          }
          if (Dr) {
            if (!Ru(T, function(fs, As) {
              if (!Vs(Dr, As) && (io === fs || ge(io, fs, F, ee, De)))
                return Dr.push(As);
            })) {
              ir = !1;
              break;
            }
          } else if (!(io === Bo || ge(io, Bo, F, ee, De))) {
            ir = !1;
            break;
          }
        }
        return De.delete(S), De.delete(T), ir;
      }
      function aw(S, T, F, ee, ge, De, Qe) {
        switch (F) {
          case Vr:
            if (S.byteLength != T.byteLength || S.byteOffset != T.byteOffset)
              return !1;
            S = S.buffer, T = T.buffer;
          case gr:
            return !(S.byteLength != T.byteLength || !De(new Dp(S), new Dp(T)));
          case oe:
          case qn:
          case qt:
            return Ga(+S, +T);
          case Zt:
            return S.name == T.name && S.message == T.message;
          case ht:
          case Ye:
            return S == T + "";
          case Ge:
            var it = nd;
          case bn:
            var At = ee & ne;
            if (it || (it = Mm), S.size != T.size && !At)
              return !1;
            var vn = Qe.get(S);
            if (vn)
              return vn == T;
            ee |= se, Qe.set(S, T);
            var gn = Kg(it(S), it(T), ee, ge, De, Qe);
            return Qe.delete(S), gn;
          case nn:
            if (iu)
              return iu.call(S) == iu.call(T);
        }
        return !1;
      }
      function Gp(S, T, F, ee, ge, De) {
        var Qe = F & ne, it = xf(S), At = it.length, vn = xf(T), gn = vn.length;
        if (At != gn && !Qe)
          return !1;
        for (var Nn = At; Nn--; ) {
          var ir = it[Nn];
          if (!(Qe ? ir in T : ys.call(T, ir)))
            return !1;
        }
        var Dr = De.get(S), io = De.get(T);
        if (Dr && io)
          return Dr == T && io == S;
        var Bo = !0;
        De.set(S, T), De.set(T, S);
        for (var eo = Qe; ++Nn < At; ) {
          ir = it[Nn];
          var fs = S[ir], As = T[ir];
          if (ee)
            var Lc = Qe ? ee(As, fs, ir, T, S, De) : ee(fs, As, ir, S, T, De);
          if (!(Lc === c ? fs === As || ge(fs, As, F, ee, De) : Lc)) {
            Bo = !1;
            break;
          }
          eo || (eo = ir == "constructor");
        }
        if (Bo && !eo) {
          var xl = S.constructor, Zd = T.constructor;
          xl != Zd && "constructor" in S && "constructor" in T && !(typeof xl == "function" && xl instanceof xl && typeof Zd == "function" && Zd instanceof Zd) && (Bo = !1);
        }
        return De.delete(S), De.delete(T), Bo;
      }
      function Zp(S) {
        return cw(jm(S, c, mw), S + "");
      }
      function xf(S) {
        return Fo(S, Fc, Ay);
      }
      function us(S) {
        return Fo(S, bu, qC);
      }
      var Tf = od ? function(S) {
        return od.get(S);
      } : jw;
      function cb(S) {
        for (var T = S.name + "", F = Ys[T], ee = ys.call(Ys, T) ? F.length : 0; ee--; ) {
          var ge = F[ee], De = ge.func;
          if (De == null || De == S)
            return ge.name;
        }
        return T;
      }
      function Ul(S) {
        var T = ys.call(ye, "placeholder") ? ye : S;
        return T.placeholder;
      }
      function Wr() {
        var S = ye.iteratee || og;
        return S = S === og ? M : S, arguments.length ? S(arguments[0], arguments[1]) : S;
      }
      function lb(S, T) {
        var F = S.__data__;
        return ub(T) ? F[typeof T == "string" ? "string" : "hash"] : F.map;
      }
      function Kp(S) {
        for (var T = Fc(S), F = T.length; F--; ) {
          var ee = T[F], ge = S[ee];
          T[F] = [ee, ge, _f(ge)];
        }
        return T;
      }
      function Gh(S, T) {
        var F = kp(S, T);
        return Cy(F) ? F : c;
      }
      function q1(S) {
        var T = ys.call(S, Ss), F = S[Ss];
        try {
          S[Ss] = c;
          var ee = !0;
        } catch {
        }
        var ge = Bm.call(S);
        return ee && (T ? S[Ss] = F : delete S[Ss]), ge;
      }
      var Ay = au ? function(S) {
        return S == null ? [] : (S = Xo(S), Xc(au(S), function(T) {
          return df.call(S, T);
        }));
      } : ih, qC = au ? function(S) {
        for (var T = []; S; )
          $d(T, Ay(S)), S = Hm(S);
        return T;
      } : ih, Sl = ai;
      (Aa && Sl(new Aa(new ArrayBuffer(1))) != Vr || rd && Sl(new rd()) != Ge || Fd && Sl(Fd.resolve()) != Ct || $s && Sl(new $s()) != bn || ba && Sl(new ba()) != $n) && (Sl = function(S) {
        var T = ai(S), F = T == ke ? S.constructor : c, ee = F ? qm(F) : "";
        if (ee)
          switch (ee) {
            case zg:
              return Vr;
            case Yv:
              return Ge;
            case Vo:
              return Ct;
            case $u:
              return bn;
            case mo:
              return $n;
          }
        return T;
      });
      function Wm(S, T, F) {
        for (var ee = -1, ge = F.length; ++ee < ge; ) {
          var De = F[ee], Qe = De.size;
          switch (De.type) {
            case "drop":
              S += Qe;
              break;
            case "dropRight":
              T -= Qe;
              break;
            case "take":
              T = Bi(T, S + Qe);
              break;
            case "takeRight":
              S = Ia(S, T - Qe);
              break;
          }
        }
        return { start: S, end: T };
      }
      function Vk(S) {
        var T = S.match(Qa);
        return T ? T[1].split(Xa) : [];
      }
      function G1(S, T, F) {
        T = zp(T, S);
        for (var ee = -1, ge = T.length, De = !1; ++ee < ge; ) {
          var Qe = Bu(T[ee]);
          if (!(De = S != null && F(S, Qe)))
            break;
          S = S[Qe];
        }
        return De || ++ee != ge ? De : (ge = S == null ? 0 : S.length, !!ge && oh(ge) && Yp(Qe, ge) && (Br(S) || ji(S)));
      }
      function Yg(S) {
        var T = S.length, F = new S.constructor(T);
        return T && typeof S[0] == "string" && ys.call(S, "index") && (F.index = S.index, F.input = S.input), F;
      }
      function xc(S) {
        return typeof S.constructor == "function" && !Ud(S) ? cu(Hm(S)) : {};
      }
      function Hn(S, T, F) {
        var ee = S.constructor;
        switch (T) {
          case gr:
            return Up(S);
          case oe:
          case qn:
            return new ee(+S);
          case Vr:
            return Zg(S, F);
          case Xr:
          case pc:
          case Eo:
          case uo:
          case Es:
          case br:
          case hs:
          case Ps:
          case qo:
            return wf(S, F);
          case Ge:
            return new ee();
          case qt:
          case Ye:
            return new ee(S);
          case ht:
            return Lu(S);
          case bn:
            return new ee();
          case nn:
            return Na(S);
        }
      }
      function L2(S, T) {
        var F = T.length;
        if (!F)
          return S;
        var ee = F - 1;
        return T[ee] = (F > 1 ? "& " : "") + T[ee], T = T.join(F > 2 ? ", " : " "), S.replace(Xf, `{
/* [wrapped with ` + T + `] */
`);
      }
      function iw(S) {
        return Br(S) || ji(S) || !!(rm && S && S[rm]);
      }
      function Yp(S, T) {
        var F = typeof S;
        return T = T ?? at, !!T && (F == "number" || F != "symbol" && of.test(S)) && S > -1 && S % 1 == 0 && S < T;
      }
      function mu(S, T, F) {
        if (!li(F))
          return !1;
        var ee = typeof T;
        return (ee == "number" ? Os(F) && Yp(T, F.length) : ee == "string" && T in F) ? Ga(F[T], S) : !1;
      }
      function Qp(S, T) {
        if (Br(S))
          return !1;
        var F = typeof S;
        return F == "number" || F == "symbol" || F == "boolean" || S == null || Fa(S) ? !0 : Xl.test(S) || !gc.test(S) || T != null && S in Xo(T);
      }
      function ub(S) {
        var T = typeof S;
        return T == "string" || T == "number" || T == "symbol" || T == "boolean" ? S !== "__proto__" : S === null;
      }
      function Qg(S) {
        var T = cb(S), F = ye[T];
        if (typeof F != "function" || !(T in ts.prototype))
          return !1;
        if (S === F)
          return !0;
        var ee = Tf(F);
        return !!ee && S === ee[0];
      }
      function db(S) {
        return !!ec && ec in S;
      }
      var Z1 = ga ? Qm : uv;
      function Ud(S) {
        var T = S && S.constructor, F = typeof T == "function" && T.prototype || oi;
        return S === F;
      }
      function _f(S) {
        return S === S && !li(S);
      }
      function fb(S, T) {
        return function(F) {
          return F == null ? !1 : F[S] === T && (T !== c || S in Xo(F));
        };
      }
      function Wd(S) {
        var T = qd(S, function(ee) {
          return F.size === O && F.clear(), ee;
        }), F = T.cache;
        return T;
      }
      function K1(S, T) {
        var F = S[1], ee = T[1], ge = F | ee, De = ge < (Q | he | q), Qe = ee == q && F == G || ee == q && F == Te && S[7].length <= T[8] || ee == (q | Te) && T[7].length <= T[8] && F == G;
        if (!(De || Qe))
          return S;
        ee & Q && (S[2] = T[2], ge |= F & Q ? 0 : ue);
        var it = T[3];
        if (it) {
          var At = S[3];
          S[3] = At ? _y(At, it, T[4]) : it, S[4] = At ? wc(S[3], R) : T[4];
        }
        return it = T[5], it && (At = S[5], S[5] = At ? Wp(At, it, T[6]) : it, S[6] = At ? wc(S[5], R) : T[6]), it = T[7], it && (S[7] = it), ee & q && (S[8] = S[8] == null ? T[8] : Bi(S[8], T[8])), S[9] == null && (S[9] = T[9]), S[0] = T[0], S[1] = ge, S;
      }
      function GC(S) {
        var T = [];
        if (S != null)
          for (var F in Xo(S))
            T.push(F);
        return T;
      }
      function mb(S) {
        return Bm.call(S);
      }
      function jm(S, T, F) {
        return T = Ia(T === c ? S.length - 1 : T, 0), function() {
          for (var ee = arguments, ge = -1, De = Ia(ee.length - T, 0), Qe = Ft(De); ++ge < De; )
            Qe[ge] = ee[T + ge];
          ge = -1;
          for (var it = Ft(T + 1); ++ge < T; )
            it[ge] = ee[ge];
          return it[T] = F(Qe), bs(S, this, it);
        };
      }
      function ZC(S, T) {
        return T.length < 2 ? S : tc(S, qr(T, 0, -1));
      }
      function pb(S, T) {
        for (var F = S.length, ee = Bi(T.length, F), ge = yl(S); ee--; ) {
          var De = T[ee];
          S[ee] = Yp(De, F) ? ge[De] : c;
        }
        return S;
      }
      function Xp(S, T) {
        if (!(T === "constructor" && typeof S[T] == "function") && T != "__proto__")
          return S[T];
      }
      var jd = uw(du), ol = Ci || function(S, T) {
        return as.setTimeout(S, T);
      }, cw = uw(jh);
      function lw(S, T, F) {
        var ee = T + "";
        return cw(S, L2(ee, Y1(Vk(ee), F)));
      }
      function uw(S) {
        var T = 0, F = 0;
        return function() {
          var ee = Kv(), ge = pt - (ee - F);
          if (F = ee, ge > 0) {
            if (++T >= Ce)
              return arguments[0];
          } else
            T = 0;
          return S.apply(c, arguments);
        };
      }
      function hb(S, T) {
        var F = -1, ee = S.length, ge = ee - 1;
        for (T = T === c ? ee : T; ++F < T; ) {
          var De = bf(F, ge), Qe = S[De];
          S[De] = S[F], S[F] = Qe;
        }
        return S.length = T, S;
      }
      var pu = Wd(function(S) {
        var T = [];
        return S.charCodeAt(0) === 46 && T.push(""), S.replace(gs, function(F, ee, ge, De) {
          T.push(ge ? De.replace(Sp, "$1") : ee || F);
        }), T;
      });
      function Bu(S) {
        if (typeof S == "string" || Fa(S))
          return S;
        var T = S + "";
        return T == "0" && 1 / S == -bt ? "-0" : T;
      }
      function qm(S) {
        if (S != null) {
          try {
            return Du.call(S);
          } catch {
          }
          try {
            return S + "";
          } catch {
          }
        }
        return "";
      }
      function Y1(S, T) {
        return Ur(xt, function(F) {
          var ee = "_." + F[0];
          T & F[1] && !Ds(S, ee) && S.push(ee);
        }), S.sort();
      }
      function KC(S) {
        if (S instanceof ts)
          return S.clone();
        var T = new pl(S.__wrapped__, S.__chain__);
        return T.__actions__ = yl(S.__actions__), T.__index__ = S.__index__, T.__values__ = S.__values__, T;
      }
      function YC(S, T, F) {
        (F ? mu(S, T, F) : T === c) ? T = 1 : T = Ia(Uo(T), 0);
        var ee = S == null ? 0 : S.length;
        if (!ee || T < 1)
          return [];
        for (var ge = 0, De = 0, Qe = Ft(su(ee / T)); ge < ee; )
          Qe[De++] = qr(S, ge, ge += T);
        return Qe;
      }
      function dw(S) {
        for (var T = -1, F = S == null ? 0 : S.length, ee = 0, ge = []; ++T < F; ) {
          var De = S[T];
          De && (ge[ee++] = De);
        }
        return ge;
      }
      function gb() {
        var S = arguments.length;
        if (!S)
          return [];
        for (var T = Ft(S - 1), F = arguments[0], ee = S; ee--; )
          T[ee - 1] = arguments[ee];
        return $d(Br(F) ? yl(F) : [F], ka(T, 1));
      }
      var vb = Ro(function(S, T) {
        return qi(S) ? si(S, ka(T, 1, qi, !0)) : [];
      }), Q1 = Ro(function(S, T) {
        var F = Of(T);
        return qi(F) && (F = c), qi(S) ? si(S, ka(T, 1, qi, !0), Wr(F, 2)) : [];
      }), B2 = Ro(function(S, T) {
        var F = Of(T);
        return qi(F) && (F = c), qi(S) ? si(S, ka(T, 1, qi, !0), c, F) : [];
      });
      function X1(S, T, F) {
        var ee = S == null ? 0 : S.length;
        return ee ? (T = F || T === c ? 1 : Uo(T), qr(S, T < 0 ? 0 : T, ee)) : [];
      }
      function bb(S, T, F) {
        var ee = S == null ? 0 : S.length;
        return ee ? (T = F || T === c ? 1 : Uo(T), T = ee - T, qr(S, 0, T < 0 ? 0 : T)) : [];
      }
      function H2(S, T) {
        return S && S.length ? Vm(S, Wr(T, 3), !0, !0) : [];
      }
      function ky(S, T) {
        return S && S.length ? Vm(S, Wr(T, 3), !0) : [];
      }
      function fw(S, T, F, ee) {
        var ge = S == null ? 0 : S.length;
        return ge ? (F && typeof F != "number" && mu(S, T, F) && (F = 0, ee = ge), jg(S, T, F, ee)) : [];
      }
      function hu(S, T, F) {
        var ee = S == null ? 0 : S.length;
        if (!ee)
          return -1;
        var ge = F == null ? 0 : Uo(F);
        return ge < 0 && (ge = Ia(ee + ge, 0)), Oa(S, Wr(T, 3), ge);
      }
      function Ny(S, T, F) {
        var ee = S == null ? 0 : S.length;
        if (!ee)
          return -1;
        var ge = ee - 1;
        return F !== c && (ge = Uo(F), ge = F < 0 ? Ia(ee + ge, 0) : Bi(ge, ee - 1)), Oa(S, Wr(T, 3), ge, !0);
      }
      function mw(S) {
        var T = S == null ? 0 : S.length;
        return T ? ka(S, 1) : [];
      }
      function J1(S) {
        var T = S == null ? 0 : S.length;
        return T ? ka(S, bt) : [];
      }
      function Uk(S, T) {
        var F = S == null ? 0 : S.length;
        return F ? (T = T === c ? 1 : Uo(T), ka(S, T)) : [];
      }
      function e0(S) {
        for (var T = -1, F = S == null ? 0 : S.length, ee = {}; ++T < F; ) {
          var ge = S[T];
          ee[ge[0]] = ge[1];
        }
        return ee;
      }
      function Jp(S) {
        return S && S.length ? S[0] : c;
      }
      function Gm(S, T, F) {
        var ee = S == null ? 0 : S.length;
        if (!ee)
          return -1;
        var ge = F == null ? 0 : Uo(F);
        return ge < 0 && (ge = Ia(ee + ge, 0)), Pa(S, T, ge);
      }
      function pw(S) {
        var T = S == null ? 0 : S.length;
        return T ? qr(S, 0, -1) : [];
      }
      var yb = Ro(function(S) {
        var T = _a(S, Hp);
        return T.length && T[0] === S[0] ? lm(T) : [];
      }), t0 = Ro(function(S) {
        var T = Of(S), F = _a(S, Hp);
        return T === Of(F) ? T = c : F.pop(), F.length && F[0] === S[0] ? lm(F, Wr(T, 2)) : [];
      }), QC = Ro(function(S) {
        var T = Of(S), F = _a(S, Hp);
        return T = typeof T == "function" ? T : c, T && F.pop(), F.length && F[0] === S[0] ? lm(F, c, T) : [];
      });
      function Is(S, T) {
        return S == null ? "" : el.call(S, T);
      }
      function Of(S) {
        var T = S == null ? 0 : S.length;
        return T ? S[T - 1] : c;
      }
      function ja(S, T, F) {
        var ee = S == null ? 0 : S.length;
        if (!ee)
          return -1;
        var ge = ee;
        return F !== c && (ge = Uo(F), ge = ge < 0 ? Ia(ee + ge, 0) : Bi(ge, ee - 1)), T === T ? Mg(S, T, ge) : Oa(S, zs, ge, !0);
      }
      function XC(S, T) {
        return S && S.length ? Pr(S, Uo(T)) : c;
      }
      var ua = Ro(Xg);
      function Xg(S, T) {
        return S && S.length && T && T.length ? Ic(S, T) : S;
      }
      function Ti(S, T, F) {
        return S && S.length && T && T.length ? Ic(S, T, Wr(F, 2)) : S;
      }
      function wa(S, T, F) {
        return S && S.length && T && T.length ? Ic(S, T, c, F) : S;
      }
      var dd = Zp(function(S, T) {
        var F = S == null ? 0 : S.length, ee = Ws(S, T);
        return uu(S, _a(T, function(ge) {
          return Yp(ge, F) ? +ge : ge;
        }).sort(z1)), ee;
      });
      function hw(S, T) {
        var F = [];
        if (!(S && S.length))
          return F;
        var ee = -1, ge = [], De = S.length;
        for (T = Wr(T, 3); ++ee < De; ) {
          var Qe = S[ee];
          T(Qe, ee, S) && (F.push(Qe), ge.push(ee));
        }
        return uu(S, ge), F;
      }
      function oc(S) {
        return S == null ? S : ml.call(S);
      }
      function Ry(S, T, F) {
        var ee = S == null ? 0 : S.length;
        return ee ? (F && typeof F != "number" && mu(S, T, F) ? (T = 0, F = ee) : (T = T == null ? 0 : Uo(T), F = F === c ? ee : Uo(F)), qr(S, T, F)) : [];
      }
      function Sb(S, T) {
        return ci(S, T);
      }
      function Zm(S, T, F) {
        return rc(S, T, Wr(F, 2));
      }
      function wb(S, T) {
        var F = S == null ? 0 : S.length;
        if (F) {
          var ee = ci(S, T);
          if (ee < F && Ga(S[ee], T))
            return ee;
        }
        return -1;
      }
      function Zh(S, T) {
        return ci(S, T, !0);
      }
      function eh(S, T, F) {
        return rc(S, T, Wr(F, 2), !0);
      }
      function z2(S, T) {
        var F = S == null ? 0 : S.length;
        if (F) {
          var ee = ci(S, T, !0) - 1;
          if (Ga(S[ee], T))
            return ee;
        }
        return -1;
      }
      function JC(S) {
        return S && S.length ? tb(S) : [];
      }
      function Wk(S, T) {
        return S && S.length ? tb(S, Wr(T, 2)) : [];
      }
      function jk(S) {
        var T = S == null ? 0 : S.length;
        return T ? qr(S, 1, T) : [];
      }
      function Af(S, T, F) {
        return S && S.length ? (T = F || T === c ? 1 : Uo(T), qr(S, 0, T < 0 ? 0 : T)) : [];
      }
      function wl(S, T, F) {
        var ee = S == null ? 0 : S.length;
        return ee ? (T = F || T === c ? 1 : Uo(T), T = ee - T, qr(S, T < 0 ? 0 : T, ee)) : [];
      }
      function V2(S, T) {
        return S && S.length ? Vm(S, Wr(T, 3), !1, !0) : [];
      }
      function U2(S, T) {
        return S && S.length ? Vm(S, Wr(T, 3)) : [];
      }
      var Kh = Ro(function(S) {
        return fu(ka(S, 1, qi, !0));
      }), Py = Ro(function(S) {
        var T = Of(S);
        return qi(T) && (T = c), fu(ka(S, 1, qi, !0), Wr(T, 2));
      }), n0 = Ro(function(S) {
        var T = Of(S);
        return T = typeof T == "function" ? T : c, fu(ka(S, 1, qi, !0), c, T);
      });
      function r0(S) {
        return S && S.length ? fu(S) : [];
      }
      function Km(S, T) {
        return S && S.length ? fu(S, Wr(T, 2)) : [];
      }
      function Eb(S, T) {
        return T = typeof T == "function" ? T : c, S && S.length ? fu(S, c, T) : [];
      }
      function Yh(S) {
        if (!(S && S.length))
          return [];
        var T = 0;
        return S = Xc(S, function(F) {
          if (qi(F))
            return T = Ia(F.length, T), !0;
        }), is(T, function(F) {
          return _a(S, hi(F));
        });
      }
      function Jg(S, T) {
        if (!(S && S.length))
          return [];
        var F = Yh(S);
        return T == null ? F : _a(F, function(ee) {
          return bs(T, c, ee);
        });
      }
      var ev = Ro(function(S, T) {
        return qi(S) ? si(S, T) : [];
      }), ex = Ro(function(S) {
        return um(Xc(S, qi));
      }), Ma = Ro(function(S) {
        var T = Of(S);
        return qi(T) && (T = c), um(Xc(S, qi), Wr(T, 2));
      }), tx = Ro(function(S) {
        var T = Of(S);
        return T = typeof T == "function" ? T : c, um(Xc(S, qi), c, T);
      }), Cb = Ro(Yh);
      function nx(S, T) {
        return WC(S || [], T || [], sm);
      }
      function o0(S, T) {
        return WC(S || [], T || [], Sa);
      }
      var sl = Ro(function(S) {
        var T = S.length, F = T > 1 ? S[T - 1] : c;
        return F = typeof F == "function" ? (S.pop(), F) : c, Jg(S, F);
      });
      function Hu(S) {
        var T = ye(S);
        return T.__chain__ = !0, T;
      }
      function rx(S, T) {
        return T(S), S;
      }
      function tv(S, T) {
        return T(S);
      }
      var nv = Zp(function(S) {
        var T = S.length, F = T ? S[0] : 0, ee = this.__wrapped__, ge = function(De) {
          return Ws(De, S);
        };
        return T > 1 || this.__actions__.length || !(ee instanceof ts) || !Yp(F) ? this.thru(ge) : (ee = ee.slice(F, +F + (T ? 1 : 0)), ee.__actions__.push({
          func: tv,
          args: [ge],
          thisArg: c
        }), new pl(ee, this.__chain__).thru(function(De) {
          return T && !De.length && De.push(c), De;
        }));
      });
      function W2() {
        return Hu(this);
      }
      function ox() {
        return new pl(this.value(), this.__chain__);
      }
      function gw() {
        this.__values__ === c && (this.__values__ = kw(this.value()));
        var S = this.__index__ >= this.__values__.length, T = S ? c : this.__values__[this.__index__++];
        return { done: S, value: T };
      }
      function zu() {
        return this;
      }
      function s0(S) {
        for (var T, F = this; F instanceof zm; ) {
          var ee = KC(F);
          ee.__index__ = 0, ee.__values__ = c, T ? ge.__wrapped__ = ee : T = ee;
          var ge = ee;
          F = F.__wrapped__;
        }
        return ge.__wrapped__ = S, T;
      }
      function qa() {
        var S = this.__wrapped__;
        if (S instanceof ts) {
          var T = S;
          return this.__actions__.length && (T = new ts(this)), T = T.reverse(), T.__actions__.push({
            func: tv,
            args: [oc],
            thisArg: c
          }), new pl(T, this.__chain__);
        }
        return this.thru(oc);
      }
      function fm() {
        return Gg(this.__wrapped__, this.__actions__);
      }
      var xb = Vl(function(S, T, F) {
        ys.call(S, F) ? ++S[F] : Mu(S, F, 1);
      });
      function Qh(S, T, F) {
        var ee = Br(S) ? ni : Mt;
        return F && mu(S, T, F) && (T = c), ee(S, Wr(T, 3));
      }
      function rv(S, T) {
        var F = Br(S) ? Xc : xo;
        return F(S, Wr(T, 3));
      }
      var ov = ob(hu), th = ob(Ny);
      function sx(S, T) {
        return ka(Tb(S, T), 1);
      }
      function sv(S, T) {
        return ka(Tb(S, T), bt);
      }
      function Xh(S, T, F) {
        return F = F === c ? 1 : Uo(F), ka(Tb(S, T), F);
      }
      function Jh(S, T) {
        var F = Br(S) ? Ur : Ts;
        return F(S, Wr(T, 3));
      }
      function vw(S, T) {
        var F = Br(S) ? Qc : Wg;
        return F(S, Wr(T, 3));
      }
      var j2 = Vl(function(S, T, F) {
        ys.call(S, F) ? S[F].push(T) : Mu(S, F, [T]);
      });
      function bw(S, T, F, ee) {
        S = Os(S) ? S : vm(S), F = F && !ee ? Uo(F) : 0;
        var ge = S.length;
        return F < 0 && (F = Ia(ge + F, 0)), Hy(S) ? F <= ge && S.indexOf(T, F) > -1 : !!ge && Pa(S, T, F) > -1;
      }
      var q2 = Ro(function(S, T, F) {
        var ee = -1, ge = typeof T == "function", De = Os(S) ? Ft(S.length) : [];
        return Ts(S, function(Qe) {
          De[++ee] = ge ? bs(T, Qe, F) : ld(Qe, T, F);
        }), De;
      }), a0 = Vl(function(S, T, F) {
        Mu(S, F, T);
      });
      function Tb(S, T) {
        var F = Br(S) ? _a : qe;
        return F(S, Wr(T, 3));
      }
      function Vu(S, T, F, ee) {
        return S == null ? [] : (Br(T) || (T = T == null ? [] : [T]), F = ee ? c : F, Br(F) || (F = F == null ? [] : [F]), la(S, T, F));
      }
      var ax = Vl(function(S, T, F) {
        S[F ? 0 : 1].push(T);
      }, function() {
        return [[], []];
      });
      function _b(S, T, F) {
        var ee = Br(S) ? Oo : Lh, ge = arguments.length < 3;
        return ee(S, Wr(T, 4), F, ge, Ts);
      }
      function ix(S, T, F) {
        var ee = Br(S) ? Nu : Lh, ge = arguments.length < 3;
        return ee(S, Wr(T, 4), F, ge, Wg);
      }
      function G2(S, T) {
        var F = Br(S) ? Xc : xo;
        return F(S, kf(Wr(T, 3)));
      }
      function Dy(S) {
        var T = Br(S) ? ad : Fp;
        return T(S);
      }
      function eg(S, T, F) {
        (F ? mu(S, T, F) : T === c) ? T = 1 : T = Uo(T);
        var ee = Br(S) ? Xv : qg;
        return ee(S, T);
      }
      function i0(S) {
        var T = Br(S) ? gf : Lp;
        return T(S);
      }
      function po(S) {
        if (S == null)
          return 0;
        if (Os(S))
          return Hy(S) ? lf(S) : S.length;
        var T = Sl(S);
        return T == Ge || T == bn ? S.size : W(S).length;
      }
      function Uu(S, T, F) {
        var ee = Br(S) ? Ru : oo;
        return F && mu(S, T, F) && (T = c), ee(S, Wr(T, 3));
      }
      var mm = Ro(function(S, T) {
        if (S == null)
          return [];
        var F = T.length;
        return F > 1 && mu(S, T[0], T[1]) ? T = [] : F > 2 && mu(T[0], T[1], T[2]) && (T = [T[0]]), la(S, ka(T, 1), []);
      }), Ob = Zv || function() {
        return as.Date.now();
      };
      function ds(S, T) {
        if (typeof T != "function")
          throw new $a(v);
        return S = Uo(S), function() {
          if (--S < 1)
            return T.apply(this, arguments);
        };
      }
      function Ab(S, T, F) {
        return T = F ? c : T, T = S && T == null ? S.length : T, Cf(S, q, c, c, c, c, T);
      }
      function c0(S, T) {
        var F;
        if (typeof T != "function")
          throw new $a(v);
        return S = Uo(S), function() {
          return --S > 0 && (F = T.apply(this, arguments)), S <= 1 && (T = c), F;
        };
      }
      var bi = Ro(function(S, T, F) {
        var ee = Q;
        if (F.length) {
          var ge = wc(F, Ul(bi));
          ee |= we;
        }
        return Cf(S, ee, T, F, ge);
      }), pm = Ro(function(S, T, F) {
        var ee = Q | he;
        if (F.length) {
          var ge = wc(F, Ul(pm));
          ee |= we;
        }
        return Cf(T, ee, S, F, ge);
      });
      function nh(S, T, F) {
        T = F ? c : T;
        var ee = Cf(S, G, c, c, c, c, c, T);
        return ee.placeholder = nh.placeholder, ee;
      }
      function l0(S, T, F) {
        T = F ? c : T;
        var ee = Cf(S, me, c, c, c, c, c, T);
        return ee.placeholder = l0.placeholder, ee;
      }
      function $y(S, T, F) {
        var ee, ge, De, Qe, it, At, vn = 0, gn = !1, Nn = !1, ir = !0;
        if (typeof S != "function")
          throw new $a(v);
        T = pd(T) || 0, li(F) && (gn = !!F.leading, Nn = "maxWait" in F, De = Nn ? Ia(pd(F.maxWait) || 0, T) : De, ir = "trailing" in F ? !!F.trailing : ir);
        function Dr(sc) {
          var Kd = ee, Ms = ge;
          return ee = ge = c, vn = sc, Qe = S.apply(Ms, Kd), Qe;
        }
        function io(sc) {
          return vn = sc, it = ol(fs, T), gn ? Dr(sc) : Qe;
        }
        function Bo(sc) {
          var Kd = sc - At, Ms = sc - vn, O_ = T - Kd;
          return Nn ? Bi(O_, De - Ms) : O_;
        }
        function eo(sc) {
          var Kd = sc - At, Ms = sc - vn;
          return At === c || Kd >= T || Kd < 0 || Nn && Ms >= De;
        }
        function fs() {
          var sc = Ob();
          if (eo(sc))
            return As(sc);
          it = ol(fs, Bo(sc));
        }
        function As(sc) {
          return it = c, ir && ee ? Dr(sc) : (ee = ge = c, Qe);
        }
        function Lc() {
          it !== c && Sf(it), vn = 0, ee = At = ge = it = c;
        }
        function xl() {
          return it === c ? Qe : As(Ob());
        }
        function Zd() {
          var sc = Ob(), Kd = eo(sc);
          if (ee = arguments, ge = this, At = sc, Kd) {
            if (it === c)
              return io(At);
            if (Nn)
              return Sf(it), it = ol(fs, T), Dr(At);
          }
          return it === c && (it = ol(fs, T)), Qe;
        }
        return Zd.cancel = Lc, Zd.flush = xl, Zd;
      }
      var Iy = Ro(function(S, T) {
        return $p(S, 1, T);
      }), yw = Ro(function(S, T, F) {
        return $p(S, pd(T) || 0, F);
      });
      function u0(S) {
        return Cf(S, Le);
      }
      function qd(S, T) {
        if (typeof S != "function" || T != null && typeof T != "function")
          throw new $a(v);
        var F = function() {
          var ee = arguments, ge = T ? T.apply(this, ee) : ee[0], De = F.cache;
          if (De.has(ge))
            return De.get(ge);
          var Qe = S.apply(this, ee);
          return F.cache = De.set(ge, Qe) || De, Qe;
        };
        return F.cache = new (qd.Cache || ra)(), F;
      }
      qd.Cache = ra;
      function kf(S) {
        if (typeof S != "function")
          throw new $a(v);
        return function() {
          var T = arguments;
          switch (T.length) {
            case 0:
              return !S.call(this);
            case 1:
              return !S.call(this, T[0]);
            case 2:
              return !S.call(this, T[0], T[1]);
            case 3:
              return !S.call(this, T[0], T[1], T[2]);
          }
          return !S.apply(this, T);
        };
      }
      function Z2(S) {
        return c0(2, S);
      }
      var yt = Wa(function(S, T) {
        T = T.length == 1 && Br(T[0]) ? _a(T[0], ri(Wr())) : _a(ka(T, 1), ri(Wr()));
        var F = T.length;
        return Ro(function(ee) {
          for (var ge = -1, De = Bi(ee.length, F); ++ge < De; )
            ee[ge] = T[ge].call(this, ee[ge]);
          return bs(S, this, ee);
        });
      }), av = Ro(function(S, T) {
        var F = wc(T, Ul(av));
        return Cf(S, we, c, T, F);
      }), iv = Ro(function(S, T) {
        var F = wc(T, Ul(iv));
        return Cf(S, be, c, T, F);
      }), fd = Zp(function(S, T) {
        return Cf(S, Te, c, c, c, T);
      });
      function Sw(S, T) {
        if (typeof S != "function")
          throw new $a(v);
        return T = T === c ? T : Uo(T), Ro(S, T);
      }
      function sa(S, T) {
        if (typeof S != "function")
          throw new $a(v);
        return T = T == null ? 0 : Ia(Uo(T), 0), Ro(function(F) {
          var ee = F[T], ge = Hd(F, 0, T);
          return ee && $d(ge, ee), bs(S, this, ge);
        });
      }
      function d0(S, T, F) {
        var ee = !0, ge = !0;
        if (typeof S != "function")
          throw new $a(v);
        return li(F) && (ee = "leading" in F ? !!F.leading : ee, ge = "trailing" in F ? !!F.trailing : ge), $y(S, T, {
          leading: ee,
          maxWait: T,
          trailing: ge
        });
      }
      function rh(S) {
        return Ab(S, 1);
      }
      function ww(S, T) {
        return av(xy(T), S);
      }
      function f0() {
        if (!arguments.length)
          return [];
        var S = arguments[0];
        return Br(S) ? S : [S];
      }
      function Ew(S) {
        return ya(S, Z);
      }
      function My(S, T) {
        return T = typeof T == "function" ? T : c, ya(S, Z, T);
      }
      function kb(S) {
        return ya(S, I | Z);
      }
      function Cw(S, T) {
        return T = typeof T == "function" ? T : c, ya(S, I | Z, T);
      }
      function K2(S, T) {
        return T == null || ro(S, T, Fc(T));
      }
      function Ga(S, T) {
        return S === T || S !== S && T !== T;
      }
      var Wi = ls(cm), Mc = ls(function(S, T) {
        return S >= T;
      }), ji = lt(function() {
        return arguments;
      }()) ? lt : function(S) {
        return Gi(S) && ys.call(S, "callee") && !df.call(S, "callee");
      }, Br = Ft.isArray, El = Sr ? ri(Sr) : gl;
      function Os(S) {
        return S != null && oh(S.length) && !Qm(S);
      }
      function qi(S) {
        return Gi(S) && Os(S);
      }
      function Fy(S) {
        return S === !0 || S === !1 || Gi(S) && ai(S) == oe;
      }
      var Ym = Vh || uv, Ly = Rc ? ri(Rc) : Fu;
      function xw(S) {
        return Gi(S) && S.nodeType === 1 && !tg(S);
      }
      function cx(S) {
        if (S == null)
          return !0;
        if (Os(S) && (Br(S) || typeof S == "string" || typeof S.splice == "function" || Ym(S) || gm(S) || ji(S)))
          return !S.length;
        var T = Sl(S);
        if (T == Ge || T == bn)
          return !S.size;
        if (Ud(S))
          return !W(S).length;
        for (var F in S)
          if (ys.call(S, F))
            return !1;
        return !0;
      }
      function m0(S, T) {
        return rl(S, T);
      }
      function Tw(S, T, F) {
        F = typeof F == "function" ? F : c;
        var ee = F ? F(S, T) : c;
        return ee === c ? rl(S, T, c, F) : !!ee;
      }
      function _w(S) {
        if (!Gi(S))
          return !1;
        var T = ai(S);
        return T == Zt || T == Rn || typeof S.message == "string" && typeof S.name == "string" && !tg(S);
      }
      function Y2(S) {
        return typeof S == "number" && Rr(S);
      }
      function Qm(S) {
        if (!li(S))
          return !1;
        var T = ai(S);
        return T == Jt || T == wo || T == ut || T == an;
      }
      function lx(S) {
        return typeof S == "number" && S == Uo(S);
      }
      function oh(S) {
        return typeof S == "number" && S > -1 && S % 1 == 0 && S <= at;
      }
      function li(S) {
        var T = typeof S;
        return S != null && (T == "object" || T == "function");
      }
      function Gi(S) {
        return S != null && typeof S == "object";
      }
      var Q2 = rn ? ri(rn) : vi;
      function gu(S, T) {
        return S === T || ii(S, T, Kp(T));
      }
      function qk(S, T, F) {
        return F = typeof F == "function" ? F : c, ii(S, T, Kp(T), F);
      }
      function hm(S) {
        return Aw(S) && S != +S;
      }
      function mn(S) {
        if (Z1(S))
          throw new Qr(m);
        return Cy(S);
      }
      function Ow(S) {
        return S === null;
      }
      function Zi(S) {
        return S == null;
      }
      function Aw(S) {
        return typeof S == "number" || Gi(S) && ai(S) == qt;
      }
      function tg(S) {
        if (!Gi(S) || ai(S) != ke)
          return !1;
        var T = Hm(S);
        if (T === null)
          return !0;
        var F = ys.call(T, "constructor") && T.constructor;
        return typeof F == "function" && F instanceof F && Du.call(F) == Gv;
      }
      var By = na ? ri(na) : bl;
      function vu(S) {
        return lx(S) && S >= -at && S <= at;
      }
      var ux = Dm ? ri(Dm) : vf;
      function Hy(S) {
        return typeof S == "string" || !Br(S) && Gi(S) && ai(S) == Ye;
      }
      function Fa(S) {
        return typeof S == "symbol" || Gi(S) && ai(S) == nn;
      }
      var gm = Ta ? ri(Ta) : sr;
      function zy(S) {
        return S === c;
      }
      function Xm(S) {
        return Gi(S) && Sl(S) == $n;
      }
      function Nf(S) {
        return Gi(S) && ai(S) == mr;
      }
      var Fn = ls(Ee), md = ls(function(S, T) {
        return S <= T;
      });
      function kw(S) {
        if (!S)
          return [];
        if (Os(S))
          return Hy(S) ? Ec(S) : yl(S);
        if (cs && S[cs])
          return Np(S[cs]());
        var T = Sl(S), F = T == Ge ? nd : T == bn ? Mm : vm;
        return F(S);
      }
      function Jm(S) {
        if (!S)
          return S === 0 ? S : 0;
        if (S = pd(S), S === bt || S === -bt) {
          var T = S < 0 ? -1 : 1;
          return T * _n;
        }
        return S === S ? S : 0;
      }
      function Uo(S) {
        var T = Jm(S), F = T % 1;
        return T === T ? F ? T - F : T : 0;
      }
      function Nw(S) {
        return S ? Mo(Uo(S), 0, Ne) : 0;
      }
      function pd(S) {
        if (typeof S == "number")
          return S;
        if (Fa(S))
          return st;
        if (li(S)) {
          var T = typeof S.valueOf == "function" ? S.valueOf() : S;
          S = li(T) ? T + "" : T;
        }
        if (typeof S != "string")
          return S === 0 ? S : +S;
        S = Ji(S);
        var F = bc.test(S);
        return F || wp.test(S) ? kn(S.slice(2), F ? 2 : 8) : ea.test(S) ? st : +S;
      }
      function p0(S) {
        return zd(S, bu(S));
      }
      function X2(S) {
        return S ? Mo(Uo(S), -at, at) : S === 0 ? S : 0;
      }
      function aa(S) {
        return S == null ? "" : oa(S);
      }
      var J2 = Vd(function(S, T) {
        if (Ud(T) || Os(T)) {
          zd(T, Fc(T), S);
          return;
        }
        for (var F in T)
          ys.call(T, F) && sm(S, F, T[F]);
      }), al = Vd(function(S, T) {
        zd(T, bu(T), S);
      }), ng = Vd(function(S, T, F, ee) {
        zd(T, bu(T), S, ee);
      }), e_ = Vd(function(S, T, F, ee) {
        zd(T, Fc(T), S, ee);
      }), t_ = Zp(Ws);
      function Rw(S, T) {
        var F = cu(S);
        return T == null ? F : am(F, T);
      }
      var n_ = Ro(function(S, T) {
        S = Xo(S);
        var F = -1, ee = T.length, ge = ee > 2 ? T[2] : c;
        for (ge && mu(T[0], T[1], ge) && (ee = 1); ++F < ee; )
          for (var De = T[F], Qe = bu(De), it = -1, At = Qe.length; ++it < At; ) {
            var vn = Qe[it], gn = S[vn];
            (gn === c || Ga(gn, oi[vn]) && !ys.call(S, vn)) && (S[vn] = De[vn]);
          }
        return S;
      }), dx = Ro(function(S) {
        return S.push(c, ib), bs(hx, c, S);
      });
      function fx(S, T) {
        return no(S, Wr(T, 3), cd);
      }
      function Vy(S, T) {
        return no(S, Wr(T, 3), lu);
      }
      function mx(S, T) {
        return S == null ? S : eb(S, Wr(T, 3), bu);
      }
      function Pw(S, T) {
        return S == null ? S : id(S, Wr(T, 3), bu);
      }
      function cv(S, T) {
        return S && cd(S, Wr(T, 3));
      }
      function r_(S, T) {
        return S && lu(S, Wr(T, 3));
      }
      function o_(S) {
        return S == null ? [] : Wh(S, Fc(S));
      }
      function Dw(S) {
        return S == null ? [] : Wh(S, bu(S));
      }
      function $w(S, T, F) {
        var ee = S == null ? c : tc(S, T);
        return ee === c ? F : ee;
      }
      function sh(S, T) {
        return S != null && G1(S, T, nc);
      }
      function Gr(S, T) {
        return S != null && G1(S, T, Ey);
      }
      var Iw = nr(function(S, T, F) {
        T != null && typeof T.toString != "function" && (T = Bm.call(T)), S[T] = F;
      }, jy(hd)), Cl = nr(function(S, T, F) {
        T != null && typeof T.toString != "function" && (T = Bm.call(T)), ys.call(S, T) ? S[T].push(F) : S[T] = [F];
      }, Wr), h0 = Ro(ld);
      function Fc(S) {
        return Os(S) ? xi(S) : W(S);
      }
      function bu(S) {
        return Os(S) ? xi(S, !0) : de(S);
      }
      function g0(S, T) {
        var F = {};
        return T = Wr(T, 3), cd(S, function(ee, ge, De) {
          Mu(F, T(ee, ge, De), ee);
        }), F;
      }
      function px(S, T) {
        var F = {};
        return T = Wr(T, 3), cd(S, function(ee, ge, De) {
          Mu(F, ge, T(ee, ge, De));
        }), F;
      }
      var s_ = Vd(function(S, T, F) {
        Sn(S, T, F);
      }), hx = Vd(function(S, T, F, ee) {
        Sn(S, T, F, ee);
      }), Nb = Zp(function(S, T) {
        var F = {};
        if (S == null)
          return F;
        var ee = !1;
        T = _a(T, function(De) {
          return De = zp(De, S), ee || (ee = De.length > 1), De;
        }), zd(S, us(S), F), ee && (F = ya(F, I | L | Z, F2));
        for (var ge = T.length; ge--; )
          ud(F, T[ge]);
        return F;
      });
      function gx(S, T) {
        return ah(S, kf(Wr(T)));
      }
      var Gk = Zp(function(S, T) {
        return S == null ? {} : Lo(S, T);
      });
      function ah(S, T) {
        if (S == null)
          return {};
        var F = _a(us(S), function(ee) {
          return [ee];
        });
        return T = Wr(T), _s(S, F, function(ee, ge) {
          return T(ee, ge[0]);
        });
      }
      function a_(S, T, F) {
        T = zp(T, S);
        var ee = -1, ge = T.length;
        for (ge || (ge = 1, S = c); ++ee < ge; ) {
          var De = S == null ? c : S[Bu(T[ee])];
          De === c && (ee = ge, De = F), S = Qm(De) ? De.call(S) : De;
        }
        return S;
      }
      function Rb(S, T, F) {
        return S == null ? S : Sa(S, T, F);
      }
      function i_(S, T, F, ee) {
        return ee = typeof ee == "function" ? ee : c, S == null ? S : Sa(S, T, F, ee);
      }
      var v0 = Pt(Fc), Mw = Pt(bu);
      function lv(S, T, F) {
        var ee = Br(S), ge = ee || Ym(S) || gm(S);
        if (T = Wr(T, 4), F == null) {
          var De = S && S.constructor;
          ge ? F = ee ? new De() : [] : li(S) ? F = Qm(De) ? cu(Hm(S)) : {} : F = {};
        }
        return (ge ? Ur : cd)(S, function(Qe, it, At) {
          return T(F, Qe, it, At);
        }), F;
      }
      function c_(S, T) {
        return S == null ? !0 : ud(S, T);
      }
      function vx(S, T, F) {
        return S == null ? S : Bp(S, T, xy(F));
      }
      function bx(S, T, F, ee) {
        return ee = typeof ee == "function" ? ee : c, S == null ? S : Bp(S, T, xy(F), ee);
      }
      function vm(S) {
        return S == null ? [] : Da(S, Fc(S));
      }
      function yx(S) {
        return S == null ? [] : Da(S, bu(S));
      }
      function Fw(S, T, F) {
        return F === c && (F = T, T = c), F !== c && (F = pd(F), F = F === F ? F : 0), T !== c && (T = pd(T), T = T === T ? T : 0), Mo(pd(S), T, F);
      }
      function l_(S, T, F) {
        return T = Jm(T), F === c ? (F = T, T = 0) : F = Jm(F), S = pd(S), Ip(S, T, F);
      }
      function Sx(S, T, F) {
        if (F && typeof F != "boolean" && mu(S, T, F) && (T = F = c), F === c && (typeof T == "boolean" ? (F = T, T = c) : typeof S == "boolean" && (F = S, S = c)), S === c && T === c ? (S = 0, T = 1) : (S = Jm(S), T === c ? (T = S, S = 0) : T = Jm(T)), S > T) {
          var ee = S;
          S = T, T = ee;
        }
        if (F || S % 1 || T % 1) {
          var ge = va();
          return Bi(S + ge * (T - S + Rm("1e-" + ((ge + "").length - 1))), T);
        }
        return bf(S, T);
      }
      var ep = qp(function(S, T, F) {
        return T = T.toLowerCase(), S + (F ? Pb(T) : T);
      });
      function Pb(S) {
        return w0(aa(S).toLowerCase());
      }
      function Db(S) {
        return S = aa(S), S && S.replace(Ou, Bh).replace(Se, "");
      }
      function b0(S, T, F) {
        S = aa(S), T = oa(T);
        var ee = S.length;
        F = F === c ? ee : Mo(Uo(F), 0, ee);
        var ge = F;
        return F -= T.length, F >= 0 && S.slice(F, ge) == T;
      }
      function Uy(S) {
        return S = aa(S), S && $i.test(S) ? S.replace(Yr, Ap) : S;
      }
      function Gd(S) {
        return S = aa(S), S && Ei.test(S) ? S.replace(lr, "\\$&") : S;
      }
      var $b = qp(function(S, T, F) {
        return S + (F ? "-" : "") + T.toLowerCase();
      }), Wy = qp(function(S, T, F) {
        return S + (F ? " " : "") + T.toLowerCase();
      }), rg = nb("toLowerCase");
      function y0(S, T, F) {
        S = aa(S), T = Uo(T);
        var ee = T ? lf(S) : 0;
        if (!T || ee >= T)
          return S;
        var ge = (T - ee) / 2;
        return qh(Li(ge), F) + S + qh(su(ge), F);
      }
      function u_(S, T, F) {
        S = aa(S), T = Uo(T);
        var ee = T ? lf(S) : 0;
        return T && ee < T ? S + qh(T - ee, F) : S;
      }
      function d_(S, T, F) {
        S = aa(S), T = Uo(T);
        var ee = T ? lf(S) : 0;
        return T && ee < T ? qh(T - ee, F) + S : S;
      }
      function wx(S, T, F) {
        return F || T == null ? T = 0 : T && (T = +T), Hi(aa(S).replace(Jl, ""), T || 0);
      }
      function f_(S, T, F) {
        return (F ? mu(S, T, F) : T === c) ? T = 1 : T = Uo(T), Mp(aa(S), T);
      }
      function Lw() {
        var S = arguments, T = aa(S[0]);
        return S.length < 3 ? T : T.replace(S[1], S[2]);
      }
      var m_ = qp(function(S, T, F) {
        return S + (F ? "_" : "") + T.toLowerCase();
      });
      function p_(S, T, F) {
        return F && typeof F != "number" && mu(S, T, F) && (T = F = c), F = F === c ? Ne : F >>> 0, F ? (S = aa(S), S && (typeof T == "string" || T != null && !By(T)) && (T = oa(T), !T && gi(S)) ? Hd(Ec(S), 0, F) : S.split(T, F)) : [];
      }
      var Ex = qp(function(S, T, F) {
        return S + (F ? " " : "") + w0(T);
      });
      function h_(S, T, F) {
        return S = aa(S), F = F == null ? 0 : Mo(Uo(F), 0, S.length), T = oa(T), S.slice(F, F + T.length) == T;
      }
      function Cx(S, T, F) {
        var ee = ye.templateSettings;
        F && mu(S, T, F) && (T = c), S = aa(S), T = ng({}, T, ee, jC);
        var ge = ng({}, T.imports, ee.imports, jC), De = Fc(ge), Qe = Da(ge, De), it, At, vn = 0, gn = T.interpolate || Au, Nn = "__p += '", ir = Rp(
          (T.escape || Au).source + "|" + gn.source + "|" + (gn === es ? Yu : Au).source + "|" + (T.evaluate || Au).source + "|$",
          "g"
        ), Dr = "//# sourceURL=" + (ys.call(T, "sourceURL") ? (T.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++Yo + "]") + `
`;
        S.replace(ir, function(eo, fs, As, Lc, xl, Zd) {
          return As || (As = Lc), Nn += S.slice(vn, Zd).replace(nt, Pc), fs && (it = !0, Nn += `' +
__e(` + fs + `) +
'`), xl && (At = !0, Nn += `';
` + xl + `;
__p += '`), As && (Nn += `' +
((__t = (` + As + `)) == null ? '' : __t) +
'`), vn = Zd + eo.length, eo;
        }), Nn += `';
`;
        var io = ys.call(T, "variable") && T.variable;
        if (!io)
          Nn = `with (obj) {
` + Nn + `
}
`;
        else if (Nl.test(io))
          throw new Qr(g);
        Nn = (At ? Nn.replace(hc, "") : Nn).replace(Co, "$1").replace(fl, "$1;"), Nn = "function(" + (io || "obj") + `) {
` + (io ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (it ? ", __e = _.escape" : "") + (At ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + Nn + `return __p
}`;
        var Bo = Tx(function() {
          return No(De, Dr + "return " + Nn).apply(c, Qe);
        });
        if (Bo.source = Nn, _w(Bo))
          throw Bo;
        return Bo;
      }
      function g_(S) {
        return aa(S).toLowerCase();
      }
      function S0(S) {
        return aa(S).toUpperCase();
      }
      function v_(S, T, F) {
        if (S = aa(S), S && (F || T === c))
          return Ji(S);
        if (!S || !(T = oa(T)))
          return S;
        var ee = Ec(S), ge = Ec(T), De = Ll(ee, ge), Qe = cf(ee, ge) + 1;
        return Hd(ee, De, Qe).join("");
      }
      function xx(S, T, F) {
        if (S = aa(S), S && (F || T === c))
          return S.slice(0, Fg(S) + 1);
        if (!S || !(T = oa(T)))
          return S;
        var ee = Ec(S), ge = cf(ee, Ec(T)) + 1;
        return Hd(ee, 0, ge).join("");
      }
      function Ib(S, T, F) {
        if (S = aa(S), S && (F || T === c))
          return S.replace(Jl, "");
        if (!S || !(T = oa(T)))
          return S;
        var ee = Ec(S), ge = Ll(ee, Ec(T));
        return Hd(ee, ge).join("");
      }
      function Bw(S, T) {
        var F = je, ee = Ie;
        if (li(T)) {
          var ge = "separator" in T ? T.separator : ge;
          F = "length" in T ? Uo(T.length) : F, ee = "omission" in T ? oa(T.omission) : ee;
        }
        S = aa(S);
        var De = S.length;
        if (gi(S)) {
          var Qe = Ec(S);
          De = Qe.length;
        }
        if (F >= De)
          return S;
        var it = F - lf(ee);
        if (it < 1)
          return ee;
        var At = Qe ? Hd(Qe, 0, it).join("") : S.slice(0, it);
        if (ge === c)
          return At + ee;
        if (Qe && (it += At.length - it), By(ge)) {
          if (S.slice(it).search(ge)) {
            var vn, gn = At;
            for (ge.global || (ge = Rp(ge.source, aa(vc.exec(ge)) + "g")), ge.lastIndex = 0; vn = ge.exec(gn); )
              var Nn = vn.index;
            At = At.slice(0, Nn === c ? it : Nn);
          }
        } else if (S.indexOf(oa(ge), it) != it) {
          var ir = At.lastIndexOf(ge);
          ir > -1 && (At = At.slice(0, ir));
        }
        return At + ee;
      }
      function Hw(S) {
        return S = aa(S), S && xa.test(S) ? S.replace(fn, Fe) : S;
      }
      var zw = qp(function(S, T, F) {
        return S + (F ? " " : "") + T.toUpperCase();
      }), w0 = nb("toUpperCase");
      function E0(S, T, F) {
        return S = aa(S), T = F ? c : T, T === c ? Pu(S) ? Fm(S) : Op(S) : S.match(T) || [];
      }
      var Tx = Ro(function(S, T) {
        try {
          return bs(S, c, T);
        } catch (F) {
          return _w(F) ? F : new Qr(F);
        }
      }), C0 = Zp(function(S, T) {
        return Ur(T, function(F) {
          F = Bu(F), Mu(S, F, bi(S[F], S));
        }), S;
      });
      function x0(S) {
        var T = S == null ? 0 : S.length, F = Wr();
        return S = T ? _a(S, function(ee) {
          if (typeof ee[1] != "function")
            throw new $a(v);
          return [F(ee[0]), ee[1]];
        }) : [], Ro(function(ee) {
          for (var ge = -1; ++ge < T; ) {
            var De = S[ge];
            if (bs(De[0], this, ee))
              return bs(De[1], this, ee);
          }
        });
      }
      function b_(S) {
        return Dc(ya(S, I));
      }
      function jy(S) {
        return function() {
          return S;
        };
      }
      function _x(S, T) {
        return S == null || S !== S ? T : S;
      }
      var y_ = sb(), Vw = sb(!0);
      function hd(S) {
        return S;
      }
      function og(S) {
        return M(typeof S == "function" ? S : ya(S, I));
      }
      function S_(S) {
        return kt(ya(S, I));
      }
      function Uw(S, T) {
        return tn(S, ya(T, I));
      }
      var w_ = Ro(function(S, T) {
        return function(F) {
          return ld(F, S, T);
        };
      }), E_ = Ro(function(S, T) {
        return function(F) {
          return ld(S, F, T);
        };
      });
      function Ww(S, T, F) {
        var ee = Fc(T), ge = Wh(T, ee);
        F == null && !(li(T) && (ge.length || !ee.length)) && (F = T, T = S, S = this, ge = Wh(T, Fc(T)));
        var De = !(li(F) && "chain" in F) || !!F.chain, Qe = Qm(S);
        return Ur(ge, function(it) {
          var At = T[it];
          S[it] = At, Qe && (S.prototype[it] = function() {
            var vn = this.__chain__;
            if (De || vn) {
              var gn = S(this.__wrapped__), Nn = gn.__actions__ = yl(this.__actions__);
              return Nn.push({ func: At, args: arguments, thisArg: S }), gn.__chain__ = vn, gn;
            }
            return At.apply(S, $d([this.value()], arguments));
          });
        }), S;
      }
      function Ox() {
        return as._ === this && (as._ = Pp), this;
      }
      function jw() {
      }
      function Tc(S) {
        return S = Uo(S), Ro(function(T) {
          return Pr(T, S);
        });
      }
      var Zk = ab(_a), Mb = ab(ni), T0 = ab(Ru);
      function qw(S) {
        return Qp(S) ? hi(Bu(S)) : zl(S);
      }
      function Gw(S) {
        return function(T) {
          return S == null ? c : tc(S, T);
        };
      }
      var Ax = W1(), kx = W1(!0);
      function ih() {
        return [];
      }
      function uv() {
        return !1;
      }
      function C_() {
        return {};
      }
      function x_() {
        return "";
      }
      function qy() {
        return !0;
      }
      function Zw(S, T) {
        if (S = Uo(S), S < 1 || S > at)
          return [];
        var F = Ne, ee = Bi(S, Ne);
        T = Wr(T), S -= Ne;
        for (var ge = is(ee, T); ++F < S; )
          T(F);
        return ge;
      }
      function Nx(S) {
        return Br(S) ? _a(S, Bu) : Fa(S) ? [S] : yl(pu(aa(S)));
      }
      function Ki(S) {
        var T = ++ou;
        return aa(S) + T;
      }
      var Rx = Ef(function(S, T) {
        return S + T;
      }, 0), Kw = Oy("ceil"), Kk = Ef(function(S, T) {
        return S / T;
      }, 1), Fb = Oy("floor");
      function T_(S) {
        return S && S.length ? $c(S, hd, cm) : c;
      }
      function Px(S, T) {
        return S && S.length ? $c(S, Wr(T, 2), cm) : c;
      }
      function Yw(S) {
        return Mi(S, hd);
      }
      function Gy(S, T) {
        return Mi(S, Wr(T, 2));
      }
      function _0(S) {
        return S && S.length ? $c(S, hd, Ee) : c;
      }
      function Lb(S, T) {
        return S && S.length ? $c(S, Wr(T, 2), Ee) : c;
      }
      var __ = Ef(function(S, T) {
        return S * T;
      }, 1), sg = Oy("round"), Dx = Ef(function(S, T) {
        return S - T;
      }, 0);
      function ag(S) {
        return S && S.length ? $m(S, hd) : 0;
      }
      function ig(S, T) {
        return S && S.length ? $m(S, Wr(T, 2)) : 0;
      }
      return ye.after = ds, ye.ary = Ab, ye.assign = J2, ye.assignIn = al, ye.assignInWith = ng, ye.assignWith = e_, ye.at = t_, ye.before = c0, ye.bind = bi, ye.bindAll = C0, ye.bindKey = pm, ye.castArray = f0, ye.chain = Hu, ye.chunk = YC, ye.compact = dw, ye.concat = gb, ye.cond = x0, ye.conforms = b_, ye.constant = jy, ye.countBy = xb, ye.create = Rw, ye.curry = nh, ye.curryRight = l0, ye.debounce = $y, ye.defaults = n_, ye.defaultsDeep = dx, ye.defer = Iy, ye.delay = yw, ye.difference = vb, ye.differenceBy = Q1, ye.differenceWith = B2, ye.drop = X1, ye.dropRight = bb, ye.dropRightWhile = H2, ye.dropWhile = ky, ye.fill = fw, ye.filter = rv, ye.flatMap = sx, ye.flatMapDeep = sv, ye.flatMapDepth = Xh, ye.flatten = mw, ye.flattenDeep = J1, ye.flattenDepth = Uk, ye.flip = u0, ye.flow = y_, ye.flowRight = Vw, ye.fromPairs = e0, ye.functions = o_, ye.functionsIn = Dw, ye.groupBy = j2, ye.initial = pw, ye.intersection = yb, ye.intersectionBy = t0, ye.intersectionWith = QC, ye.invert = Iw, ye.invertBy = Cl, ye.invokeMap = q2, ye.iteratee = og, ye.keyBy = a0, ye.keys = Fc, ye.keysIn = bu, ye.map = Tb, ye.mapKeys = g0, ye.mapValues = px, ye.matches = S_, ye.matchesProperty = Uw, ye.memoize = qd, ye.merge = s_, ye.mergeWith = hx, ye.method = w_, ye.methodOf = E_, ye.mixin = Ww, ye.negate = kf, ye.nthArg = Tc, ye.omit = Nb, ye.omitBy = gx, ye.once = Z2, ye.orderBy = Vu, ye.over = Zk, ye.overArgs = yt, ye.overEvery = Mb, ye.overSome = T0, ye.partial = av, ye.partialRight = iv, ye.partition = ax, ye.pick = Gk, ye.pickBy = ah, ye.property = qw, ye.propertyOf = Gw, ye.pull = ua, ye.pullAll = Xg, ye.pullAllBy = Ti, ye.pullAllWith = wa, ye.pullAt = dd, ye.range = Ax, ye.rangeRight = kx, ye.rearg = fd, ye.reject = G2, ye.remove = hw, ye.rest = Sw, ye.reverse = oc, ye.sampleSize = eg, ye.set = Rb, ye.setWith = i_, ye.shuffle = i0, ye.slice = Ry, ye.sortBy = mm, ye.sortedUniq = JC, ye.sortedUniqBy = Wk, ye.split = p_, ye.spread = sa, ye.tail = jk, ye.take = Af, ye.takeRight = wl, ye.takeRightWhile = V2, ye.takeWhile = U2, ye.tap = rx, ye.throttle = d0, ye.thru = tv, ye.toArray = kw, ye.toPairs = v0, ye.toPairsIn = Mw, ye.toPath = Nx, ye.toPlainObject = p0, ye.transform = lv, ye.unary = rh, ye.union = Kh, ye.unionBy = Py, ye.unionWith = n0, ye.uniq = r0, ye.uniqBy = Km, ye.uniqWith = Eb, ye.unset = c_, ye.unzip = Yh, ye.unzipWith = Jg, ye.update = vx, ye.updateWith = bx, ye.values = vm, ye.valuesIn = yx, ye.without = ev, ye.words = E0, ye.wrap = ww, ye.xor = ex, ye.xorBy = Ma, ye.xorWith = tx, ye.zip = Cb, ye.zipObject = nx, ye.zipObjectDeep = o0, ye.zipWith = sl, ye.entries = v0, ye.entriesIn = Mw, ye.extend = al, ye.extendWith = ng, Ww(ye, ye), ye.add = Rx, ye.attempt = Tx, ye.camelCase = ep, ye.capitalize = Pb, ye.ceil = Kw, ye.clamp = Fw, ye.clone = Ew, ye.cloneDeep = kb, ye.cloneDeepWith = Cw, ye.cloneWith = My, ye.conformsTo = K2, ye.deburr = Db, ye.defaultTo = _x, ye.divide = Kk, ye.endsWith = b0, ye.eq = Ga, ye.escape = Uy, ye.escapeRegExp = Gd, ye.every = Qh, ye.find = ov, ye.findIndex = hu, ye.findKey = fx, ye.findLast = th, ye.findLastIndex = Ny, ye.findLastKey = Vy, ye.floor = Fb, ye.forEach = Jh, ye.forEachRight = vw, ye.forIn = mx, ye.forInRight = Pw, ye.forOwn = cv, ye.forOwnRight = r_, ye.get = $w, ye.gt = Wi, ye.gte = Mc, ye.has = sh, ye.hasIn = Gr, ye.head = Jp, ye.identity = hd, ye.includes = bw, ye.indexOf = Gm, ye.inRange = l_, ye.invoke = h0, ye.isArguments = ji, ye.isArray = Br, ye.isArrayBuffer = El, ye.isArrayLike = Os, ye.isArrayLikeObject = qi, ye.isBoolean = Fy, ye.isBuffer = Ym, ye.isDate = Ly, ye.isElement = xw, ye.isEmpty = cx, ye.isEqual = m0, ye.isEqualWith = Tw, ye.isError = _w, ye.isFinite = Y2, ye.isFunction = Qm, ye.isInteger = lx, ye.isLength = oh, ye.isMap = Q2, ye.isMatch = gu, ye.isMatchWith = qk, ye.isNaN = hm, ye.isNative = mn, ye.isNil = Zi, ye.isNull = Ow, ye.isNumber = Aw, ye.isObject = li, ye.isObjectLike = Gi, ye.isPlainObject = tg, ye.isRegExp = By, ye.isSafeInteger = vu, ye.isSet = ux, ye.isString = Hy, ye.isSymbol = Fa, ye.isTypedArray = gm, ye.isUndefined = zy, ye.isWeakMap = Xm, ye.isWeakSet = Nf, ye.join = Is, ye.kebabCase = $b, ye.last = Of, ye.lastIndexOf = ja, ye.lowerCase = Wy, ye.lowerFirst = rg, ye.lt = Fn, ye.lte = md, ye.max = T_, ye.maxBy = Px, ye.mean = Yw, ye.meanBy = Gy, ye.min = _0, ye.minBy = Lb, ye.stubArray = ih, ye.stubFalse = uv, ye.stubObject = C_, ye.stubString = x_, ye.stubTrue = qy, ye.multiply = __, ye.nth = XC, ye.noConflict = Ox, ye.noop = jw, ye.now = Ob, ye.pad = y0, ye.padEnd = u_, ye.padStart = d_, ye.parseInt = wx, ye.random = Sx, ye.reduce = _b, ye.reduceRight = ix, ye.repeat = f_, ye.replace = Lw, ye.result = a_, ye.round = sg, ye.runInContext = Je, ye.sample = Dy, ye.size = po, ye.snakeCase = m_, ye.some = Uu, ye.sortedIndex = Sb, ye.sortedIndexBy = Zm, ye.sortedIndexOf = wb, ye.sortedLastIndex = Zh, ye.sortedLastIndexBy = eh, ye.sortedLastIndexOf = z2, ye.startCase = Ex, ye.startsWith = h_, ye.subtract = Dx, ye.sum = ag, ye.sumBy = ig, ye.template = Cx, ye.times = Zw, ye.toFinite = Jm, ye.toInteger = Uo, ye.toLength = Nw, ye.toLower = g_, ye.toNumber = pd, ye.toSafeInteger = X2, ye.toString = aa, ye.toUpper = S0, ye.trim = v_, ye.trimEnd = xx, ye.trimStart = Ib, ye.truncate = Bw, ye.unescape = Hw, ye.uniqueId = Ki, ye.upperCase = zw, ye.upperFirst = w0, ye.each = Jh, ye.eachRight = vw, ye.first = Jp, Ww(ye, function() {
        var S = {};
        return cd(ye, function(T, F) {
          ys.call(ye.prototype, F) || (S[F] = T);
        }), S;
      }(), { chain: !1 }), ye.VERSION = i, Ur(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(S) {
        ye[S].placeholder = ye;
      }), Ur(["drop", "take"], function(S, T) {
        ts.prototype[S] = function(F) {
          F = F === c ? 1 : Ia(Uo(F), 0);
          var ee = this.__filtered__ && !T ? new ts(this) : this.clone();
          return ee.__filtered__ ? ee.__takeCount__ = Bi(F, ee.__takeCount__) : ee.__views__.push({
            size: Bi(F, Ne),
            type: S + (ee.__dir__ < 0 ? "Right" : "")
          }), ee;
        }, ts.prototype[S + "Right"] = function(F) {
          return this.reverse()[S](F).reverse();
        };
      }), Ur(["filter", "map", "takeWhile"], function(S, T) {
        var F = T + 1, ee = F == sn || F == z;
        ts.prototype[S] = function(ge) {
          var De = this.clone();
          return De.__iteratees__.push({
            iteratee: Wr(ge, 3),
            type: F
          }), De.__filtered__ = De.__filtered__ || ee, De;
        };
      }), Ur(["head", "last"], function(S, T) {
        var F = "take" + (T ? "Right" : "");
        ts.prototype[S] = function() {
          return this[F](1).value()[0];
        };
      }), Ur(["initial", "tail"], function(S, T) {
        var F = "drop" + (T ? "" : "Right");
        ts.prototype[S] = function() {
          return this.__filtered__ ? new ts(this) : this[F](1);
        };
      }), ts.prototype.compact = function() {
        return this.filter(hd);
      }, ts.prototype.find = function(S) {
        return this.filter(S).head();
      }, ts.prototype.findLast = function(S) {
        return this.reverse().find(S);
      }, ts.prototype.invokeMap = Ro(function(S, T) {
        return typeof S == "function" ? new ts(this) : this.map(function(F) {
          return ld(F, S, T);
        });
      }), ts.prototype.reject = function(S) {
        return this.filter(kf(Wr(S)));
      }, ts.prototype.slice = function(S, T) {
        S = Uo(S);
        var F = this;
        return F.__filtered__ && (S > 0 || T < 0) ? new ts(F) : (S < 0 ? F = F.takeRight(-S) : S && (F = F.drop(S)), T !== c && (T = Uo(T), F = T < 0 ? F.dropRight(-T) : F.take(T - S)), F);
      }, ts.prototype.takeRightWhile = function(S) {
        return this.reverse().takeWhile(S).reverse();
      }, ts.prototype.toArray = function() {
        return this.take(Ne);
      }, cd(ts.prototype, function(S, T) {
        var F = /^(?:filter|find|map|reject)|While$/.test(T), ee = /^(?:head|last)$/.test(T), ge = ye[ee ? "take" + (T == "last" ? "Right" : "") : T], De = ee || /^find/.test(T);
        ge && (ye.prototype[T] = function() {
          var Qe = this.__wrapped__, it = ee ? [1] : arguments, At = Qe instanceof ts, vn = it[0], gn = At || Br(Qe), Nn = function(fs) {
            var As = ge.apply(ye, $d([fs], it));
            return ee && ir ? As[0] : As;
          };
          gn && F && typeof vn == "function" && vn.length != 1 && (At = gn = !1);
          var ir = this.__chain__, Dr = !!this.__actions__.length, io = De && !ir, Bo = At && !Dr;
          if (!De && gn) {
            Qe = Bo ? Qe : new ts(this);
            var eo = S.apply(Qe, it);
            return eo.__actions__.push({ func: tv, args: [Nn], thisArg: c }), new pl(eo, ir);
          }
          return io && Bo ? S.apply(this, it) : (eo = this.thru(Nn), io ? ee ? eo.value()[0] : eo.value() : eo);
        });
      }), Ur(["pop", "push", "shift", "sort", "splice", "unshift"], function(S) {
        var T = Hl[S], F = /^(?:push|sort|unshift)$/.test(S) ? "tap" : "thru", ee = /^(?:pop|shift)$/.test(S);
        ye.prototype[S] = function() {
          var ge = arguments;
          if (ee && !this.__chain__) {
            var De = this.value();
            return T.apply(Br(De) ? De : [], ge);
          }
          return this[F](function(Qe) {
            return T.apply(Br(Qe) ? Qe : [], ge);
          });
        };
      }), cd(ts.prototype, function(S, T) {
        var F = ye[T];
        if (F) {
          var ee = F.name + "";
          ys.call(Ys, ee) || (Ys[ee] = []), Ys[ee].push({ name: T, func: F });
        }
      }), Ys[Jr(c, he).name] = [{
        name: "wrapper",
        func: c
      }], ts.prototype.clone = Qv, ts.prototype.reverse = Uh, ts.prototype.value = Vg, ye.prototype.at = nv, ye.prototype.chain = W2, ye.prototype.commit = ox, ye.prototype.next = gw, ye.prototype.plant = s0, ye.prototype.reverse = qa, ye.prototype.toJSON = ye.prototype.valueOf = ye.prototype.value = fm, ye.prototype.first = ye.prototype.head, cs && (ye.prototype[cs] = zu), ye;
    }, Lm = Lg();
    vs ? ((vs.exports = Lm)._ = Lm, _p._ = Lm) : as._ = Lm;
  }).call(S1);
})(YW, YW.exports);
var Ize = YW.exports;
const Mze = /* @__PURE__ */ Ku(Ize);
function kie() {
}
kie.prototype = new Error();
class rme {
  constructor() {
    this._addFilter = (o, c) => {
      if (!Array.isArray(o))
        throw new Error(`Filter value "${o}" in query state must be an array.`);
      if (!(o.length === 2 || o.length === 3))
        throw new Error(`Filter value "${o}" in query state must be an array of 2 or 3 elements`);
      const i = o.length === 3;
      var d = o[0], m = o[1];
      if (i) {
        if (!Array.isArray(o[2]))
          throw new Error(`Filter value "${o[2]}" in query state must be an array.`);
        m = m + "::" + o[2][1];
      }
      d in c ? c[d].push(m) : c[d] = [m];
    }, this._addFilters = (o) => {
      if (!Array.isArray(o))
        throw new Error(`Filters query state "${o}" must be an array.`);
      const c = {};
      return o.forEach((i) => {
        this._addFilter(i, c);
      }), c;
    }, this.serialize = this.serialize.bind(this);
  }
  /**
   * Return a serialized version of the app state `query` for the API backend.
   * @param {object} stateQuery the `query` state to serialize
   */
  serialize(o) {
    const {
      queryString: c,
      sortBy: i,
      sortOrder: d,
      page: m,
      size: v,
      filters: g,
      hiddenParams: C
    } = o;
    let O = {};
    c !== null && (O.q = c), i !== null && (O.sort = i, d !== null && (O.sort = d === "desc" ? `-${i}` : i)), m > 0 && (O.page = m), v > 0 && (O.size = v), nw(C) || GW(O, this._addFilters(C));
    const R = this._addFilters(g);
    return GW(O, R), lI.stringify(O, {
      arrayFormat: "repeat"
    });
  }
}
class Fze {
  constructor() {
    this.serialize = this.serialize.bind(this);
  }
  /**
   * Return a serialized version of the API backend response for the app state `results`.
   * @param {object} payload the backend response payload
   */
  serialize(o) {
    const {
      aggregations: c,
      hits: i,
      ...d
    } = o;
    return {
      aggregations: c || {},
      hits: i.hits,
      total: i.total,
      extras: d
    };
  }
}
function nW(r, o) {
  return r.indexOf(o) === 0 && (r.length === o.length || r.indexOf(o + "&") === 0);
}
function Boe(r) {
  return lI.stringify({
    q: r
  });
}
function Lze(r) {
  return lI.parse(r).q;
}
function Qve(r) {
  if (r.length === 3) {
    const c = [r[0], r[1]], i = Qve(r[2]);
    return i.length && c.push(i), c;
  }
  return [];
}
function ome(r, o) {
  const c = Boe(r), i = o.map((v) => Boe(v));
  let d = !1;
  const m = i.filter((v) => {
    const g = nW(v, c), C = nW(c, v);
    return g && !d && (d = !0), !g && !C;
  });
  if (!d)
    m.push(c);
  else if (r.length === 3) {
    const g = Qve(r), C = Boe(g), O = m.some((R) => {
      const I = nW(R, C), L = nW(C, R);
      return I || L;
    });
    (nw(m) || !O) && m.push(C);
  }
  return m.map((v) => Lze(v));
}
const Xve = (r, o) => {
  if (nw(r))
    return;
  if (!Sge(t5e(r)))
    return ome(r, o);
  let c = o;
  for (const i of r)
    c = ome(i, c);
  return c;
}, Jve = (r, o, c) => {
  let i = I5e(o, c);
  return nw(i.filters) || (i.filters = Xve(i.filters, r.filters)), i;
}, QW = {
  queryString: "",
  suggestions: [],
  sortBy: null,
  sortOrder: null,
  page: -1,
  size: -1,
  filters: [],
  hiddenParams: [],
  layout: null
}, ebe = Object.keys(QW), Bze = {
  loading: !1,
  data: {
    hits: [],
    total: 0,
    aggregations: {}
  },
  error: {}
}, Hze = {
  hasUserChangedSorting: !1,
  initialSortBy: null,
  initialSortOrder: null
};
class zze {
  constructor() {
    this._checkFilter = (o) => {
      if (!Array.isArray(o))
        throw new Error(`Filter value "${o}" in query state must be an array.`);
      if (!(o.length === 2 || o.length === 3))
        throw new Error(`Filter value "${o}" in query state must be an array of 2 or 3 elements`);
    }, this._addFilter = (o, c) => {
      this._checkFilter(o);
      const i = o[0], d = o[1], m = o.length === 3;
      m && this._checkFilter(o[2]), i in c ? m ? c[i].push(d + "::" + o[2][1]) : c[i].push(d) : m ? c[i] = [d + "::" + o[2][1]] : c[i] = [d];
    }, this._addFilters = (o) => {
      if (!Array.isArray(o))
        throw new Error(`Filters query state "${o}" must be an array.`);
      const c = {};
      return o.forEach((i) => {
        this._addFilter(i, c);
      }), c;
    }, this.serialize = this.serialize.bind(this);
  }
  /**
   * Return a serialized version of the app state `query` for the API backend.
   * @param {object} stateQuery the `query` state to serialize
   */
  serialize(o) {
    const {
      queryString: c,
      sortBy: i,
      sortOrder: d,
      page: m,
      size: v,
      filters: g,
      hiddenParams: C
    } = o;
    let O = {};
    c !== null && (O.q = c), i !== null && (O.sort = i, d !== null && (O.sort = d === "desc" ? `-${i}` : i)), m > 0 && (O.page = m), v > 0 && (O.size = v), nw(C) || GW(O, this._addFilters(C));
    const R = this._addFilters(g);
    return GW(O, R), lI.stringify(O, {
      arrayFormat: "repeat"
    });
  }
}
class tbe {
  constructor(o) {
    this.axiosConfig = KL(o, "axios", {}), this.validateAxiosConfig(), this.initSerializers(o), this.initInterceptors(o), this.initAxios(), this.search = this.search.bind(this), this.axiosCancelToken = oB.CancelToken;
  }
  validateAxiosConfig() {
    if (!BFe(this.axiosConfig, "url"))
      throw new Error("InvenioSearchApi config: `url` field is required.");
  }
  initInterceptors(o) {
    this.requestInterceptor = KL(o, "interceptors.request", void 0), this.responseInterceptor = KL(o, "interceptors.response", void 0);
  }
  getSerializer(o) {
    const c = {
      InvenioRecordsResourcesRequestSerializer: zze,
      InvenioRequestSerializer: rme
    };
    return typeof o == "string" ? c[o] : o || rme;
  }
  initSerializers(o) {
    var c;
    const i = this.getSerializer((c = o.invenio) === null || c === void 0 ? void 0 : c.requestSerializer), d = KL(o, "invenio.responseSerializer", Fze);
    this.requestSerializer = new i(), this.responseSerializer = new d();
  }
  initAxios() {
    const o = {
      paramsSerializer: this.requestSerializer.serialize,
      ...this.axiosConfig
    };
    this.http = oB.create(o), this.addInterceptors();
  }
  addInterceptors() {
    this.requestInterceptor && this.http.interceptors.request.use(this.requestInterceptor.resolve, this.requestInterceptor.reject), this.responseInterceptor && this.http.interceptors.request.use(this.responseInterceptor.resolve, this.responseInterceptor.reject);
  }
  /**
   * Perform the backend request to search and return the serialized list of results for the app state `results`.
   * @param {string} stateQuery the `query` state with the user input
   */
  async search(o) {
    this.axiosCancel && this.axiosCancel.cancel(), this.axiosCancel = this.axiosCancelToken.source();
    try {
      let c = await this.http.request({
        url: this.axiosConfig.url,
        params: o,
        cancelToken: this.axiosCancel.token
      });
      c = this.responseSerializer.serialize(c.data);
      const i = Jve(o, c.extras, ebe);
      return nw(i) || (c.newQueryState = i), delete c.extras, c;
    } catch (c) {
      throw oB.isCancel(c) ? new kie() : c;
    }
  }
}
class Vze {
  constructor() {
    this.isValid = (o, c, i) => {
      switch (c) {
        case "queryString":
        case "sortBy":
          return !0;
        case "sortOrder":
          return ["asc", "desc"].includes(i);
        case "page":
        case "size":
          return P7e(i) && i > 0;
        case "layout":
          return ["grid", "list"].includes(i);
        case "filters":
        case "hiddenParams": {
          const d = Sge(i) ? i : [i], m = ":", v = o.urlFilterSeparator, g = `[^\\${m}\\${v}]*`, C = `${g}\\${m}${g}`, O = `${C}(\\${v}${C})*`, R = new RegExp(`^${O}$`);
          return d.every((I) => String(I).match(R));
        }
        default:
          return !1;
      }
    };
  }
}
const Uze = (r) => {
  window.history.pushState && window.history.pushState({
    path: r
  }, "", r);
}, sme = (r) => {
  window.history.replaceState && window.history.replaceState({
    path: r
  }, "", r);
};
class Wze {
  constructor() {
    this._convertValue = (o, c) => {
      switch (o) {
        case this.paramsMapping.page:
        case this.paramsMapping.size:
          return parseInt(c);
        default:
          return c;
      }
    }, this.parse = this.parse.bind(this), this.paramsMapping = {};
  }
  set urlParamsMapping(o) {
    this.paramsMapping = o;
  }
  /**
   * Parse the URL query string and return an object with all the params.
   * @param {string} queryString the query string to parse
   */
  parse() {
    let o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    const c = lI.parse(o, {
      ignoreQueryPrefix: !0
    }), i = {};
    return Object.entries(c).forEach((d) => {
      const m = d[0], v = d[1];
      i[m] = this._convertValue(m, v);
    }), i;
  }
}
class jze {
  constructor() {
    let o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (this._filterListToString = (c) => {
      const i = c.length === 3 ? this.urlFilterSeparator.concat(this._filterListToString(c[2])) : "";
      return `${c[0]}:${c[1]}${i}`;
    }, this._mapQueryStateToUrlParams = (c) => {
      const i = {};
      Object.keys(c).filter((m) => m in this.urlParamsMapping).filter((m) => (m === "page" || m === "size") && c[m] <= 0 || m === "hiddenParams" ? !1 : c[m] !== null).forEach((m) => {
        const v = this.urlParamsMapping[m];
        m === "filters" ? i[v] = c[m].map((g) => this._filterListToString(g)) : i[v] = c[m];
      });
      const d = (m, v) => {
        const g = "q";
        return m === g ? -1 : v === g ? 1 : m.localeCompare(v);
      };
      return lI.stringify(i, {
        addQueryPrefix: !0,
        skipNulls: !0,
        indices: !1,
        // order for filters params is not important, remove indices
        sort: d
      });
    }, this._filterStringToList = (c) => {
      const i = c.indexOf(this.urlFilterSeparator), d = i > -1, m = c.indexOf(":");
      if (m === -1)
        throw new Error(`Filter "${c}" not parsable. Format expected: "<agg name>:<value>"`);
      const v = c.slice(0, m), g = d ? i : c.length, C = c.slice(m + 1, g);
      let O = [v, C];
      if (d) {
        const R = c.slice(i + 1, c.length);
        O.push(this._filterStringToList(R));
      }
      return O;
    }, this._mapUrlParamsToQueryState = (c) => {
      const i = {};
      return Object.keys(c).forEach((d) => {
        const m = this.fromUrlParamsMapping[d];
        this.urlParamValidator.isValid(this, m, c[d]) ? (i[m] = c[d], m === "filters" && (Array.isArray(c[d]) || (c[d] = [c[d]]), i[m] = c[d].map((v) => this._filterStringToList(v)))) : console.warn(`URL parameter '${d}' with value '${c[d]}' is incorrect and was ignored.`);
      }), i;
    }, this._mergeParamsIntoState = (c, i) => {
      const d = ZD(i);
      return Object.keys(c).forEach((m) => {
        d[m] = c[m];
      }), d;
    }, this.urlParamsMapping = nRe(o.urlParamsMapping) ? o.urlParamsMapping : {
      queryString: "q",
      sortBy: "sort",
      sortOrder: "order",
      page: "p",
      size: "s",
      layout: "l",
      filters: "f",
      hiddenParams: "hp"
    }, this.keepHistory = o.keepHistory !== void 0 ? o.keepHistory : !0, !S7e(this.keepHistory))
      throw new Error(`"keepHistory configuration must be a boolean, ${this.keepHistory} provided.`);
    if (this.urlFilterSeparator = o.urlFilterSeparator !== void 0 ? o.urlFilterSeparator : "+", !O7e(this.urlFilterSeparator))
      throw new Error(`"urlFilterSeparator configuration must be a string, ${this.urlFilterSeparator} provided.`);
    this.urlParamValidator = o.urlParamValidator || new Vze(), this.urlParser = o.urlParser || new Wze(), this.urlParser.urlParamsMapping = this.urlParamsMapping, this.fromUrlParamsMapping = {}, Object.keys(this.urlParamsMapping).forEach((c) => {
      this.fromUrlParamsMapping[this.urlParamsMapping[c]] = c;
    }), this.get = this.get.bind(this), this.set = this.set.bind(this), this.replace = this.replace.bind(this);
  }
  /**
   * Return a new version of the given `query` state with updated values parsed from the URL query string.
   * @param {object} queryState the `query` state
   */
  get(o) {
    const c = this.urlParser.parse(window.location.search), i = this._mapUrlParamsToQueryState(c), d = this._mergeParamsIntoState(i, o), m = this._mapQueryStateToUrlParams(d);
    return sme(m), d;
  }
  /**
   * Update the URL query string parameters from the given `query` state
   * @param {object} stateQuery the `query` state
   */
  set(o) {
    if (this.keepHistory) {
      const c = this._mapQueryStateToUrlParams(o);
      Uze(c);
    } else
      this.replace(o);
  }
  /**
   * Replace the URL query string parameters from the given `query` state
   * @param {object} stateQuery the `query` state
   */
  replace(o) {
    const c = this._mapQueryStateToUrlParams(o);
    sme(c);
  }
}
const qze = "SET_QUERY_COMPONENT_INITIAL_STATE", nbe = "SET_QUERY_STRING", Nie = "SET_QUERY_SORTING", Rie = "SET_QUERY_SORT_BY", Pie = "SET_QUERY_SORT_ORDER", e5 = "SET_QUERY_STATE", rbe = "SET_QUERY_PAGINATION_PAGE", obe = "SET_QUERY_PAGINATION_SIZE", sbe = "SET_QUERY_FILTERS", abe = "SET_QUERY_SUGGESTIONS", ibe = "SET_SUGGESTION_STRING", cbe = "CLEAR_QUERY_SUGGESTIONS", lbe = "RESULTS_LOADING", ube = "RESULTS_FETCH_SUCCESS", dbe = "RESULTS_FETCH_ERROR", Lse = "RESULTS_UPDATE_LAYOUT", fbe = "RESET_QUERY", Gze = (r) => (o) => {
  r && o(L1({
    shouldUpdateUrlQueryString: !1,
    shouldReplaceUrlQueryString: !0
  }));
}, mbe = (r) => (o) => {
  o({
    type: e5,
    payload: r
  }), o(L1());
}, pbe = (r) => (o) => {
  o({
    type: nbe,
    payload: r
  }), o(L1());
}, Zze = (r, o) => (c) => {
  c({
    type: Nie,
    payload: {
      sortBy: r,
      sortOrder: o
    }
  }), c(L1());
}, Kze = (r) => (o) => {
  o({
    type: Rie,
    payload: r
  }), o(L1());
}, Yze = (r) => (o) => {
  o({
    type: Pie,
    payload: r
  }), o(L1());
}, Qze = (r) => (o) => {
  o({
    type: rbe,
    payload: r
  }), o(L1());
}, Xze = (r) => (o) => {
  o({
    type: obe,
    payload: r
  }), o(L1());
}, Die = (r) => (o) => {
  o({
    type: sbe,
    payload: r
  }), o(L1());
}, Jze = (r) => async (o, c, i) => {
  const d = i.urlHandlerApi;
  if (d) {
    await o({
      type: Lse,
      payload: r
    });
    const m = c().query;
    d.set(m);
  } else
    o({
      type: Lse,
      payload: r
    });
}, eVe = () => (r, o, c) => {
  r({
    type: fbe,
    payload: {
      queryString: "",
      page: 1,
      filters: [],
      ...c.initialQueryState
    }
  }), r(L1());
}, tVe = (r, o, c, i) => {
  const d = o.urlHandlerApi;
  d && (c ? d.replace(r) : i && d.set(r));
}, nVe = (r, o, c, i) => {
  const d = c().query;
  o({
    type: e5,
    payload: {
      ...d,
      ...r.newQueryState
    }
  });
  const m = ZD(c().query), v = i.urlHandlerApi;
  return v && v.replace(m), delete r.newStateQuery, r;
}, rVe = (r, o, c, i) => {
  function d(g, C, O, R) {
    g.queryString === "" ? (g.sortBy = O.defaultSortingOnEmptyQueryString.sortBy, g.sortOrder = O.defaultSortingOnEmptyQueryString.sortOrder) : (g.sortBy = C.initialSortBy, g.sortOrder = C.initialSortOrder), R({
      type: e5,
      payload: g
    });
  }
  function m(g, C, O, R) {
    C.hasUserChangedSorting || d(g, C, O, R);
  }
  !nw(c.defaultSortingOnEmptyQueryString) && m(r, o, c, i);
}, L1 = function() {
  let {
    shouldUpdateUrlQueryString: r = !0,
    shouldReplaceUrlQueryString: o = !1
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return async (c, i, d) => {
    const m = i().app;
    let v = ZD(i().query);
    rVe(v, m, d, c), v = ZD(i().query), tVe(v, d, o, r), c({
      type: lbe
    });
    try {
      let C = await d.searchApi.search(v);
      "newQueryState" in C && (C = nVe(ZD(C), c, i, d)), c({
        type: ube,
        payload: {
          aggregations: C.aggregations,
          hits: C.hits,
          total: C.total
        }
      });
    } catch (g) {
      if (g instanceof kie) {
        console.debug(g);
        return;
      } else
        console.error(g), c({
          type: dbe,
          payload: {
            error: g
          }
        });
    }
  };
}, oVe = (r) => (o) => {
  o({
    type: ibe,
    payload: r
  }), o(sVe());
}, sVe = () => async (r, o, c) => {
  const i = ZD(o().query), d = c.suggestionApi;
  try {
    const m = await d.search(i);
    r({
      type: abe,
      payload: {
        suggestions: m.suggestions
      }
    });
  } catch (m) {
    console.error("Could not load suggestions due to: " + m);
  }
}, aVe = () => (r) => {
  r({
    type: cbe,
    payload: {
      suggestions: []
    }
  });
}, iVe = () => (r, o, c) => {
  if (c.urlHandlerApi) {
    const i = c.urlHandlerApi.get(c.initialQueryState);
    r({
      type: e5,
      payload: i
    }), r(L1({
      shouldReplaceUrlQueryString: !0
    }));
  }
}, Zc = /* @__PURE__ */ ae.createContext({}), cVe = function() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  switch ((arguments.length > 1 ? arguments[1] : void 0).type) {
    case Nie:
      return {
        ...r,
        hasUserChangedSorting: !0
      };
    case Rie:
      return {
        ...r,
        hasUserChangedSorting: !0
      };
    case Pie:
      return {
        ...r,
        hasUserChangedSorting: !0
      };
    default:
      return r;
  }
}, lVe = function() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, o = arguments.length > 1 ? arguments[1] : void 0;
  switch (o.type) {
    case nbe:
      return {
        ...r,
        queryString: o.payload,
        page: 1
      };
    case Nie:
      return {
        ...r,
        sortBy: o.payload.sortBy,
        sortOrder: o.payload.sortOrder,
        _sortUserChanged: !0,
        page: 1
      };
    case Rie:
      return {
        ...r,
        sortBy: o.payload,
        _sortUserChanged: !0,
        page: 1
      };
    case Pie:
      return {
        ...r,
        sortOrder: o.payload,
        _sortUserChanged: !0,
        page: 1
      };
    case rbe:
      return {
        ...r,
        page: o.payload
      };
    case obe:
      return {
        ...r,
        size: o.payload,
        page: 1
      };
    case sbe:
      return {
        ...r,
        page: 1,
        filters: Xve(o.payload, r.filters)
      };
    case abe:
      return {
        ...r,
        suggestions: o.payload.suggestions
      };
    case cbe:
      return {
        ...r,
        suggestions: o.payload.suggestions
      };
    case ibe:
      return {
        ...r,
        suggestionString: o.payload
      };
    case qze:
      return {
        ...r,
        ...o.payload
      };
    case e5:
      return {
        ...r,
        ...QW,
        ...Jve(QW, o.payload, ebe)
      };
    case Lse:
      return {
        ...r,
        layout: o.payload
      };
    case fbe:
      return {
        ...r,
        ...o.payload
      };
    default:
      return r;
  }
}, uVe = function() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, o = arguments.length > 1 ? arguments[1] : void 0;
  switch (o.type) {
    case lbe:
      return {
        ...r,
        loading: !0,
        data: {
          ...r.data
        }
      };
    case ube:
      return {
        loading: !1,
        data: {
          ...r.data,
          aggregations: o.payload.aggregations,
          hits: o.payload.hits,
          total: o.payload.total
        },
        error: {}
      };
    case dbe:
      return {
        loading: !1,
        data: {
          ...r.data,
          aggregations: {},
          hits: [],
          total: 0
        },
        error: o.payload.error
      };
    default:
      return r;
  }
};
var dVe = Rze({
  app: cVe,
  query: lVe,
  results: uVe
});
function ame(r, o) {
  let {
    sortBy: c,
    sortOrder: i
  } = r, {
    sortBy: d,
    sortOrder: m
  } = o;
  return c !== d || i !== m;
}
function fVe(r, o, c) {
  const i = ame(c, o), d = !nw(r.defaultSortingOnEmptyQueryString);
  let m = !1;
  return d && (m = ame(c, r.defaultSortingOnEmptyQueryString)), i && m;
}
function mVe(r) {
  const o = {
    ...QW,
    ...r.initialQueryState
  }, c = r.urlHandlerApi ? r.urlHandlerApi.get(o) : o, i = fVe(r, o, c), d = {
    ...Hze,
    hasUserChangedSorting: i,
    initialSortBy: o.sortBy,
    initialSortOrder: o.sortOrder
  }, m = {
    ...Bze,
    loading: r.searchOnInit
  };
  return {
    app: d,
    query: c,
    results: m
  };
}
function pVe(r) {
  const o = mVe(r);
  return Zve(dVe, o, Dze($ze.withExtraArgument(r)));
}
function ime(r) {
  let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
  const i = o ? `.${o}` : "";
  return `${c ? `${c}.` : ""}${r}${i}`;
}
class $ie extends Do {
  constructor(o) {
    super(o), this.updateQueryState = (c) => {
      const {
        updateQueryState: i
      } = this.props;
      i(c);
    }, this.onQueryChanged = (c) => {
      let {
        detail: i
      } = c;
      const {
        appName: d
      } = this.context;
      if (!d)
        this.updateQueryState(i.searchQuery);
      else {
        const v = i.appName;
        v === d ? this.updateQueryState(i.searchQuery) : console.debug(`React-SearchKit '${d}': ignoring event sent for app '${v}'`);
      }
    }, this.searchOnInit = o.searchOnInit, this.eventListenerEnabled = o.eventListenerEnabled, this.onAppInitialized = o.onAppInitialized, this.searchOnUrlQueryStringChanged = o.searchOnUrlQueryStringChanged;
  }
  componentDidMount() {
    this.eventListenerEnabled && window.addEventListener("queryChanged", this.onQueryChanged), window.onpopstate = () => {
      this.searchOnUrlQueryStringChanged();
    }, this.onAppInitialized(this.searchOnInit);
  }
  componentWillUnmount() {
    window.onpopstate = () => {
    }, window.removeEventListener("queryChanged", this.onQueryChanged);
  }
  render() {
    const {
      children: o
    } = this.props;
    return o;
  }
}
$ie.defaultProps = {
  searchOnInit: !0,
  eventListenerEnabled: !1
};
$ie.contextType = Zc;
var hVe = zo.component("Bootstrap", $ie);
const gVe = (r) => ({
  onAppInitialized: (o) => r(Gze(o)),
  updateQueryState: (o) => r(mbe(o)),
  searchOnUrlQueryStringChanged: () => r(iVe())
}), vVe = Rd(null, gVe)(hVe);
class Iie extends Do {
  constructor(o) {
    super(o);
    const c = {
      searchApi: o.searchApi,
      suggestionApi: o.suggestionApi,
      urlHandlerApi: o.urlHandlerApi.enabled ? o.urlHandlerApi.customHandler || new jze(o.urlHandlerApi.overrideConfig) : null,
      searchOnInit: o.searchOnInit,
      initialQueryState: o.initialQueryState,
      defaultSortingOnEmptyQueryString: o.defaultSortingOnEmptyQueryString
    };
    this.store = pVe(c), this.appName = o.appName, this.eventListenerEnabled = o.eventListenerEnabled, this.componentIndex = 0;
  }
  render() {
    const {
      appName: o,
      children: c,
      eventListenerEnabled: i,
      overridableId: d,
      searchOnInit: m
    } = this.props, v = {
      appName: o,
      buildUID: (C, O) => ime(C, O, o),
      /* This is an internal function that will be used to create id for the checkboxes and labels, ensuring that
          they are unique */
      nextComponentIndex: () => `${this.appName}_${this.componentIndex++}`
    }, g = ime("ReactSearchKit.children", d, o);
    return /* @__PURE__ */ ae.createElement(Zc.Provider, {
      value: v
    }, /* @__PURE__ */ ae.createElement(zve, {
      store: this.store
    }, /* @__PURE__ */ ae.createElement(vVe, {
      searchOnInit: m,
      eventListenerEnabled: i
    }, /* @__PURE__ */ ae.createElement(zo, {
      id: g
    }, c))));
  }
}
Iie.defaultProps = {
  suggestionApi: null,
  urlHandlerApi: {
    enabled: !0,
    overrideConfig: {},
    customHandler: null
  },
  searchOnInit: !0,
  appName: "",
  eventListenerEnabled: !1,
  overridableId: "",
  initialQueryState: {},
  defaultSortingOnEmptyQueryString: {}
};
Iie.contextType = Zc;
var bVe = zo.component("ReactSearchKit", Iie);
class hbe extends Do {
  constructor(o) {
    super(o), this._getLabel = (c) => {
      const i = c[0];
      let d = c[1], m = [i, d];
      if (c.length === 3) {
        const {
          label: g,
          activeFilter: C
        } = this._getLabel(c[2]);
        d = `${d}.${g}`, m.push(C);
      }
      return {
        label: d,
        activeFilter: m
      };
    }, this.updateQueryFilters = o.updateQueryFilters;
  }
  render() {
    const {
      filters: o,
      overridableId: c
    } = this.props;
    return !!o.length && /* @__PURE__ */ ae.createElement(gbe, {
      filters: o,
      removeActiveFilter: this.updateQueryFilters,
      getLabel: this._getLabel,
      overridableId: c
    });
  }
}
hbe.defaultProps = {
  overridableId: ""
};
const gbe = (r) => {
  let {
    overridableId: o,
    filters: c,
    removeActiveFilter: i,
    getLabel: d
  } = r;
  const {
    buildUID: m
  } = Gc(Zc);
  return /* @__PURE__ */ ae.createElement(zo, {
    id: m("ActiveFilters.element", o),
    filters: c,
    removeActiveFilter: i,
    getLabel: d
  }, /* @__PURE__ */ ae.createElement(ae.Fragment, null, c.map((v, g) => {
    const {
      label: C,
      activeFilter: O
    } = d(v);
    return (
      // eslint-disable-next-line react/no-array-index-key
      /* @__PURE__ */ ae.createElement(Rh, {
        image: !0,
        key: g,
        onClick: () => i(O)
      }, C, /* @__PURE__ */ ae.createElement(fc, {
        name: "delete"
      }))
    );
  })));
};
gbe.defaultProps = {
  overridableId: ""
};
var yVe = zo.component("ActiveFilters", hbe);
const SVe = (r) => ({
  updateQueryFilters: (o) => r(Die(o))
});
Rd((r) => ({
  filters: r.query.filters
}), SVe)(yVe);
function wVe(r, o) {
  o === void 0 && (o = {});
  var c = o.insertAt;
  if (!(!r || typeof document > "u")) {
    var i = document.head || document.getElementsByTagName("head")[0], d = document.createElement("style");
    d.type = "text/css", c === "top" && i.firstChild ? i.insertBefore(d, i.firstChild) : i.appendChild(d), d.styleSheet ? d.styleSheet.cssText = r : d.appendChild(document.createTextNode(r));
  }
}
var EVe = `.AutoCompleteText{position:relative;z-index:100}.AutoCompleteText .input button,.AutoCompleteText .input input{border:none;border-radius:0}.AutoCompleteText ul{background-color:#fff;border:1px solid #e0e1e2;border-radius:0 0 .3rem .3rem;color:#000;list-style-type:none;margin:0;padding:0;position:absolute;text-align:left;width:100%}.AutoCompleteText ul:before{content:""}.AutoCompleteText li{cursor:pointer;padding:.3em 1em}.AutoCompleteText li:hover{background-color:#e0e1e2;border-radius:.3rem;text-decoration:underline}
/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vaG9tZS9ydW5uZXIvd29yay9yZWFjdC1zZWFyY2hraXQvcmVhY3Qtc2VhcmNoa2l0L3NyYy9saWIvY29tcG9uZW50cy9BdXRvY29tcGxldGVTZWFyY2hCYXIvQXV0b2NvbXBsZXRlU2VhcmNoQmFyLnNjc3MiLCJBdXRvY29tcGxldGVTZWFyY2hCYXIuc2NzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxrQkFDRSxpQkFBQSxDQUNBLFdDQ0YsQ0RPQSwrREFDRSxXQUFBLENBQ0EsZUNDRixDREVBLHFCQU1FLHFCQUFBLENBR0Esd0JBQUEsQ0FDQSw2QkFBQSxDQUxBLFVBQUEsQ0FGQSxvQkFBQSxDQUlBLFFBQUEsQ0FDQSxTQUFBLENBTkEsaUJBQUEsQ0FFQSxlQUFBLENBSEEsVUNVRixDREVBLDRCQUNFLFVDQ0YsQ0RFQSxxQkFFRSxjQUFBLENBREEsZ0JDRUYsQ0RFQSwyQkFFRSx3QkFBQSxDQUNBLG1CQUFBLENBRkEseUJDR0YiLCJmaWxlIjoiQXV0b2NvbXBsZXRlU2VhcmNoQmFyLnNjc3MifQ== */`;
wVe(EVe);
class vbe extends Do {
  constructor(o) {
    super(o), this._handleAutocompleteChange = (c) => {
      c.length >= this.minCharsToAutocomplete && this.updateSuggestions(c);
    }, this.onInputChange = async (c) => {
      await this.setState({
        currentValue: c
      }), this.handleAutocompleteChange(this.state.currentValue);
    }, this.executeSearch = () => {
      this.updateQueryString(this.state.currentValue);
    }, this.updateQueryString = this.props.updateQueryString, this.updateSuggestions = this.props.debounce ? Mze.debounce(this.props.updateSuggestions, this.props.debounceTime, {
      leading: !0
    }) : this.props.updateSuggestions, this.clearSuggestions = this.props.clearSuggestions, this.minCharsToAutocomplete = this.props.minCharsToAutocomplete, this.state = {
      currentValue: this.props.queryString || ""
    }, this.handleAutocompleteChange = o.handleAutocompleteChange || this._handleAutocompleteChange;
  }
  render() {
    const {
      placeholder: o,
      suggestions: c,
      overridableId: i
    } = this.props;
    return /* @__PURE__ */ ae.createElement(xVe, {
      placeholder: o,
      queryString: this.state.currentValue,
      querySuggestions: c,
      onInputChange: this.onInputChange,
      executeSearch: this.executeSearch,
      overridableId: i
    });
  }
}
vbe.defaultProps = {
  handleAutocompleteChange: null,
  placeholder: "Type something",
  minCharsToAutocomplete: 3,
  overridableId: ""
};
const CVe = (r) => /* @__PURE__ */ ae.createElement(vbe, Object.assign({
  key: r.queryString
}, r)), xVe = (r) => {
  let {
    overridableId: o,
    placeholder: c,
    queryString: i,
    querySuggestions: d,
    onInputChange: m,
    executeSearch: v,
    ...g
  } = r;
  const {
    buildUID: C
  } = Gc(Zc), O = (I, L) => {
    v();
  }, R = (I, L) => {
    I.key === "Enter" && v();
  };
  return /* @__PURE__ */ ae.createElement(zo, Object.assign({
    id: C("AutocompleteSearchBar.element", o)
  }, g), /* @__PURE__ */ ae.createElement("div", {
    className: "AutoCompleteText"
  }, /* @__PURE__ */ ae.createElement(WB, {
    action: {
      content: "Search",
      onClick: O
    },
    fluid: !0,
    placeholder: c,
    onChange: (I, L) => {
      let {
        value: Z
      } = L;
      m(Z);
    },
    value: i,
    onKeyPress: R
  }), /* @__PURE__ */ ae.createElement(TVe, {
    querySuggestions: d,
    overridableId: o
  })));
}, TVe = (r) => {
  let {
    overridableId: o,
    ...c
  } = r;
  const {
    querySuggestions: i
  } = c, {
    buildUID: d
  } = Gc(Zc), m = async (v) => {
    await (void 0).setState({
      currentValue: v
    }), (void 0).clearSuggestions(), (void 0).executeSearch();
  };
  return i.length === 0 ? null : /* @__PURE__ */ ae.createElement(zo, Object.assign({
    id: d("AutocompleteSearchBar.suggestions", o)
  }, c), /* @__PURE__ */ ae.createElement("ul", null, i.map((v) => /* @__PURE__ */ ae.createElement(hy, {
    as: "li",
    onClick: () => m(v),
    key: v
  }, v))));
};
var _Ve = zo.component("AutocompleteSearchBar", CVe);
const OVe = (r) => ({
  updateQueryString: (o) => r(pbe(o)),
  updateSuggestions: (o) => r(oVe(o)),
  clearSuggestions: () => r(aVe())
}), AVe = (r) => ({
  queryString: r.query.queryString,
  suggestions: r.query.suggestions
});
Rd(AVe, OVe)(_Ve);
class cq extends Do {
  constructor(o) {
    super(o), this._isSelected = (c, i, d) => d.filter((m) => m[0] === c && m[1] === i).length >= 1, this.getChildAggCmps = (c, i) => {
      const d = this.childAgg && this.childAgg.aggName in c;
      let m = [];
      if (d) {
        const v = c[this.childAgg.aggName].buckets;
        i.forEach((C) => {
          const O = C[0] === this.aggName, R = C[1] === c.key, I = C.length === 3;
          O && R && I && m.push(C[2]);
        });
        const g = (C) => {
          this.onFilterClicked([this.aggName, c.key, C]);
        };
        return /* @__PURE__ */ ae.createElement(cq, {
          buckets: v,
          selectedFilters: m,
          field: this.childAgg.field,
          aggName: this.childAgg.aggName,
          childAgg: this.childAgg.childAgg,
          onFilterClicked: g
        });
      }
      return null;
    }, this.field = o.field, this.aggName = o.aggName, this.childAgg = o.childAgg, this.onFilterClicked = o.onFilterClicked;
  }
  render() {
    const {
      buckets: o,
      selectedFilters: c,
      overridableId: i
    } = this.props, d = o.map((m) => {
      const v = m.key_as_string ? m.key_as_string : m.key, g = this._isSelected(this.aggName, v, c), C = (R) => {
        this.onFilterClicked([this.aggName, R]);
      }, O = (R) => this.getChildAggCmps(R, c);
      return /* @__PURE__ */ ae.createElement(ybe, {
        key: m.key,
        bucket: m,
        keyField: v,
        isSelected: g,
        onFilterClicked: C,
        getChildAggCmps: O,
        overridableId: i
      });
    });
    return /* @__PURE__ */ ae.createElement(bbe, {
      valuesCmp: d,
      overridableId: i
    });
  }
}
cq.defaultProps = {
  childAgg: null,
  overridableId: ""
};
const bbe = (r) => {
  let {
    valuesCmp: o,
    overridableId: c
  } = r;
  const {
    buildUID: i
  } = Gc(Zc);
  return /* @__PURE__ */ ae.createElement(zo, {
    id: i("BucketAggregationContainer.element", c),
    valuesCmp: o
  }, /* @__PURE__ */ ae.createElement(Rae, null, o));
};
bbe.defaultProps = {
  overridableId: ""
};
const ybe = (r) => {
  let {
    bucket: o,
    isSelected: c,
    onFilterClicked: i,
    getChildAggCmps: d,
    overridableId: m,
    keyField: v
  } = r;
  const {
    buildUID: g,
    nextComponentIndex: C
  } = Gc(Zc), O = o.label ? o.label : `${v} (${o.doc_count.toLocaleString("en-US")})`, R = d(o);
  return /* @__PURE__ */ ae.createElement(zo, {
    id: g("BucketAggregationValues.element", m),
    bucket: o,
    label: O,
    onFilterClicked: i,
    isSelected: c,
    childAggCmps: R
  }, /* @__PURE__ */ ae.createElement(Rae.Item, {
    key: o.key
  }, /* @__PURE__ */ ae.createElement(Iv, {
    label: O,
    id: C(),
    value: o.key,
    onClick: () => i(o.key),
    checked: c
  }), R));
};
ybe.defaultProps = {
  overridableId: ""
};
var kVe = zo.component("BucketAggregationValues", cq);
class Sbe extends Do {
  constructor(o) {
    super(o), this.onFilterClicked = (c) => {
      this.updateQueryFilters(c);
    }, this._renderValues = (c, i) => {
      const {
        overridableId: d
      } = this.props;
      return /* @__PURE__ */ ae.createElement(kVe, {
        buckets: c,
        selectedFilters: i,
        field: this.agg.field,
        aggName: this.agg.aggName,
        childAgg: this.agg.childAgg,
        onFilterClicked: this.onFilterClicked,
        overridableId: d
      });
    }, this._getSelectedFilters = (c) => c.filter((i) => i[0] === this.agg.aggName), this._getResultBuckets = (c) => {
      const i = KL(c, this.agg.aggName, {});
      return "buckets" in i ? (Array.isArray(i.buckets) || (i.buckets = Object.entries(i.buckets).map((d) => {
        let [m, v] = d;
        return {
          ...v,
          key: m
        };
      })), i.buckets) : [];
    }, this.title = o.title, this.agg = o.agg, this.updateQueryFilters = o.updateQueryFilters;
  }
  render() {
    const {
      userSelectionFilters: o,
      resultsAggregations: c,
      overridableId: i,
      ...d
    } = this.props, m = this._getSelectedFilters(o), v = this._getResultBuckets(c), g = v.length ? this._renderValues(v, m) : null;
    return /* @__PURE__ */ ae.createElement(wbe, Object.assign({
      title: this.title,
      containerCmp: g,
      overridableId: i
    }, d));
  }
}
Sbe.defaultProps = {
  overridableId: ""
};
const wbe = (r) => {
  let {
    overridableId: o,
    agg: c,
    title: i,
    containerCmp: d,
    updateQueryFilters: m
  } = r;
  const {
    buildUID: v
  } = Gc(Zc);
  return d && /* @__PURE__ */ ae.createElement(zo, {
    id: v("BucketAggregation.element", o),
    agg: c,
    title: i,
    containerCmp: d,
    updateQueryFilters: m
  }, /* @__PURE__ */ ae.createElement(Tu, null, /* @__PURE__ */ ae.createElement(Tu.Content, null, /* @__PURE__ */ ae.createElement(Tu.Header, null, i)), /* @__PURE__ */ ae.createElement(Tu.Content, null, d)));
};
wbe.defaultProps = {
  containerCmp: null,
  overridableId: ""
};
var NVe = zo.component("BucketAggregation", Sbe);
const RVe = (r) => ({
  updateQueryFilters: (o) => r(Die(o))
});
Rd((r) => ({
  userSelectionFilters: r.query.filters,
  resultsAggregations: r.results.data.aggregations
}), RVe)(NVe);
class Ebe extends Do {
  render() {
    const {
      children: o,
      condition: c
    } = this.props;
    return c ? o : null;
  }
}
Ebe.defaultProps = {
  condition: !0
};
var yy = zo.component("ShouldRender", Ebe);
class Cbe extends Do {
  render() {
    const {
      loading: o,
      totalResults: c,
      label: i,
      overridableId: d
    } = this.props;
    return /* @__PURE__ */ ae.createElement(yy, {
      condition: !o && c > 0
    }, i(/* @__PURE__ */ ae.createElement(xbe, {
      totalResults: c,
      overridableId: d
    })));
  }
}
Cbe.defaultProps = {
  label: (r) => r,
  overridableId: ""
};
const xbe = (r) => {
  let {
    totalResults: o,
    overridableId: c
  } = r;
  const {
    buildUID: i
  } = Gc(Zc), d = i("Count.element", c);
  return /* @__PURE__ */ ae.createElement(zo, {
    id: d,
    totalResults: o
  }, /* @__PURE__ */ ae.createElement(Rh, {
    color: "blue"
  }, o.toLocaleString("en-US")));
};
xbe.defaultProps = {
  overridableId: ""
};
var PVe = zo.component("Count", Cbe);
const DVe = Rd((r) => ({
  loading: r.results.loading,
  totalResults: r.results.data.total
}))(PVe);
class Tbe extends Do {
  constructor(o) {
    super(o), this.resetQuery = o.resetQuery;
  }
  render() {
    const {
      loading: o,
      totalResults: c,
      error: i,
      queryString: d,
      extraContent: m,
      overridableId: v,
      userSelectionFilters: g,
      ...C
    } = this.props;
    return /* @__PURE__ */ ae.createElement(yy, {
      condition: !o && nw(i) && c === 0
    }, /* @__PURE__ */ ae.createElement(_be, Object.assign({}, C, {
      queryString: d,
      resetQuery: this.resetQuery,
      extraContent: m,
      userSelectionFilters: g,
      overridableId: v
    })));
  }
}
Tbe.defaultProps = {
  queryString: "",
  extraContent: null,
  overridableId: ""
};
const _be = (r) => {
  let {
    overridableId: o,
    queryString: c,
    resetQuery: i,
    extraContent: d,
    userSelectionFilters: m
  } = r;
  const {
    buildUID: v
  } = Gc(Zc);
  return /* @__PURE__ */ ae.createElement(zo, {
    id: v("EmptyResults.element", o),
    queryString: c,
    resetQuery: i,
    extraContent: d,
    userSelectionFilters: m
  }, /* @__PURE__ */ ae.createElement(ZS, {
    placeholder: !0,
    textAlign: "center"
  }, /* @__PURE__ */ ae.createElement(yC, {
    icon: !0
  }, /* @__PURE__ */ ae.createElement(fc, {
    name: "search"
  }), "No results found!"), c && /* @__PURE__ */ ae.createElement("em", null, 'Current search "', c, '"'), /* @__PURE__ */ ae.createElement("br", null), /* @__PURE__ */ ae.createElement(hy, {
    primary: !0,
    onClick: () => i()
  }, "Clear query"), d));
};
_be.defaultProps = {
  queryString: "",
  extraContent: null,
  overridableId: ""
};
var $Ve = zo.component("EmptyResults", Tbe);
const IVe = (r) => ({
  resetQuery: () => r(eVe())
}), MVe = Rd((r) => ({
  loading: r.results.loading,
  totalResults: r.results.data.total,
  error: r.results.error,
  queryString: r.query.queryString,
  userSelectionFilters: r.query.filters
}), IVe)($Ve);
function Obe(r) {
  let {
    loading: o,
    error: c,
    overridableId: i
  } = r;
  return /* @__PURE__ */ ae.createElement(yy, {
    condition: !o && !nw(c)
  }, /* @__PURE__ */ ae.createElement(Abe, {
    error: c,
    overridableId: i
  }));
}
Obe.defaultProps = {
  overridableId: ""
};
const Abe = (r) => {
  let {
    error: o,
    overridableId: c
  } = r;
  const {
    buildUID: i
  } = Gc(Zc);
  return /* @__PURE__ */ ae.createElement(zo, {
    id: i("Error.element", c),
    error: o
  }, /* @__PURE__ */ ae.createElement("div", null, "Oops! Something went wrong while fetching results."));
};
Abe.defaultProps = {
  overridableId: ""
};
var FVe = zo.component("Error", Obe);
Rd((r) => ({
  loading: r.results.loading,
  error: r.results.error
}))(FVe);
function LVe(r) {
  const o = (d) => /* @__PURE__ */ ae.createElement(r, d);
  return Rd((d) => ({
    currentQueryState: d.query,
    currentResultsState: d.results
  }), (d) => ({
    updateQueryState: (m) => d(mbe(m))
  }))(o);
}
class kbe extends Do {
  constructor(o) {
    super(o), this.onLayoutChange = (c) => {
      this.updateLayout(c);
    }, this.updateLayout = o.updateLayout;
  }
  render() {
    const {
      currentLayout: o,
      loading: c,
      totalResults: i,
      overridableId: d
    } = this.props;
    return /* @__PURE__ */ ae.createElement(yy, {
      condition: o !== null && !c && i > 0
    }, /* @__PURE__ */ ae.createElement(Nbe, {
      currentLayout: o,
      onLayoutChange: this.onLayoutChange,
      overridableId: d
    }));
  }
}
kbe.defaultProps = {
  currentLayout: null,
  overridableId: ""
};
const Nbe = (r) => {
  let {
    overridableId: o,
    currentLayout: c,
    onLayoutChange: i
  } = r;
  const {
    buildUID: d
  } = Gc(Zc);
  return /* @__PURE__ */ ae.createElement(zo, {
    id: d("LayoutSwitcher.element", o),
    currentLayout: c,
    onLayoutChange: i
  }, /* @__PURE__ */ ae.createElement(h2, {
    compact: !0,
    icon: !0
  }, /* @__PURE__ */ ae.createElement(h2.Item, {
    name: "list",
    active: c === "list",
    onClick: (m, v) => {
      let {
        name: g
      } = v;
      return i(g);
    }
  }, /* @__PURE__ */ ae.createElement(fc, {
    name: "list layout"
  })), /* @__PURE__ */ ae.createElement(h2.Item, {
    name: "grid",
    active: c === "grid",
    onClick: (m, v) => {
      let {
        name: g
      } = v;
      return i(g);
    }
  }, /* @__PURE__ */ ae.createElement(fc, {
    name: "grid layout"
  }))));
};
Nbe.defaultProps = {
  currentLayout: null,
  overridableId: ""
};
var BVe = zo.component("LayoutSwitcher", kbe);
const HVe = (r) => ({
  updateLayout: (o) => r(Jze(o))
});
Rd((r) => ({
  loading: r.results.loading,
  currentLayout: r.query.layout,
  totalResults: r.results.data.total
}), HVe)(BVe);
const cme = {
  boundaryRangeCount: 1,
  siblingRangeCount: 1,
  showEllipsis: !0,
  showFirst: !0,
  showLast: !0,
  showPrev: !0,
  showNext: !0,
  size: "large"
};
class Rbe extends Do {
  constructor(o) {
    super(o), this.onPageChange = (c) => {
      const {
        currentPage: i
      } = this.props;
      c !== i && this.updateQueryPage(c);
    }, this.updateQueryPage = o.updateQueryPage, this.options = o.options ? {
      ...cme,
      ...o.options
    } : cme;
  }
  render() {
    const {
      loading: o,
      totalResults: c,
      currentPage: i,
      currentSize: d,
      overridableId: m,
      showWhenOnlyOnePage: v
    } = this.props;
    return /* @__PURE__ */ ae.createElement(yy, {
      condition: !o && i > -1 && d > -1 && v ? c > 0 : c > d
    }, /* @__PURE__ */ ae.createElement(Pbe, {
      currentPage: i,
      currentSize: d,
      totalResults: c,
      onPageChange: this.onPageChange,
      options: this.options,
      overridableId: m,
      maxTotalResults: this.options.maxTotalResults
    }));
  }
}
Rbe.defaultProps = {
  options: {},
  overridableId: "",
  showWhenOnlyOnePage: !0
};
const Pbe = (r) => {
  let {
    overridableId: o,
    currentPage: c,
    currentSize: i,
    totalResults: d,
    onPageChange: m,
    options: v,
    maxTotalResults: g,
    ...C
  } = r;
  const O = v.boundaryRangeCount, R = v.siblingRangeCount, I = v.showEllipsis, L = v.showFirst, Z = v.showLast, ne = v.showPrev, se = v.showNext, Q = v.size, he = Math.floor(g / i), ue = Math.ceil(d / i), G = Math.min(ue, he), {
    buildUID: me
  } = Gc(Zc);
  return c > ue && m(ue), /* @__PURE__ */ ae.createElement(zo, {
    id: me("Pagination.element", o),
    currentPage: c,
    currentSize: i,
    totalResults: d,
    options: v,
    onPageChange: m
  }, /* @__PURE__ */ ae.createElement(Pk, Object.assign({
    activePage: c,
    totalPages: G,
    onPageChange: (we, be) => {
      let {
        activePage: q
      } = be;
      return m(q);
    },
    boundaryRange: O,
    siblingRange: R,
    ellipsisItem: I ? void 0 : null,
    firstItem: L ? void 0 : null,
    lastItem: Z ? void 0 : null,
    prevItem: ne ? void 0 : null,
    nextItem: se ? void 0 : null,
    size: Q
  }, C)));
};
Pbe.defaultProps = {
  options: {},
  overridableId: "",
  maxTotalResults: 1e4
};
var zVe = zo.component("Pagination", Rbe);
const VVe = (r) => ({
  updateQueryPage: (o) => r(Qze(o))
}), UVe = Rd((r) => ({
  currentPage: r.query.page,
  currentSize: r.query.size,
  loading: r.results.loading,
  totalResults: r.results.data.total
}), VVe)(zVe);
function Dbe(r) {
  let {
    loading: o,
    totalResults: c,
    results: i,
    resultsPerRow: d,
    overridableId: m,
    onResultsRendered: v
  } = r;
  return Ch(() => {
    v && v();
  }, [v]), /* @__PURE__ */ ae.createElement(yy, {
    condition: !o && c > 0
  }, /* @__PURE__ */ ae.createElement($be, {
    results: i,
    resultsPerRow: d,
    overridableId: m
  }));
}
Dbe.defaultProps = {
  resultsPerRow: 3,
  overridableId: "",
  onResultsRendered: () => {
  }
};
const WVe = (r) => {
  let {
    result: o,
    overridableId: c
  } = r;
  const {
    buildUID: i
  } = Gc(Zc);
  return /* @__PURE__ */ ae.createElement(zo, {
    id: i("ResultsGrid.item", c),
    result: o
  }, /* @__PURE__ */ ae.createElement(Tu, {
    fluid: !0,
    href: `#${o.id}`
  }, /* @__PURE__ */ ae.createElement(Qf, {
    src: o.imgSrc || "http://placehold.it/200"
  }), /* @__PURE__ */ ae.createElement(Tu.Content, null, /* @__PURE__ */ ae.createElement(Tu.Header, null, o.title), /* @__PURE__ */ ae.createElement(Tu.Description, null, o.description))));
}, $be = (r) => {
  let {
    overridableId: o,
    results: c,
    resultsPerRow: i
  } = r;
  const {
    buildUID: d
  } = Gc(Zc), m = c.map((v, g) => (
    // eslint-disable-next-line react/no-array-index-key
    /* @__PURE__ */ ae.createElement(WVe, {
      key: g,
      result: v,
      overridableId: o
    })
  ));
  return /* @__PURE__ */ ae.createElement(zo, {
    id: d("ResultsGrid.container", o),
    results: m,
    resultsPerRow: i
  }, /* @__PURE__ */ ae.createElement(Tu.Group, {
    itemsPerRow: i
  }, m));
};
$be.defaultProps = {
  resultsPerRow: 3,
  overridableId: ""
};
var jVe = zo.component("ResultsGrid", Dbe);
const qVe = Rd((r) => ({
  loading: r.results.loading,
  totalResults: r.results.data.total,
  results: r.results.data.hits
}))(jVe);
function Ibe(r) {
  let {
    loading: o,
    totalResults: c,
    results: i,
    overridableId: d,
    onResultsRendered: m
  } = r;
  return Ch(() => {
    m && m();
  }, [m]), /* @__PURE__ */ ae.createElement(yy, {
    condition: !o && c > 0
  }, /* @__PURE__ */ ae.createElement(Mbe, {
    results: i,
    overridableId: d
  }));
}
Ibe.defaultProps = {
  overridableId: "",
  onResultsRendered: () => {
  }
};
const GVe = (r) => {
  let {
    result: o,
    overridableId: c
  } = r;
  const {
    buildUID: i
  } = Gc(Zc);
  return /* @__PURE__ */ ae.createElement(zo, {
    id: i("ResultsList.item", c),
    result: o
  }, /* @__PURE__ */ ae.createElement(rf, {
    href: `#${o.id}`
  }, /* @__PURE__ */ ae.createElement(rf.Image, {
    size: "small",
    src: o.imgSrc || "http://placehold.it/200"
  }), /* @__PURE__ */ ae.createElement(rf.Content, null, /* @__PURE__ */ ae.createElement(rf.Header, null, o.title), /* @__PURE__ */ ae.createElement(rf.Description, null, o.description))));
}, Mbe = (r) => {
  let {
    results: o,
    overridableId: c
  } = r;
  const {
    buildUID: i
  } = Gc(Zc), d = o.map((m, v) => (
    // eslint-disable-next-line react/no-array-index-key
    /* @__PURE__ */ ae.createElement(GVe, {
      result: m,
      key: v,
      overridableId: c
    })
  ));
  return /* @__PURE__ */ ae.createElement(zo, {
    id: i("ResultsList.container", c),
    results: d
  }, /* @__PURE__ */ ae.createElement(rf.Group, {
    divided: !0,
    relaxed: !0,
    link: !0
  }, d));
};
Mbe.defaultProps = {
  overridableId: ""
};
var ZVe = zo.component("ResultsList", Ibe);
const Fbe = Rd((r) => ({
  loading: r.results.loading,
  totalResults: r.results.data.total,
  results: r.results.data.hits
}))(ZVe);
function Lbe(r) {
  let {
    children: o,
    loading: c,
    overridableId: i
  } = r;
  return c ? /* @__PURE__ */ ae.createElement(Bbe, {
    overridableId: i
  }) : o;
}
Lbe.defaultProps = {
  overridableId: ""
};
const Bbe = (r) => {
  let {
    overridableId: o
  } = r;
  const {
    buildUID: c
  } = Gc(Zc);
  return /* @__PURE__ */ ae.createElement(zo, {
    id: c("ResultsLoader.element", o)
  }, /* @__PURE__ */ ae.createElement(h$, {
    active: !0,
    size: "huge",
    inline: "centered"
  }));
};
Bbe.defaultProps = {
  overridableId: ""
};
var KVe = zo.component("ResultsLoader", Lbe);
const YVe = Rd((r) => ({
  loading: r.results.loading
}))(KVe);
function Hbe(r) {
  let {
    loading: o,
    totalResults: c,
    currentLayout: i,
    overridableId: d,
    onResultsRendered: m
  } = r;
  return /* @__PURE__ */ ae.createElement(yy, {
    condition: i != null && !o && c > 0
  }, /* @__PURE__ */ ae.createElement(zbe, {
    layout: i,
    overridableId: d,
    onResultsRendered: m
  }));
}
Hbe.defaultProps = {
  currentLayout: null,
  overridableId: "",
  onResultsRendered: () => {
  }
};
const zbe = (r) => {
  let {
    layout: o,
    overridableId: c,
    onResultsRendered: i
  } = r;
  const {
    buildUID: d
  } = Gc(Zc);
  return /* @__PURE__ */ ae.createElement(zo, {
    id: d("ResultsMultiLayout.element", c),
    layout: o,
    onResultsRendered: i
  }, o === "list" ? /* @__PURE__ */ ae.createElement(Fbe, {
    overridableId: c,
    onResultsRendered: i
  }) : /* @__PURE__ */ ae.createElement(qVe, {
    overridableId: c,
    onResultsRendered: i
  }));
};
zbe.defaultProps = {
  layout: "",
  overridableId: "",
  onResultsRendered: () => {
  }
};
var QVe = zo.component("ResultsMultiLayout", Hbe);
Rd((r) => ({
  loading: r.results.loading,
  totalResults: r.results.data.total,
  currentLayout: r.query.layout
}))(QVe);
class Vbe extends Do {
  constructor(o) {
    super(o), this.onChange = (c) => {
      const {
        currentSize: i
      } = this.props;
      c !== i && this.updateQuerySize(c);
    }, this.options = o.values, this.updateQuerySize = o.updateQuerySize;
  }
  render() {
    const {
      loading: o,
      currentSize: c,
      totalResults: i,
      label: d,
      overridableId: m,
      ariaLabel: v,
      selectOnNavigation: g,
      showWhenOnlyOnePage: C
    } = this.props;
    return /* @__PURE__ */ ae.createElement(yy, {
      condition: !o && c !== -1 && C ? i > 0 : i > c
    }, d(/* @__PURE__ */ ae.createElement(Ube, {
      currentSize: c,
      options: this.options,
      onValueChange: this.onChange,
      overridableId: m,
      ariaLabel: v,
      selectOnNavigation: g
    })));
  }
}
Vbe.defaultProps = {
  label: (r) => r,
  overridableId: "",
  ariaLabel: "Results per page",
  selectOnNavigation: !1,
  showWhenOnlyOnePage: !0
};
const Ube = (r) => {
  let {
    overridableId: o,
    currentSize: c,
    options: i,
    onValueChange: d,
    ariaLabel: m,
    selectOnNavigation: v
  } = r;
  const {
    buildUID: g
  } = Gc(Zc), C = i.map((O, R) => ({
    key: R,
    text: O.text,
    value: O.value
  }));
  return /* @__PURE__ */ ae.createElement(zo, {
    id: g("ResultsPerPage.element", o),
    currentSize: c,
    options: i,
    onValueChange: d,
    ariaLabel: m,
    selectOnNavigation: v
  }, /* @__PURE__ */ ae.createElement(kl, {
    inline: !0,
    compact: !0,
    options: C,
    value: c,
    onChange: (O, R) => {
      let {
        value: I
      } = R;
      return d(I);
    },
    "aria-label": m,
    selectOnNavigation: v
  }));
};
Ube.defaultProps = {
  ariaLabel: "Results per page",
  selectOnNavigation: !1,
  overridableId: ""
};
var XVe = zo.component("ResultsPerPage", Vbe);
const JVe = (r) => ({
  updateQuerySize: (o) => r(Xze(o))
}), eUe = Rd((r) => ({
  loading: r.results.loading,
  currentSize: r.query.size,
  totalResults: r.results.data.total
}), JVe)(XVe);
class Wbe extends Do {
  constructor(o) {
    super(o), this.onInputChange = (c) => {
      this.setState({
        currentValue: c
      });
    }, this.executeSearch = () => {
      const {
        currentValue: c
      } = this.state;
      this.updateQueryString(c);
    }, this.onBtnSearchClick = () => {
      this.executeSearch();
    }, this.onKeyPress = (c) => {
      c.key === "Enter" && this.executeSearch();
    }, this.updateQueryString = o.updateQueryString, this.state = {
      currentValue: o.queryString || ""
    };
  }
  render() {
    const {
      actionProps: o,
      autofocus: c,
      executeSearch: i,
      onBtnSearchClick: d,
      onInputChange: m,
      onKeyPress: v,
      overridableId: g,
      placeholder: C,
      uiProps: O
    } = this.props, {
      currentValue: R
    } = this.state;
    return /* @__PURE__ */ ae.createElement(Mie, {
      actionProps: o,
      autofocus: c,
      executeSearch: i || this.executeSearch,
      onBtnSearchClick: d || this.onBtnSearchClick,
      onInputChange: m || this.onInputChange,
      onKeyPress: v || this.onKeyPress,
      overridableId: g,
      placeholder: C,
      queryString: R,
      uiProps: O
    });
  }
}
Wbe.defaultProps = {
  actionProps: null,
  autofocus: !1,
  executeSearch: null,
  onBtnSearchClick: null,
  onInputChange: null,
  onKeyPress: null,
  overridableId: "",
  placeholder: "",
  queryString: "",
  uiProps: null
};
const jbe = (r) => {
  const {
    queryString: o
  } = r;
  return /* @__PURE__ */ ae.createElement(Wbe, Object.assign({
    key: o
  }, r));
};
jbe.defaultProps = {
  queryString: ""
};
class Mie extends Do {
  componentDidMount() {
    const {
      autofocus: o
    } = this.props;
    o && this.focusInput && this.focusInput.focus();
  }
  render() {
    const {
      actionProps: o,
      onBtnSearchClick: c,
      onInputChange: i,
      onKeyPress: d,
      overridableId: m,
      placeholder: v,
      queryString: g,
      uiProps: C
    } = this.props, {
      buildUID: O
    } = this.context;
    return /* @__PURE__ */ ae.createElement(zo, {
      id: O("SearchBar.element", m),
      queryString: g,
      onBtnSearchClick: c,
      onInputChange: i,
      onKeyPress: d,
      placeholder: v,
      actionProps: o,
      uiProps: C
    }, /* @__PURE__ */ ae.createElement(WB, Object.assign({
      action: {
        content: "Search",
        onClick: c,
        ...o
      },
      fluid: !0
    }, C, {
      placeholder: v || "Type something",
      onChange: (R, I) => {
        let {
          value: L
        } = I;
        i(L);
      },
      value: g,
      onKeyPress: d,
      ref: (R) => {
        this.focusInput = R;
      }
    })));
  }
}
Mie.defaultProps = {
  actionProps: null,
  autofocus: !1,
  onBtnSearchClick: null,
  onInputChange: null,
  onKeyPress: null,
  overridableId: "",
  placeholder: "",
  queryString: "",
  uiProps: null
};
Mie.contextType = Zc;
var tUe = zo.component("SearchBar", jbe);
const nUe = (r) => ({
  updateQueryString: (o) => r(pbe(o))
}), rUe = Rd((r) => ({
  queryString: r.query.queryString
}), nUe)(tUe);
class qbe extends Do {
  constructor(o) {
    super(o), this._computeValue = (c, i) => i ? `${c}-${i}` : c, this.onChange = (c) => {
      const {
        currentSortBy: i,
        currentSortOrder: d
      } = this.props;
      if (c === this._computeValue(i, d))
        return;
      const m = this.options.find((v) => v.value === c);
      this.updateQuerySorting(m.sortBy, m.sortOrder);
    }, this.options = o.values, this.updateQuerySorting = o.updateQuerySorting, this.options.forEach((c) => c.value = this._computeValue(c.sortBy, c.sortOrder));
  }
  render() {
    const {
      currentSortBy: o,
      currentSortOrder: c,
      loading: i,
      totalResults: d,
      label: m,
      overridableId: v,
      sortOrderDisabled: g,
      ariaLabel: C,
      selectOnNavigation: O
    } = this.props;
    return /* @__PURE__ */ ae.createElement(yy, {
      condition: o !== null && (g || o !== null) && !i && d > 0
    }, m(/* @__PURE__ */ ae.createElement(Gbe, {
      currentSortBy: o,
      currentSortOrder: c,
      options: this.options,
      onValueChange: this.onChange,
      computeValue: this._computeValue,
      overridableId: v,
      ariaLabel: C,
      selectOnNavigation: O
    })));
  }
}
qbe.defaultProps = {
  currentSortBy: null,
  currentSortOrder: null,
  label: (r) => r,
  overridableId: "",
  sortOrderDisabled: !1,
  ariaLabel: "Sort",
  selectOnNavigation: !1
};
const Gbe = (r) => {
  let {
    overridableId: o,
    currentSortBy: c,
    currentSortOrder: i,
    options: d,
    onValueChange: m,
    computeValue: v,
    ariaLabel: g,
    selectOnNavigation: C
  } = r;
  const {
    buildUID: O
  } = Gc(Zc), R = v(c, i), I = d.map((L, Z) => ({
    key: Z,
    text: L.text,
    value: L.value
  }));
  return /* @__PURE__ */ ae.createElement(zo, {
    id: O("Sort.element", o),
    options: d,
    currentSortBy: c,
    currentSortOrder: i,
    onValueChange: m,
    ariaLabel: g,
    selectOnNavigation: C
  }, /* @__PURE__ */ ae.createElement(kl, {
    selection: !0,
    options: I,
    value: R,
    onChange: (L, Z) => {
      let {
        value: ne
      } = Z;
      return m(ne);
    },
    "aria-label": g,
    selectOnNavigation: C
  }));
};
Gbe.defaultProps = {
  currentSortBy: null,
  currentSortOrder: null,
  overridableId: "",
  ariaLabel: "Sort",
  selectOnNavigation: !1
};
var oUe = zo.component("Sort", qbe);
const sUe = (r) => ({
  updateQuerySorting: (o, c) => r(Zze(o, c))
});
Rd((r) => ({
  currentSortBy: r.query.sortBy,
  currentSortOrder: r.query.sortOrder,
  loading: r.results.loading,
  totalResults: r.results.data.total
}), sUe)(oUe);
class Zbe extends Do {
  constructor(o) {
    super(o), this.onChange = (c) => {
      const {
        currentSortBy: i
      } = this.props;
      c !== i && this.updateQuerySortBy(c);
    }, this.options = o.values, this.updateQuerySortBy = o.updateQuerySortBy;
  }
  render() {
    const {
      currentSortBy: o,
      loading: c,
      totalResults: i,
      label: d,
      overridableId: m,
      ariaLabel: v,
      selectOnNavigation: g
    } = this.props;
    return /* @__PURE__ */ ae.createElement(yy, {
      condition: o !== null && !c && i > 0
    }, d(/* @__PURE__ */ ae.createElement(Kbe, {
      currentSortBy: o,
      options: this.options,
      onValueChange: this.onChange,
      overridableId: m,
      ariaLabel: v,
      selectOnNavigation: g
    })));
  }
}
Zbe.defaultProps = {
  currentSortBy: null,
  label: (r) => r,
  overridableId: "",
  ariaLabel: "Sort Results By",
  selectOnNavigation: !1
};
const Kbe = (r) => {
  let {
    overridableId: o,
    currentSortBy: c,
    options: i,
    onValueChange: d,
    ariaLabel: m,
    selectOnNavigation: v
  } = r;
  const {
    buildUID: g
  } = Gc(Zc), C = i.map((O, R) => ({
    key: R,
    text: O.text,
    value: O.value
  }));
  return /* @__PURE__ */ ae.createElement(zo, {
    id: g("SortBy.element", o),
    options: i,
    currentSortBy: c,
    onValueChange: d,
    ariaLabel: m,
    selectOnNavigation: v
  }, /* @__PURE__ */ ae.createElement(kl, {
    selection: !0,
    compact: !0,
    options: C,
    value: c,
    onChange: (O, R) => {
      let {
        value: I
      } = R;
      return d(I);
    },
    "aria-label": m,
    selectOnNavigation: v
  }));
};
Kbe.defaultProps = {
  currentSortBy: null,
  overridableId: "",
  ariaLabel: "Sort Results By",
  selectOnNavigation: !1
};
var aUe = zo.component("SortBy", Zbe);
const iUe = (r) => ({
  updateQuerySortBy: (o) => r(Kze(o))
});
Rd((r) => ({
  loading: r.results.loading,
  totalResults: r.results.data.total,
  currentSortBy: r.query.sortBy
}), iUe)(aUe);
class Ybe extends Do {
  constructor(o) {
    super(o), this.onChange = (c) => {
      const {
        currentSortOrder: i
      } = this.props;
      c !== i && this.updateQuerySortOrder(c);
    }, this.options = o.values, this.updateQuerySortOrder = o.updateQuerySortOrder;
  }
  render() {
    const {
      currentSortOrder: o,
      loading: c,
      totalResults: i,
      label: d,
      overridableId: m,
      ariaLabel: v,
      selectOnNavigation: g
    } = this.props;
    return /* @__PURE__ */ ae.createElement(yy, {
      condition: o !== null && !c && i > 0
    }, d(/* @__PURE__ */ ae.createElement(Qbe, {
      currentSortOrder: o,
      options: this.options,
      onValueChange: this.onChange,
      overridableId: m,
      ariaLabel: v,
      selectOnNavigation: g
    })));
  }
}
Ybe.defaultProps = {
  currentSortOrder: null,
  label: (r) => r,
  overridableId: "",
  ariaLabel: "Sort Order",
  selectOnNavigation: !1
};
const Qbe = (r) => {
  let {
    overridableId: o,
    currentSortOrder: c,
    options: i,
    onValueChange: d,
    ariaLabel: m,
    selectOnNavigation: v
  } = r;
  const {
    buildUID: g
  } = Gc(Zc), C = i.map((O, R) => ({
    key: R,
    text: O.text,
    value: O.value
  }));
  return /* @__PURE__ */ ae.createElement(zo, {
    id: g("SortOrder.element", o),
    options: i,
    currentSortOrder: c,
    onValueChange: d,
    ariaLabel: m,
    selectOnNavigation: v
  }, /* @__PURE__ */ ae.createElement(kl, {
    selection: !0,
    compact: !0,
    options: C,
    value: c,
    onChange: (O, R) => {
      let {
        value: I
      } = R;
      return d(I);
    },
    "aria-label": m,
    selectOnNavigation: v
  }));
};
Qbe.defaultProps = {
  currentSortOrder: null,
  overridableId: "",
  ariaLabel: "Sort Order",
  selectOnNavigation: !1
};
var cUe = zo.component("SortOrder", Ybe);
const lUe = (r) => ({
  updateQuerySortOrder: (o) => r(Yze(o))
});
Rd((r) => ({
  loading: r.results.loading,
  totalResults: r.results.data.total,
  currentSortOrder: r.query.sortOrder
}), lUe)(cUe);
const Xbe = (r) => {
  let {
    overridableId: o,
    userSelectionFilters: c,
    title: i,
    label: d,
    filterValue: m,
    updateQueryFilters: v
  } = r;
  const g = (I) => I.filter((Z) => Z[0] === m[0]).length > 0, C = () => {
    v(m);
  }, {
    buildUID: O
  } = Gc(Zc), R = g(c);
  return /* @__PURE__ */ ae.createElement(zo, {
    id: O("SearchFilters.Toggle.element", o),
    title: i,
    label: d,
    filterValue: m,
    userSelectionFilters: c,
    updateQueryFilters: v
  }, /* @__PURE__ */ ae.createElement(Tu, null, /* @__PURE__ */ ae.createElement(Tu.Content, null, /* @__PURE__ */ ae.createElement(Tu.Header, null, i)), /* @__PURE__ */ ae.createElement(Tu.Content, null, /* @__PURE__ */ ae.createElement(Iv, {
    toggle: !0,
    label: d,
    onClick: C,
    checked: R
  }))));
};
Xbe.defaultProps = {
  overridableId: ""
};
var uUe = zo.component("SearchFilters.Toggle", Xbe);
const dUe = (r) => ({
  updateQueryFilters: (o) => r(Die(o))
});
Rd((r) => ({
  userSelectionFilters: r.query.filters
}), dUe)(uUe);
const Jbe = ae.createContext(
  null
), fUe = ({ config: r, children: o }) => /* @__PURE__ */ ae.createElement(Jbe.Provider, { value: { config: r } }, o), mUe = () => {
  const r = ae.useContext(Jbe);
  if (!r)
    throw new Error("useSearchConfig must be used within a SearchProvider");
  return r;
}, pUe = ({
  result: r,
  index: o
}) => /* @__PURE__ */ ae.createElement(Ah, { key: o }, /* @__PURE__ */ ae.createElement(nf, null, r.title || "No title"), /* @__PURE__ */ ae.createElement(nf, null, r.created), /* @__PURE__ */ ae.createElement(nf, null, r.status), /* @__PURE__ */ ae.createElement(nf, null, "999"), /* @__PURE__ */ ae.createElement(nf, null, "999"), /* @__PURE__ */ ae.createElement(nf, null, r.serializer), /* @__PURE__ */ ae.createElement(nf, null, r.mode), /* @__PURE__ */ ae.createElement(nf, { style: { width: "220px" } }, /* @__PURE__ */ ae.createElement("div", { style: { display: "flex", alignItems: "center", gap: "10px" } }, /* @__PURE__ */ ae.createElement(
  kl,
  {
    text: "Select Action",
    floating: !0,
    labeled: !0,
    className: "icon",
    options: [
      {
        key: "download",
        text: "Download",
        value: "download",
        disabled: !0
      },
      {
        key: "delete",
        text: "Delete",
        value: "delete",
        disabled: !0
      }
    ]
  }
), /* @__PURE__ */ ae.createElement(hy, { basic: !0, size: "tiny" }, /* @__PURE__ */ ae.createElement(fc, { name: "eye" }), "View")))), hUe = ({ children: r }) => /* @__PURE__ */ ae.createElement(Lv, { celled: !0, size: "small", comp: !0 }, /* @__PURE__ */ ae.createElement(WS, null, /* @__PURE__ */ ae.createElement(Ah, null, /* @__PURE__ */ ae.createElement(_g, null, "ID"), /* @__PURE__ */ ae.createElement(_g, null, "Date"), /* @__PURE__ */ ae.createElement(_g, null, "Status"), /* @__PURE__ */ ae.createElement(_g, null, "Records"), /* @__PURE__ */ ae.createElement(_g, null, "Files"), /* @__PURE__ */ ae.createElement(_g, null, "Provider"), /* @__PURE__ */ ae.createElement(_g, null, "Mode"), /* @__PURE__ */ ae.createElement(_g, null, "Actions"))), /* @__PURE__ */ ae.createElement(vC, null, r)), tC = {
  aggs: [],
  appId: "search",
  defaultSortingOnEmptyQueryString: [
    {
      sortBy: "newest"
    }
  ],
  initialQueryState: {
    filters: [],
    hiddenParams: null,
    layout: "list",
    page: 1,
    size: 20,
    sortBy: "newest"
  },
  layoutOptions: {
    gridView: !1,
    listView: !0
  },
  paginationOptions: {
    defaultValue: 20,
    maxTotalResults: 1e4,
    resultsPerPage: [
      {
        text: "20",
        value: 20
      },
      {
        text: "50",
        value: 50
      }
    ]
  },
  searchApi: {
    axios: {
      headers: {
        Accept: "application/vnd.inveniordm.v1+json"
      },
      url: "/api/importer-tasks",
      withCredentials: !0
    },
    invenio: {
      requestSerializer: "InvenioRecordsResourcesRequestSerializer"
    }
  },
  sortOptions: [
    {
      sortBy: "newest",
      text: "Newest"
    },
    {
      sortBy: "oldest",
      text: "Oldest"
    }
  ],
  sortOrderDisabled: !0
};
var Ko = {};
const gUe = /* @__PURE__ */ q$(SNe), vUe = /* @__PURE__ */ q$(fIe), bUe = /* @__PURE__ */ q$(xNe);
var yUe = "__lodash_hash_undefined__";
function SUe(r) {
  return this.__data__.set(r, yUe), this;
}
var wUe = SUe;
function EUe(r) {
  return this.__data__.has(r);
}
var CUe = EUe, xUe = aie, TUe = wUe, _Ue = CUe;
function XW(r) {
  var o = -1, c = r == null ? 0 : r.length;
  for (this.__data__ = new xUe(); ++o < c; )
    this.add(r[o]);
}
XW.prototype.add = XW.prototype.push = TUe;
XW.prototype.has = _Ue;
var eye = XW;
function OUe(r, o) {
  for (var c = -1, i = r == null ? 0 : r.length; ++c < i; )
    if (o(r[c], c, r))
      return !0;
  return !1;
}
var AUe = OUe;
function kUe(r, o) {
  return r.has(o);
}
var tye = kUe, NUe = eye, RUe = AUe, PUe = tye, DUe = 1, $Ue = 2;
function IUe(r, o, c, i, d, m) {
  var v = c & DUe, g = r.length, C = o.length;
  if (g != C && !(v && C > g))
    return !1;
  var O = m.get(r), R = m.get(o);
  if (O && R)
    return O == o && R == r;
  var I = -1, L = !0, Z = c & $Ue ? new NUe() : void 0;
  for (m.set(r, o), m.set(o, r); ++I < g; ) {
    var ne = r[I], se = o[I];
    if (i)
      var Q = v ? i(se, ne, I, o, r, m) : i(ne, se, I, r, o, m);
    if (Q !== void 0) {
      if (Q)
        continue;
      L = !1;
      break;
    }
    if (Z) {
      if (!RUe(o, function(he, ue) {
        if (!PUe(Z, ue) && (ne === he || d(ne, he, c, i, m)))
          return Z.push(ue);
      })) {
        L = !1;
        break;
      }
    } else if (!(ne === se || d(ne, se, c, i, m))) {
      L = !1;
      break;
    }
  }
  return m.delete(r), m.delete(o), L;
}
var nye = IUe;
function MUe(r) {
  var o = -1, c = Array(r.size);
  return r.forEach(function(i, d) {
    c[++o] = [d, i];
  }), c;
}
var FUe = MUe;
function LUe(r) {
  var o = -1, c = Array(r.size);
  return r.forEach(function(i) {
    c[++o] = i;
  }), c;
}
var Fie = LUe, lme = J$, ume = Dve, BUe = Yj, HUe = nye, zUe = FUe, VUe = Fie, UUe = 1, WUe = 2, jUe = "[object Boolean]", qUe = "[object Date]", GUe = "[object Error]", ZUe = "[object Map]", KUe = "[object Number]", YUe = "[object RegExp]", QUe = "[object Set]", XUe = "[object String]", JUe = "[object Symbol]", e9e = "[object ArrayBuffer]", t9e = "[object DataView]", dme = lme ? lme.prototype : void 0, Hoe = dme ? dme.valueOf : void 0;
function n9e(r, o, c, i, d, m, v) {
  switch (c) {
    case t9e:
      if (r.byteLength != o.byteLength || r.byteOffset != o.byteOffset)
        return !1;
      r = r.buffer, o = o.buffer;
    case e9e:
      return !(r.byteLength != o.byteLength || !m(new ume(r), new ume(o)));
    case jUe:
    case qUe:
    case KUe:
      return BUe(+r, +o);
    case GUe:
      return r.name == o.name && r.message == o.message;
    case YUe:
    case XUe:
      return r == o + "";
    case ZUe:
      var g = zUe;
    case QUe:
      var C = i & UUe;
      if (g || (g = VUe), r.size != o.size && !C)
        return !1;
      var O = v.get(r);
      if (O)
        return O == o;
      i |= WUe, v.set(r, o);
      var R = HUe(g(r), g(o), i, d, m, v);
      return v.delete(r), R;
    case JUe:
      if (Hoe)
        return Hoe.call(r) == Hoe.call(o);
  }
  return !1;
}
var r9e = n9e, fme = Pve, o9e = 1, s9e = Object.prototype, a9e = s9e.hasOwnProperty;
function i9e(r, o, c, i, d, m) {
  var v = c & o9e, g = fme(r), C = g.length, O = fme(o), R = O.length;
  if (C != R && !v)
    return !1;
  for (var I = C; I--; ) {
    var L = g[I];
    if (!(v ? L in o : a9e.call(o, L)))
      return !1;
  }
  var Z = m.get(r), ne = m.get(o);
  if (Z && ne)
    return Z == o && ne == r;
  var se = !0;
  m.set(r, o), m.set(o, r);
  for (var Q = v; ++I < C; ) {
    L = g[I];
    var he = r[L], ue = o[L];
    if (i)
      var G = v ? i(ue, he, L, o, r, m) : i(he, ue, L, r, o, m);
    if (!(G === void 0 ? he === ue || d(he, ue, c, i, m) : G)) {
      se = !1;
      break;
    }
    Q || (Q = L == "constructor");
  }
  if (se && !Q) {
    var me = r.constructor, we = o.constructor;
    me != we && "constructor" in r && "constructor" in o && !(typeof me == "function" && me instanceof me && typeof we == "function" && we instanceof we) && (se = !1);
  }
  return m.delete(r), m.delete(o), se;
}
var c9e = i9e, zoe = yie, l9e = nye, u9e = r9e, d9e = c9e, mme = GB, pme = $h, hme = Bj, f9e = Jae, m9e = 1, gme = "[object Arguments]", vme = "[object Array]", rW = "[object Object]", p9e = Object.prototype, bme = p9e.hasOwnProperty;
function h9e(r, o, c, i, d, m) {
  var v = pme(r), g = pme(o), C = v ? vme : mme(r), O = g ? vme : mme(o);
  C = C == gme ? rW : C, O = O == gme ? rW : O;
  var R = C == rW, I = O == rW, L = C == O;
  if (L && hme(r)) {
    if (!hme(o))
      return !1;
    v = !0, R = !1;
  }
  if (L && !R)
    return m || (m = new zoe()), v || f9e(r) ? l9e(r, o, c, i, d, m) : u9e(r, o, C, c, i, d, m);
  if (!(c & m9e)) {
    var Z = R && bme.call(r, "__wrapped__"), ne = I && bme.call(o, "__wrapped__");
    if (Z || ne) {
      var se = Z ? r.value() : r, Q = ne ? o.value() : o;
      return m || (m = new zoe()), d(se, Q, c, i, m);
    }
  }
  return L ? (m || (m = new zoe()), d9e(r, o, c, i, d, m)) : !1;
}
var g9e = h9e, v9e = g9e, yme = M1;
function rye(r, o, c, i, d) {
  return r === o ? !0 : r == null || o == null || !yme(r) && !yme(o) ? r !== r && o !== o : v9e(r, o, c, i, rye, d);
}
var oye = rye, b9e = yie, y9e = oye, S9e = 1, w9e = 2;
function E9e(r, o, c, i) {
  var d = c.length, m = d, v = !i;
  if (r == null)
    return !m;
  for (r = Object(r); d--; ) {
    var g = c[d];
    if (v && g[2] ? g[1] !== r[g[0]] : !(g[0] in r))
      return !1;
  }
  for (; ++d < m; ) {
    g = c[d];
    var C = g[0], O = r[C], R = g[1];
    if (v && g[2]) {
      if (O === void 0 && !(C in r))
        return !1;
    } else {
      var I = new b9e();
      if (i)
        var L = i(O, R, C, r, o, I);
      if (!(L === void 0 ? y9e(R, O, S9e | w9e, i, I) : L))
        return !1;
    }
  }
  return !0;
}
var C9e = E9e, x9e = I1;
function T9e(r) {
  return r === r && !x9e(r);
}
var sye = T9e, _9e = sye, O9e = JB;
function A9e(r) {
  for (var o = O9e(r), c = o.length; c--; ) {
    var i = o[c], d = r[i];
    o[c] = [i, d, _9e(d)];
  }
  return o;
}
var k9e = A9e;
function N9e(r, o) {
  return function(c) {
    return c == null ? !1 : c[r] === o && (o !== void 0 || r in Object(c));
  };
}
var aye = N9e, R9e = C9e, P9e = k9e, D9e = aye;
function $9e(r) {
  var o = P9e(r);
  return o.length == 1 && o[0][2] ? D9e(o[0][0], o[0][1]) : function(c) {
    return c === r || R9e(c, r, o);
  };
}
var iye = $9e, I9e = oye, M9e = lie, F9e = nq, L9e = sie, B9e = sye, H9e = aye, z9e = iI, V9e = 1, U9e = 2;
function W9e(r, o) {
  return L9e(r) && B9e(o) ? H9e(z9e(r), o) : function(c) {
    var i = M9e(c, r);
    return i === void 0 && i === o ? F9e(c, r) : I9e(o, i, V9e | U9e);
  };
}
var j9e = W9e;
function q9e(r) {
  return function(o) {
    return o == null ? void 0 : o[r];
  };
}
var G9e = q9e, Z9e = eq;
function K9e(r) {
  return function(o) {
    return Z9e(o, r);
  };
}
var Y9e = K9e, Q9e = G9e, X9e = Y9e, J9e = sie, eWe = iI;
function tWe(r) {
  return J9e(r) ? Q9e(eWe(r)) : X9e(r);
}
var nWe = tWe, rWe = iye, oWe = j9e, sWe = vie, aWe = $h, iWe = nWe;
function cWe(r) {
  return typeof r == "function" ? r : r == null ? sWe : typeof r == "object" ? aWe(r) ? oWe(r[0], r[1]) : rWe(r) : iWe(r);
}
var Lie = cWe, lWe = cie, uWe = Lie, dWe = Tve, fWe = Eie;
function mWe(r, o) {
  if (r == null)
    return {};
  var c = lWe(fWe(r), function(i) {
    return [i];
  });
  return o = uWe(o), dWe(r, c, function(i, d) {
    return o(i, d[0]);
  });
}
var pWe = mWe, hWe = function(o) {
  return gWe(o) && !vWe(o);
};
function gWe(r) {
  return !!r && typeof r == "object";
}
function vWe(r) {
  var o = Object.prototype.toString.call(r);
  return o === "[object RegExp]" || o === "[object Date]" || SWe(r);
}
var bWe = typeof Symbol == "function" && Symbol.for, yWe = bWe ? Symbol.for("react.element") : 60103;
function SWe(r) {
  return r.$$typeof === yWe;
}
function wWe(r) {
  return Array.isArray(r) ? [] : {};
}
function JW(r, o) {
  return o.clone !== !1 && o.isMergeableObject(r) ? IB(wWe(r), r, o) : r;
}
function EWe(r, o, c) {
  return r.concat(o).map(function(i) {
    return JW(i, c);
  });
}
function CWe(r, o, c) {
  var i = {};
  return c.isMergeableObject(r) && Object.keys(r).forEach(function(d) {
    i[d] = JW(r[d], c);
  }), Object.keys(o).forEach(function(d) {
    !c.isMergeableObject(o[d]) || !r[d] ? i[d] = JW(o[d], c) : i[d] = IB(r[d], o[d], c);
  }), i;
}
function IB(r, o, c) {
  c = c || {}, c.arrayMerge = c.arrayMerge || EWe, c.isMergeableObject = c.isMergeableObject || hWe;
  var i = Array.isArray(o), d = Array.isArray(r), m = i === d;
  return m ? i ? c.arrayMerge(r, o, c) : CWe(r, o, c) : JW(o, c);
}
IB.all = function(o, c) {
  if (!Array.isArray(o))
    throw new Error("first argument should be an array");
  return o.reduce(function(i, d) {
    return IB(i, d, c);
  }, {});
};
var Bse = IB;
function lq(r, o, c, i) {
  var d = !c;
  c || (c = {});
  for (var m = -1, v = o.length; ++m < v; ) {
    var g = o[m], C = i ? i(c[g], r[g], g, c, r) : void 0;
    C === void 0 && (C = r[g]), d ? Sj(c, g, C) : yae(c, g, C);
  }
  return c;
}
function xWe(r, o) {
  return r && lq(o, Yf(o), r);
}
function TWe(r, o) {
  return r && lq(o, Pae(o), r);
}
var cye = typeof exports == "object" && exports && !exports.nodeType && exports, Sme = cye && typeof module == "object" && module && !module.nodeType && module, _We = Sme && Sme.exports === cye, wme = _We ? Ph.Buffer : void 0, Eme = wme ? wme.allocUnsafe : void 0;
function OWe(r, o) {
  if (o)
    return r.slice();
  var c = r.length, i = Eme ? Eme(c) : new r.constructor(c);
  return r.copy(i), i;
}
function AWe(r, o) {
  return lq(r, hae(r), o);
}
function kWe(r, o) {
  return lq(r, Uhe(r), o);
}
var NWe = Object.prototype, RWe = NWe.hasOwnProperty;
function PWe(r) {
  var o = r.length, c = new r.constructor(o);
  return o && typeof r[0] == "string" && RWe.call(r, "index") && (c.index = r.index, c.input = r.input), c;
}
function Bie(r) {
  var o = new r.constructor(r.byteLength);
  return new OW(o).set(new OW(r)), o;
}
function DWe(r, o) {
  var c = o ? Bie(r.buffer) : r.buffer;
  return new r.constructor(c, r.byteOffset, r.byteLength);
}
var $We = /\w*$/;
function IWe(r) {
  var o = new r.constructor(r.source, $We.exec(r));
  return o.lastIndex = r.lastIndex, o;
}
var Cme = py ? py.prototype : void 0, xme = Cme ? Cme.valueOf : void 0;
function MWe(r) {
  return xme ? Object(xme.call(r)) : {};
}
function FWe(r, o) {
  var c = o ? Bie(r.buffer) : r.buffer;
  return new r.constructor(c, r.byteOffset, r.length);
}
var LWe = "[object Boolean]", BWe = "[object Date]", HWe = "[object Map]", zWe = "[object Number]", VWe = "[object RegExp]", UWe = "[object Set]", WWe = "[object String]", jWe = "[object Symbol]", qWe = "[object ArrayBuffer]", GWe = "[object DataView]", ZWe = "[object Float32Array]", KWe = "[object Float64Array]", YWe = "[object Int8Array]", QWe = "[object Int16Array]", XWe = "[object Int32Array]", JWe = "[object Uint8Array]", eje = "[object Uint8ClampedArray]", tje = "[object Uint16Array]", nje = "[object Uint32Array]";
function rje(r, o, c) {
  var i = r.constructor;
  switch (o) {
    case qWe:
      return Bie(r);
    case LWe:
    case BWe:
      return new i(+r);
    case GWe:
      return DWe(r, c);
    case ZWe:
    case KWe:
    case YWe:
    case QWe:
    case XWe:
    case JWe:
    case eje:
    case tje:
    case nje:
      return FWe(r, c);
    case HWe:
      return new i();
    case zWe:
    case WWe:
      return new i(r);
    case VWe:
      return IWe(r);
    case UWe:
      return new i();
    case jWe:
      return MWe(r);
  }
}
function oje(r) {
  return typeof r.constructor == "function" && !gj(r) ? Tj(Sae(r)) : {};
}
var sje = "[object Map]";
function aje(r) {
  return Nh(r) && ZA(r) == sje;
}
var Tme = QD && QD.isMap, ije = Tme ? G$(Tme) : aje;
const cje = ije;
var lje = "[object Set]";
function uje(r) {
  return Nh(r) && ZA(r) == lje;
}
var _me = QD && QD.isSet, dje = _me ? G$(_me) : uje;
const fje = dje;
var mje = 1, pje = 2, hje = 4, lye = "[object Arguments]", gje = "[object Array]", vje = "[object Boolean]", bje = "[object Date]", yje = "[object Error]", uye = "[object Function]", Sje = "[object GeneratorFunction]", wje = "[object Map]", Eje = "[object Number]", dye = "[object Object]", Cje = "[object RegExp]", xje = "[object Set]", Tje = "[object String]", _je = "[object Symbol]", Oje = "[object WeakMap]", Aje = "[object ArrayBuffer]", kje = "[object DataView]", Nje = "[object Float32Array]", Rje = "[object Float64Array]", Pje = "[object Int8Array]", Dje = "[object Int16Array]", $je = "[object Int32Array]", Ije = "[object Uint8Array]", Mje = "[object Uint8ClampedArray]", Fje = "[object Uint16Array]", Lje = "[object Uint32Array]", jc = {};
jc[lye] = jc[gje] = jc[Aje] = jc[kje] = jc[vje] = jc[bje] = jc[Nje] = jc[Rje] = jc[Pje] = jc[Dje] = jc[$je] = jc[wje] = jc[Eje] = jc[dye] = jc[Cje] = jc[xje] = jc[Tje] = jc[_je] = jc[Ije] = jc[Mje] = jc[Fje] = jc[Lje] = !0;
jc[yje] = jc[uye] = jc[Oje] = !1;
function lB(r, o, c, i, d, m) {
  var v, g = o & mje, C = o & pje, O = o & hje;
  if (c && (v = d ? c(r, i, d, m) : c(r)), v !== void 0)
    return v;
  if (!Fv(r))
    return r;
  var R = qc(r);
  if (R) {
    if (v = PWe(r), !g)
      return $j(r, v);
  } else {
    var I = ZA(r), L = I == uye || I == Sje;
    if (pB(r))
      return OWe(r, g);
    if (I == dye || I == lye || L && !d) {
      if (v = C || L ? {} : oje(r), !g)
        return C ? kWe(r, TWe(v, r)) : AWe(r, xWe(v, r));
    } else {
      if (!jc[I])
        return d ? r : {};
      v = rje(r, I, g);
    }
  }
  m || (m = new MS());
  var Z = m.get(r);
  if (Z)
    return Z;
  m.set(r, v), fje(r) ? r.forEach(function(Q) {
    v.add(lB(Q, o, c, Q, r, m));
  }) : cje(r) && r.forEach(function(Q, he) {
    v.set(he, lB(Q, o, c, he, r, m));
  });
  var ne = O ? C ? Whe : nse : C ? Pae : Yf, se = R ? void 0 : ne(r);
  return vae(se || r, function(Q, he) {
    se && (he = Q, Q = r[he]), yae(v, he, lB(Q, o, c, he, r, m));
  }), v;
}
var Bje = 1, Hje = 4;
function YL(r) {
  return lB(r, Bje | Hje);
}
var Ome = Array.isArray, Ame = Object.keys, zje = Object.prototype.hasOwnProperty, Vje = typeof Element < "u";
function Hse(r, o) {
  if (r === o)
    return !0;
  if (r && o && typeof r == "object" && typeof o == "object") {
    var c = Ome(r), i = Ome(o), d, m, v;
    if (c && i) {
      if (m = r.length, m != o.length)
        return !1;
      for (d = m; d-- !== 0; )
        if (!Hse(r[d], o[d]))
          return !1;
      return !0;
    }
    if (c != i)
      return !1;
    var g = r instanceof Date, C = o instanceof Date;
    if (g != C)
      return !1;
    if (g && C)
      return r.getTime() == o.getTime();
    var O = r instanceof RegExp, R = o instanceof RegExp;
    if (O != R)
      return !1;
    if (O && R)
      return r.toString() == o.toString();
    var I = Ame(r);
    if (m = I.length, m !== Ame(o).length)
      return !1;
    for (d = m; d-- !== 0; )
      if (!zje.call(o, I[d]))
        return !1;
    if (Vje && r instanceof Element && o instanceof Element)
      return r === o;
    for (d = m; d-- !== 0; )
      if (v = I[d], !(v === "_owner" && r.$$typeof) && !Hse(r[v], o[v]))
        return !1;
    return !0;
  }
  return r !== r && o !== o;
}
var Uje = function(o, c) {
  try {
    return Hse(o, c);
  } catch (i) {
    if (i.message && i.message.match(/stack|recursion/i) || i.number === -2146828260)
      return console.warn("Warning: react-fast-compare does not handle circular references.", i.name, i.message), !1;
    throw i;
  }
};
const l2 = /* @__PURE__ */ Ku(Uje);
var Wje = process.env.NODE_ENV === "production";
function di(r, o) {
  if (!Wje) {
    if (r)
      return;
    var c = "Warning: " + o;
    typeof console < "u" && console.warn(c);
    try {
      throw Error(c);
    } catch {
    }
  }
}
var jje = 4;
function kme(r) {
  return lB(r, jje);
}
function fye(r) {
  return qc(r) ? E1(r, kk) : b2(r) ? [r] : $j(Cpe(BS(r)));
}
function ma() {
  return ma = Object.assign || function(r) {
    for (var o = 1; o < arguments.length; o++) {
      var c = arguments[o];
      for (var i in c)
        Object.prototype.hasOwnProperty.call(c, i) && (r[i] = c[i]);
    }
    return r;
  }, ma.apply(this, arguments);
}
function uq(r, o) {
  r.prototype = Object.create(o.prototype), r.prototype.constructor = r, r.__proto__ = o;
}
function Ag(r, o) {
  if (r == null)
    return {};
  var c = {}, i = Object.keys(r), d, m;
  for (m = 0; m < i.length; m++)
    d = i[m], !(o.indexOf(d) >= 0) && (c[d] = r[d]);
  return c;
}
function Nme(r) {
  if (r === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return r;
}
var t5 = /* @__PURE__ */ b0e(void 0);
t5.displayName = "FormikContext";
var mye = t5.Provider, pye = t5.Consumer;
function dq() {
  var r = Gc(t5);
  return r || (process.env.NODE_ENV !== "production" ? di(!1, "Formik context is undefined, please verify you are calling useFormikContext() as child of a <Formik> component.") : di(!1)), r;
}
var zse = function(o) {
  return Array.isArray(o) && o.length === 0;
}, Al = function(o) {
  return typeof o == "function";
}, LC = function(o) {
  return o !== null && typeof o == "object";
}, hye = function(o) {
  return String(Math.floor(Number(o))) === o;
}, SW = function(o) {
  return Object.prototype.toString.call(o) === "[object String]";
}, qje = function(o) {
  return o !== o;
}, n5 = function(o) {
  return _k.count(o) === 0;
}, wW = function(o) {
  return LC(o) && Al(o.then);
}, Gje = function(o) {
  return o && LC(o) && LC(o.target);
};
function gye(r) {
  if (r = r || (typeof document < "u" ? document : void 0), typeof r > "u")
    return null;
  try {
    return r.activeElement || r.body;
  } catch {
    return r.body;
  }
}
function pa(r, o, c, i) {
  i === void 0 && (i = 0);
  for (var d = fye(o); r && i < d.length; )
    r = r[d[i++]];
  return i !== d.length && !r || r === void 0 ? c : r;
}
function _1(r, o, c) {
  for (var i = kme(r), d = i, m = 0, v = fye(o); m < v.length - 1; m++) {
    var g = v[m], C = pa(r, v.slice(0, m + 1));
    if (C && (LC(C) || Array.isArray(C)))
      d = d[g] = kme(C);
    else {
      var O = v[m + 1];
      d = d[g] = hye(O) && Number(O) >= 0 ? [] : {};
    }
  }
  return (m === 0 ? r : d)[v[m]] === c ? r : (c === void 0 ? delete d[v[m]] : d[v[m]] = c, m === 0 && c === void 0 && delete i[v[m]], i);
}
function Hie(r, o, c, i) {
  c === void 0 && (c = /* @__PURE__ */ new WeakMap()), i === void 0 && (i = {});
  for (var d = 0, m = Object.keys(r); d < m.length; d++) {
    var v = m[d], g = r[v];
    LC(g) ? c.get(g) || (c.set(g, !0), i[v] = Array.isArray(g) ? [] : {}, Hie(g, o, c, i[v])) : i[v] = o;
  }
  return i;
}
function Zje(r, o) {
  switch (o.type) {
    case "SET_VALUES":
      return ma({}, r, {
        values: o.payload
      });
    case "SET_TOUCHED":
      return ma({}, r, {
        touched: o.payload
      });
    case "SET_ERRORS":
      return l2(r.errors, o.payload) ? r : ma({}, r, {
        errors: o.payload
      });
    case "SET_STATUS":
      return ma({}, r, {
        status: o.payload
      });
    case "SET_ISSUBMITTING":
      return ma({}, r, {
        isSubmitting: o.payload
      });
    case "SET_ISVALIDATING":
      return ma({}, r, {
        isValidating: o.payload
      });
    case "SET_FIELD_VALUE":
      return ma({}, r, {
        values: _1(r.values, o.payload.field, o.payload.value)
      });
    case "SET_FIELD_TOUCHED":
      return ma({}, r, {
        touched: _1(r.touched, o.payload.field, o.payload.value)
      });
    case "SET_FIELD_ERROR":
      return ma({}, r, {
        errors: _1(r.errors, o.payload.field, o.payload.value)
      });
    case "RESET_FORM":
      return ma({}, r, o.payload);
    case "SET_FORMIK_STATE":
      return o.payload(r);
    case "SUBMIT_ATTEMPT":
      return ma({}, r, {
        touched: Hie(r.values, !0),
        isSubmitting: !0,
        submitCount: r.submitCount + 1
      });
    case "SUBMIT_FAILURE":
      return ma({}, r, {
        isSubmitting: !1
      });
    case "SUBMIT_SUCCESS":
      return ma({}, r, {
        isSubmitting: !1
      });
    default:
      return r;
  }
}
var kA = {}, oW = {};
function vye(r) {
  var o = r.validateOnChange, c = o === void 0 ? !0 : o, i = r.validateOnBlur, d = i === void 0 ? !0 : i, m = r.validateOnMount, v = m === void 0 ? !1 : m, g = r.isInitialValid, C = r.enableReinitialize, O = C === void 0 ? !1 : C, R = r.onSubmit, I = Ag(r, ["validateOnChange", "validateOnBlur", "validateOnMount", "isInitialValid", "enableReinitialize", "onSubmit"]), L = ma({
    validateOnChange: c,
    validateOnBlur: d,
    validateOnMount: v,
    onSubmit: R
  }, I), Z = uy(L.initialValues), ne = uy(L.initialErrors || kA), se = uy(L.initialTouched || oW), Q = uy(L.initialStatus), he = uy(!1), ue = uy({});
  process.env.NODE_ENV !== "production" && Ch(function() {
    typeof g > "u" || (process.env.NODE_ENV !== "production" ? di(!1, "isInitialValid has been deprecated and will be removed in future versions of Formik. Please use initialErrors or validateOnMount instead.") : di(!1));
  }, []), Ch(function() {
    return he.current = !0, function() {
      he.current = !1;
    };
  }, []);
  var G = Spe(0), me = G[1], we = uy({
    values: YL(L.initialValues),
    errors: YL(L.initialErrors) || kA,
    touched: YL(L.initialTouched) || oW,
    status: YL(L.initialStatus),
    isSubmitting: !1,
    isValidating: !1,
    submitCount: 0
  }), be = we.current, q = _d(function(Ye) {
    var nn = we.current;
    we.current = Zje(nn, Ye), nn !== we.current && me(function(Bt) {
      return Bt + 1;
    });
  }, []), Te = _d(function(Ye, nn) {
    return new Promise(function(Bt, $n) {
      var mr = L.validate(Ye, nn);
      mr == null ? Bt(kA) : wW(mr) ? mr.then(function(gr) {
        Bt(gr || kA);
      }, function(gr) {
        process.env.NODE_ENV !== "production" && console.warn("Warning: An unhandled error was caught during validation in <Formik validate />", gr), $n(gr);
      }) : Bt(mr);
    });
  }, [L.validate]), Le = _d(function(Ye, nn) {
    var Bt = L.validationSchema, $n = Al(Bt) ? Bt(nn) : Bt, mr = nn && $n.validateAt ? $n.validateAt(nn, Ye) : Sye(Ye, $n);
    return new Promise(function(gr, Vr) {
      mr.then(function() {
        gr(kA);
      }, function(Xr) {
        Xr.name === "ValidationError" ? gr(yye(Xr)) : (process.env.NODE_ENV !== "production" && console.warn("Warning: An unhandled error was caught during validation in <Formik validationSchema />", Xr), Vr(Xr));
      });
    });
  }, [L.validationSchema]), je = _d(function(Ye, nn) {
    return new Promise(function(Bt) {
      return Bt(ue.current[Ye].validate(nn));
    });
  }, []), Ie = _d(function(Ye) {
    var nn = Object.keys(ue.current).filter(function($n) {
      return Al(ue.current[$n].validate);
    }), Bt = nn.length > 0 ? nn.map(function($n) {
      return je($n, pa(Ye, $n));
    }) : [Promise.resolve("DO_NOT_DELETE_YOU_WILL_BE_FIRED")];
    return Promise.all(Bt).then(function($n) {
      return $n.reduce(function(mr, gr, Vr) {
        return gr === "DO_NOT_DELETE_YOU_WILL_BE_FIRED" || gr && (mr = _1(mr, nn[Vr], gr)), mr;
      }, {});
    });
  }, [je]), Ce = _d(function(Ye) {
    return Promise.all([Ie(Ye), L.validationSchema ? Le(Ye) : {}, L.validate ? Te(Ye) : {}]).then(function(nn) {
      var Bt = nn[0], $n = nn[1], mr = nn[2], gr = Bse.all([Bt, $n, mr], {
        arrayMerge: Kje
      });
      return gr;
    });
  }, [L.validate, L.validationSchema, Ie, Te, Le]), pt = cy(function(Ye) {
    return Ye === void 0 && (Ye = be.values), q({
      type: "SET_ISVALIDATING",
      payload: !0
    }), Ce(Ye).then(function(nn) {
      return he.current && (q({
        type: "SET_ISVALIDATING",
        payload: !1
      }), q({
        type: "SET_ERRORS",
        payload: nn
      })), nn;
    });
  });
  Ch(function() {
    v && he.current === !0 && l2(Z.current, L.initialValues) && pt(Z.current);
  }, [v, pt]);
  var sn = _d(function(Ye) {
    var nn = Ye && Ye.values ? Ye.values : Z.current, Bt = Ye && Ye.errors ? Ye.errors : ne.current ? ne.current : L.initialErrors || {}, $n = Ye && Ye.touched ? Ye.touched : se.current ? se.current : L.initialTouched || {}, mr = Ye && Ye.status ? Ye.status : Q.current ? Q.current : L.initialStatus;
    Z.current = nn, ne.current = Bt, se.current = $n, Q.current = mr;
    var gr = function() {
      q({
        type: "RESET_FORM",
        payload: {
          isSubmitting: !!Ye && !!Ye.isSubmitting,
          errors: Bt,
          touched: $n,
          status: mr,
          values: nn,
          isValidating: !!Ye && !!Ye.isValidating,
          submitCount: Ye && Ye.submitCount && typeof Ye.submitCount == "number" ? Ye.submitCount : 0
        }
      });
    };
    if (L.onReset) {
      var Vr = L.onReset(be.values, wo);
      wW(Vr) ? Vr.then(gr) : gr();
    } else
      gr();
  }, [L.initialErrors, L.initialStatus, L.initialTouched, L.onReset]);
  Ch(function() {
    he.current === !0 && !l2(Z.current, L.initialValues) && O && (Z.current = L.initialValues, sn(), v && pt(Z.current));
  }, [O, L.initialValues, sn, v, pt]), Ch(function() {
    O && he.current === !0 && !l2(ne.current, L.initialErrors) && (ne.current = L.initialErrors || kA, q({
      type: "SET_ERRORS",
      payload: L.initialErrors || kA
    }));
  }, [O, L.initialErrors]), Ch(function() {
    O && he.current === !0 && !l2(se.current, L.initialTouched) && (se.current = L.initialTouched || oW, q({
      type: "SET_TOUCHED",
      payload: L.initialTouched || oW
    }));
  }, [O, L.initialTouched]), Ch(function() {
    O && he.current === !0 && !l2(Q.current, L.initialStatus) && (Q.current = L.initialStatus, q({
      type: "SET_STATUS",
      payload: L.initialStatus
    }));
  }, [O, L.initialStatus, L.initialTouched]);
  var Lt = cy(function(Ye) {
    if (ue.current[Ye] && Al(ue.current[Ye].validate)) {
      var nn = pa(be.values, Ye), Bt = ue.current[Ye].validate(nn);
      return wW(Bt) ? (q({
        type: "SET_ISVALIDATING",
        payload: !0
      }), Bt.then(function($n) {
        return $n;
      }).then(function($n) {
        q({
          type: "SET_FIELD_ERROR",
          payload: {
            field: Ye,
            value: $n
          }
        }), q({
          type: "SET_ISVALIDATING",
          payload: !1
        });
      })) : (q({
        type: "SET_FIELD_ERROR",
        payload: {
          field: Ye,
          value: Bt
        }
      }), Promise.resolve(Bt));
    } else if (L.validationSchema)
      return q({
        type: "SET_ISVALIDATING",
        payload: !0
      }), Le(be.values, Ye).then(function($n) {
        return $n;
      }).then(function($n) {
        q({
          type: "SET_FIELD_ERROR",
          payload: {
            field: Ye,
            value: pa($n, Ye)
          }
        }), q({
          type: "SET_ISVALIDATING",
          payload: !1
        });
      });
    return Promise.resolve();
  }), z = _d(function(Ye, nn) {
    var Bt = nn.validate;
    ue.current[Ye] = {
      validate: Bt
    };
  }, []), bt = _d(function(Ye) {
    delete ue.current[Ye];
  }, []), at = cy(function(Ye, nn) {
    q({
      type: "SET_TOUCHED",
      payload: Ye
    });
    var Bt = nn === void 0 ? d : nn;
    return Bt ? pt(be.values) : Promise.resolve();
  }), _n = _d(function(Ye) {
    q({
      type: "SET_ERRORS",
      payload: Ye
    });
  }, []), st = cy(function(Ye, nn) {
    var Bt = Al(Ye) ? Ye(be.values) : Ye;
    q({
      type: "SET_VALUES",
      payload: Bt
    });
    var $n = nn === void 0 ? c : nn;
    return $n ? pt(Bt) : Promise.resolve();
  }), Ne = _d(function(Ye, nn) {
    q({
      type: "SET_FIELD_ERROR",
      payload: {
        field: Ye,
        value: nn
      }
    });
  }, []), vt = cy(function(Ye, nn, Bt) {
    q({
      type: "SET_FIELD_VALUE",
      payload: {
        field: Ye,
        value: nn
      }
    });
    var $n = Bt === void 0 ? c : Bt;
    return $n ? pt(_1(be.values, Ye, nn)) : Promise.resolve();
  }), Gt = _d(function(Ye, nn) {
    var Bt = nn, $n = Ye, mr;
    if (!SW(Ye)) {
      Ye.persist && Ye.persist();
      var gr = Ye.target ? Ye.target : Ye.currentTarget, Vr = gr.type, Xr = gr.name, pc = gr.id, Eo = gr.value, uo = gr.checked, Es = gr.outerHTML, br = gr.options, hs = gr.multiple;
      Bt = nn || Xr || pc, !Bt && process.env.NODE_ENV !== "production" && Rme({
        htmlContent: Es,
        documentationAnchorLink: "handlechange-e-reactchangeeventany--void",
        handlerName: "handleChange"
      }), $n = /number|range/.test(Vr) ? (mr = parseFloat(Eo), isNaN(mr) ? "" : mr) : /checkbox/.test(Vr) ? Qje(pa(be.values, Bt), uo, Eo) : br && hs ? Yje(br) : Eo;
    }
    Bt && vt(Bt, $n);
  }, [vt, be.values]), xt = cy(function(Ye) {
    if (SW(Ye))
      return function(nn) {
        return Gt(nn, Ye);
      };
    Gt(Ye);
  }), cn = cy(function(Ye, nn, Bt) {
    nn === void 0 && (nn = !0), q({
      type: "SET_FIELD_TOUCHED",
      payload: {
        field: Ye,
        value: nn
      }
    });
    var $n = Bt === void 0 ? d : Bt;
    return $n ? pt(be.values) : Promise.resolve();
  }), He = _d(function(Ye, nn) {
    Ye.persist && Ye.persist();
    var Bt = Ye.target, $n = Bt.name, mr = Bt.id, gr = Bt.outerHTML, Vr = nn || $n || mr;
    !Vr && process.env.NODE_ENV !== "production" && Rme({
      htmlContent: gr,
      documentationAnchorLink: "handleblur-e-any--void",
      handlerName: "handleBlur"
    }), cn(Vr, !0);
  }, [cn]), ut = cy(function(Ye) {
    if (SW(Ye))
      return function(nn) {
        return He(nn, Ye);
      };
    He(Ye);
  }), oe = _d(function(Ye) {
    Al(Ye) ? q({
      type: "SET_FORMIK_STATE",
      payload: Ye
    }) : q({
      type: "SET_FORMIK_STATE",
      payload: function() {
        return Ye;
      }
    });
  }, []), qn = _d(function(Ye) {
    q({
      type: "SET_STATUS",
      payload: Ye
    });
  }, []), Rn = _d(function(Ye) {
    q({
      type: "SET_ISSUBMITTING",
      payload: Ye
    });
  }, []), Zt = cy(function() {
    return q({
      type: "SUBMIT_ATTEMPT"
    }), pt().then(function(Ye) {
      var nn = Ye instanceof Error, Bt = !nn && Object.keys(Ye).length === 0;
      if (Bt) {
        var $n;
        try {
          if ($n = Ge(), $n === void 0)
            return;
        } catch (mr) {
          throw mr;
        }
        return Promise.resolve($n).then(function(mr) {
          return he.current && q({
            type: "SUBMIT_SUCCESS"
          }), mr;
        }).catch(function(mr) {
          if (he.current)
            throw q({
              type: "SUBMIT_FAILURE"
            }), mr;
        });
      } else if (he.current && (q({
        type: "SUBMIT_FAILURE"
      }), nn))
        throw Ye;
    });
  }), Jt = cy(function(Ye) {
    if (Ye && Ye.preventDefault && Al(Ye.preventDefault) && Ye.preventDefault(), Ye && Ye.stopPropagation && Al(Ye.stopPropagation) && Ye.stopPropagation(), process.env.NODE_ENV !== "production" && typeof document < "u") {
      var nn = gye();
      nn !== null && nn instanceof HTMLButtonElement && (nn.attributes && nn.attributes.getNamedItem("type") || (process.env.NODE_ENV !== "production" ? di(!1, 'You submitted a Formik form using a button with an unspecified `type` attribute.  Most browsers default button elements to `type="submit"`. If this is not a submit button, please add `type="button"`.') : di(!1)));
    }
    Zt().catch(function(Bt) {
      console.warn("Warning: An unhandled error was caught from submitForm()", Bt);
    });
  }), wo = {
    resetForm: sn,
    validateForm: pt,
    validateField: Lt,
    setErrors: _n,
    setFieldError: Ne,
    setFieldTouched: cn,
    setFieldValue: vt,
    setStatus: qn,
    setSubmitting: Rn,
    setTouched: at,
    setValues: st,
    setFormikState: oe,
    submitForm: Zt
  }, Ge = cy(function() {
    return R(be.values, wo);
  }), qt = cy(function(Ye) {
    Ye && Ye.preventDefault && Al(Ye.preventDefault) && Ye.preventDefault(), Ye && Ye.stopPropagation && Al(Ye.stopPropagation) && Ye.stopPropagation(), sn();
  }), St = _d(function(Ye) {
    return {
      value: pa(be.values, Ye),
      error: pa(be.errors, Ye),
      touched: !!pa(be.touched, Ye),
      initialValue: pa(Z.current, Ye),
      initialTouched: !!pa(se.current, Ye),
      initialError: pa(ne.current, Ye)
    };
  }, [be.errors, be.touched, be.values]), ke = _d(function(Ye) {
    return {
      setValue: function(Bt, $n) {
        return vt(Ye, Bt, $n);
      },
      setTouched: function(Bt, $n) {
        return cn(Ye, Bt, $n);
      },
      setError: function(Bt) {
        return Ne(Ye, Bt);
      }
    };
  }, [vt, cn, Ne]), Ct = _d(function(Ye) {
    var nn = LC(Ye), Bt = nn ? Ye.name : Ye, $n = pa(be.values, Bt), mr = {
      name: Bt,
      value: $n,
      onChange: xt,
      onBlur: ut
    };
    if (nn) {
      var gr = Ye.type, Vr = Ye.value, Xr = Ye.as, pc = Ye.multiple;
      gr === "checkbox" ? Vr === void 0 ? mr.checked = !!$n : (mr.checked = !!(Array.isArray($n) && ~$n.indexOf(Vr)), mr.value = Vr) : gr === "radio" ? (mr.checked = $n === Vr, mr.value = Vr) : Xr === "select" && pc && (mr.value = mr.value || [], mr.multiple = !0);
    }
    return mr;
  }, [ut, xt, be.values]), an = Rv(function() {
    return !l2(Z.current, be.values);
  }, [Z.current, be.values]), ht = Rv(function() {
    return typeof g < "u" ? an ? be.errors && Object.keys(be.errors).length === 0 : g !== !1 && Al(g) ? g(L) : g : be.errors && Object.keys(be.errors).length === 0;
  }, [g, an, be.errors, L]), bn = ma({}, be, {
    initialValues: Z.current,
    initialErrors: ne.current,
    initialTouched: se.current,
    initialStatus: Q.current,
    handleBlur: ut,
    handleChange: xt,
    handleReset: qt,
    handleSubmit: Jt,
    resetForm: sn,
    setErrors: _n,
    setFormikState: oe,
    setFieldTouched: cn,
    setFieldValue: vt,
    setFieldError: Ne,
    setStatus: qn,
    setSubmitting: Rn,
    setTouched: at,
    setValues: st,
    submitForm: Zt,
    validateForm: pt,
    validateField: Lt,
    isValid: ht,
    dirty: an,
    unregisterField: bt,
    registerField: z,
    getFieldProps: Ct,
    getFieldMeta: St,
    getFieldHelpers: ke,
    validateOnBlur: d,
    validateOnChange: c,
    validateOnMount: v
  });
  return bn;
}
function bye(r) {
  var o = vye(r), c = r.component, i = r.children, d = r.render, m = r.innerRef;
  return y0e(m, function() {
    return o;
  }), process.env.NODE_ENV !== "production" && Ch(function() {
    r.render && (process.env.NODE_ENV !== "production" ? di(!1, "<Formik render> has been deprecated and will be removed in future versions of Formik. Please use a child callback function instead. To get rid of this warning, replace <Formik render={(props) => ...} /> with <Formik>{(props) => ...}</Formik>") : di(!1));
  }, []), Od(mye, {
    value: o
  }, c ? Od(c, o) : d ? d(o) : i ? Al(i) ? i(o) : n5(i) ? null : _k.only(i) : null);
}
function Rme(r) {
  var o = r.htmlContent, c = r.documentationAnchorLink, i = r.handlerName;
  console.warn("Warning: Formik called `" + i + "`, but you forgot to pass an `id` or `name` attribute to your input:\n    " + o + `
    Formik cannot determine which value to update. For more info see https://formik.org/docs/api/formik#` + c + `
  `);
}
function yye(r) {
  var o = {};
  if (r.inner) {
    if (r.inner.length === 0)
      return _1(o, r.path, r.message);
    for (var d = r.inner, c = Array.isArray(d), i = 0, d = c ? d : d[Symbol.iterator](); ; ) {
      var m;
      if (c) {
        if (i >= d.length)
          break;
        m = d[i++];
      } else {
        if (i = d.next(), i.done)
          break;
        m = i.value;
      }
      var v = m;
      pa(o, v.path) || (o = _1(o, v.path, v.message));
    }
  }
  return o;
}
function Sye(r, o, c, i) {
  c === void 0 && (c = !1);
  var d = ej(r);
  return o[c ? "validateSync" : "validate"](d, {
    abortEarly: !1,
    context: i || d
  });
}
function ej(r) {
  var o = Array.isArray(r) ? [] : {};
  for (var c in r)
    if (Object.prototype.hasOwnProperty.call(r, c)) {
      var i = String(c);
      Array.isArray(r[i]) === !0 ? o[i] = r[i].map(function(d) {
        return Array.isArray(d) === !0 || y2(d) ? ej(d) : d !== "" ? d : void 0;
      }) : y2(r[i]) ? o[i] = ej(r[i]) : o[i] = r[i] !== "" ? r[i] : void 0;
    }
  return o;
}
function Kje(r, o, c) {
  var i = r.slice();
  return o.forEach(function(m, v) {
    if (typeof i[v] > "u") {
      var g = c.clone !== !1, C = g && c.isMergeableObject(m);
      i[v] = C ? Bse(Array.isArray(m) ? [] : {}, m, c) : m;
    } else
      c.isMergeableObject(m) ? i[v] = Bse(r[v], m, c) : r.indexOf(m) === -1 && i.push(m);
  }), i;
}
function Yje(r) {
  return Array.from(r).filter(function(o) {
    return o.selected;
  }).map(function(o) {
    return o.value;
  });
}
function Qje(r, o, c) {
  if (typeof r == "boolean")
    return !!o;
  var i = [], d = !1, m = -1;
  if (Array.isArray(r))
    i = r, m = r.indexOf(c), d = m >= 0;
  else if (!c || c == "true" || c == "false")
    return !!o;
  return o && c && !d ? i.concat(c) : d ? i.slice(0, m).concat(i.slice(m + 1)) : i;
}
var Xje = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? ype : Ch;
function cy(r) {
  var o = uy(r);
  return Xje(function() {
    o.current = r;
  }), _d(function() {
    for (var c = arguments.length, i = new Array(c), d = 0; d < c; d++)
      i[d] = arguments[d];
    return o.current.apply(void 0, i);
  }, []);
}
function Jje(r) {
  var o = dq(), c = o.getFieldProps, i = o.getFieldMeta, d = o.getFieldHelpers, m = o.registerField, v = o.unregisterField, g = LC(r), C = g ? r : {
    name: r
  }, O = C.name, R = C.validate;
  Ch(function() {
    return O && m(O, {
      validate: R
    }), function() {
      O && v(O);
    };
  }, [m, v, O, R]), process.env.NODE_ENV !== "production" && (o || (process.env.NODE_ENV !== "production" ? di(!1, "useField() / <Field /> must be used underneath a <Formik> component or withFormik() higher order component") : di(!1))), O || (process.env.NODE_ENV !== "production" ? di(!1, "Invalid field name. Either pass `useField` a string or an object containing a `name` key.") : di(!1));
  var I = Rv(function() {
    return d(O);
  }, [d, O]);
  return [c(C), i(O), I];
}
function eqe(r) {
  var o = r.validate, c = r.name, i = r.render, d = r.children, m = r.as, v = r.component, g = r.className, C = Ag(r, ["validate", "name", "render", "children", "as", "component", "className"]), O = dq(), R = Ag(O, ["validate", "validationSchema"]);
  process.env.NODE_ENV !== "production" && Ch(function() {
    i && (process.env.NODE_ENV !== "production" ? di(!1, '<Field render> has been deprecated and will be removed in future versions of Formik. Please use a child callback function instead. To get rid of this warning, replace <Field name="' + c + '" render={({field, form}) => ...} /> with <Field name="' + c + '">{({field, form, meta}) => ...}</Field>') : di(!1)), m && d && Al(d) && (process.env.NODE_ENV !== "production" ? di(!1, "You should not use <Field as> and <Field children> as a function in the same <Field> component; <Field as> will be ignored.") : di(!1)), v && d && Al(d) && (process.env.NODE_ENV !== "production" ? di(!1, "You should not use <Field component> and <Field children> as a function in the same <Field> component; <Field component> will be ignored.") : di(!1)), i && d && !n5(d) && (process.env.NODE_ENV !== "production" ? di(!1, "You should not use <Field render> and <Field children> in the same <Field> component; <Field children> will be ignored") : di(!1));
  }, []);
  var I = R.registerField, L = R.unregisterField;
  Ch(function() {
    return I(c, {
      validate: o
    }), function() {
      L(c);
    };
  }, [I, L, c, o]);
  var Z = R.getFieldProps(ma({
    name: c
  }, C)), ne = R.getFieldMeta(c), se = {
    field: Z,
    form: R
  };
  if (i)
    return i(ma({}, se, {
      meta: ne
    }));
  if (Al(d))
    return d(ma({}, se, {
      meta: ne
    }));
  if (v) {
    if (typeof v == "string") {
      var Q = C.innerRef, he = Ag(C, ["innerRef"]);
      return Od(v, ma({
        ref: Q
      }, Z, he, {
        className: g
      }), d);
    }
    return Od(v, ma({
      field: Z,
      form: R
    }, C, {
      className: g
    }), d);
  }
  var ue = m || "input";
  if (typeof ue == "string") {
    var G = C.innerRef, me = Ag(C, ["innerRef"]);
    return Od(ue, ma({
      ref: G
    }, Z, me, {
      className: g
    }), d);
  }
  return Od(ue, ma({}, Z, C, {
    className: g
  }), d);
}
var wye = /* @__PURE__ */ S0e(function(r, o) {
  var c = r.action, i = Ag(r, ["action"]), d = c ?? "#", m = dq(), v = m.handleReset, g = m.handleSubmit;
  return Od("form", ma({
    onSubmit: g,
    ref: o,
    onReset: v,
    action: d
  }, i));
});
wye.displayName = "Form";
function tqe(r) {
  var o = r.mapPropsToValues, c = o === void 0 ? function(d) {
    var m = {};
    for (var v in d)
      d.hasOwnProperty(v) && typeof d[v] != "function" && (m[v] = d[v]);
    return m;
  } : o, i = Ag(r, ["mapPropsToValues"]);
  return function(m) {
    var v = m.displayName || m.name || m.constructor && m.constructor.name || "Component", g = /* @__PURE__ */ function(C) {
      uq(O, C);
      function O() {
        for (var I, L = arguments.length, Z = new Array(L), ne = 0; ne < L; ne++)
          Z[ne] = arguments[ne];
        return I = C.call.apply(C, [this].concat(Z)) || this, I.validate = function(se) {
          return i.validate(se, I.props);
        }, I.validationSchema = function() {
          return Al(i.validationSchema) ? i.validationSchema(I.props) : i.validationSchema;
        }, I.handleSubmit = function(se, Q) {
          return i.handleSubmit(se, ma({}, Q, {
            props: I.props
          }));
        }, I.renderFormComponent = function(se) {
          return Od(m, ma({}, I.props, se));
        }, I;
      }
      var R = O.prototype;
      return R.render = function() {
        var L = this.props, Z = Ag(L, ["children"]);
        return Od(bye, ma({}, Z, i, {
          validate: i.validate && this.validate,
          validationSchema: i.validationSchema && this.validationSchema,
          initialValues: c(this.props),
          initialStatus: i.mapPropsToStatus && i.mapPropsToStatus(this.props),
          initialErrors: i.mapPropsToErrors && i.mapPropsToErrors(this.props),
          initialTouched: i.mapPropsToTouched && i.mapPropsToTouched(this.props),
          onSubmit: this.handleSubmit,
          children: this.renderFormComponent
        }));
      }, O;
    }(Do);
    return g.displayName = "WithFormik(" + v + ")", KW(
      g,
      m
      // cast type to ComponentClass (even if SFC)
    );
  };
}
function fq(r) {
  var o = function(d) {
    return Od(pye, null, function(m) {
      return m || (process.env.NODE_ENV !== "production" ? di(!1, "Formik context is undefined, please verify you are rendering <Form>, <Field>, <FastField>, <FieldArray>, or your custom context-using component as a child of a <Formik> component. Component name: " + r.name) : di(!1)), Od(r, ma({}, d, {
        formik: m
      }));
    });
  }, c = r.displayName || r.name || r.constructor && r.constructor.name || "Component";
  return o.WrappedComponent = r, o.displayName = "FormikConnect(" + c + ")", KW(
    o,
    r
    // cast type to ComponentClass (even if SFC)
  );
}
var Eye = function(o, c, i) {
  var d = Ck(o), m = d[c];
  return d.splice(c, 1), d.splice(i, 0, m), d;
}, Cye = function(o, c, i) {
  var d = Ck(o), m = d[c];
  return d[c] = d[i], d[i] = m, d;
}, EW = function(o, c, i) {
  var d = Ck(o);
  return d.splice(c, 0, i), d;
}, xye = function(o, c, i) {
  var d = Ck(o);
  return d[c] = i, d;
}, Ck = function(o) {
  if (o) {
    if (Array.isArray(o))
      return [].concat(o);
    var c = Object.keys(o).map(function(i) {
      return parseInt(i);
    }).reduce(function(i, d) {
      return d > i ? d : i;
    }, 0);
    return Array.from(ma({}, o, {
      length: c + 1
    }));
  } else
    return [];
}, Pme = function(o, c) {
  var i = typeof o == "function" ? o : c;
  return function(d) {
    if (Array.isArray(d) || LC(d)) {
      var m = Ck(d);
      return i(m);
    }
    return d;
  };
}, Tye = /* @__PURE__ */ function(r) {
  uq(o, r);
  function o(i) {
    var d;
    return d = r.call(this, i) || this, d.updateArrayField = function(m, v, g) {
      var C = d.props, O = C.name, R = C.formik.setFormikState;
      R(function(I) {
        var L = Pme(g, m), Z = Pme(v, m), ne = _1(I.values, O, m(pa(I.values, O))), se = g ? L(pa(I.errors, O)) : void 0, Q = v ? Z(pa(I.touched, O)) : void 0;
        return zse(se) && (se = void 0), zse(Q) && (Q = void 0), ma({}, I, {
          values: ne,
          errors: g ? _1(I.errors, O, se) : I.errors,
          touched: v ? _1(I.touched, O, Q) : I.touched
        });
      });
    }, d.push = function(m) {
      return d.updateArrayField(function(v) {
        return [].concat(Ck(v), [YL(m)]);
      }, !1, !1);
    }, d.handlePush = function(m) {
      return function() {
        return d.push(m);
      };
    }, d.swap = function(m, v) {
      return d.updateArrayField(function(g) {
        return Cye(g, m, v);
      }, !0, !0);
    }, d.handleSwap = function(m, v) {
      return function() {
        return d.swap(m, v);
      };
    }, d.move = function(m, v) {
      return d.updateArrayField(function(g) {
        return Eye(g, m, v);
      }, !0, !0);
    }, d.handleMove = function(m, v) {
      return function() {
        return d.move(m, v);
      };
    }, d.insert = function(m, v) {
      return d.updateArrayField(function(g) {
        return EW(g, m, v);
      }, function(g) {
        return EW(g, m, null);
      }, function(g) {
        return EW(g, m, null);
      });
    }, d.handleInsert = function(m, v) {
      return function() {
        return d.insert(m, v);
      };
    }, d.replace = function(m, v) {
      return d.updateArrayField(function(g) {
        return xye(g, m, v);
      }, !1, !1);
    }, d.handleReplace = function(m, v) {
      return function() {
        return d.replace(m, v);
      };
    }, d.unshift = function(m) {
      var v = -1;
      return d.updateArrayField(function(g) {
        var C = g ? [m].concat(g) : [m];
        return v = C.length, C;
      }, function(g) {
        return g ? [null].concat(g) : [null];
      }, function(g) {
        return g ? [null].concat(g) : [null];
      }), v;
    }, d.handleUnshift = function(m) {
      return function() {
        return d.unshift(m);
      };
    }, d.handleRemove = function(m) {
      return function() {
        return d.remove(m);
      };
    }, d.handlePop = function() {
      return function() {
        return d.pop();
      };
    }, d.remove = d.remove.bind(Nme(d)), d.pop = d.pop.bind(Nme(d)), d;
  }
  var c = o.prototype;
  return c.componentDidUpdate = function(d) {
    this.props.validateOnChange && this.props.formik.validateOnChange && !l2(pa(d.formik.values, d.name), pa(this.props.formik.values, this.props.name)) && this.props.formik.validateForm(this.props.formik.values);
  }, c.remove = function(d) {
    var m;
    return this.updateArrayField(
      // so this gets call 3 times
      function(v) {
        var g = v ? Ck(v) : [];
        return m || (m = g[d]), Al(g.splice) && g.splice(d, 1), Al(g.every) && g.every(function(C) {
          return C === void 0;
        }) ? [] : g;
      },
      !0,
      !0
    ), m;
  }, c.pop = function() {
    var d;
    return this.updateArrayField(
      // so this gets call 3 times
      function(m) {
        var v = m.slice();
        return d || (d = v && v.pop && v.pop()), v;
      },
      !0,
      !0
    ), d;
  }, c.render = function() {
    var d = {
      push: this.push,
      pop: this.pop,
      swap: this.swap,
      move: this.move,
      insert: this.insert,
      replace: this.replace,
      unshift: this.unshift,
      remove: this.remove,
      handlePush: this.handlePush,
      handlePop: this.handlePop,
      handleSwap: this.handleSwap,
      handleMove: this.handleMove,
      handleInsert: this.handleInsert,
      handleReplace: this.handleReplace,
      handleUnshift: this.handleUnshift,
      handleRemove: this.handleRemove
    }, m = this.props, v = m.component, g = m.render, C = m.children, O = m.name, R = m.formik, I = Ag(R, ["validate", "validationSchema"]), L = ma({}, d, {
      form: I,
      name: O
    });
    return v ? Od(v, L) : g ? g(L) : C ? typeof C == "function" ? C(L) : n5(C) ? null : _k.only(C) : null;
  }, o;
}(Do);
Tye.defaultProps = {
  validateOnChange: !0
};
var nqe = /* @__PURE__ */ fq(Tye), rqe = /* @__PURE__ */ function(r) {
  uq(o, r);
  function o() {
    return r.apply(this, arguments) || this;
  }
  var c = o.prototype;
  return c.shouldComponentUpdate = function(d) {
    return pa(this.props.formik.errors, this.props.name) !== pa(d.formik.errors, this.props.name) || pa(this.props.formik.touched, this.props.name) !== pa(d.formik.touched, this.props.name) || Object.keys(this.props).length !== Object.keys(d).length;
  }, c.render = function() {
    var d = this.props, m = d.component, v = d.formik, g = d.render, C = d.children, O = d.name, R = Ag(d, ["component", "formik", "render", "children", "name"]), I = pa(v.touched, O), L = pa(v.errors, O);
    return I && L ? g ? Al(g) ? g(L) : null : C ? Al(C) ? C(L) : null : m ? Od(m, R, L) : L : null;
  }, o;
}(Do), oqe = /* @__PURE__ */ fq(rqe), sqe = /* @__PURE__ */ function(r) {
  uq(o, r);
  function o(i) {
    var d;
    d = r.call(this, i) || this;
    var m = i.render, v = i.children, g = i.component, C = i.as, O = i.name;
    return m && (process.env.NODE_ENV !== "production" ? di(!1, "<FastField render> has been deprecated. Please use a child callback function instead: <FastField name={" + O + "}>{props => ...}</FastField> instead.") : di(!1)), g && m && (process.env.NODE_ENV !== "production" ? di(!1, "You should not use <FastField component> and <FastField render> in the same <FastField> component; <FastField component> will be ignored") : di(!1)), C && v && Al(v) && (process.env.NODE_ENV !== "production" ? di(!1, "You should not use <FastField as> and <FastField children> as a function in the same <FastField> component; <FastField as> will be ignored.") : di(!1)), g && v && Al(v) && (process.env.NODE_ENV !== "production" ? di(!1, "You should not use <FastField component> and <FastField children> as a function in the same <FastField> component; <FastField component> will be ignored.") : di(!1)), m && v && !n5(v) && (process.env.NODE_ENV !== "production" ? di(!1, "You should not use <FastField render> and <FastField children> in the same <FastField> component; <FastField children> will be ignored") : di(!1)), d;
  }
  var c = o.prototype;
  return c.shouldComponentUpdate = function(d) {
    return this.props.shouldUpdate ? this.props.shouldUpdate(d, this.props) : d.name !== this.props.name || pa(d.formik.values, this.props.name) !== pa(this.props.formik.values, this.props.name) || pa(d.formik.errors, this.props.name) !== pa(this.props.formik.errors, this.props.name) || pa(d.formik.touched, this.props.name) !== pa(this.props.formik.touched, this.props.name) || Object.keys(this.props).length !== Object.keys(d).length || d.formik.isSubmitting !== this.props.formik.isSubmitting;
  }, c.componentDidMount = function() {
    this.props.formik.registerField(this.props.name, {
      validate: this.props.validate
    });
  }, c.componentDidUpdate = function(d) {
    this.props.name !== d.name && (this.props.formik.unregisterField(d.name), this.props.formik.registerField(this.props.name, {
      validate: this.props.validate
    })), this.props.validate !== d.validate && this.props.formik.registerField(this.props.name, {
      validate: this.props.validate
    });
  }, c.componentWillUnmount = function() {
    this.props.formik.unregisterField(this.props.name);
  }, c.render = function() {
    var d = this.props, m = d.name, v = d.render, g = d.as, C = d.children, O = d.component, R = d.formik, I = Ag(d, ["validate", "name", "render", "as", "children", "component", "shouldUpdate", "formik"]), L = Ag(R, ["validate", "validationSchema"]), Z = R.getFieldProps(ma({
      name: m
    }, I)), ne = {
      value: pa(R.values, m),
      error: pa(R.errors, m),
      touched: !!pa(R.touched, m),
      initialValue: pa(R.initialValues, m),
      initialTouched: !!pa(R.initialTouched, m),
      initialError: pa(R.initialErrors, m)
    }, se = {
      field: Z,
      meta: ne,
      form: L
    };
    if (v)
      return v(se);
    if (Al(C))
      return C(se);
    if (O) {
      if (typeof O == "string") {
        var Q = I.innerRef, he = Ag(I, ["innerRef"]);
        return Od(O, ma({
          ref: Q
        }, Z, he), C);
      }
      return Od(O, ma({
        field: Z,
        form: R
      }, I), C);
    }
    var ue = g || "input";
    if (typeof ue == "string") {
      var G = I.innerRef, me = Ag(I, ["innerRef"]);
      return Od(ue, ma({
        ref: G
      }, Z, me), C);
    }
    return Od(ue, ma({}, Z, I), C);
  }, o;
}(Do), aqe = /* @__PURE__ */ fq(sqe);
const iqe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ErrorMessage: oqe,
  FastField: aqe,
  Field: eqe,
  FieldArray: nqe,
  Form: wye,
  Formik: bye,
  FormikConsumer: pye,
  FormikContext: t5,
  FormikProvider: mye,
  connect: fq,
  getActiveElement: gye,
  getIn: pa,
  insert: EW,
  isEmptyArray: zse,
  isEmptyChildren: n5,
  isFunction: Al,
  isInputEvent: Gje,
  isInteger: hye,
  isNaN: qje,
  isObject: LC,
  isPromise: wW,
  isString: SW,
  move: Eye,
  prepareDataForValidation: ej,
  replace: xye,
  setIn: _1,
  setNestedObjectValues: Hie,
  swap: Cye,
  useField: Jje,
  useFormik: vye,
  useFormikContext: dq,
  validateYupSchema: Sye,
  withFormik: tqe,
  yupToFormErrors: yye
}, Symbol.toStringTag, { value: "Module" })), cqe = /* @__PURE__ */ q$(iqe);
function lqe(r) {
  var o = r == null ? 0 : r.length;
  return o ? r[o - 1] : void 0;
}
var uqe = lqe;
function dqe(r, o, c) {
  var i = -1, d = r.length;
  o < 0 && (o = -o > d ? 0 : d + o), c = c > d ? d : c, c < 0 && (c += d), d = o > c ? 0 : c - o >>> 0, o >>>= 0;
  for (var m = Array(d); ++i < d; )
    m[i] = r[i + o];
  return m;
}
var fqe = dqe, mqe = eq, pqe = fqe;
function hqe(r, o) {
  return o.length < 2 ? r : mqe(r, pqe(o, 0, -1));
}
var gqe = hqe, vqe = aI, bqe = uqe, yqe = gqe, Sqe = iI;
function wqe(r, o) {
  return o = vqe(o, r), r = yqe(r, o), r == null || delete r[Sqe(bqe(o))];
}
var Eqe = wqe, Cqe = UC, xqe = wie, Tqe = M1, _qe = "[object Object]", Oqe = Function.prototype, Aqe = Object.prototype, _ye = Oqe.toString, kqe = Aqe.hasOwnProperty, Nqe = _ye.call(Object);
function Rqe(r) {
  if (!Tqe(r) || Cqe(r) != _qe)
    return !1;
  var o = xqe(r);
  if (o === null)
    return !0;
  var c = kqe.call(o, "constructor") && o.constructor;
  return typeof c == "function" && c instanceof c && _ye.call(c) == Nqe;
}
var Pqe = Rqe, Dqe = Pqe;
function $qe(r) {
  return Dqe(r) ? void 0 : r;
}
var Iqe = $qe, Mqe = cie, Fqe = xie, Lqe = Eqe, Bqe = aI, Hqe = uI, zqe = Iqe, Vqe = Ove, Uqe = Eie, Wqe = 1, jqe = 2, qqe = 4, Gqe = Vqe(function(r, o) {
  var c = {};
  if (r == null)
    return c;
  var i = !1;
  o = Mqe(o, function(m) {
    return m = Bqe(m, r), i || (i = m.length > 1), m;
  }), Hqe(r, Uqe(r), c), i && (c = Fqe(c, Wqe | jqe | qqe, zqe));
  for (var d = o.length; d--; )
    Lqe(c, o[d]);
  return c;
}), Zqe = Gqe;
function Kqe(r) {
  return function(o, c, i) {
    for (var d = -1, m = Object(o), v = i(o), g = v.length; g--; ) {
      var C = v[r ? g : ++d];
      if (c(m[C], C, m) === !1)
        break;
    }
    return o;
  };
}
var Yqe = Kqe, Qqe = Yqe, Xqe = Qqe(), Jqe = Xqe, eGe = Jqe, tGe = JB;
function nGe(r, o) {
  return r && eGe(r, o, tGe);
}
var rGe = nGe, oGe = ZB;
function sGe(r, o) {
  return function(c, i) {
    if (c == null)
      return c;
    if (!oGe(c))
      return r(c, i);
    for (var d = c.length, m = o ? d : -1, v = Object(c); (o ? m-- : ++m < d) && i(v[m], m, v) !== !1; )
      ;
    return c;
  };
}
var aGe = sGe, iGe = rGe, cGe = aGe, lGe = cGe(iGe), uGe = lGe, dGe = uGe;
function fGe(r, o) {
  var c = [];
  return dGe(r, function(i, d, m) {
    o(i, d, m) && c.push(i);
  }), c;
}
var mGe = fGe, pGe = Ave, hGe = mGe, gGe = Lie, vGe = $h;
function bGe(r, o) {
  var c = vGe(r) ? pGe : hGe;
  return c(r, gGe(o));
}
var yGe = bGe, SGe = xie, wGe = iye, EGe = 1;
function CGe(r) {
  return wGe(SGe(r, EGe));
}
var xGe = CGe, TGe = $1, _Ge = function() {
  return TGe.Date.now();
}, OGe = _Ge, AGe = /\s/;
function kGe(r) {
  for (var o = r.length; o-- && AGe.test(r.charAt(o)); )
    ;
  return o;
}
var NGe = kGe, RGe = NGe, PGe = /^\s+/;
function DGe(r) {
  return r && r.slice(0, RGe(r) + 1).replace(PGe, "");
}
var $Ge = DGe, IGe = $Ge, Dme = I1, MGe = Zj, $me = 0 / 0, FGe = /^[-+]0x[0-9a-f]+$/i, LGe = /^0b[01]+$/i, BGe = /^0o[0-7]+$/i, HGe = parseInt;
function zGe(r) {
  if (typeof r == "number")
    return r;
  if (MGe(r))
    return $me;
  if (Dme(r)) {
    var o = typeof r.valueOf == "function" ? r.valueOf() : r;
    r = Dme(o) ? o + "" : o;
  }
  if (typeof r != "string")
    return r === 0 ? r : +r;
  r = IGe(r);
  var c = LGe.test(r);
  return c || BGe.test(r) ? HGe(r.slice(2), c ? 2 : 8) : FGe.test(r) ? $me : +r;
}
var VGe = zGe, UGe = I1, Voe = OGe, Ime = VGe, WGe = "Expected a function", jGe = Math.max, qGe = Math.min;
function GGe(r, o, c) {
  var i, d, m, v, g, C, O = 0, R = !1, I = !1, L = !0;
  if (typeof r != "function")
    throw new TypeError(WGe);
  o = Ime(o) || 0, UGe(c) && (R = !!c.leading, I = "maxWait" in c, m = I ? jGe(Ime(c.maxWait) || 0, o) : m, L = "trailing" in c ? !!c.trailing : L);
  function Z(be) {
    var q = i, Te = d;
    return i = d = void 0, O = be, v = r.apply(Te, q), v;
  }
  function ne(be) {
    return O = be, g = setTimeout(he, o), R ? Z(be) : v;
  }
  function se(be) {
    var q = be - C, Te = be - O, Le = o - q;
    return I ? qGe(Le, m - Te) : Le;
  }
  function Q(be) {
    var q = be - C, Te = be - O;
    return C === void 0 || q >= o || q < 0 || I && Te >= m;
  }
  function he() {
    var be = Voe();
    if (Q(be))
      return ue(be);
    g = setTimeout(he, se(be));
  }
  function ue(be) {
    return g = void 0, L && i ? Z(be) : (i = d = void 0, v);
  }
  function G() {
    g !== void 0 && clearTimeout(g), O = 0, i = C = d = g = void 0;
  }
  function me() {
    return g === void 0 ? v : ue(Voe());
  }
  function we() {
    var be = Voe(), q = Q(be);
    if (i = arguments, d = this, C = be, q) {
      if (g === void 0)
        return ne(C);
      if (I)
        return clearTimeout(g), g = setTimeout(he, o), Z(C);
    }
    return g === void 0 && (g = setTimeout(he, o)), v;
  }
  return we.cancel = G, we.flush = me, we;
}
var ZGe = GGe;
function KGe(r, o, c, i) {
  for (var d = r.length, m = c + (i ? 1 : -1); i ? m-- : ++m < d; )
    if (o(r[m], m, r))
      return m;
  return -1;
}
var YGe = KGe;
function QGe(r) {
  return r !== r;
}
var XGe = QGe;
function JGe(r, o, c) {
  for (var i = c - 1, d = r.length; ++i < d; )
    if (r[i] === o)
      return i;
  return -1;
}
var eZe = JGe, tZe = YGe, nZe = XGe, rZe = eZe;
function oZe(r, o, c) {
  return o === o ? rZe(r, o, c) : tZe(r, nZe, c);
}
var sZe = oZe, aZe = sZe;
function iZe(r, o) {
  var c = r == null ? 0 : r.length;
  return !!c && aZe(r, o, 0) > -1;
}
var cZe = iZe;
function lZe(r, o, c) {
  for (var i = -1, d = r == null ? 0 : r.length; ++i < d; )
    if (c(o, r[i]))
      return !0;
  return !1;
}
var uZe = lZe;
function dZe() {
}
var fZe = dZe, Uoe = vge, mZe = fZe, pZe = Fie, hZe = 1 / 0, gZe = Uoe && 1 / pZe(new Uoe([, -0]))[1] == hZe ? function(r) {
  return new Uoe(r);
} : mZe, vZe = gZe, bZe = eye, yZe = cZe, SZe = uZe, wZe = tye, EZe = vZe, CZe = Fie, xZe = 200;
function TZe(r, o, c) {
  var i = -1, d = yZe, m = r.length, v = !0, g = [], C = g;
  if (c)
    v = !1, d = SZe;
  else if (m >= xZe) {
    var O = o ? null : EZe(r);
    if (O)
      return CZe(O);
    v = !1, d = wZe, C = new bZe();
  } else
    C = o ? [] : g;
  e:
    for (; ++i < m; ) {
      var R = r[i], I = o ? o(R) : R;
      if (R = c || R !== 0 ? R : 0, v && I === I) {
        for (var L = C.length; L--; )
          if (C[L] === I)
            continue e;
        o && C.push(I), g.push(R);
      } else
        d(C, I, c) || (C !== g && C.push(I), g.push(R));
    }
  return g;
}
var _Ze = TZe, OZe = Lie, AZe = _Ze;
function kZe(r, o) {
  return r && r.length ? AZe(r, OZe(o)) : [];
}
var NZe = kZe, Oye = {}, RZe = (r) => encodeURIComponent(r).replace(/[!'()*]/g, (o) => `%${o.charCodeAt(0).toString(16).toUpperCase()}`), Aye = "%[a-f0-9]{2}", Mme = new RegExp("(" + Aye + ")|([^%]+?)", "gi"), Fme = new RegExp("(" + Aye + ")+", "gi");
function Vse(r, o) {
  try {
    return [decodeURIComponent(r.join(""))];
  } catch {
  }
  if (r.length === 1)
    return r;
  o = o || 1;
  var c = r.slice(0, o), i = r.slice(o);
  return Array.prototype.concat.call([], Vse(c), Vse(i));
}
function PZe(r) {
  try {
    return decodeURIComponent(r);
  } catch {
    for (var o = r.match(Mme) || [], c = 1; c < o.length; c++)
      r = Vse(o, c).join(""), o = r.match(Mme) || [];
    return r;
  }
}
function DZe(r) {
  for (var o = {
    "%FE%FF": "",
    "%FF%FE": ""
  }, c = Fme.exec(r); c; ) {
    try {
      o[c[0]] = decodeURIComponent(c[0]);
    } catch {
      var i = PZe(c[0]);
      i !== c[0] && (o[c[0]] = i);
    }
    c = Fme.exec(r);
  }
  o["%C2"] = "";
  for (var d = Object.keys(o), m = 0; m < d.length; m++) {
    var v = d[m];
    r = r.replace(new RegExp(v, "g"), o[v]);
  }
  return r;
}
var $Ze = function(r) {
  if (typeof r != "string")
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof r + "`");
  try {
    return r = r.replace(/\+/g, " "), decodeURIComponent(r);
  } catch {
    return DZe(r);
  }
}, IZe = (r, o) => {
  if (!(typeof r == "string" && typeof o == "string"))
    throw new TypeError("Expected the arguments to be of type `string`");
  if (o === "")
    return [r];
  const c = r.indexOf(o);
  return c === -1 ? [r] : [
    r.slice(0, c),
    r.slice(c + o.length)
  ];
}, MZe = function(r, o) {
  for (var c = {}, i = Object.keys(r), d = Array.isArray(o), m = 0; m < i.length; m++) {
    var v = i[m], g = r[v];
    (d ? o.indexOf(v) !== -1 : o(v, g, r)) && (c[v] = g);
  }
  return c;
};
(function(r) {
  const o = RZe, c = $Ze, i = IZe, d = MZe, m = (ue) => ue == null, v = Symbol("encodeFragmentIdentifier");
  function g(ue) {
    switch (ue.arrayFormat) {
      case "index":
        return (G) => (me, we) => {
          const be = me.length;
          return we === void 0 || ue.skipNull && we === null || ue.skipEmptyString && we === "" ? me : we === null ? [...me, [R(G, ue), "[", be, "]"].join("")] : [
            ...me,
            [R(G, ue), "[", R(be, ue), "]=", R(we, ue)].join("")
          ];
        };
      case "bracket":
        return (G) => (me, we) => we === void 0 || ue.skipNull && we === null || ue.skipEmptyString && we === "" ? me : we === null ? [...me, [R(G, ue), "[]"].join("")] : [...me, [R(G, ue), "[]=", R(we, ue)].join("")];
      case "colon-list-separator":
        return (G) => (me, we) => we === void 0 || ue.skipNull && we === null || ue.skipEmptyString && we === "" ? me : we === null ? [...me, [R(G, ue), ":list="].join("")] : [...me, [R(G, ue), ":list=", R(we, ue)].join("")];
      case "comma":
      case "separator":
      case "bracket-separator": {
        const G = ue.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return (me) => (we, be) => be === void 0 || ue.skipNull && be === null || ue.skipEmptyString && be === "" ? we : (be = be === null ? "" : be, we.length === 0 ? [[R(me, ue), G, R(be, ue)].join("")] : [[we, R(be, ue)].join(ue.arrayFormatSeparator)]);
      }
      default:
        return (G) => (me, we) => we === void 0 || ue.skipNull && we === null || ue.skipEmptyString && we === "" ? me : we === null ? [...me, R(G, ue)] : [...me, [R(G, ue), "=", R(we, ue)].join("")];
    }
  }
  function C(ue) {
    let G;
    switch (ue.arrayFormat) {
      case "index":
        return (me, we, be) => {
          if (G = /\[(\d*)\]$/.exec(me), me = me.replace(/\[\d*\]$/, ""), !G) {
            be[me] = we;
            return;
          }
          be[me] === void 0 && (be[me] = {}), be[me][G[1]] = we;
        };
      case "bracket":
        return (me, we, be) => {
          if (G = /(\[\])$/.exec(me), me = me.replace(/\[\]$/, ""), !G) {
            be[me] = we;
            return;
          }
          if (be[me] === void 0) {
            be[me] = [we];
            return;
          }
          be[me] = [].concat(be[me], we);
        };
      case "colon-list-separator":
        return (me, we, be) => {
          if (G = /(:list)$/.exec(me), me = me.replace(/:list$/, ""), !G) {
            be[me] = we;
            return;
          }
          if (be[me] === void 0) {
            be[me] = [we];
            return;
          }
          be[me] = [].concat(be[me], we);
        };
      case "comma":
      case "separator":
        return (me, we, be) => {
          const q = typeof we == "string" && we.includes(ue.arrayFormatSeparator), Te = typeof we == "string" && !q && I(we, ue).includes(ue.arrayFormatSeparator);
          we = Te ? I(we, ue) : we;
          const Le = q || Te ? we.split(ue.arrayFormatSeparator).map((je) => I(je, ue)) : we === null ? we : I(we, ue);
          be[me] = Le;
        };
      case "bracket-separator":
        return (me, we, be) => {
          const q = /(\[\])$/.test(me);
          if (me = me.replace(/\[\]$/, ""), !q) {
            be[me] = we && I(we, ue);
            return;
          }
          const Te = we === null ? [] : we.split(ue.arrayFormatSeparator).map((Le) => I(Le, ue));
          if (be[me] === void 0) {
            be[me] = Te;
            return;
          }
          be[me] = [].concat(be[me], Te);
        };
      default:
        return (me, we, be) => {
          if (be[me] === void 0) {
            be[me] = we;
            return;
          }
          be[me] = [].concat(be[me], we);
        };
    }
  }
  function O(ue) {
    if (typeof ue != "string" || ue.length !== 1)
      throw new TypeError("arrayFormatSeparator must be single character string");
  }
  function R(ue, G) {
    return G.encode ? G.strict ? o(ue) : encodeURIComponent(ue) : ue;
  }
  function I(ue, G) {
    return G.decode ? c(ue) : ue;
  }
  function L(ue) {
    return Array.isArray(ue) ? ue.sort() : typeof ue == "object" ? L(Object.keys(ue)).sort((G, me) => Number(G) - Number(me)).map((G) => ue[G]) : ue;
  }
  function Z(ue) {
    const G = ue.indexOf("#");
    return G !== -1 && (ue = ue.slice(0, G)), ue;
  }
  function ne(ue) {
    let G = "";
    const me = ue.indexOf("#");
    return me !== -1 && (G = ue.slice(me)), G;
  }
  function se(ue) {
    ue = Z(ue);
    const G = ue.indexOf("?");
    return G === -1 ? "" : ue.slice(G + 1);
  }
  function Q(ue, G) {
    return G.parseNumbers && !Number.isNaN(Number(ue)) && typeof ue == "string" && ue.trim() !== "" ? ue = Number(ue) : G.parseBooleans && ue !== null && (ue.toLowerCase() === "true" || ue.toLowerCase() === "false") && (ue = ue.toLowerCase() === "true"), ue;
  }
  function he(ue, G) {
    G = Object.assign({
      decode: !0,
      sort: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: !1,
      parseBooleans: !1
    }, G), O(G.arrayFormatSeparator);
    const me = C(G), we = /* @__PURE__ */ Object.create(null);
    if (typeof ue != "string" || (ue = ue.trim().replace(/^[?#&]/, ""), !ue))
      return we;
    for (const be of ue.split("&")) {
      if (be === "")
        continue;
      let [q, Te] = i(G.decode ? be.replace(/\+/g, " ") : be, "=");
      Te = Te === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(G.arrayFormat) ? Te : I(Te, G), me(I(q, G), Te, we);
    }
    for (const be of Object.keys(we)) {
      const q = we[be];
      if (typeof q == "object" && q !== null)
        for (const Te of Object.keys(q))
          q[Te] = Q(q[Te], G);
      else
        we[be] = Q(q, G);
    }
    return G.sort === !1 ? we : (G.sort === !0 ? Object.keys(we).sort() : Object.keys(we).sort(G.sort)).reduce((be, q) => {
      const Te = we[q];
      return Te && typeof Te == "object" && !Array.isArray(Te) ? be[q] = L(Te) : be[q] = Te, be;
    }, /* @__PURE__ */ Object.create(null));
  }
  r.extract = se, r.parse = he, r.stringify = (ue, G) => {
    if (!ue)
      return "";
    G = Object.assign({
      encode: !0,
      strict: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, G), O(G.arrayFormatSeparator);
    const me = (Te) => G.skipNull && m(ue[Te]) || G.skipEmptyString && ue[Te] === "", we = g(G), be = {};
    for (const Te of Object.keys(ue))
      me(Te) || (be[Te] = ue[Te]);
    const q = Object.keys(be);
    return G.sort !== !1 && q.sort(G.sort), q.map((Te) => {
      const Le = ue[Te];
      return Le === void 0 ? "" : Le === null ? R(Te, G) : Array.isArray(Le) ? Le.length === 0 && G.arrayFormat === "bracket-separator" ? R(Te, G) + "[]" : Le.reduce(we(Te), []).join("&") : R(Te, G) + "=" + R(Le, G);
    }).filter((Te) => Te.length > 0).join("&");
  }, r.parseUrl = (ue, G) => {
    G = Object.assign({
      decode: !0
    }, G);
    const [me, we] = i(ue, "#");
    return Object.assign(
      {
        url: me.split("?")[0] || "",
        query: he(se(ue), G)
      },
      G && G.parseFragmentIdentifier && we ? { fragmentIdentifier: I(we, G) } : {}
    );
  }, r.stringifyUrl = (ue, G) => {
    G = Object.assign({
      encode: !0,
      strict: !0,
      [v]: !0
    }, G);
    const me = Z(ue.url).split("?")[0] || "", we = r.extract(ue.url), be = r.parse(we, { sort: !1 }), q = Object.assign(be, ue.query);
    let Te = r.stringify(q, G);
    Te && (Te = `?${Te}`);
    let Le = ne(ue.url);
    return ue.fragmentIdentifier && (Le = `#${G[v] ? R(ue.fragmentIdentifier, G) : ue.fragmentIdentifier}`), `${me}${Te}${Le}`;
  }, r.pick = (ue, G, me) => {
    me = Object.assign({
      parseFragmentIdentifier: !0,
      [v]: !1
    }, me);
    const { url: we, query: be, fragmentIdentifier: q } = r.parseUrl(ue, me);
    return r.stringifyUrl({
      url: we,
      query: d(be, G),
      fragmentIdentifier: q
    }, me);
  }, r.exclude = (ue, G, me) => {
    const we = Array.isArray(G) ? (be) => !G.includes(be) : (be, q) => !G(be, q);
    return r.pick(ue, we, me);
  };
})(Oye);
var Use = globalThis && globalThis.__assign || function() {
  return Use = Object.assign || function(r) {
    for (var o, c = 1, i = arguments.length; c < i; c++) {
      o = arguments[c];
      for (var d in o)
        Object.prototype.hasOwnProperty.call(o, d) && (r[d] = o[d]);
    }
    return r;
  }, Use.apply(this, arguments);
}, kye = {
  onActivate: Bn.func,
  onAddUndo: Bn.func,
  onBeforeAddUndo: Bn.func,
  onBeforeExecCommand: Bn.func,
  onBeforeGetContent: Bn.func,
  onBeforeRenderUI: Bn.func,
  onBeforeSetContent: Bn.func,
  onBeforePaste: Bn.func,
  onBlur: Bn.func,
  onChange: Bn.func,
  onClearUndos: Bn.func,
  onClick: Bn.func,
  onContextMenu: Bn.func,
  onCommentChange: Bn.func,
  onCopy: Bn.func,
  onCut: Bn.func,
  onDblclick: Bn.func,
  onDeactivate: Bn.func,
  onDirty: Bn.func,
  onDrag: Bn.func,
  onDragDrop: Bn.func,
  onDragEnd: Bn.func,
  onDragGesture: Bn.func,
  onDragOver: Bn.func,
  onDrop: Bn.func,
  onExecCommand: Bn.func,
  onFocus: Bn.func,
  onFocusIn: Bn.func,
  onFocusOut: Bn.func,
  onGetContent: Bn.func,
  onHide: Bn.func,
  onInit: Bn.func,
  onKeyDown: Bn.func,
  onKeyPress: Bn.func,
  onKeyUp: Bn.func,
  onLoadContent: Bn.func,
  onMouseDown: Bn.func,
  onMouseEnter: Bn.func,
  onMouseLeave: Bn.func,
  onMouseMove: Bn.func,
  onMouseOut: Bn.func,
  onMouseOver: Bn.func,
  onMouseUp: Bn.func,
  onNodeChange: Bn.func,
  onObjectResizeStart: Bn.func,
  onObjectResized: Bn.func,
  onObjectSelected: Bn.func,
  onPaste: Bn.func,
  onPostProcess: Bn.func,
  onPostRender: Bn.func,
  onPreProcess: Bn.func,
  onProgressState: Bn.func,
  onRedo: Bn.func,
  onRemove: Bn.func,
  onReset: Bn.func,
  onSaveContent: Bn.func,
  onSelectionChange: Bn.func,
  onSetAttrib: Bn.func,
  onSetContent: Bn.func,
  onShow: Bn.func,
  onSubmit: Bn.func,
  onUndo: Bn.func,
  onVisualAid: Bn.func,
  onSkinLoadError: Bn.func,
  onThemeLoadError: Bn.func,
  onModelLoadError: Bn.func,
  onPluginLoadError: Bn.func,
  onIconsLoadError: Bn.func,
  onLanguageLoadError: Bn.func,
  onScriptsLoad: Bn.func,
  onScriptsLoadError: Bn.func
}, FZe = Use({ apiKey: Bn.string, id: Bn.string, inline: Bn.bool, init: Bn.object, initialValue: Bn.string, onEditorChange: Bn.func, value: Bn.string, tagName: Bn.string, cloudChannel: Bn.string, plugins: Bn.oneOfType([Bn.string, Bn.array]), toolbar: Bn.oneOfType([Bn.string, Bn.array]), disabled: Bn.bool, textareaName: Bn.string, tinymceScriptSrc: Bn.oneOfType([
  Bn.string,
  Bn.arrayOf(Bn.string),
  Bn.arrayOf(Bn.shape({
    src: Bn.string,
    async: Bn.bool,
    defer: Bn.bool
  }))
]), rollback: Bn.oneOfType([Bn.number, Bn.oneOf([!1])]), scriptLoading: Bn.shape({
  async: Bn.bool,
  defer: Bn.bool,
  delay: Bn.number
}) }, kye), Woe = function(r) {
  return typeof r == "function";
}, Lme = function(r) {
  return r in kye;
}, Bme = function(r) {
  return r.substr(2);
}, LZe = function(r, o, c, i, d, m, v) {
  var g = Object.keys(d).filter(Lme), C = Object.keys(m).filter(Lme), O = g.filter(function(I) {
    return m[I] === void 0;
  }), R = C.filter(function(I) {
    return d[I] === void 0;
  });
  O.forEach(function(I) {
    var L = Bme(I), Z = v[L];
    c(L, Z), delete v[L];
  }), R.forEach(function(I) {
    var L = i(r, I), Z = Bme(I);
    v[Z] = L, o(Z, L);
  });
}, BZe = function(r, o, c, i, d) {
  return LZe(
    d,
    r.on.bind(r),
    r.off.bind(r),
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    function(m, v) {
      return function(g) {
        var C;
        return (C = m(v)) === null || C === void 0 ? void 0 : C(g, r);
      };
    },
    o,
    c,
    i
  );
}, Hme = 0, Nye = function(r) {
  var o = Date.now(), c = Math.floor(Math.random() * 1e9);
  return Hme++, r + "_" + c + Hme + String(o);
}, zme = function(r) {
  return r !== null && (r.tagName.toLowerCase() === "textarea" || r.tagName.toLowerCase() === "input");
}, Vme = function(r) {
  return typeof r > "u" || r === "" ? [] : Array.isArray(r) ? r : r.split(" ");
}, HZe = function(r, o) {
  return Vme(r).concat(Vme(o));
}, zZe = function() {
  return window.InputEvent && typeof InputEvent.prototype.getTargetRanges == "function";
}, VZe = function(r) {
  if (!("isConnected" in Node.prototype)) {
    for (var o = r, c = r.parentNode; c != null; )
      o = c, c = o.parentNode;
    return o === r.ownerDocument;
  }
  return r.isConnected;
}, Ume = function(r, o) {
  r !== void 0 && (r.mode != null && typeof r.mode == "object" && typeof r.mode.set == "function" ? r.mode.set(o) : r.setMode(o));
}, Wse = globalThis && globalThis.__assign || function() {
  return Wse = Object.assign || function(r) {
    for (var o, c = 1, i = arguments.length; c < i; c++) {
      o = arguments[c];
      for (var d in o)
        Object.prototype.hasOwnProperty.call(o, d) && (r[d] = o[d]);
    }
    return r;
  }, Wse.apply(this, arguments);
}, UZe = function(r, o, c) {
  var i, d, m = r.createElement("script");
  m.referrerPolicy = "origin", m.type = "application/javascript", m.id = o.id, m.src = o.src, m.async = (i = o.async) !== null && i !== void 0 ? i : !1, m.defer = (d = o.defer) !== null && d !== void 0 ? d : !1;
  var v = function() {
    m.removeEventListener("load", v), m.removeEventListener("error", g), c(o.src);
  }, g = function(C) {
    m.removeEventListener("load", v), m.removeEventListener("error", g), c(o.src, C);
  };
  m.addEventListener("load", v), m.addEventListener("error", g), r.head && r.head.appendChild(m);
}, WZe = function(r) {
  var o = {}, c = function(v, g) {
    var C = o[v];
    C.done = !0, C.error = g;
    for (var O = 0, R = C.handlers; O < R.length; O++) {
      var I = R[O];
      I(v, g);
    }
    C.handlers = [];
  }, i = function(v, g, C) {
    var O = function(ue) {
      return C !== void 0 ? C(ue) : console.error(ue);
    };
    if (v.length === 0) {
      O(new Error("At least one script must be provided"));
      return;
    }
    for (var R = 0, I = !1, L = function(ue, G) {
      I || (G ? (I = !0, O(G)) : ++R === v.length && g());
    }, Z = 0, ne = v; Z < ne.length; Z++) {
      var se = ne[Z], Q = o[se.src];
      if (Q)
        Q.done ? L(se.src, Q.error) : Q.handlers.push(L);
      else {
        var he = Nye("tiny-");
        o[se.src] = {
          id: he,
          src: se.src,
          done: !1,
          error: null,
          handlers: [L]
        }, UZe(r, Wse({ id: he }, se), c);
      }
    }
  }, d = function() {
    for (var v, g = 0, C = Object.values(o); g < C.length; g++) {
      var O = C[g], R = r.getElementById(O.id);
      R != null && R.tagName === "SCRIPT" && ((v = R.parentNode) === null || v === void 0 || v.removeChild(R));
    }
    o = {};
  }, m = function() {
    return r;
  };
  return {
    loadScripts: i,
    deleteScripts: d,
    getDocument: m
  };
}, jZe = function() {
  var r = [], o = function(d) {
    var m = r.find(function(v) {
      return v.getDocument() === d;
    });
    return m === void 0 && (m = WZe(d), r.push(m)), m;
  }, c = function(d, m, v, g, C) {
    var O = function() {
      return o(d).loadScripts(m, g, C);
    };
    v > 0 ? setTimeout(O, v) : O();
  }, i = function() {
    for (var d = r.pop(); d != null; d = r.pop())
      d.deleteScripts();
  };
  return {
    loadList: c,
    reinitialize: i
  };
}, qZe = jZe(), joe = function(r) {
  var o = r;
  return o && o.tinymce ? o.tinymce : null;
}, GZe = globalThis && globalThis.__extends || function() {
  var r = function(o, c) {
    return r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, d) {
      i.__proto__ = d;
    } || function(i, d) {
      for (var m in d)
        Object.prototype.hasOwnProperty.call(d, m) && (i[m] = d[m]);
    }, r(o, c);
  };
  return function(o, c) {
    if (typeof c != "function" && c !== null)
      throw new TypeError("Class extends value " + String(c) + " is not a constructor or null");
    r(o, c);
    function i() {
      this.constructor = o;
    }
    o.prototype = c === null ? Object.create(c) : (i.prototype = c.prototype, new i());
  };
}(), tj = globalThis && globalThis.__assign || function() {
  return tj = Object.assign || function(r) {
    for (var o, c = 1, i = arguments.length; c < i; c++) {
      o = arguments[c];
      for (var d in o)
        Object.prototype.hasOwnProperty.call(o, d) && (r[d] = o[d]);
    }
    return r;
  }, tj.apply(this, arguments);
}, ZZe = (
  /** @class */
  function(r) {
    GZe(o, r);
    function o(c) {
      var i, d, m, v = r.call(this, c) || this;
      return v.rollbackTimer = void 0, v.valueCursor = void 0, v.rollbackChange = function() {
        var g = v.editor, C = v.props.value;
        g && C && C !== v.currentContent && g.undoManager.ignore(function() {
          if (g.setContent(C), v.valueCursor && (!v.inline || g.hasFocus()))
            try {
              g.selection.moveToBookmark(v.valueCursor);
            } catch {
            }
        }), v.rollbackTimer = void 0;
      }, v.handleBeforeInput = function(g) {
        if (v.props.value !== void 0 && v.props.value === v.currentContent && v.editor && (!v.inline || v.editor.hasFocus()))
          try {
            v.valueCursor = v.editor.selection.getBookmark(3);
          } catch {
          }
      }, v.handleBeforeInputSpecial = function(g) {
        (g.key === "Enter" || g.key === "Backspace" || g.key === "Delete") && v.handleBeforeInput(g);
      }, v.handleEditorChange = function(g) {
        var C = v.editor;
        if (C && C.initialized) {
          var O = C.getContent();
          v.props.value !== void 0 && v.props.value !== O && v.props.rollback !== !1 && (v.rollbackTimer || (v.rollbackTimer = window.setTimeout(v.rollbackChange, typeof v.props.rollback == "number" ? v.props.rollback : 200))), O !== v.currentContent && (v.currentContent = O, Woe(v.props.onEditorChange) && v.props.onEditorChange(O, C));
        }
      }, v.handleEditorChangeSpecial = function(g) {
        (g.key === "Backspace" || g.key === "Delete") && v.handleEditorChange(g);
      }, v.initialise = function(g) {
        var C, O, R;
        g === void 0 && (g = 0);
        var I = v.elementRef.current;
        if (I) {
          if (!VZe(I)) {
            if (g === 0)
              setTimeout(function() {
                return v.initialise(1);
              }, 1);
            else if (g < 100)
              setTimeout(function() {
                return v.initialise(g + 1);
              }, 100);
            else
              throw new Error("tinymce can only be initialised when in a document");
            return;
          }
          var L = joe(v.view);
          if (!L)
            throw new Error("tinymce should have been loaded into global scope");
          var Z = tj(tj({}, v.props.init), { selector: void 0, target: I, readonly: v.props.disabled, inline: v.inline, plugins: HZe((C = v.props.init) === null || C === void 0 ? void 0 : C.plugins, v.props.plugins), toolbar: (O = v.props.toolbar) !== null && O !== void 0 ? O : (R = v.props.init) === null || R === void 0 ? void 0 : R.toolbar, setup: function(ne) {
            v.editor = ne, v.bindHandlers({}), v.inline && !zme(I) && ne.once("PostRender", function(se) {
              ne.setContent(v.getInitialValue(), { no_events: !0 });
            }), v.props.init && Woe(v.props.init.setup) && v.props.init.setup(ne);
          }, init_instance_callback: function(ne) {
            var se, Q, he = v.getInitialValue();
            v.currentContent = (se = v.currentContent) !== null && se !== void 0 ? se : ne.getContent(), v.currentContent !== he && (v.currentContent = he, ne.setContent(he), ne.undoManager.clear(), ne.undoManager.add(), ne.setDirty(!1));
            var ue = (Q = v.props.disabled) !== null && Q !== void 0 ? Q : !1;
            Ume(v.editor, ue ? "readonly" : "design"), v.props.init && Woe(v.props.init.init_instance_callback) && v.props.init.init_instance_callback(ne);
          } });
          v.inline || (I.style.visibility = ""), zme(I) && (I.value = v.getInitialValue()), L.init(Z);
        }
      }, v.id = v.props.id || Nye("tiny-react"), v.elementRef = Ya.createRef(), v.inline = (m = (i = v.props.inline) !== null && i !== void 0 ? i : (d = v.props.init) === null || d === void 0 ? void 0 : d.inline) !== null && m !== void 0 ? m : !1, v.boundHandlers = {}, v;
    }
    return Object.defineProperty(o.prototype, "view", {
      get: function() {
        var c, i;
        return (i = (c = this.elementRef.current) === null || c === void 0 ? void 0 : c.ownerDocument.defaultView) !== null && i !== void 0 ? i : window;
      },
      enumerable: !1,
      configurable: !0
    }), o.prototype.componentDidUpdate = function(c) {
      var i = this, d, m;
      if (this.rollbackTimer && (clearTimeout(this.rollbackTimer), this.rollbackTimer = void 0), this.editor && (this.bindHandlers(c), this.editor.initialized)) {
        if (this.currentContent = (d = this.currentContent) !== null && d !== void 0 ? d : this.editor.getContent(), typeof this.props.initialValue == "string" && this.props.initialValue !== c.initialValue)
          this.editor.setContent(this.props.initialValue), this.editor.undoManager.clear(), this.editor.undoManager.add(), this.editor.setDirty(!1);
        else if (typeof this.props.value == "string" && this.props.value !== this.currentContent) {
          var v = this.editor;
          v.undoManager.transact(function() {
            var C;
            if (!i.inline || v.hasFocus())
              try {
                C = v.selection.getBookmark(3);
              } catch {
              }
            var O = i.valueCursor;
            if (v.setContent(i.props.value), !i.inline || v.hasFocus())
              for (var R = 0, I = [C, O]; R < I.length; R++) {
                var L = I[R];
                if (L)
                  try {
                    v.selection.moveToBookmark(L), i.valueCursor = L;
                    break;
                  } catch {
                  }
              }
          });
        }
        if (this.props.disabled !== c.disabled) {
          var g = (m = this.props.disabled) !== null && m !== void 0 ? m : !1;
          Ume(this.editor, g ? "readonly" : "design");
        }
      }
    }, o.prototype.componentDidMount = function() {
      var c = this, i, d, m, v, g;
      if (joe(this.view) !== null)
        this.initialise();
      else if (Array.isArray(this.props.tinymceScriptSrc) && this.props.tinymceScriptSrc.length === 0)
        (d = (i = this.props).onScriptsLoadError) === null || d === void 0 || d.call(i, new Error("No `tinymce` global is present but the `tinymceScriptSrc` prop was an empty array."));
      else if (!((m = this.elementRef.current) === null || m === void 0) && m.ownerDocument) {
        var C = function() {
          var R, I;
          (I = (R = c.props).onScriptsLoad) === null || I === void 0 || I.call(R), c.initialise();
        }, O = function(R) {
          var I, L;
          (L = (I = c.props).onScriptsLoadError) === null || L === void 0 || L.call(I, R);
        };
        qZe.loadList(this.elementRef.current.ownerDocument, this.getScriptSources(), (g = (v = this.props.scriptLoading) === null || v === void 0 ? void 0 : v.delay) !== null && g !== void 0 ? g : 0, C, O);
      }
    }, o.prototype.componentWillUnmount = function() {
      var c = this, i = this.editor;
      i && (i.off(this.changeEvents(), this.handleEditorChange), i.off(this.beforeInputEvent(), this.handleBeforeInput), i.off("keypress", this.handleEditorChangeSpecial), i.off("keydown", this.handleBeforeInputSpecial), i.off("NewBlock", this.handleEditorChange), Object.keys(this.boundHandlers).forEach(function(d) {
        i.off(d, c.boundHandlers[d]);
      }), this.boundHandlers = {}, i.remove(), this.editor = void 0);
    }, o.prototype.render = function() {
      return this.inline ? this.renderInline() : this.renderIframe();
    }, o.prototype.changeEvents = function() {
      var c, i, d, m = (d = (i = (c = joe(this.view)) === null || c === void 0 ? void 0 : c.Env) === null || i === void 0 ? void 0 : i.browser) === null || d === void 0 ? void 0 : d.isIE();
      return m ? "change keyup compositionend setcontent CommentChange" : "change input compositionend setcontent CommentChange";
    }, o.prototype.beforeInputEvent = function() {
      return zZe() ? "beforeinput SelectionChange" : "SelectionChange";
    }, o.prototype.renderInline = function() {
      var c = this.props.tagName, i = c === void 0 ? "div" : c;
      return Ya.createElement(i, {
        ref: this.elementRef,
        id: this.id
      });
    }, o.prototype.renderIframe = function() {
      return Ya.createElement("textarea", {
        ref: this.elementRef,
        style: { visibility: "hidden" },
        name: this.props.textareaName,
        id: this.id
      });
    }, o.prototype.getScriptSources = function() {
      var c, i, d = (c = this.props.scriptLoading) === null || c === void 0 ? void 0 : c.async, m = (i = this.props.scriptLoading) === null || i === void 0 ? void 0 : i.defer;
      if (this.props.tinymceScriptSrc !== void 0)
        return typeof this.props.tinymceScriptSrc == "string" ? [{ src: this.props.tinymceScriptSrc, async: d, defer: m }] : this.props.tinymceScriptSrc.map(function(O) {
          return typeof O == "string" ? { src: O, async: d, defer: m } : O;
        });
      var v = this.props.cloudChannel, g = this.props.apiKey ? this.props.apiKey : "no-api-key", C = "https://cdn.tiny.cloud/1/".concat(g, "/tinymce/").concat(v, "/tinymce.min.js");
      return [{ src: C, async: d, defer: m }];
    }, o.prototype.getInitialValue = function() {
      return typeof this.props.initialValue == "string" ? this.props.initialValue : typeof this.props.value == "string" ? this.props.value : "";
    }, o.prototype.bindHandlers = function(c) {
      var i = this;
      if (this.editor !== void 0) {
        BZe(this.editor, c, this.props, this.boundHandlers, function(g) {
          return i.props[g];
        });
        var d = function(g) {
          return g.onEditorChange !== void 0 || g.value !== void 0;
        }, m = d(c), v = d(this.props);
        !m && v ? (this.editor.on(this.changeEvents(), this.handleEditorChange), this.editor.on(this.beforeInputEvent(), this.handleBeforeInput), this.editor.on("keydown", this.handleBeforeInputSpecial), this.editor.on("keyup", this.handleEditorChangeSpecial), this.editor.on("NewBlock", this.handleEditorChange)) : m && !v && (this.editor.off(this.changeEvents(), this.handleEditorChange), this.editor.off(this.beforeInputEvent(), this.handleBeforeInput), this.editor.off("keydown", this.handleBeforeInputSpecial), this.editor.off("keyup", this.handleEditorChangeSpecial), this.editor.off("NewBlock", this.handleEditorChange));
      }
    }, o.propTypes = FZe, o.defaultProps = {
      cloudChannel: "6"
    }, o;
  }(Ya.Component)
);
const KZe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Editor: ZZe
}, Symbol.toStringTag, { value: "Module" })), YZe = /* @__PURE__ */ q$(KZe);
var QZe = { exports: {} };
(function(r) {
  (function() {
    var o = function(e) {
      if (e === null)
        return "null";
      if (e === void 0)
        return "undefined";
      var n = typeof e;
      return n === "object" && (Array.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === "Array") ? "array" : n === "object" && (String.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === "String") ? "string" : n;
    }, c = function(e) {
      return [
        "undefined",
        "boolean",
        "number",
        "string",
        "function",
        "xml",
        "null"
      ].indexOf(e) !== -1;
    }, i = function(e, n) {
      var s = Array.prototype.slice.call(e);
      return s.sort(n);
    }, d = function(e, n) {
      return m(function(s, l) {
        return e.eq(n(s), n(l));
      });
    }, m = function(e) {
      return { eq: e };
    }, v = m(function(e, n) {
      return e === n;
    }), g = v, C = function(e) {
      return m(function(n, s) {
        if (n.length !== s.length)
          return !1;
        for (var l = n.length, f = 0; f < l; f++)
          if (!e.eq(n[f], s[f]))
            return !1;
        return !0;
      });
    }, O = function(e, n) {
      return d(C(e), function(s) {
        return i(s, n);
      });
    }, R = function(e) {
      return m(function(n, s) {
        var l = Object.keys(n), f = Object.keys(s);
        if (!O(g).eq(l, f))
          return !1;
        for (var b = l.length, E = 0; E < b; E++) {
          var N = l[E];
          if (!e.eq(n[N], s[N]))
            return !1;
        }
        return !0;
      });
    }, I = m(function(e, n) {
      if (e === n)
        return !0;
      var s = o(e), l = o(n);
      return s !== l ? !1 : c(s) ? e === n : s === "array" ? C(I).eq(e, n) : s === "object" ? R(I).eq(e, n) : !1;
    });
    const L = Object.getPrototypeOf, Z = (e, n, s) => {
      var l;
      return s(e, n.prototype) ? !0 : ((l = e.constructor) === null || l === void 0 ? void 0 : l.name) === n.name;
    }, ne = (e) => {
      const n = typeof e;
      return e === null ? "null" : n === "object" && Array.isArray(e) ? "array" : n === "object" && Z(e, String, (s, l) => l.isPrototypeOf(s)) ? "string" : n;
    }, se = (e) => (n) => ne(n) === e, Q = (e) => (n) => typeof n === e, he = (e) => (n) => e === n, ue = (e, n) => me(e) && Z(e, n, (s, l) => L(s) === l), G = se("string"), me = se("object"), we = (e) => ue(e, Object), be = se("array"), q = he(null), Te = Q("boolean"), Le = he(void 0), je = (e) => e == null, Ie = (e) => !je(e), Ce = Q("function"), pt = Q("number"), sn = (e, n) => {
      if (be(e)) {
        for (let s = 0, l = e.length; s < l; ++s)
          if (!n(e[s]))
            return !1;
        return !0;
      }
      return !1;
    }, Lt = () => {
    }, z = (e, n) => (...s) => e(n.apply(null, s)), bt = (e, n) => (s) => e(n(s)), at = (e) => () => e, _n = (e) => e, st = (e, n) => e === n;
    function Ne(e, ...n) {
      return (...s) => {
        const l = n.concat(s);
        return e.apply(null, l);
      };
    }
    const vt = (e) => (n) => !e(n), Gt = (e) => () => {
      throw new Error(e);
    }, xt = (e) => e(), cn = (e) => {
      e();
    }, He = at(!1), ut = at(!0);
    class oe {
      constructor(n, s) {
        this.tag = n, this.value = s;
      }
      static some(n) {
        return new oe(!0, n);
      }
      static none() {
        return oe.singletonNone;
      }
      fold(n, s) {
        return this.tag ? s(this.value) : n();
      }
      isSome() {
        return this.tag;
      }
      isNone() {
        return !this.tag;
      }
      map(n) {
        return this.tag ? oe.some(n(this.value)) : oe.none();
      }
      bind(n) {
        return this.tag ? n(this.value) : oe.none();
      }
      exists(n) {
        return this.tag && n(this.value);
      }
      forall(n) {
        return !this.tag || n(this.value);
      }
      filter(n) {
        return !this.tag || n(this.value) ? this : oe.none();
      }
      getOr(n) {
        return this.tag ? this.value : n;
      }
      or(n) {
        return this.tag ? this : n;
      }
      getOrThunk(n) {
        return this.tag ? this.value : n();
      }
      orThunk(n) {
        return this.tag ? this : n();
      }
      getOrDie(n) {
        if (this.tag)
          return this.value;
        throw new Error(n ?? "Called getOrDie on None");
      }
      static from(n) {
        return Ie(n) ? oe.some(n) : oe.none();
      }
      getOrNull() {
        return this.tag ? this.value : null;
      }
      getOrUndefined() {
        return this.value;
      }
      each(n) {
        this.tag && n(this.value);
      }
      toArray() {
        return this.tag ? [this.value] : [];
      }
      toString() {
        return this.tag ? `some(${this.value})` : "none()";
      }
    }
    oe.singletonNone = new oe(!1);
    const qn = Array.prototype.slice, Rn = Array.prototype.indexOf, Zt = Array.prototype.push, Jt = (e, n) => Rn.call(e, n), wo = (e, n) => {
      const s = Jt(e, n);
      return s === -1 ? oe.none() : oe.some(s);
    }, Ge = (e, n) => Jt(e, n) > -1, qt = (e, n) => {
      for (let s = 0, l = e.length; s < l; s++) {
        const f = e[s];
        if (n(f, s))
          return !0;
      }
      return !1;
    }, St = (e, n) => {
      const s = e.length, l = new Array(s);
      for (let f = 0; f < s; f++) {
        const b = e[f];
        l[f] = n(b, f);
      }
      return l;
    }, ke = (e, n) => {
      for (let s = 0, l = e.length; s < l; s++) {
        const f = e[s];
        n(f, s);
      }
    }, Ct = (e, n) => {
      for (let s = e.length - 1; s >= 0; s--) {
        const l = e[s];
        n(l, s);
      }
    }, an = (e, n) => {
      const s = [], l = [];
      for (let f = 0, b = e.length; f < b; f++) {
        const E = e[f];
        (n(E, f) ? s : l).push(E);
      }
      return {
        pass: s,
        fail: l
      };
    }, ht = (e, n) => {
      const s = [];
      for (let l = 0, f = e.length; l < f; l++) {
        const b = e[l];
        n(b, l) && s.push(b);
      }
      return s;
    }, bn = (e, n, s) => (Ct(e, (l, f) => {
      s = n(s, l, f);
    }), s), Ye = (e, n, s) => (ke(e, (l, f) => {
      s = n(s, l, f);
    }), s), nn = (e, n, s) => {
      for (let l = 0, f = e.length; l < f; l++) {
        const b = e[l];
        if (n(b, l))
          return oe.some(b);
        if (s(b, l))
          break;
      }
      return oe.none();
    }, Bt = (e, n) => nn(e, n, He), $n = (e, n) => {
      for (let s = 0, l = e.length; s < l; s++) {
        const f = e[s];
        if (n(f, s))
          return oe.some(s);
      }
      return oe.none();
    }, mr = (e) => {
      const n = [];
      for (let s = 0, l = e.length; s < l; ++s) {
        if (!be(e[s]))
          throw new Error("Arr.flatten item " + s + " was not an array, input: " + e);
        Zt.apply(n, e[s]);
      }
      return n;
    }, gr = (e, n) => mr(St(e, n)), Vr = (e, n) => {
      for (let s = 0, l = e.length; s < l; ++s) {
        const f = e[s];
        if (n(f, s) !== !0)
          return !1;
      }
      return !0;
    }, Xr = (e) => {
      const n = qn.call(e, 0);
      return n.reverse(), n;
    }, pc = (e, n) => ht(e, (s) => !Ge(n, s)), Eo = (e, n) => {
      const s = {};
      for (let l = 0, f = e.length; l < f; l++) {
        const b = e[l];
        s[String(b)] = n(b, l);
      }
      return s;
    }, uo = (e, n) => {
      const s = qn.call(e, 0);
      return s.sort(n), s;
    }, Es = (e, n) => n >= 0 && n < e.length ? oe.some(e[n]) : oe.none(), br = (e) => Es(e, 0), hs = (e) => Es(e, e.length - 1), Ps = Ce(Array.from) ? Array.from : (e) => qn.call(e), qo = (e, n) => {
      for (let s = 0; s < e.length; s++) {
        const l = n(e[s], s);
        if (l.isSome())
          return l;
      }
      return oe.none();
    }, hc = (e, n) => {
      const s = [], l = Ce(n) ? (f) => qt(s, (b) => n(b, f)) : (f) => Ge(s, f);
      for (let f = 0, b = e.length; f < b; f++) {
        const E = e[f];
        l(E) || s.push(E);
      }
      return s;
    }, Co = Object.keys, fl = Object.hasOwnProperty, fn = (e, n) => {
      const s = Co(e);
      for (let l = 0, f = s.length; l < f; l++) {
        const b = s[l], E = e[b];
        n(E, b);
      }
    }, Yr = (e, n) => xa(e, (s, l) => ({
      k: l,
      v: n(s, l)
    })), xa = (e, n) => {
      const s = {};
      return fn(e, (l, f) => {
        const b = n(l, f);
        s[b.k] = b.v;
      }), s;
    }, $i = (e) => (n, s) => {
      e[s] = n;
    }, Kc = (e, n, s, l) => {
      fn(e, (f, b) => {
        (n(f, b) ? s : l)(f, b);
      });
    }, wi = (e, n) => {
      const s = {}, l = {};
      return Kc(e, n, $i(s), $i(l)), {
        t: s,
        f: l
      };
    }, es = (e, n) => {
      const s = {};
      return Kc(e, n, $i(s), Lt), s;
    }, gc = (e, n) => {
      const s = [];
      return fn(e, (l, f) => {
        s.push(n(l, f));
      }), s;
    }, Xl = (e) => gc(e, _n), gs = (e, n) => lr(e, n) ? oe.from(e[n]) : oe.none(), lr = (e, n) => fl.call(e, n), Ei = (e, n) => lr(e, n) && e[n] !== void 0 && e[n] !== null, Jl = (e, n, s = I) => R(s).eq(e, n), Pd = (e) => {
      const n = {};
      return ke(e, (s) => {
        n[s] = {};
      }), Co(n);
    }, Xf = (e) => e.length !== void 0, Qa = Array.isArray, Xa = (e) => {
      if (Qa(e))
        return e;
      {
        const n = [];
        for (let s = 0, l = e.length; s < l; s++)
          n[s] = e[s];
        return n;
      }
    }, ia = (e, n, s) => {
      if (!e)
        return !1;
      if (s = s || e, Xf(e)) {
        for (let l = 0, f = e.length; l < f; l++)
          if (n.call(s, e[l], l, e) === !1)
            return !1;
      } else
        for (const l in e)
          if (lr(e, l) && n.call(s, e[l], l, e) === !1)
            return !1;
      return !0;
    }, Nl = (e, n) => {
      const s = [];
      return ia(e, (l, f) => {
        s.push(n(l, f, e));
      }), s;
    }, Sp = (e, n) => {
      const s = [];
      return ia(e, (l, f) => {
        (!n || n(l, f, e)) && s.push(l);
      }), s;
    }, Yu = (e, n) => {
      if (e) {
        for (let s = 0, l = e.length; s < l; s++)
          if (e[s] === n)
            return s;
      }
      return -1;
    }, vc = (e, n, s, l) => {
      let f = Le(s) ? e[0] : s;
      for (let b = 0; b < e.length; b++)
        f = n.call(l, f, e[b], b);
      return f;
    }, ea = (e, n, s) => {
      for (let l = 0, f = e.length; l < f; l++)
        if (n.call(s, e[l], l, e))
          return l;
      return -1;
    }, bc = (e) => e[e.length - 1], Qu = (e) => {
      let n = !1, s;
      return (...l) => (n || (n = !0, s = e.apply(null, l)), s);
    }, wp = (e, n, s, l) => {
      const f = e.isiOS() && /ipad/i.test(s) === !0, b = e.isiOS() && !f, E = e.isiOS() || e.isAndroid(), N = E || l("(pointer:coarse)"), D = f || !b && E && l("(min-device-width:768px)"), U = b || E && !D, J = n.isSafari() && e.isiOS() && /safari/i.test(s) === !1, te = !U && !D && !J;
      return {
        isiPad: at(f),
        isiPhone: at(b),
        isTablet: at(D),
        isPhone: at(U),
        isTouch: at(N),
        isAndroid: e.isAndroid,
        isiOS: e.isiOS,
        isWebView: at(J),
        isDesktop: at(te)
      };
    }, of = (e, n) => {
      for (let s = 0; s < e.length; s++) {
        const l = e[s];
        if (l.test(n))
          return l;
      }
    }, Ou = (e, n) => {
      const s = of(e, n);
      if (!s)
        return {
          major: 0,
          minor: 0
        };
      const l = (f) => Number(n.replace(s, "$" + f));
      return Ja(l(1), l(2));
    }, Au = (e, n) => {
      const s = String(n).toLowerCase();
      return e.length === 0 ? nt() : Ou(e, s);
    }, nt = () => Ja(0, 0), Ja = (e, n) => ({
      major: e,
      minor: n
    }), eu = {
      nu: Ja,
      detect: Au,
      unknown: nt
    }, Ep = (e, n) => qo(n.brands, (s) => {
      const l = s.brand.toLowerCase();
      return Bt(e, (f) => {
        var b;
        return l === ((b = f.brand) === null || b === void 0 ? void 0 : b.toLowerCase());
      }).map((f) => ({
        current: f.name,
        version: eu.nu(parseInt(s.version, 10), 0)
      }));
    }), Jf = (e, n) => {
      const s = String(n).toLowerCase();
      return Bt(e, (l) => l.search(s));
    }, os = (e, n) => Jf(e, n).map((s) => {
      const l = eu.detect(s.versionRegexes, n);
      return {
        current: s.name,
        version: l
      };
    }), Cp = (e, n) => Jf(e, n).map((s) => {
      const l = eu.detect(s.versionRegexes, n);
      return {
        current: s.name,
        version: l
      };
    }), Am = (e, n) => e.substring(n), tu = (e, n, s) => n === "" || e.length >= n.length && e.substr(s, s + n.length) === n, em = (e, n) => Gs(e, n) ? Am(e, n.length) : e, Hs = (e, n, s = 0, l) => {
      const f = e.indexOf(n, s);
      return f !== -1 ? Le(l) ? !0 : f + n.length <= l : !1;
    }, Gs = (e, n) => tu(e, n, 0), Ac = (e, n) => tu(e, n, e.length - n.length), kc = (e) => (n) => n.replace(e, ""), Xu = kc(/^\s+|\s+$/g), Ju = kc(/^\s+/g), ed = kc(/\s+$/g), $o = (e) => e.length > 0, ei = (e) => !$o(e), Rl = (e, n) => n <= 0 ? "" : new Array(n + 1).join(e), td = (e, n = 10) => {
      const s = parseInt(e, n);
      return isNaN(s) ? oe.none() : oe.some(s);
    }, Xi = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/, Zs = (e) => (n) => Hs(n, e), ss = [
      {
        name: "Edge",
        versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
        search: (e) => Hs(e, "edge/") && Hs(e, "chrome") && Hs(e, "safari") && Hs(e, "applewebkit")
      },
      {
        name: "Chromium",
        brand: "Chromium",
        versionRegexes: [
          /.*?chrome\/([0-9]+)\.([0-9]+).*/,
          Xi
        ],
        search: (e) => Hs(e, "chrome") && !Hs(e, "chromeframe")
      },
      {
        name: "IE",
        versionRegexes: [
          /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
          /.*?rv:([0-9]+)\.([0-9]+).*/
        ],
        search: (e) => Hs(e, "msie") || Hs(e, "trident")
      },
      {
        name: "Opera",
        versionRegexes: [
          Xi,
          /.*?opera\/([0-9]+)\.([0-9]+).*/
        ],
        search: Zs("opera")
      },
      {
        name: "Firefox",
        versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
        search: Zs("firefox")
      },
      {
        name: "Safari",
        versionRegexes: [
          Xi,
          /.*?cpu os ([0-9]+)_([0-9]+).*/
        ],
        search: (e) => (Hs(e, "safari") || Hs(e, "mobile/")) && Hs(e, "applewebkit")
      }
    ], yc = [
      {
        name: "Windows",
        search: Zs("win"),
        versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: "iOS",
        search: (e) => Hs(e, "iphone") || Hs(e, "ipad"),
        versionRegexes: [
          /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
          /.*cpu os ([0-9]+)_([0-9]+).*/,
          /.*cpu iphone os ([0-9]+)_([0-9]+).*/
        ]
      },
      {
        name: "Android",
        search: Zs("android"),
        versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: "macOS",
        search: Zs("mac os x"),
        versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
      },
      {
        name: "Linux",
        search: Zs("linux"),
        versionRegexes: []
      },
      {
        name: "Solaris",
        search: Zs("sunos"),
        versionRegexes: []
      },
      {
        name: "FreeBSD",
        search: Zs("freebsd"),
        versionRegexes: []
      },
      {
        name: "ChromeOS",
        search: Zs("cros"),
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
      }
    ], tm = {
      browsers: at(ss),
      oses: at(yc)
    }, Io = "Edge", za = "Chromium", ti = "IE", Ra = "Opera", Pl = "Firefox", nu = "Safari", Ii = () => Dl({
      current: void 0,
      version: eu.unknown()
    }), Dl = (e) => {
      const n = e.current, s = e.version, l = (f) => () => n === f;
      return {
        current: n,
        version: s,
        isEdge: l(Io),
        isChromium: l(za),
        isIE: l(ti),
        isOpera: l(Ra),
        isFirefox: l(Pl),
        isSafari: l(nu)
      };
    }, $l = {
      unknown: Ii,
      nu: Dl,
      edge: at(Io),
      chromium: at(za),
      ie: at(ti),
      opera: at(Ra),
      firefox: at(Pl),
      safari: at(nu)
    }, km = "Windows", Il = "iOS", xp = "Android", Nc = "Linux", ku = "macOS", sf = "Solaris", Nm = "FreeBSD", Tp = "ChromeOS", Se = () => Ve({
      current: void 0,
      version: eu.unknown()
    }), Ve = (e) => {
      const n = e.current, s = e.version, l = (f) => () => n === f;
      return {
        current: n,
        version: s,
        isWindows: l(km),
        isiOS: l(Il),
        isAndroid: l(xp),
        isMacOS: l(ku),
        isLinux: l(Nc),
        isSolaris: l(sf),
        isFreeBSD: l(Nm),
        isChromeOS: l(Tp)
      };
    }, tt = {
      unknown: Se,
      nu: Ve,
      windows: at(km),
      ios: at(Il),
      android: at(xp),
      linux: at(Nc),
      macos: at(ku),
      solaris: at(sf),
      freebsd: at(Nm),
      chromeos: at(Tp)
    }, en = { detect: (e, n, s) => {
      const l = tm.browsers(), f = tm.oses(), b = n.bind((D) => Ep(l, D)).orThunk(() => os(l, e)).fold($l.unknown, $l.nu), E = Cp(f, e).fold(tt.unknown, tt.nu), N = wp(E, b, e, s);
      return {
        browser: b,
        os: E,
        deviceType: N
      };
    } }, ur = (e) => window.matchMedia(e).matches;
    let Yo = Qu(() => en.detect(navigator.userAgent, oe.from(navigator.userAgentData), ur));
    const Lr = () => Yo(), Nr = navigator.userAgent, Ks = Lr(), fo = Ks.browser, ta = Ks.os, Yc = Ks.deviceType, Rm = Nr.indexOf("Windows Phone") !== -1, kn = {
      transparentSrc: "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
      documentMode: fo.isIE() ? document.documentMode || 7 : 10,
      cacheSuffix: null,
      container: null,
      canHaveCSP: !fo.isIE(),
      windowsPhone: Rm,
      browser: {
        current: fo.current,
        version: fo.version,
        isChromium: fo.isChromium,
        isEdge: fo.isEdge,
        isFirefox: fo.isFirefox,
        isIE: fo.isIE,
        isOpera: fo.isOpera,
        isSafari: fo.isSafari
      },
      os: {
        current: ta.current,
        version: ta.version,
        isAndroid: ta.isAndroid,
        isChromeOS: ta.isChromeOS,
        isFreeBSD: ta.isFreeBSD,
        isiOS: ta.isiOS,
        isLinux: ta.isLinux,
        isMacOS: ta.isMacOS,
        isSolaris: ta.isSolaris,
        isWindows: ta.isWindows
      },
      deviceType: {
        isDesktop: Yc.isDesktop,
        isiPad: Yc.isiPad,
        isiPhone: Yc.isiPhone,
        isPhone: Yc.isPhone,
        isTablet: Yc.isTablet,
        isTouch: Yc.isTouch,
        isWebView: Yc.isWebView
      }
    }, Pm = /^\s*|\s*$/g, ca = (e) => je(e) ? "" : ("" + e).replace(Pm, ""), as = (e, n) => n ? n === "array" && Qa(e) ? !0 : typeof e === n : e !== void 0, _p = (e, n, s = {}) => {
      const l = G(e) ? e.split(n || ",") : e || [];
      let f = l.length;
      for (; f--; )
        s[l[f]] = {};
      return s;
    }, vs = lr, Wv = (e, ...n) => {
      for (let s = 0; s < n.length; s++) {
        const l = n[s];
        for (const f in l)
          if (lr(l, f)) {
            const b = l[f];
            b !== void 0 && (e[f] = b);
          }
      }
      return e;
    }, Va = function(e, n, s, l) {
      l = l || this, e && (s && (e = e[s]), ia(e, (f, b) => n.call(l, f, b, s) === !1 ? !1 : (Va(f, n, s, l), !0)));
    }, rn = {
      trim: ca,
      isArray: Qa,
      is: as,
      toArray: Xa,
      makeMap: _p,
      each: ia,
      map: Nl,
      grep: Sp,
      inArray: Yu,
      hasOwn: vs,
      extend: Wv,
      walk: Va,
      resolve: (e, n = window) => {
        const s = e.split(".");
        for (let l = 0, f = s.length; l < f && (n = n[s[l]], !!n); l++)
          ;
        return n;
      },
      explode: (e, n) => be(e) ? e : e === "" ? [] : Nl(e.split(n || ","), ca),
      _addCacheSuffix: (e) => {
        const n = kn.cacheSuffix;
        return n && (e += (e.indexOf("?") === -1 ? "?" : "&") + n), e;
      }
    }, na = (e, n, s = st) => e.exists((l) => s(l, n)), Dm = (e, n, s = st) => bs(e, n, s).getOr(e.isNone() && n.isNone()), Ta = (e) => {
      const n = [], s = (l) => {
        n.push(l);
      };
      for (let l = 0; l < e.length; l++)
        e[l].each(s);
      return n;
    }, bs = (e, n, s) => e.isSome() && n.isSome() ? oe.some(s(e.getOrDie(), n.getOrDie())) : oe.none(), Dd = (e, n, s, l) => e.isSome() && n.isSome() && s.isSome() ? oe.some(l(e.getOrDie(), n.getOrDie(), s.getOrDie())) : oe.none(), Ur = (e, n) => e ? oe.some(n) : oe.none(), Qc = typeof window < "u" ? window : Function("return this;")(), ni = (e, n) => {
      let s = n ?? Qc;
      for (let l = 0; l < e.length && s !== void 0 && s !== null; ++l)
        s = s[e[l]];
      return s;
    }, Xc = (e, n) => {
      const s = e.split(".");
      return ni(s, n);
    }, Ds = (e, n) => Xc(e, n), af = (e, n) => {
      const s = Ds(e, n);
      if (s == null)
        throw new Error(e + " not available on this browser");
      return s;
    }, _a = Object.getPrototypeOf, $d = (e) => af("HTMLElement", e), Oo = (e) => {
      const n = Xc("ownerDocument.defaultView", e);
      return me(e) && ($d(n).prototype.isPrototypeOf(e) || /^HTML\w*Element$/.test(_a(e).constructor.name));
    }, Nu = 8, Ru = 9, Jc = 11, Ml = 1, Op = 3, no = (e) => e.dom.nodeName.toLowerCase(), Oa = (e) => e.dom.nodeType, Pa = (e) => (n) => Oa(n) === e, jv = (e) => Oa(e) === Nu || no(e) === "#comment", zs = (e) => Mi(e) && Oo(e.dom), Mi = Pa(Ml), hi = Pa(Op), Fh = Pa(Ru), Lh = Pa(Jc), Fl = (e) => (n) => Mi(n) && no(n) === e, $m = (e, n, s) => {
      if (G(s) || Te(s) || pt(s))
        e.setAttribute(n, s + "");
      else
        throw console.error("Invalid call to Attribute.set. Key ", n, ":: Value ", s, ":: Element ", e), new Error("Attribute value was not simple");
    }, is = (e, n, s) => {
      $m(e.dom, n, s);
    }, ru = (e, n) => {
      const s = e.dom;
      fn(n, (l, f) => {
        $m(s, f, l);
      });
    }, Ji = (e, n) => {
      const s = e.dom.getAttribute(n);
      return s === null ? void 0 : s;
    }, ri = (e, n) => oe.from(Ji(e, n)), Da = (e, n) => {
      const s = e.dom;
      return s && s.hasAttribute ? s.hasAttribute(n) : !1;
    }, Vs = (e, n) => {
      e.dom.removeAttribute(n);
    }, Ll = (e) => {
      const n = e.dom.attributes;
      return n == null || n.length === 0;
    }, cf = (e) => Ye(e.dom.attributes, (n, s) => (n[s.name] = s.value, n), {}), nm = (e, n) => {
      const s = Ji(e, n);
      return s === void 0 || s === "" ? [] : s.split(" ");
    }, Bh = (e, n, s) => {
      const f = nm(e, n).concat([s]);
      return is(e, n, f.join(" ")), !0;
    }, Ap = (e, n, s) => {
      const l = ht(nm(e, n), (f) => f !== s);
      return l.length > 0 ? is(e, n, l.join(" ")) : Vs(e, n), !1;
    }, Pc = (e) => e.dom.classList !== void 0, kp = (e) => nm(e, "class"), gi = (e, n) => Bh(e, "class", n), Pu = (e, n) => Ap(e, "class", n), Np = (e, n) => Ge(kp(e), n) ? Pu(e, n) : gi(e, n), nd = (e, n) => {
      Pc(e) ? e.dom.classList.add(n) : gi(e, n);
    }, Im = (e) => {
      (Pc(e) ? e.dom.classList : kp(e)).length === 0 && Vs(e, "class");
    }, wc = (e, n) => {
      Pc(e) ? e.dom.classList.remove(n) : Pu(e, n), Im(e);
    }, Mm = (e, n) => {
      const s = Pc(e) ? e.dom.classList.toggle(n) : Np(e, n);
      return Im(e), s;
    }, Id = (e, n) => Pc(e) && e.dom.classList.contains(n), Ig = (e, n) => {
      const l = (n || document).createElement("div");
      if (l.innerHTML = e, !l.hasChildNodes() || l.childNodes.length > 1) {
        const f = "HTML does not have a single root node";
        throw console.error(f, e), new Error(f);
      }
      return Ec(l.childNodes[0]);
    }, Mg = (e, n) => {
      const l = (n || document).createElement(e);
      return Ec(l);
    }, lf = (e, n) => {
      const l = (n || document).createTextNode(e);
      return Ec(l);
    }, Ec = (e) => {
      if (e == null)
        throw new Error("Node cannot be null or undefined");
      return { dom: e };
    }, Fe = {
      fromHtml: Ig,
      fromTag: Mg,
      fromText: lf,
      fromDom: Ec,
      fromPoint: (e, n, s) => oe.from(e.dom.elementFromPoint(n, s)).map(Ec)
    }, uf = (e, n) => {
      const s = [], l = (b) => (s.push(b), n(b));
      let f = n(e);
      do
        f = f.bind(l);
      while (f.isSome());
      return s;
    }, Bl = (e, n) => {
      const s = e.dom;
      if (s.nodeType !== Ml)
        return !1;
      {
        const l = s;
        if (l.matches !== void 0)
          return l.matches(n);
        if (l.msMatchesSelector !== void 0)
          return l.msMatchesSelector(n);
        if (l.webkitMatchesSelector !== void 0)
          return l.webkitMatchesSelector(n);
        if (l.mozMatchesSelector !== void 0)
          return l.mozMatchesSelector(n);
        throw new Error("Browser lacks native selectors");
      }
    }, Fm = (e) => e.nodeType !== Ml && e.nodeType !== Ru && e.nodeType !== Jc || e.childElementCount === 0, Lg = (e, n) => {
      const s = n === void 0 ? document : n.dom;
      return Fm(s) ? [] : St(s.querySelectorAll(e), Fe.fromDom);
    }, Lm = (e, n) => {
      const s = n === void 0 ? document : n.dom;
      return Fm(s) ? oe.none() : oe.from(s.querySelector(e)).map(Fe.fromDom);
    }, Je = (e, n) => e.dom === n.dom, Wt = (e, n) => {
      const s = e.dom, l = n.dom;
      return s === l ? !1 : s.contains(l);
    }, Ft = (e) => Fe.fromDom(e.dom.ownerDocument), er = (e) => Fh(e) ? e : Ft(e), Qr = (e) => Fe.fromDom(er(e).dom.documentElement), No = (e) => Fe.fromDom(er(e).dom.defaultView), Qo = (e) => oe.from(e.dom.parentNode).map(Fe.fromDom), Xo = (e) => oe.from(e.dom.parentElement).map(Fe.fromDom), Rp = (e, n) => {
      const s = Ce(n) ? n : He;
      let l = e.dom;
      const f = [];
      for (; l.parentNode !== null && l.parentNode !== void 0; ) {
        const b = l.parentNode, E = Fe.fromDom(b);
        if (f.push(E), s(E) === !0)
          break;
        l = b;
      }
      return f;
    }, qv = (e) => {
      const n = (s) => ht(s, (l) => !Je(e, l));
      return Qo(e).map(ga).map(n).getOr([]);
    }, $a = (e) => oe.from(e.dom.previousSibling).map(Fe.fromDom), Hl = (e) => oe.from(e.dom.nextSibling).map(Fe.fromDom), Bg = (e) => Xr(uf(e, $a)), oi = (e) => uf(e, Hl), ga = (e) => St(e.dom.childNodes, Fe.fromDom), Du = (e, n) => {
      const s = e.dom.childNodes;
      return oe.from(s[n]).map(Fe.fromDom);
    }, ys = (e) => Du(e, 0), ou = (e) => Du(e, e.dom.childNodes.length - 1), ec = (e) => e.dom.childNodes.length, Bm = (e) => e.dom.hasChildNodes(), Gv = (e) => {
      const n = e.dom.head;
      if (n == null)
        throw new Error("Head is not available yet");
      return Fe.fromDom(n);
    }, Pp = (e) => Lh(e) && Ie(e.dom.host), Hh = Ce(Element.prototype.attachShadow) && Ce(Node.prototype.getRootNode), Md = at(Hh), Cc = Hh ? (e) => Fe.fromDom(e.dom.getRootNode()) : er, Dp = (e) => Pp(e) ? e : Gv(er(e)), wy = (e) => Pp(e) ? e : Fe.fromDom(er(e).dom.body), Hm = (e) => {
      const n = Cc(e);
      return Pp(n) ? oe.some(n) : oe.none();
    }, zh = (e) => Fe.fromDom(e.dom.host), df = (e) => {
      if (Md() && Ie(e.target)) {
        const n = Fe.fromDom(e.target);
        if (Mi(n) && ff(n) && e.composed && e.composedPath) {
          const s = e.composedPath();
          if (s)
            return br(s);
        }
      }
      return oe.from(e.target);
    }, ff = (e) => Ie(e.dom.shadowRoot), rm = (e) => {
      const n = hi(e) ? e.dom.parentNode : e.dom;
      if (n == null || n.ownerDocument === null)
        return !1;
      const s = n.ownerDocument;
      return Hm(Fe.fromDom(n)).fold(() => s.body.contains(n), bt(rm, zh));
    };
    var cs = (e, n, s, l, f) => e(s, l) ? oe.some(s) : Ce(f) && f(s) ? oe.none() : n(s, l, f);
    const Ss = (e, n, s) => {
      let l = e.dom;
      const f = Ce(s) ? s : He;
      for (; l.parentNode; ) {
        l = l.parentNode;
        const b = Fe.fromDom(l);
        if (n(b))
          return oe.some(b);
        if (f(b))
          break;
      }
      return oe.none();
    }, Fi = (e, n, s) => cs((f, b) => b(f), Ss, e, n, s), Hg = (e, n) => {
      const s = e.dom;
      return s.parentNode ? Zv(Fe.fromDom(s.parentNode), (l) => !Je(e, l) && n(l)) : oe.none();
    }, Zv = (e, n) => {
      const s = (f) => n(Fe.fromDom(f));
      return Bt(e.dom.childNodes, s).map(Fe.fromDom);
    }, Ci = (e, n) => {
      const s = (l) => {
        for (let f = 0; f < l.childNodes.length; f++) {
          const b = Fe.fromDom(l.childNodes[f]);
          if (n(b))
            return oe.some(b);
          const E = s(l.childNodes[f]);
          if (E.isSome())
            return E;
        }
        return oe.none();
      };
      return s(e.dom);
    }, su = (e, n, s) => Ss(e, (l) => Bl(l, n), s), Li = (e, n) => Lm(n, e), au = (e, n, s) => cs((f, b) => Bl(f, b), su, e, n, s), Vh = (e) => au(e, "[contenteditable]"), Rr = (e, n = !1) => rm(e) ? e.dom.isContentEditable : Vh(e).fold(at(n), (s) => el(s) === "true"), el = (e) => e.dom.contentEditable, mf = (e) => e.style !== void 0 && Ce(e.style.getPropertyValue), Ia = (e, n, s) => {
      if (!G(s))
        throw console.error("Invalid call to CSS.set. Property ", n, ":: Value ", s, ":: Element ", e), new Error("CSS value must be a string: " + s);
      mf(e) && e.style.setProperty(n, s);
    }, Bi = (e, n) => {
      mf(e) && e.style.removeProperty(n);
    }, Kv = (e, n, s) => {
      const l = e.dom;
      Ia(l, n, s);
    }, Hi = (e, n) => {
      const s = e.dom;
      fn(n, (l, f) => {
        Ia(s, f, l);
      });
    }, va = (e, n) => {
      const s = e.dom, f = window.getComputedStyle(s).getPropertyValue(n);
      return f === "" && !rm(e) ? ml(s, n) : f;
    }, ml = (e, n) => mf(e) ? e.style.getPropertyValue(n) : "", Aa = (e, n) => {
      const s = e.dom, l = ml(s, n);
      return oe.from(l).filter((f) => f.length > 0);
    }, rd = (e) => {
      const n = {}, s = e.dom;
      if (mf(s))
        for (let l = 0; l < s.style.length; l++) {
          const f = s.style.item(l);
          n[f] = s.style[f];
        }
      return n;
    }, Fd = (e, n) => {
      const s = e.dom;
      Bi(s, n), na(ri(e, "style").map(Xu), "") && Vs(e, "style");
    }, $s = (e) => e.dom.offsetWidth, ba = (e, n) => {
      Qo(e).each((l) => {
        l.dom.insertBefore(n.dom, e.dom);
      });
    }, tl = (e, n) => {
      Hl(e).fold(() => {
        Qo(e).each((f) => {
          Ys(f, n);
        });
      }, (l) => {
        ba(l, n);
      });
    }, od = (e, n) => {
      ys(e).fold(() => {
        Ys(e, n);
      }, (l) => {
        e.dom.insertBefore(n.dom, l.dom);
      });
    }, Ys = (e, n) => {
      e.dom.appendChild(n.dom);
    }, zg = (e, n) => {
      ba(e, n), Ys(n, e);
    }, Yv = (e, n) => {
      ke(n, (s, l) => {
        const f = l === 0 ? e : n[l - 1];
        tl(f, s);
      });
    }, Vo = (e, n) => {
      ke(n, (s) => {
        Ys(e, s);
      });
    }, $u = (e) => {
      e.dom.textContent = "", ke(ga(e), (n) => {
        mo(n);
      });
    }, mo = (e) => {
      const n = e.dom;
      n.parentNode !== null && n.parentNode.removeChild(n);
    }, zi = (e) => {
      const n = ga(e);
      n.length > 0 && Yv(e, n), mo(e);
    }, iu = (e, n) => {
      const l = (n || document).createElement("div");
      return l.innerHTML = e, ga(Fe.fromDom(l));
    }, sd = (e) => St(e, Fe.fromDom), ye = (e) => e.dom.innerHTML, cu = (e, n) => {
      const l = Ft(e).dom, f = Fe.fromDom(l.createDocumentFragment()), b = iu(n, l);
      Vo(f, b), $u(e), Ys(e, f);
    }, zm = (e) => {
      const n = Fe.fromTag("div"), s = Fe.fromDom(e.dom.cloneNode(!0));
      return Ys(n, s), ye(n);
    }, pl = (e, n, s, l, f, b, E) => ({
      target: e,
      x: n,
      y: s,
      stop: l,
      prevent: f,
      kill: b,
      raw: E
    }), ts = (e) => {
      const n = Fe.fromDom(df(e).getOr(e.target)), s = () => e.stopPropagation(), l = () => e.preventDefault(), f = z(l, s);
      return pl(n, e.clientX, e.clientY, s, l, f, e);
    }, Qv = (e, n) => (s) => {
      e(s) && n(ts(s));
    }, Uh = (e, n, s, l, f) => {
      const b = Qv(s, l);
      return e.dom.addEventListener(n, b, f), { unbind: Ne(Iu, e, n, b, f) };
    }, Vg = (e, n, s, l) => Uh(e, n, s, l, !1), Iu = (e, n, s, l) => {
      e.dom.removeEventListener(n, s, l);
    }, H = (e, n) => ({
      left: e,
      top: n,
      translate: (l, f) => H(e + l, n + f)
    }), X = H, fe = (e) => {
      const n = e.getBoundingClientRect();
      return X(n.left, n.top);
    }, Me = (e, n) => e !== void 0 ? e : n !== void 0 ? n : 0, We = (e) => {
      const n = e.dom.ownerDocument, s = n.body, l = n.defaultView, f = n.documentElement;
      if (s === e.dom)
        return X(s.offsetLeft, s.offsetTop);
      const b = Me(l == null ? void 0 : l.pageYOffset, f.scrollTop), E = Me(l == null ? void 0 : l.pageXOffset, f.scrollLeft), N = Me(f.clientTop, s.clientTop), D = Me(f.clientLeft, s.clientLeft);
      return Ut(e).translate(E - D, b - N);
    }, Ut = (e) => {
      const n = e.dom, l = n.ownerDocument.body;
      return l === n ? X(l.offsetLeft, l.offsetTop) : rm(e) ? fe(n) : X(0, 0);
    }, Wn = (e) => {
      const n = e !== void 0 ? e.dom : document, s = n.body.scrollLeft || n.documentElement.scrollLeft, l = n.body.scrollTop || n.documentElement.scrollTop;
      return X(s, l);
    }, xr = (e, n, s) => {
      const f = (s !== void 0 ? s.dom : document).defaultView;
      f && f.scrollTo(e, n);
    }, wr = (e, n) => {
      Lr().browser.isSafari() && Ce(e.dom.scrollIntoViewIfNeeded) ? e.dom.scrollIntoViewIfNeeded(!1) : e.dom.scrollIntoView(n);
    }, pr = (e) => {
      const n = e === void 0 ? window : e;
      return Lr().browser.isFirefox() ? oe.none() : oe.from(n.visualViewport);
    }, Us = (e, n, s, l) => ({
      x: e,
      y: n,
      width: s,
      height: l,
      right: e + s,
      bottom: n + l
    }), ra = (e) => {
      const n = e === void 0 ? window : e, s = n.document, l = Wn(Fe.fromDom(s));
      return pr(n).fold(() => {
        const f = n.document.documentElement, b = f.clientWidth, E = f.clientHeight;
        return Us(l.left, l.top, b, E);
      }, (f) => Us(Math.max(f.pageLeft, l.left), Math.max(f.pageTop, l.top), f.width, f.height));
    }, hl = (e, n) => ht(ga(e), n), Ld = (e, n) => {
      let s = [];
      return ke(ga(e), (l) => {
        n(l) && (s = s.concat([l])), s = s.concat(Ld(l, n));
      }), s;
    }, Vi = (e, n) => Lg(n, e), rw = (e, n, s) => su(e, n, s).isSome();
    class xs {
      constructor(n, s) {
        this.node = n, this.rootNode = s, this.current = this.current.bind(this), this.next = this.next.bind(this), this.prev = this.prev.bind(this), this.prev2 = this.prev2.bind(this);
      }
      current() {
        return this.node;
      }
      next(n) {
        return this.node = this.findSibling(this.node, "firstChild", "nextSibling", n), this.node;
      }
      prev(n) {
        return this.node = this.findSibling(this.node, "lastChild", "previousSibling", n), this.node;
      }
      prev2(n) {
        return this.node = this.findPreviousNode(this.node, n), this.node;
      }
      findSibling(n, s, l, f) {
        if (n) {
          if (!f && n[s])
            return n[s];
          if (n !== this.rootNode) {
            let b = n[l];
            if (b)
              return b;
            for (let E = n.parentNode; E && E !== this.rootNode; E = E.parentNode)
              if (b = E[l], b)
                return b;
          }
        }
      }
      findPreviousNode(n, s) {
        if (n) {
          const l = n.previousSibling;
          if (this.rootNode && l === this.rootNode)
            return;
          if (l) {
            if (!s) {
              for (let b = l.lastChild; b; b = b.lastChild)
                if (!b.lastChild)
                  return b;
            }
            return l;
          }
          const f = n.parentNode;
          if (f && f !== this.rootNode)
            return f;
        }
      }
    }
    const jn = (e) => (n) => !!n && n.nodeType === e, pf = (e) => !!e && !Object.getPrototypeOf(e), Un = jn(1), Ui = (e) => Un(e) && zs(Fe.fromDom(e)), B1 = (e) => Un(e) && e.namespaceURI === "http://www.w3.org/2000/svg", hf = (e) => {
      const n = e.toLowerCase();
      return (s) => Ie(s) && s.nodeName.toLowerCase() === n;
    }, Ua = (e) => {
      const n = e.map((s) => s.toLowerCase());
      return (s) => {
        if (s && s.nodeName) {
          const l = s.nodeName.toLowerCase();
          return Ge(n, l);
        }
        return !1;
      };
    }, om = (e, n) => {
      const s = n.toLowerCase().split(" ");
      return (l) => {
        if (Un(l)) {
          const f = l.ownerDocument.defaultView;
          if (f)
            for (let b = 0; b < s.length; b++) {
              const E = f.getComputedStyle(l, null);
              if ((E ? E.getPropertyValue(e) : null) === s[b])
                return !0;
            }
        }
        return !1;
      };
    }, Ug = (e) => (n) => Un(n) && n.hasAttribute(e), xi = (e, n) => (s) => Un(s) && s.getAttribute(e) === n, ad = (e) => Un(e) && e.hasAttribute("data-mce-bogus"), Xv = (e) => Un(e) && e.getAttribute("data-mce-bogus") === "all", gf = (e) => Un(e) && e.tagName === "TABLE", Jv = (e) => (n) => !!(Ui(n) && (n.contentEditable === e || n.getAttribute("data-mce-contenteditable") === e)), sm = Ua([
      "textarea",
      "input"
    ]), Qt = jn(3), H1 = jn(4), am = jn(7), im = jn(8), Mu = jn(9), Ws = jn(11), Mo = hf("br"), ya = hf("img"), Dc = Jv("true"), ro = Jv("false"), $p = Ua([
      "td",
      "th"
    ]), si = Ua([
      "td",
      "th",
      "caption"
    ]), Ts = Ua([
      "video",
      "audio",
      "object",
      "embed"
    ]), Wg = hf("li"), Mt = hf("details"), $c = hf("summary"), jg = "\uFEFF", xo = "", ka = (e) => e === jg, eb = (e) => e.replace(/\uFEFF/g, ""), cd = ((e, n) => {
      const s = (b) => {
        if (!e(b))
          throw new Error("Can only get " + n + " value of a " + n + " node");
        return l(b).getOr("");
      }, l = (b) => e(b) ? oe.from(b.dom.nodeValue) : oe.none();
      return {
        get: s,
        getOption: l,
        set: (b, E) => {
          if (!e(b))
            throw new Error("Can only set raw " + n + " value of a " + n + " node");
          b.dom.nodeValue = E;
        }
      };
    })(hi, "text"), lu = (e) => cd.get(e), Wh = (e) => cd.getOption(e), tc = (e, n) => cd.set(e, n), Fo = [
      "td",
      "th"
    ], ai = [
      "thead",
      "tbody",
      "tfoot"
    ], cm = [
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "p",
      "div",
      "address",
      "pre",
      "form",
      "blockquote",
      "center",
      "dir",
      "fieldset",
      "header",
      "footer",
      "article",
      "section",
      "hgroup",
      "aside",
      "nav",
      "figure"
    ], nc = [
      "li",
      "dd",
      "dt"
    ], Ey = [
      "ul",
      "ol",
      "dl"
    ], Ip = [
      "pre",
      "script",
      "textarea",
      "style"
    ], lm = (e) => {
      let n;
      return (s) => (n = n || Eo(e, ut), lr(n, no(s)));
    }, nl = (e) => no(e) === "table", ld = (e) => Mi(e) && no(e) === "br", lt = lm(cm), gl = lm(Ey), Fu = lm(nc), rl = lm(ai), vl = lm(Fo), vi = lm(Ip), ii = (e) => {
      const n = [];
      let s = e.dom;
      for (; s; )
        n.push(Fe.fromDom(s)), s = s.lastChild;
      return n;
    }, Cy = (e) => {
      const n = Vi(e, "br"), s = ht(ii(e).slice(-1), ld);
      n.length === s.length && ke(s, mo);
    }, bl = () => {
      const e = Fe.fromTag("br");
      return is(e, "data-mce-bogus", "1"), e;
    }, vf = (e) => {
      $u(e), Ys(e, bl());
    }, sr = (e, n) => {
      ou(e).each((s) => {
        $a(s).each((l) => {
          n.isBlock(no(e)) && ld(s) && n.isBlock(no(l)) && mo(s);
        });
      });
    }, M = jg, W = ka, de = eb, Ee = (e) => e.insertContent(M, { preserve_zwsp: !0 }), qe = Un, kt = Qt, tn = (e) => (kt(e) && (e = e.parentNode), qe(e) && e.hasAttribute("data-mce-caret")), Sn = (e) => kt(e) && W(e.data), Xn = (e) => tn(e) || Sn(e), Pr = (e) => e.firstChild !== e.lastChild || !Mo(e.firstChild), la = (e, n) => {
      var s;
      const f = ((s = e.ownerDocument) !== null && s !== void 0 ? s : document).createTextNode(M), b = e.parentNode;
      if (n) {
        const E = e.previousSibling;
        if (kt(E)) {
          if (Xn(E))
            return E;
          if (uu(E))
            return E.splitText(E.data.length - 1);
        }
        b == null || b.insertBefore(f, e);
      } else {
        const E = e.nextSibling;
        if (kt(E)) {
          if (Xn(E))
            return E;
          if (Ic(E))
            return E.splitText(1), E;
        }
        e.nextSibling ? b == null || b.insertBefore(f, e.nextSibling) : b == null || b.appendChild(f);
      }
      return f;
    }, Lo = (e) => {
      const n = e.container();
      return Qt(n) ? n.data.charAt(e.offset()) === M || e.isAtStart() && Sn(n.previousSibling) : !1;
    }, _s = (e) => {
      const n = e.container();
      return Qt(n) ? n.data.charAt(e.offset() - 1) === M || e.isAtEnd() && Sn(n.nextSibling) : !1;
    }, zl = (e, n, s) => {
      var l;
      const b = ((l = n.ownerDocument) !== null && l !== void 0 ? l : document).createElement(e);
      b.setAttribute("data-mce-caret", s ? "before" : "after"), b.setAttribute("data-mce-bogus", "all"), b.appendChild(bl().dom);
      const E = n.parentNode;
      return s ? E == null || E.insertBefore(b, n) : n.nextSibling ? E == null || E.insertBefore(b, n.nextSibling) : E == null || E.appendChild(b), b;
    }, Ic = (e) => kt(e) && e.data[0] === M, uu = (e) => kt(e) && e.data[e.data.length - 1] === M, bf = (e) => {
      var n;
      const s = e.getElementsByTagName("br"), l = s[s.length - 1];
      ad(l) && ((n = l.parentNode) === null || n === void 0 || n.removeChild(l));
    }, Bd = (e) => e && e.hasAttribute("data-mce-caret") ? (bf(e), e.removeAttribute("data-mce-caret"), e.removeAttribute("data-mce-bogus"), e.removeAttribute("style"), e.removeAttribute("data-mce-style"), e.removeAttribute("_moz_abspos"), e) : null, Mp = (e) => tn(e.startContainer), Ro = Dc, Fp = ro, qg = Mo, Sa = Qt, du = Ua([
      "script",
      "style",
      "textarea"
    ]), jh = Ua([
      "img",
      "input",
      "textarea",
      "hr",
      "iframe",
      "video",
      "audio",
      "object",
      "embed"
    ]), Lp = Ua(["table"]), qr = Xn, oo = (e) => qr(e) ? !1 : Sa(e) ? !du(e.parentNode) : jh(e) || qg(e) || Lp(e) || rc(e), ci = (e) => Un(e) && e.getAttribute("unselectable") === "true", rc = (e) => !ci(e) && Fp(e), tb = (e, n) => {
      for (let s = e.parentNode; s && s !== n; s = s.parentNode) {
        if (rc(s))
          return !1;
        if (Ro(s))
          return !0;
      }
      return !0;
    }, yf = (e) => rc(e) ? !Ye(Ps(e.getElementsByTagName("*")), (n, s) => n || Ro(s), !1) : !1, oa = (e) => jh(e) || yf(e), fu = (e, n) => oo(e) && tb(e, n), ud = /^[ \t\r\n]*$/, Bp = (e) => ud.test(e), Vm = (e) => {
      for (const n of e)
        if (!ka(n))
          return !1;
      return !0;
    }, Gg = (e) => " \f	\v".indexOf(e) !== -1, um = (e) => e === `
` || e === "\r", WC = (e, n) => n < e.length && n >= 0 ? um(e[n]) : !1, Hp = (e, n = 4, s = !0, l = !0) => {
      const f = Rl(" ", n), b = e.replace(/\t/g, f);
      return Ye(b, (N, D) => Gg(D) || D === xo ? N.pcIsSpace || N.str === "" && s || N.str.length === b.length - 1 && l || WC(b, N.str.length + 1) ? {
        pcIsSpace: !1,
        str: N.str + xo
      } : {
        pcIsSpace: !0,
        str: N.str + " "
      } : {
        pcIsSpace: um(D),
        str: N.str + D
      }, {
        pcIsSpace: !1,
        str: ""
      }).str;
    }, xy = (e, n) => {
      const s = Fe.fromDom(n), l = Fe.fromDom(e);
      return rw(l, "pre,code", Ne(Je, s));
    }, zp = (e, n) => Qt(e) && Bp(e.data) && !xy(e, n), Wa = (e) => Un(e) && e.nodeName === "A" && !e.hasAttribute("href") && (e.hasAttribute("name") || e.hasAttribute("id")), Hd = (e, n) => oo(e) && !zp(e, n) || Wa(e) || Sf(e), Sf = Ug("data-mce-bookmark"), Vp = Ug("data-mce-bogus"), Up = xi("data-mce-bogus", "all"), Zg = (e) => Xo(Fe.fromDom(e)).exists((n) => !Rr(n)), Lu = (e, n) => {
      let s = 0;
      if (Hd(e, e))
        return !1;
      {
        let l = e.firstChild;
        if (!l)
          return !0;
        const f = new xs(l, e);
        do {
          if (n) {
            if (Up(l)) {
              l = f.next(!0);
              continue;
            }
            if (Vp(l)) {
              l = f.next();
              continue;
            }
          }
          if (Dc(l) && Zg(l))
            return !1;
          if (Mo(l)) {
            s++, l = f.next();
            continue;
          }
          if (Hd(l, e))
            return !1;
          l = f.next();
        } while (l);
        return s <= 1;
      }
    }, Na = (e, n = !0) => Lu(e.dom, n), wf = (e) => e.toLowerCase() === "svg", z1 = (e) => wf(e.nodeName), Ty = (e) => (e == null ? void 0 : e.nodeName) === "svg" ? "svg" : "html", _y = ["svg"], Wp = () => {
      let e = [];
      const n = () => e[e.length - 1];
      return {
        track: (b) => {
          z1(b) && e.push(b);
          let E = n();
          return E && !E.contains(b) && (e.pop(), E = n()), Ty(E);
        },
        current: () => Ty(n()),
        reset: () => {
          e = [];
        }
      };
    }, yl = "data-mce-block", zd = (e) => ht(Co(e), (n) => !/[A-Z]/.test(n)), Um = (e) => St(zd(e), (n) => `${n}:` + St(_y, (s) => `not(${s} ${n})`).join(":")).join(","), dm = (e, n) => Ie(n.querySelector(e)) ? (n.setAttribute(yl, "true"), n.getAttribute("data-mce-selected") === "inline-boundary" && n.removeAttribute("data-mce-selected"), !0) : (n.removeAttribute(yl), !1), Vl = (e, n) => {
      const s = Um(e.getTransparentElements()), l = Um(e.getBlockElements());
      return ht(n.querySelectorAll(s), (f) => dm(l, f));
    }, Vd = (e, n) => {
      var s;
      const l = n ? "lastChild" : "firstChild";
      for (let f = e[l]; f; f = f[l])
        if (Na(Fe.fromDom(f))) {
          (s = f.parentNode) === null || s === void 0 || s.removeChild(f);
          return;
        }
    }, jp = (e, n) => {
      const s = document.createRange(), l = e.parentNode;
      if (l) {
        s.setStartBefore(e), s.setEndBefore(n);
        const f = s.extractContents();
        Vd(f, !0), s.setStartAfter(n), s.setEndAfter(e);
        const b = s.extractContents();
        Vd(b, !1), Na(Fe.fromDom(f)) || l.insertBefore(f, e), Na(Fe.fromDom(n)) || l.insertBefore(n, e), Na(Fe.fromDom(b)) || l.insertBefore(b, e), l.removeChild(e);
      }
    }, ow = (e, n, s) => {
      const l = e.getBlockElements(), f = Fe.fromDom(n), b = (N) => no(N) in l, E = (N) => Je(N, f);
      ke(sd(s), (N) => {
        Ss(N, b, E).each((D) => {
          const U = hl(N, (J) => b(J) && !e.isValidChild(no(D), no(J)));
          if (U.length > 0) {
            const J = Xo(D);
            ke(U, (te) => {
              Ss(te, b, E).each((ce) => {
                jp(ce.dom, te.dom);
              });
            }), J.each((te) => Vl(e, te.dom));
          }
        });
      });
    }, V1 = (e, n, s) => {
      ke([
        ...s,
        ...Jr(e, n) ? [n] : []
      ], (l) => ke(Vi(Fe.fromDom(l), l.nodeName.toLowerCase()), (f) => {
        nr(e, f.dom) && zi(f);
      }));
    }, nb = (e, n) => {
      const s = Vl(e, n);
      ow(e, n, s), V1(e, n, s);
    }, qp = (e, n) => {
      if (sb(e, n)) {
        const s = Um(e.getBlockElements());
        dm(s, n);
      }
    }, rb = (e, n, s) => {
      const l = (b) => Je(b, Fe.fromDom(n)), f = Rp(Fe.fromDom(s), l);
      Es(f, f.length - 2).filter(Mi).fold(() => nb(e, n), (b) => nb(e, b.dom));
    }, U1 = (e) => e.hasAttribute(yl), ob = (e, n) => lr(e.getTransparentElements(), n), sb = (e, n) => Un(n) && ob(e, n.nodeName), Jr = (e, n) => sb(e, n) && U1(n), nr = (e, n) => sb(e, n) && !U1(n), Ef = (e, n) => n.type === 1 && ob(e, n.name) && G(n.attr(yl)), ab = Lr().browser, qh = (e) => Bt(e, Mi), M2 = (e) => ab.isFirefox() && no(e) === "table" ? qh(ga(e)).filter((n) => no(n) === "caption").bind((n) => qh(oi(n)).map((s) => {
      const l = s.dom.offsetTop, f = n.dom.offsetTop, b = n.dom.offsetHeight;
      return l <= f ? -b : 0;
    })).getOr(0) : 0, W1 = (e, n) => e.children && Ge(e.children, n), ls = (e, n, s) => {
      let l = 0, f = 0;
      const b = e.ownerDocument;
      if (s = s || e, n) {
        if (s === e && n.getBoundingClientRect && va(Fe.fromDom(e), "position") === "static") {
          const N = n.getBoundingClientRect();
          return l = N.left + (b.documentElement.scrollLeft || e.scrollLeft) - b.documentElement.clientLeft, f = N.top + (b.documentElement.scrollTop || e.scrollTop) - b.documentElement.clientTop, {
            x: l,
            y: f
          };
        }
        let E = n;
        for (; E && E !== s && E.nodeType && !W1(E, s); ) {
          const N = E;
          l += N.offsetLeft || 0, f += N.offsetTop || 0, E = N.offsetParent;
        }
        for (E = n.parentNode; E && E !== s && E.nodeType && !W1(E, s); )
          l -= E.scrollLeft || 0, f -= E.scrollTop || 0, E = E.parentNode;
        f += M2(Fe.fromDom(n));
      }
      return {
        x: l,
        y: f
      };
    }, j1 = (e, n = {}) => {
      let s = 0;
      const l = {}, f = Fe.fromDom(e), b = er(f), E = (Ke) => {
        n.referrerPolicy = Ke;
      }, N = (Ke) => {
        n.contentCssCors = Ke;
      }, D = (Ke) => {
        Ys(Dp(f), Ke);
      }, U = (Ke) => {
        const et = Dp(f);
        Li(et, "#" + Ke).each(mo);
      }, J = (Ke) => gs(l, Ke).getOrThunk(() => ({
        id: "mce-u" + s++,
        passed: [],
        failed: [],
        count: 0
      })), te = (Ke) => new Promise((et, rt) => {
        let dt;
        const Ht = rn._addCacheSuffix(Ke), ln = J(Ht);
        l[Ht] = ln, ln.count++;
        const Dn = (Mn, rr) => {
          ke(Mn, cn), ln.status = rr, ln.passed = [], ln.failed = [], dt && (dt.onload = null, dt.onerror = null, dt = null);
        }, Rt = () => Dn(ln.passed, 2), Tt = () => Dn(ln.failed, 3);
        if (et && ln.passed.push(et), rt && ln.failed.push(rt), ln.status === 1)
          return;
        if (ln.status === 2) {
          Rt();
          return;
        }
        if (ln.status === 3) {
          Tt();
          return;
        }
        ln.status = 1;
        const Kt = Fe.fromTag("link", b.dom);
        ru(Kt, {
          rel: "stylesheet",
          type: "text/css",
          id: ln.id
        }), n.contentCssCors && is(Kt, "crossOrigin", "anonymous"), n.referrerPolicy && is(Kt, "referrerpolicy", n.referrerPolicy), dt = Kt.dom, dt.onload = Rt, dt.onerror = Tt, D(Kt), is(Kt, "href", Ht);
      }), ce = (Ke, et) => {
        const rt = J(Ke);
        l[Ke] = rt, rt.count++;
        const dt = Fe.fromTag("style", b.dom);
        ru(dt, {
          rel: "stylesheet",
          type: "text/css",
          id: rt.id
        }), dt.dom.innerHTML = et, D(dt);
      }, Oe = (Ke) => Promise.allSettled(St(Ke, (rt) => te(rt).then(at(rt)))).then((rt) => {
        const dt = an(rt, (Ht) => Ht.status === "fulfilled");
        return dt.fail.length > 0 ? Promise.reject(St(dt.fail, (Ht) => Ht.reason)) : St(dt.pass, (Ht) => Ht.value);
      }), Re = (Ke) => {
        const et = rn._addCacheSuffix(Ke);
        gs(l, et).each((rt) => {
          --rt.count === 0 && (delete l[et], U(rt.id));
        });
      };
      return {
        load: te,
        loadRawCss: ce,
        loadAll: Oe,
        unload: Re,
        unloadRawCss: (Ke) => {
          gs(l, Ke).each((et) => {
            --et.count === 0 && (delete l[Ke], U(et.id));
          });
        },
        unloadAll: (Ke) => {
          ke(Ke, (et) => {
            Re(et);
          });
        },
        _setReferrerPolicy: E,
        _setContentCssCors: N
      };
    }, sw = (() => {
      const e = /* @__PURE__ */ new WeakMap();
      return { forElement: (s, l) => {
        const b = Cc(s).dom;
        return oe.from(e.get(b)).getOrThunk(() => {
          const E = j1(b, l);
          return e.set(b, E), E;
        });
      } };
    })(), Pt = (e) => e.nodeName.toLowerCase() === "span", Cf = (e, n, s) => Ie(e) && (Hd(e, n) || s.isInline(e.nodeName.toLowerCase())), jC = (e, n, s) => {
      const l = new xs(e, n).prev(!1), f = new xs(e, n).next(!1), b = Le(l) || Cf(l, n, s), E = Le(f) || Cf(f, n, s);
      return b && E;
    }, ib = (e) => Pt(e) && e.getAttribute("data-mce-type") === "bookmark", F2 = (e, n, s) => Qt(e) && e.data.length > 0 && jC(e, n, s), Kg = (e) => Un(e) ? e.childNodes.length > 0 : !1, aw = (e) => Ws(e) || Mu(e), Gp = (e, n, s, l) => {
      var f;
      const b = l || n;
      if (Un(n) && ib(n))
        return n;
      const E = n.childNodes;
      for (let N = E.length - 1; N >= 0; N--)
        Gp(e, E[N], s, b);
      if (Un(n)) {
        const N = n.childNodes;
        N.length === 1 && ib(N[0]) && ((f = n.parentNode) === null || f === void 0 || f.insertBefore(N[0], n));
      }
      return !aw(n) && !Hd(n, b) && !Kg(n) && !F2(n, b, s) && e.remove(n), n;
    }, Zp = rn.makeMap, xf = /[&<>\"\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, us = /[<>&\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, Tf = /[<>&\"\']/g, cb = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi, Ul = {
      128: "",
      130: "",
      131: "",
      132: "",
      133: "",
      134: "",
      135: "",
      136: "",
      137: "",
      138: "",
      139: "",
      140: "",
      142: "",
      145: "",
      146: "",
      147: "",
      148: "",
      149: "",
      150: "",
      151: "",
      152: "",
      153: "",
      154: "",
      155: "",
      156: "",
      158: "",
      159: ""
    }, Wr = {
      '"': "&quot;",
      "'": "&#39;",
      "<": "&lt;",
      ">": "&gt;",
      "&": "&amp;",
      "`": "&#96;"
    }, lb = {
      "&lt;": "<",
      "&gt;": ">",
      "&amp;": "&",
      "&quot;": '"',
      "&apos;": "'"
    }, Kp = (e) => {
      const n = Fe.fromTag("div").dom;
      return n.innerHTML = e, n.textContent || n.innerText || e;
    }, Gh = (e, n) => {
      const s = {};
      if (e) {
        const l = e.split(",");
        n = n || 10;
        for (let f = 0; f < l.length; f += 2) {
          const b = String.fromCharCode(parseInt(l[f], n));
          if (!Wr[b]) {
            const E = "&" + l[f + 1] + ";";
            s[b] = E, s[E] = b;
          }
        }
        return s;
      } else
        return;
    }, q1 = Gh("50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro", 32), Ay = (e, n) => e.replace(n ? xf : us, (s) => Wr[s] || s), qC = (e) => ("" + e).replace(Tf, (n) => Wr[n] || n), Sl = (e, n) => e.replace(n ? xf : us, (s) => s.length > 1 ? "&#" + ((s.charCodeAt(0) - 55296) * 1024 + (s.charCodeAt(1) - 56320) + 65536) + ";" : Wr[s] || "&#" + s.charCodeAt(0) + ";"), Wm = (e, n, s) => {
      const l = s || q1;
      return e.replace(n ? xf : us, (f) => Wr[f] || l[f] || f);
    }, Yg = {
      encodeRaw: Ay,
      encodeAllRaw: qC,
      encodeNumeric: Sl,
      encodeNamed: Wm,
      getEncodeFunc: (e, n) => {
        const s = Gh(n) || q1, l = (E, N) => E.replace(N ? xf : us, (D) => Wr[D] !== void 0 ? Wr[D] : s[D] !== void 0 ? s[D] : D.length > 1 ? "&#" + ((D.charCodeAt(0) - 55296) * 1024 + (D.charCodeAt(1) - 56320) + 65536) + ";" : "&#" + D.charCodeAt(0) + ";"), f = (E, N) => Wm(E, N, s), b = Zp(e.replace(/\+/g, ","));
        return b.named && b.numeric ? l : b.named ? n ? f : Wm : b.numeric ? Sl : Ay;
      },
      decode: (e) => e.replace(cb, (n, s) => s ? (s.charAt(0).toLowerCase() === "x" ? s = parseInt(s.substr(1), 16) : s = parseInt(s, 10), s > 65535 ? (s -= 65536, String.fromCharCode(55296 + (s >> 10), 56320 + (s & 1023))) : Ul[s] || String.fromCharCode(s)) : lb[n] || q1[n] || Kp(n))
    }, xc = (e, n) => (e = rn.trim(e), e ? e.split(n || " ") : []), Hn = (e) => new RegExp("^" + e.replace(/([?+*])/g, ".$1") + "$"), L2 = (e) => {
      const n = /^(~)?(.+)$/;
      return gr(xc(e, ","), (s) => {
        const l = n.exec(s);
        if (l) {
          const f = l[1] === "~", b = f ? "span" : "div", E = l[2];
          return [{
            inline: f,
            cloneName: b,
            name: E
          }];
        } else
          return [];
      });
    }, iw = (e) => {
      let n, s, l;
      if (n = "id accesskey class dir lang style tabindex title role", s = "address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul", l = "a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd label map noscript object q s samp script select small span strong sub sup textarea u var #text #comment", e !== "html4") {
        const b = "a ins del canvas map";
        n += " contenteditable contextmenu draggable dropzone hidden spellcheck translate", s += " article aside details dialog figure main header footer hgroup section nav " + b, l += " audio canvas command datalist mark meter output picture progress time wbr video ruby bdi keygen svg";
      }
      e !== "html5-strict" && (n += " xml:lang", l = [
        l,
        "acronym applet basefont big font strike tt"
      ].join(" "), s = [
        s,
        "center dir isindex noframes"
      ].join(" "));
      const f = [
        s,
        l
      ].join(" ");
      return {
        globalAttributes: n,
        blockContent: s,
        phrasingContent: l,
        flowContent: f
      };
    }, Yp = (e) => {
      const { globalAttributes: n, phrasingContent: s, flowContent: l } = iw(e), f = {}, b = (D, U, J) => {
        f[D] = {
          attributes: Eo(U, at({})),
          attributesOrder: U,
          children: Eo(J, at({}))
        };
      }, E = (D, U = "", J = "") => {
        const te = xc(J), ce = xc(D);
        let Oe = ce.length;
        const Re = xc([
          n,
          U
        ].join(" "));
        for (; Oe--; )
          b(ce[Oe], Re.slice(), te);
      }, N = (D, U) => {
        const J = xc(D), te = xc(U);
        let ce = J.length;
        for (; ce--; ) {
          const Oe = f[J[ce]];
          for (let Re = 0, xe = te.length; Re < xe; Re++)
            Oe.attributes[te[Re]] = {}, Oe.attributesOrder.push(te[Re]);
        }
      };
      return e !== "html5-strict" && (ke(xc("acronym applet basefont big font strike tt"), (J) => {
        E(J, "", s);
      }), ke(xc("center dir isindex noframes"), (J) => {
        E(J, "", l);
      })), E("html", "manifest", "head body"), E("head", "", "base command link meta noscript script style title"), E("title hr noscript br"), E("base", "href target"), E("link", "href rel media hreflang type sizes hreflang"), E("meta", "name http-equiv content charset"), E("style", "media type scoped"), E("script", "src async defer type charset"), E("body", "onafterprint onbeforeprint onbeforeunload onblur onerror onfocus onhashchange onload onmessage onoffline ononline onpagehide onpageshow onpopstate onresize onscroll onstorage onunload", l), E("dd div", "", l), E("address dt caption", "", e === "html4" ? s : l), E("h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn", "", s), E("blockquote", "cite", l), E("ol", "reversed start type", "li"), E("ul", "", "li"), E("li", "value", l), E("dl", "", "dt dd"), E("a", "href target rel media hreflang type", e === "html4" ? s : l), E("q", "cite", s), E("ins del", "cite datetime", l), E("img", "src sizes srcset alt usemap ismap width height"), E("iframe", "src name width height", l), E("embed", "src type width height"), E("object", "data type typemustmatch name usemap form width height", [
        l,
        "param"
      ].join(" ")), E("param", "name value"), E("map", "name", [
        l,
        "area"
      ].join(" ")), E("area", "alt coords shape href target rel media hreflang type"), E("table", "border", "caption colgroup thead tfoot tbody tr" + (e === "html4" ? " col" : "")), E("colgroup", "span", "col"), E("col", "span"), E("tbody thead tfoot", "", "tr"), E("tr", "", "td th"), E("td", "colspan rowspan headers", l), E("th", "colspan rowspan headers scope abbr", l), E("form", "accept-charset action autocomplete enctype method name novalidate target", l), E("fieldset", "disabled form name", [
        l,
        "legend"
      ].join(" ")), E("label", "form for", s), E("input", "accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate formtarget height list max maxlength min multiple name pattern readonly required size src step type value width"), E("button", "disabled form formaction formenctype formmethod formnovalidate formtarget name type value", e === "html4" ? l : s), E("select", "disabled form multiple name required size", "option optgroup"), E("optgroup", "disabled label", "option"), E("option", "disabled label selected value"), E("textarea", "cols dirname disabled form maxlength name readonly required rows wrap"), E("menu", "type label", [
        l,
        "li"
      ].join(" ")), E("noscript", "", l), e !== "html4" && (E("wbr"), E("ruby", "", [
        s,
        "rt rp"
      ].join(" ")), E("figcaption", "", l), E("mark rt rp bdi", "", s), E("summary", "", [
        s,
        "h1 h2 h3 h4 h5 h6"
      ].join(" ")), E("canvas", "width height", l), E("video", "src crossorigin poster preload autoplay mediagroup loop muted controls width height buffered", [
        l,
        "track source"
      ].join(" ")), E("audio", "src crossorigin preload autoplay mediagroup loop muted controls buffered volume", [
        l,
        "track source"
      ].join(" ")), E("picture", "", "img source"), E("source", "src srcset type media sizes"), E("track", "kind src srclang label default"), E("datalist", "", [
        s,
        "option"
      ].join(" ")), E("article section nav aside main header footer", "", l), E("hgroup", "", "h1 h2 h3 h4 h5 h6"), E("figure", "", [
        l,
        "figcaption"
      ].join(" ")), E("time", "datetime", s), E("dialog", "open", l), E("command", "type label icon disabled checked radiogroup command"), E("output", "for form name", s), E("progress", "value max", s), E("meter", "value min max low high optimum", s), E("details", "open", [
        l,
        "summary"
      ].join(" ")), E("keygen", "autofocus challenge disabled form keytype name"), b("svg", "id tabindex lang xml:space class style x y width height viewBox preserveAspectRatio zoomAndPan transform".split(" "), [])), e !== "html5-strict" && (N("script", "language xml:space"), N("style", "xml:space"), N("object", "declare classid code codebase codetype archive standby align border hspace vspace"), N("embed", "align name hspace vspace"), N("param", "valuetype type"), N("a", "charset name rev shape coords"), N("br", "clear"), N("applet", "codebase archive code object alt name width height align hspace vspace"), N("img", "name longdesc align border hspace vspace"), N("iframe", "longdesc frameborder marginwidth marginheight scrolling align"), N("font basefont", "size color face"), N("input", "usemap align"), N("select"), N("textarea"), N("h1 h2 h3 h4 h5 h6 div p legend caption", "align"), N("ul", "type compact"), N("li", "type"), N("ol dl menu dir", "compact"), N("pre", "width xml:space"), N("hr", "align noshade size width"), N("isindex", "prompt"), N("table", "summary width frame rules cellspacing cellpadding align bgcolor"), N("col", "width align char charoff valign"), N("colgroup", "width align char charoff valign"), N("thead", "align char charoff valign"), N("tr", "align char charoff valign bgcolor"), N("th", "axis align char charoff valign nowrap bgcolor width height"), N("form", "accept"), N("td", "abbr axis scope align char charoff valign nowrap bgcolor width height"), N("tfoot", "align char charoff valign"), N("tbody", "align char charoff valign"), N("area", "nohref"), N("body", "background bgcolor text link vlink alink")), e !== "html4" && (N("input button select textarea", "autofocus"), N("input textarea", "placeholder"), N("a", "download"), N("link script img", "crossorigin"), N("img", "loading"), N("iframe", "sandbox seamless allow allowfullscreen loading")), e !== "html4" && ke([
        f.video,
        f.audio
      ], (D) => {
        delete D.children.audio, delete D.children.video;
      }), ke(xc("a form meter progress dfn"), (D) => {
        f[D] && delete f[D].children[D];
      }), delete f.caption.children.table, delete f.script, f;
    }, mu = (e) => e === "-" ? "remove" : "add", Qp = (e) => {
      const n = /^([+\-]?)([A-Za-z0-9_\-.\u00b7\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u037d\u037f-\u1fff\u200c-\u200d\u203f-\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]+)\[([^\]]+)]$/;
      return gr(xc(e, ","), (s) => {
        const l = n.exec(s);
        if (l) {
          const f = l[1], b = f ? mu(f) : "replace", E = l[2], N = xc(l[3], "|");
          return [{
            operation: b,
            name: E,
            validChildren: N
          }];
        } else
          return [];
      });
    }, ub = (e, n) => {
      const s = /^([!\-])?(\w+[\\:]:\w+|[^=~<]+)?(?:([=~<])(.*))?$/, l = /[*?+]/, { attributes: f, attributesOrder: b } = n;
      return ke(xc(e, "|"), (E) => {
        const N = s.exec(E);
        if (N) {
          const D = {}, U = N[1], J = N[2].replace(/[\\:]:/g, ":"), te = N[3], ce = N[4];
          if (U === "!" && (n.attributesRequired = n.attributesRequired || [], n.attributesRequired.push(J), D.required = !0), U === "-") {
            delete f[J], b.splice(rn.inArray(b, J), 1);
            return;
          }
          if (te && (te === "=" ? (n.attributesDefault = n.attributesDefault || [], n.attributesDefault.push({
            name: J,
            value: ce
          }), D.defaultValue = ce) : te === "~" ? (n.attributesForced = n.attributesForced || [], n.attributesForced.push({
            name: J,
            value: ce
          }), D.forcedValue = ce) : te === "<" && (D.validValues = rn.makeMap(ce, "?"))), l.test(J)) {
            const Oe = D;
            n.attributePatterns = n.attributePatterns || [], Oe.pattern = Hn(J), n.attributePatterns.push(Oe);
          } else
            f[J] || b.push(J), f[J] = D;
        }
      });
    }, Qg = (e, n) => {
      fn(e.attributes, (s, l) => {
        n.attributes[l] = s;
      }), n.attributesOrder.push(...e.attributesOrder);
    }, db = (e, n) => {
      const s = /^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)])?$/;
      return gr(xc(n, ","), (l) => {
        const f = s.exec(l);
        if (f) {
          const b = f[1], E = f[2], N = f[3], D = f[4], U = f[5], J = {
            attributes: {},
            attributesOrder: []
          };
          if (e.each((te) => Qg(te, J)), b === "#" ? J.paddEmpty = !0 : b === "-" && (J.removeEmpty = !0), D === "!" && (J.removeEmptyAttrs = !0), U && ub(U, J), N && (J.outputName = E), E === "@")
            if (e.isNone())
              e = oe.some(J);
            else
              return [];
          return [N ? {
            name: E,
            element: J,
            aliasName: N
          } : {
            name: E,
            element: J
          }];
        } else
          return [];
      });
    }, Z1 = {}, Ud = rn.makeMap, _f = rn.each, fb = rn.extend, Wd = rn.explode, K1 = (e, n = {}) => {
      const s = Ud(e, " ", Ud(e.toUpperCase(), " "));
      return fb(s, n);
    }, GC = (e) => K1("td th li dt dd figcaption caption details summary", e.getTextBlockElements()), mb = (e, n) => {
      if (e) {
        const s = {};
        return G(e) && (e = { "*": e }), _f(e, (l, f) => {
          s[f] = s[f.toUpperCase()] = n === "map" ? Ud(l, /[, ]/) : Wd(l, /[, ]/);
        }), s;
      } else
        return;
    }, jm = (e = {}) => {
      var n;
      const s = {}, l = {};
      let f = [];
      const b = {}, E = {}, N = (Ir, _o, Jo) => {
        const Ba = e[Ir];
        if (Ba)
          return Ud(Ba, /[, ]/, Ud(Ba.toUpperCase(), /[, ]/));
        {
          let Za = Z1[Ir];
          return Za || (Za = K1(_o, Jo), Z1[Ir] = Za), Za;
        }
      }, D = (n = e.schema) !== null && n !== void 0 ? n : "html5", U = Yp(D);
      e.verify_html === !1 && (e.valid_elements = "*[*]");
      const J = mb(e.valid_styles), te = mb(e.invalid_styles, "map"), ce = mb(e.valid_classes, "map"), Oe = N("whitespace_elements", "pre script noscript style textarea video audio iframe object code"), Re = N("self_closing_elements", "colgroup dd dt li option p td tfoot th thead tr"), xe = N("void_elements", "area base basefont br col frame hr img input isindex link meta param embed source wbr track"), Pe = N("boolean_attributes", "checked compact declare defer disabled ismap multiple nohref noresize noshade nowrap readonly selected autoplay loop controls allowfullscreen"), Ke = "td th iframe video audio object script code", et = N("non_empty_elements", Ke + " pre svg", xe), rt = N("move_caret_before_on_enter_elements", Ke + " table", xe), dt = "h1 h2 h3 h4 h5 h6", Ht = N("text_block_elements", dt + " p div address pre form blockquote center dir fieldset header footer article section hgroup aside main nav figure"), ln = N("block_elements", "hr table tbody thead tfoot th tr td li ol ul caption dl dt dd noscript menu isindex option datalist select optgroup figcaption details summary html body multicol listing", Ht), Dn = N("text_inline_elements", "span strong b em i font s strike u var cite dfn code mark q sup sub samp"), Rt = N("transparent_elements", "a ins del canvas map"), Tt = N("wrap_block_elements", "pre " + dt);
      _f("script noscript iframe noframes noembed title style textarea xmp plaintext".split(" "), (Ir) => {
        E[Ir] = new RegExp("</" + Ir + "[^>]*>", "gi");
      });
      const Kt = (Ir) => {
        const _o = oe.from(s["@"]), Jo = /[*?+]/;
        ke(db(_o, Ir ?? ""), ({ name: Ba, element: Za, aliasName: Eh }) => {
          if (Eh && (s[Eh] = Za), Jo.test(Ba)) {
            const e2 = Za;
            e2.pattern = Hn(Ba), f.push(e2);
          } else
            s[Ba] = Za;
        });
      }, Mn = (Ir) => {
        f = [], ke(Co(s), (_o) => {
          delete s[_o];
        }), Kt(Ir);
      }, rr = (Ir) => {
        delete Z1.text_block_elements, delete Z1.block_elements, ke(L2(Ir ?? ""), ({ inline: _o, name: Jo, cloneName: Ba }) => {
          if (l[Jo] = l[Ba], b[Jo] = Ba, et[Jo.toUpperCase()] = {}, et[Jo] = {}, _o || (ln[Jo.toUpperCase()] = {}, ln[Jo] = {}), !s[Jo]) {
            let Za = s[Ba];
            Za = fb({}, Za), delete Za.removeEmptyAttrs, delete Za.removeEmpty, s[Jo] = Za;
          }
          fn(l, (Za, Eh) => {
            Za[Ba] && (l[Eh] = Za = fb({}, l[Eh]), Za[Jo] = Za[Ba]);
          });
        });
      }, Fr = (Ir) => {
        ke(Qp(Ir ?? ""), ({ operation: _o, name: Jo, validChildren: Ba }) => {
          const Za = _o === "replace" ? { "#comment": {} } : l[Jo];
          ke(Ba, (Eh) => {
            _o === "remove" ? delete Za[Eh] : Za[Eh] = {};
          }), l[Jo] = Za;
        });
      }, so = (Ir) => {
        const _o = s[Ir];
        if (_o)
          return _o;
        let Jo = f.length;
        for (; Jo--; ) {
          const Ba = f[Jo];
          if (Ba.pattern.test(Ir))
            return Ba;
        }
      };
      e.valid_elements ? (Mn(e.valid_elements), _f(U, (Ir, _o) => {
        l[_o] = Ir.children;
      })) : (_f(U, (Ir, _o) => {
        s[_o] = {
          attributes: Ir.attributes,
          attributesOrder: Ir.attributesOrder
        }, l[_o] = Ir.children;
      }), _f(xc("strong/b em/i"), (Ir) => {
        const _o = xc(Ir, "/");
        s[_o[1]].outputName = _o[0];
      }), _f(Dn, (Ir, _o) => {
        s[_o] && (e.padd_empty_block_inline_children && (s[_o].paddInEmptyBlock = !0), s[_o].removeEmpty = !0);
      }), _f(xc("ol ul blockquote a table tbody"), (Ir) => {
        s[Ir] && (s[Ir].removeEmpty = !0);
      }), _f(xc("p h1 h2 h3 h4 h5 h6 th td pre div address caption li summary"), (Ir) => {
        s[Ir] && (s[Ir].paddEmpty = !0);
      }), _f(xc("span"), (Ir) => {
        s[Ir].removeEmptyAttrs = !0;
      })), delete s.svg, rr(e.custom_elements), Fr(e.valid_children), Kt(e.extended_valid_elements), Fr("+ol[ul|ol],+ul[ul|ol]"), _f({
        dd: "dl",
        dt: "dl",
        li: "ul ol",
        td: "tr",
        th: "tr",
        tr: "tbody thead tfoot",
        tbody: "table",
        thead: "table",
        tfoot: "table",
        legend: "fieldset",
        area: "map",
        param: "video audio object"
      }, (Ir, _o) => {
        s[_o] && (s[_o].parentsRequired = xc(Ir));
      }), e.invalid_elements && _f(Wd(e.invalid_elements), (Ir) => {
        s[Ir] && delete s[Ir];
      }), so("span") || Kt("span[!data-mce-type|*]");
      const Cs = at(J), Xs = at(te), Si = at(ce), Kl = at(Pe), ll = at(ln), wn = at(Ht), Ln = at(Dn), Ho = at(Object.seal(xe)), Ao = at(Re), Qn = at(et), Jn = at(rt), pn = at(Oe), kr = at(Rt), To = at(Tt), Ns = at(Object.seal(E)), Js = (Ir, _o) => {
        const Jo = l[Ir.toLowerCase()];
        return !!(Jo && Jo[_o.toLowerCase()]);
      }, Cd = (Ir, _o) => {
        const Jo = so(Ir);
        if (Jo)
          if (_o) {
            if (Jo.attributes[_o])
              return !0;
            const Ba = Jo.attributePatterns;
            if (Ba) {
              let Za = Ba.length;
              for (; Za--; )
                if (Ba[Za].pattern.test(_o))
                  return !0;
            }
          } else
            return !0;
        return !1;
      }, xm = (Ir) => lr(ll(), Ir), ry = (Ir) => !Gs(Ir, "#") && Cd(Ir) && !xm(Ir), xd = (Ir) => lr(To(), Ir) || ry(Ir), wg = at(b);
      return {
        type: D,
        children: l,
        elements: s,
        getValidStyles: Cs,
        getValidClasses: Si,
        getBlockElements: ll,
        getInvalidStyles: Xs,
        getVoidElements: Ho,
        getTextBlockElements: wn,
        getTextInlineElements: Ln,
        getBoolAttrs: Kl,
        getElementRule: so,
        getSelfClosingElements: Ao,
        getNonEmptyElements: Qn,
        getMoveCaretBeforeOnEnterElements: Jn,
        getWhitespaceElements: pn,
        getTransparentElements: kr,
        getSpecialElements: Ns,
        isValidChild: Js,
        isValid: Cd,
        isBlock: xm,
        isInline: ry,
        isWrapper: xd,
        getCustomElements: wg,
        addValidElements: Kt,
        setValidElements: Mn,
        addCustomElements: rr,
        addValidChildren: Fr
      };
    }, ZC = (e) => ({ value: pb(e) }), pb = (e) => em(e, "#").toUpperCase(), Xp = (e) => {
      const n = e.toString(16);
      return (n.length === 1 ? "0" + n : n).toUpperCase();
    }, jd = (e) => {
      const n = Xp(e.red) + Xp(e.green) + Xp(e.blue);
      return ZC(n);
    }, ol = /^\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i, cw = /^\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?(?:\.\d+)?)\s*\)\s*$/i, lw = (e, n, s, l) => ({
      red: e,
      green: n,
      blue: s,
      alpha: l
    }), uw = (e, n, s, l) => {
      const f = parseInt(e, 10), b = parseInt(n, 10), E = parseInt(s, 10), N = parseFloat(l);
      return lw(f, b, E, N);
    }, hb = (e) => {
      if (e === "transparent")
        return oe.some(lw(0, 0, 0, 0));
      const n = ol.exec(e);
      if (n !== null)
        return oe.some(uw(n[1], n[2], n[3], "1"));
      const s = cw.exec(e);
      return s !== null ? oe.some(uw(s[1], s[2], s[3], s[4])) : oe.none();
    }, pu = (e) => `rgba(${e.red},${e.green},${e.blue},${e.alpha})`, Bu = (e) => hb(e).map(jd).map((n) => "#" + n.value).getOr(e), qm = (e = {}, n) => {
      const s = /(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi, l = /\s*([^:]+):\s*([^;]+);?/g, f = /\s+$/, b = {};
      let E, N;
      const D = jg;
      n && (E = n.getValidStyles(), N = n.getInvalidStyles());
      const U = (`\\" \\' \\; \\: ; : ` + D).split(" ");
      for (let te = 0; te < U.length; te++)
        b[U[te]] = D + te, b[D + te] = U[te];
      const J = {
        parse: (te) => {
          const ce = {};
          let Oe = !1;
          const Re = e.url_converter, xe = e.url_converter_scope || J, Pe = (Rt, Tt, Kt) => {
            const Mn = ce[Rt + "-top" + Tt];
            if (!Mn)
              return;
            const rr = ce[Rt + "-right" + Tt];
            if (!rr)
              return;
            const Fr = ce[Rt + "-bottom" + Tt];
            if (!Fr)
              return;
            const so = ce[Rt + "-left" + Tt];
            if (!so)
              return;
            const Cs = [
              Mn,
              rr,
              Fr,
              so
            ];
            let Xs = Cs.length - 1;
            for (; Xs-- && Cs[Xs] === Cs[Xs + 1]; )
              ;
            Xs > -1 && Kt || (ce[Rt + Tt] = Xs === -1 ? Cs[0] : Cs.join(" "), delete ce[Rt + "-top" + Tt], delete ce[Rt + "-right" + Tt], delete ce[Rt + "-bottom" + Tt], delete ce[Rt + "-left" + Tt]);
          }, Ke = (Rt) => {
            const Tt = ce[Rt];
            if (!Tt)
              return;
            const Kt = Tt.indexOf(",") > -1 ? [Tt] : Tt.split(" ");
            let Mn = Kt.length;
            for (; Mn--; )
              if (Kt[Mn] !== Kt[0])
                return !1;
            return ce[Rt] = Kt[0], !0;
          }, et = (Rt, Tt, Kt, Mn) => {
            Ke(Tt) && Ke(Kt) && Ke(Mn) && (ce[Rt] = ce[Tt] + " " + ce[Kt] + " " + ce[Mn], delete ce[Tt], delete ce[Kt], delete ce[Mn]);
          }, rt = (Rt) => (Oe = !0, b[Rt]), dt = (Rt, Tt) => (Oe && (Rt = Rt.replace(/\uFEFF[0-9]/g, (Kt) => b[Kt])), Tt || (Rt = Rt.replace(/\\([\'\";:])/g, "$1")), Rt), Ht = (Rt) => String.fromCharCode(parseInt(Rt.slice(1), 16)), ln = (Rt) => Rt.replace(/\\[0-9a-f]+/gi, Ht), Dn = (Rt, Tt, Kt, Mn, rr, Fr) => {
            if (rr = rr || Fr, rr)
              return rr = dt(rr), "'" + rr.replace(/\'/g, "\\'") + "'";
            if (Tt = dt(Tt || Kt || Mn || ""), !e.allow_script_urls) {
              const so = Tt.replace(/[\s\r\n]+/g, "");
              if (/(java|vb)script:/i.test(so) || !e.allow_svg_data_urls && /^data:image\/svg/i.test(so))
                return "";
            }
            return Re && (Tt = Re.call(xe, Tt, "style")), "url('" + Tt.replace(/\'/g, "\\'") + "')";
          };
          if (te) {
            te = te.replace(/[\u0000-\u001F]/g, ""), te = te.replace(/\\[\"\';:\uFEFF]/g, rt).replace(/\"[^\"]+\"|\'[^\']+\'/g, (Tt) => Tt.replace(/[;:]/g, rt));
            let Rt;
            for (; Rt = l.exec(te); ) {
              l.lastIndex = Rt.index + Rt[0].length;
              let Tt = Rt[1].replace(f, "").toLowerCase(), Kt = Rt[2].replace(f, "");
              if (Tt && Kt) {
                if (Tt = ln(Tt), Kt = ln(Kt), Tt.indexOf(D) !== -1 || Tt.indexOf('"') !== -1 || !e.allow_script_urls && (Tt === "behavior" || /expression\s*\(|\/\*|\*\//.test(Kt)))
                  continue;
                Tt === "font-weight" && Kt === "700" ? Kt = "bold" : (Tt === "color" || Tt === "background-color") && (Kt = Kt.toLowerCase()), G(e.force_hex_color) && e.force_hex_color !== "off" && hb(Kt).each((Mn) => {
                  (e.force_hex_color === "always" || Mn.alpha === 1) && (Kt = Bu(pu(Mn)));
                }), Kt = Kt.replace(s, Dn), ce[Tt] = Oe ? dt(Kt, !0) : Kt;
              }
            }
            Pe("border", "", !0), Pe("border", "-width"), Pe("border", "-color"), Pe("border", "-style"), Pe("padding", ""), Pe("margin", ""), et("border", "border-width", "border-style", "border-color"), ce.border === "medium none" && delete ce.border, ce["border-image"] === "none" && delete ce["border-image"];
          }
          return ce;
        },
        serialize: (te, ce) => {
          let Oe = "";
          const Re = (Pe, Ke) => {
            const et = Ke[Pe];
            if (et)
              for (let rt = 0, dt = et.length; rt < dt; rt++) {
                const Ht = et[rt], ln = te[Ht];
                ln && (Oe += (Oe.length > 0 ? " " : "") + Ht + ": " + ln + ";");
              }
          }, xe = (Pe, Ke) => {
            if (!N || !Ke)
              return !0;
            let et = N["*"];
            return et && et[Pe] ? !1 : (et = N[Ke], !(et && et[Pe]));
          };
          return ce && E ? (Re("*", E), Re(ce, E)) : fn(te, (Pe, Ke) => {
            Pe && xe(Ke, ce) && (Oe += (Oe.length > 0 ? " " : "") + Ke + ": " + Pe + ";");
          }), Oe;
        }
      };
      return J;
    }, Y1 = {
      keyLocation: !0,
      layerX: !0,
      layerY: !0,
      returnValue: !0,
      webkitMovementX: !0,
      webkitMovementY: !0,
      keyIdentifier: !0,
      mozPressure: !0
    }, KC = (e) => e instanceof Event || Ce(e.initEvent), YC = (e) => e.isDefaultPrevented === ut || e.isDefaultPrevented === He, dw = (e) => je(e.preventDefault) || KC(e), gb = (e, n) => {
      const s = n ?? {};
      for (const l in e)
        lr(Y1, l) || (s[l] = e[l]);
      return Ie(e.composedPath) && (s.composedPath = () => e.composedPath()), Ie(e.getModifierState) && (s.getModifierState = (l) => e.getModifierState(l)), Ie(e.getTargetRanges) && (s.getTargetRanges = () => e.getTargetRanges()), s;
    }, vb = (e, n, s, l) => {
      var f;
      const b = gb(n, l);
      return b.type = e, je(b.target) && (b.target = (f = b.srcElement) !== null && f !== void 0 ? f : s), dw(n) && (b.preventDefault = () => {
        b.defaultPrevented = !0, b.isDefaultPrevented = ut, Ce(n.preventDefault) && n.preventDefault();
      }, b.stopPropagation = () => {
        b.cancelBubble = !0, b.isPropagationStopped = ut, Ce(n.stopPropagation) && n.stopPropagation();
      }, b.stopImmediatePropagation = () => {
        b.isImmediatePropagationStopped = ut, b.stopPropagation();
      }, YC(b) || (b.isDefaultPrevented = b.defaultPrevented === !0 ? ut : He, b.isPropagationStopped = b.cancelBubble === !0 ? ut : He, b.isImmediatePropagationStopped = He)), b;
    }, Q1 = "mce-data-", B2 = /^(?:mouse|contextmenu)|click/, X1 = (e, n, s, l) => {
      e.addEventListener(n, s, l || !1);
    }, bb = (e, n, s, l) => {
      e.removeEventListener(n, s, l || !1);
    }, H2 = (e) => Ie(e) && B2.test(e.type), ky = (e, n) => {
      const s = vb(e.type, e, document, n);
      if (H2(e) && Le(e.pageX) && !Le(e.clientX)) {
        const l = s.target.ownerDocument || document, f = l.documentElement, b = l.body, E = s;
        E.pageX = e.clientX + (f && f.scrollLeft || b && b.scrollLeft || 0) - (f && f.clientLeft || b && b.clientLeft || 0), E.pageY = e.clientY + (f && f.scrollTop || b && b.scrollTop || 0) - (f && f.clientTop || b && b.clientTop || 0);
      }
      return s;
    }, fw = (e, n, s) => {
      const l = e.document, f = { type: "ready" };
      if (s.domLoaded) {
        n(f);
        return;
      }
      const b = () => l.readyState === "complete" || l.readyState === "interactive" && l.body, E = () => {
        bb(e, "DOMContentLoaded", E), bb(e, "load", E), s.domLoaded || (s.domLoaded = !0, n(f)), e = null;
      };
      b() ? E() : X1(e, "DOMContentLoaded", E), s.domLoaded || X1(e, "load", E);
    };
    class hu {
      constructor() {
        this.domLoaded = !1, this.events = {}, this.count = 1, this.expando = Q1 + (+/* @__PURE__ */ new Date()).toString(32), this.hasFocusIn = "onfocusin" in document.documentElement, this.count = 1;
      }
      bind(n, s, l, f) {
        const b = this;
        let E;
        const N = window, D = (ce) => {
          b.executeHandlers(ky(ce || N.event), U);
        };
        if (!n || Qt(n) || im(n))
          return l;
        let U;
        n[b.expando] ? U = n[b.expando] : (U = b.count++, n[b.expando] = U, b.events[U] = {}), f = f || n;
        const J = s.split(" ");
        let te = J.length;
        for (; te--; ) {
          let ce = J[te], Oe = D, Re = !1, xe = !1;
          if (ce === "DOMContentLoaded" && (ce = "ready"), b.domLoaded && ce === "ready" && n.readyState === "complete") {
            l.call(f, ky({ type: ce }));
            continue;
          }
          !b.hasFocusIn && (ce === "focusin" || ce === "focusout") && (Re = !0, xe = ce === "focusin" ? "focus" : "blur", Oe = (Pe) => {
            const Ke = ky(Pe || N.event);
            Ke.type = Ke.type === "focus" ? "focusin" : "focusout", b.executeHandlers(Ke, U);
          }), E = b.events[U][ce], E ? ce === "ready" && b.domLoaded ? l(ky({ type: ce })) : E.push({
            func: l,
            scope: f
          }) : (b.events[U][ce] = E = [{
            func: l,
            scope: f
          }], E.fakeName = xe, E.capture = Re, E.nativeHandler = Oe, ce === "ready" ? fw(n, Oe, b) : X1(n, xe || ce, Oe, Re));
        }
        return n = E = null, l;
      }
      unbind(n, s, l) {
        if (!n || Qt(n) || im(n))
          return this;
        const f = n[this.expando];
        if (f) {
          let b = this.events[f];
          if (s) {
            const E = s.split(" ");
            let N = E.length;
            for (; N--; ) {
              const D = E[N], U = b[D];
              if (U) {
                if (l) {
                  let J = U.length;
                  for (; J--; )
                    if (U[J].func === l) {
                      const te = U.nativeHandler, ce = U.fakeName, Oe = U.capture, Re = U.slice(0, J).concat(U.slice(J + 1));
                      Re.nativeHandler = te, Re.fakeName = ce, Re.capture = Oe, b[D] = Re;
                    }
                }
                (!l || U.length === 0) && (delete b[D], bb(n, U.fakeName || D, U.nativeHandler, U.capture));
              }
            }
          } else
            fn(b, (E, N) => {
              bb(n, E.fakeName || N, E.nativeHandler, E.capture);
            }), b = {};
          for (const E in b)
            if (lr(b, E))
              return this;
          delete this.events[f];
          try {
            delete n[this.expando];
          } catch {
            n[this.expando] = null;
          }
        }
        return this;
      }
      fire(n, s, l) {
        return this.dispatch(n, s, l);
      }
      dispatch(n, s, l) {
        if (!n || Qt(n) || im(n))
          return this;
        const f = ky({
          type: s,
          target: n
        }, l);
        do {
          const b = n[this.expando];
          b && this.executeHandlers(f, b), n = n.parentNode || n.ownerDocument || n.defaultView || n.parentWindow;
        } while (n && !f.isPropagationStopped());
        return this;
      }
      clean(n) {
        if (!n || Qt(n) || im(n))
          return this;
        if (n[this.expando] && this.unbind(n), n.getElementsByTagName || (n = n.document), n && n.getElementsByTagName) {
          this.unbind(n);
          const s = n.getElementsByTagName("*");
          let l = s.length;
          for (; l--; )
            n = s[l], n[this.expando] && this.unbind(n);
        }
        return this;
      }
      destroy() {
        this.events = {};
      }
      cancel(n) {
        return n && (n.preventDefault(), n.stopImmediatePropagation()), !1;
      }
      executeHandlers(n, s) {
        const l = this.events[s], f = l && l[n.type];
        if (f)
          for (let b = 0, E = f.length; b < E; b++) {
            const N = f[b];
            if (N && N.func.call(N.scope, n) === !1 && n.preventDefault(), n.isImmediatePropagationStopped())
              return;
          }
      }
    }
    hu.Event = new hu();
    const Ny = rn.each, mw = rn.grep, J1 = "data-mce-style", Uk = rn.makeMap("fill-opacity font-weight line-height opacity orphans widows z-index zoom", " "), e0 = (e, n, s) => {
      je(s) || s === "" ? Vs(e, n) : is(e, n, s);
    }, Jp = (e) => e.replace(/[A-Z]/g, (n) => "-" + n.toLowerCase()), Gm = (e, n) => {
      let s = 0;
      if (e)
        for (let l = e.nodeType, f = e.previousSibling; f; f = f.previousSibling) {
          const b = f.nodeType;
          n && Qt(f) && (b === l || !f.data.length) || (s++, l = b);
        }
      return s;
    }, pw = (e, n) => {
      const s = Ji(n, "style"), l = e.serialize(e.parse(s), no(n));
      e0(n, J1, l);
    }, yb = (e, n) => pt(e) ? lr(Uk, n) ? e + "" : e + "px" : e, t0 = (e, n, s) => {
      const l = Jp(n);
      je(s) || s === "" ? Fd(e, l) : Kv(e, l, yb(s, l));
    }, QC = (e, n, s) => {
      const l = n.keep_values, f = {
        set: (E, N, D) => {
          const U = Fe.fromDom(E);
          Ce(n.url_converter) && Ie(N) && (N = n.url_converter.call(n.url_converter_scope || s(), String(N), D, E));
          const J = "data-mce-" + D;
          e0(U, J, N), e0(U, D, N);
        },
        get: (E, N) => {
          const D = Fe.fromDom(E);
          return Ji(D, "data-mce-" + N) || Ji(D, N);
        }
      }, b = {
        style: {
          set: (E, N) => {
            const D = Fe.fromDom(E);
            l && e0(D, J1, N), Vs(D, "style"), G(N) && Hi(D, e.parse(N));
          },
          get: (E) => {
            const N = Fe.fromDom(E), D = Ji(N, J1) || Ji(N, "style");
            return e.serialize(e.parse(D), no(N));
          }
        }
      };
      return l && (b.href = b.src = f), b;
    }, Is = (e, n = {}) => {
      const s = {}, l = window, f = {};
      let b = 0;
      const E = !0, N = !0, D = sw.forElement(Fe.fromDom(e), {
        contentCssCors: n.contentCssCors,
        referrerPolicy: n.referrerPolicy
      }), U = [], J = n.schema ? n.schema : jm({}), te = qm({
        url_converter: n.url_converter,
        url_converter_scope: n.url_converter_scope,
        force_hex_color: n.force_hex_color
      }, n.schema), ce = n.ownEvents ? new hu() : hu.Event, Oe = J.getBlockElements(), Re = (gt) => G(gt) ? lr(Oe, gt) : Un(gt) && (lr(Oe, gt.nodeName) || Jr(J, gt)), xe = (gt) => gt && e && G(gt) ? e.getElementById(gt) : gt, Pe = (gt) => {
        const Et = xe(gt);
        return Ie(Et) ? Fe.fromDom(Et) : null;
      }, Ke = (gt, Et, yn = "") => {
        let un;
        const cr = Pe(gt);
        if (Ie(cr) && Mi(cr)) {
          const So = OA[Et];
          So && So.get ? un = So.get(cr.dom, Et) : un = Ji(cr, Et);
        }
        return Ie(un) ? un : yn;
      }, et = (gt) => {
        const Et = xe(gt);
        return je(Et) ? [] : Et.attributes;
      }, rt = (gt, Et, yn) => {
        Ln(gt, (un) => {
          if (Un(un)) {
            const cr = Fe.fromDom(un), So = yn === "" ? null : yn, Ha = Ji(cr, Et), cc = OA[Et];
            cc && cc.set ? cc.set(cr.dom, So, Et) : e0(cr, Et, So), Ha !== So && n.onSetAttrib && n.onSetAttrib({
              attrElm: cr.dom,
              attrName: Et,
              attrValue: So
            });
          }
        });
      }, dt = (gt, Et) => gt.cloneNode(Et), Ht = () => n.root_element || e.body, ln = (gt) => {
        const Et = ra(gt);
        return {
          x: Et.x,
          y: Et.y,
          w: Et.width,
          h: Et.height
        };
      }, Dn = (gt, Et) => ls(e.body, xe(gt), Et), Rt = (gt, Et, yn) => {
        Ln(gt, (un) => {
          const cr = Fe.fromDom(un);
          t0(cr, Et, yn), n.update_styles && pw(te, cr);
        });
      }, Tt = (gt, Et) => {
        Ln(gt, (yn) => {
          const un = Fe.fromDom(yn);
          fn(Et, (cr, So) => {
            t0(un, So, cr);
          }), n.update_styles && pw(te, un);
        });
      }, Kt = (gt, Et, yn) => {
        const un = xe(gt);
        if (!(je(un) || !Ui(un) && !B1(un)))
          return yn ? va(Fe.fromDom(un), Jp(Et)) : (Et = Et.replace(/-(\D)/g, (cr, So) => So.toUpperCase()), Et === "float" && (Et = "cssFloat"), un.style ? un.style[Et] : void 0);
      }, Mn = (gt) => {
        const Et = xe(gt);
        if (!Et)
          return {
            w: 0,
            h: 0
          };
        let yn = Kt(Et, "width"), un = Kt(Et, "height");
        return (!yn || yn.indexOf("px") === -1) && (yn = "0"), (!un || un.indexOf("px") === -1) && (un = "0"), {
          w: parseInt(yn, 10) || Et.offsetWidth || Et.clientWidth,
          h: parseInt(un, 10) || Et.offsetHeight || Et.clientHeight
        };
      }, rr = (gt) => {
        const Et = xe(gt), yn = Dn(Et), un = Mn(Et);
        return {
          x: yn.x,
          y: yn.y,
          w: un.w,
          h: un.h
        };
      }, Fr = (gt, Et) => {
        if (!gt)
          return !1;
        const yn = be(gt) ? gt : [gt];
        return qt(yn, (un) => Bl(Fe.fromDom(un), Et));
      }, so = (gt, Et, yn, un) => {
        const cr = [];
        let So = xe(gt);
        un = un === void 0;
        const Ha = yn || (Ht().nodeName !== "BODY" ? Ht().parentNode : null);
        if (G(Et))
          if (Et === "*")
            Et = Un;
          else {
            const cc = Et;
            Et = (Oc) => Fr(Oc, cc);
          }
        for (; So && !(So === Ha || je(So.nodeType) || Mu(So) || Ws(So)); ) {
          if (!Et || Et(So))
            if (un)
              cr.push(So);
            else
              return [So];
          So = So.parentNode;
        }
        return un ? cr : null;
      }, Cs = (gt, Et, yn) => {
        const un = so(gt, Et, yn, !1);
        return un && un.length > 0 ? un[0] : null;
      }, Xs = (gt, Et, yn) => {
        let un = Et;
        if (gt) {
          G(Et) && (un = (cr) => Fr(cr, Et));
          for (let cr = gt[yn]; cr; cr = cr[yn])
            if (Ce(un) && un(cr))
              return cr;
        }
        return null;
      }, Si = (gt, Et) => Xs(gt, Et, "nextSibling"), Kl = (gt, Et) => Xs(gt, Et, "previousSibling"), ll = (gt) => Ce(gt.querySelectorAll), wn = (gt, Et) => {
        var yn, un;
        const cr = (un = (yn = xe(Et)) !== null && yn !== void 0 ? yn : n.root_element) !== null && un !== void 0 ? un : e;
        return ll(cr) ? Ps(cr.querySelectorAll(gt)) : [];
      }, Ln = function(gt, Et, yn) {
        const un = yn ?? this;
        if (be(gt)) {
          const cr = [];
          return Ny(gt, (So, Ha) => {
            const cc = xe(So);
            cc && cr.push(Et.call(un, cc, Ha));
          }), cr;
        } else {
          const cr = xe(gt);
          return cr ? Et.call(un, cr) : !1;
        }
      }, Ho = (gt, Et) => {
        Ln(gt, (yn) => {
          fn(Et, (un, cr) => {
            rt(yn, cr, un);
          });
        });
      }, Ao = (gt, Et) => {
        Ln(gt, (yn) => {
          const un = Fe.fromDom(yn);
          cu(un, Et);
        });
      }, Qn = (gt, Et, yn, un, cr) => Ln(gt, (So) => {
        const Ha = G(Et) ? e.createElement(Et) : Et;
        return Ie(yn) && Ho(Ha, yn), un && (!G(un) && un.nodeType ? Ha.appendChild(un) : G(un) && Ao(Ha, un)), cr ? Ha : So.appendChild(Ha);
      }), Jn = (gt, Et, yn) => Qn(e.createElement(gt), gt, Et, yn, !0), pn = Yg.decode, kr = Yg.encodeAllRaw, To = (gt, Et, yn = "") => {
        let un = "<" + gt;
        for (const cr in Et)
          Ei(Et, cr) && (un += " " + cr + '="' + kr(Et[cr]) + '"');
        return ei(yn) && lr(J.getVoidElements(), gt) ? un + " />" : un + ">" + yn + "</" + gt + ">";
      }, Ns = (gt) => {
        const Et = e.createElement("div"), yn = e.createDocumentFragment();
        yn.appendChild(Et), gt && (Et.innerHTML = gt);
        let un;
        for (; un = Et.firstChild; )
          yn.appendChild(un);
        return yn.removeChild(Et), yn;
      }, Js = (gt, Et) => Ln(gt, (yn) => {
        const un = Fe.fromDom(yn);
        return Et && ke(ga(un), (cr) => {
          hi(cr) && cr.dom.length === 0 ? mo(cr) : ba(un, cr);
        }), mo(un), un.dom;
      }), Cd = (gt) => Ln(gt, (Et) => {
        const yn = Et.attributes;
        for (let un = yn.length - 1; un >= 0; un--)
          Et.removeAttributeNode(yn.item(un));
      }), xm = (gt) => te.parse(gt), ry = (gt, Et) => te.serialize(gt, Et), xd = (gt) => {
        if (v1 !== Is.DOM && e === document) {
          if (s[gt])
            return;
          s[gt] = !0;
        }
        let Et = e.getElementById("mceDefaultStyles");
        if (!Et) {
          Et = e.createElement("style"), Et.id = "mceDefaultStyles", Et.type = "text/css";
          const yn = e.head;
          yn.firstChild ? yn.insertBefore(Et, yn.firstChild) : yn.appendChild(Et);
        }
        Et.styleSheet ? Et.styleSheet.cssText += gt : Et.appendChild(e.createTextNode(gt));
      }, wg = (gt) => {
        gt || (gt = ""), ke(gt.split(","), (Et) => {
          f[Et] = !0, D.load(Et).catch(Lt);
        });
      }, Ir = (gt, Et, yn) => {
        Ln(gt, (un) => {
          if (Un(un)) {
            const cr = Fe.fromDom(un), So = Et.split(" ");
            ke(So, (Ha) => {
              Ie(yn) ? (yn ? nd : wc)(cr, Ha) : Mm(cr, Ha);
            });
          }
        });
      }, _o = (gt, Et) => {
        Ir(gt, Et, !0);
      }, Jo = (gt, Et) => {
        Ir(gt, Et, !1);
      }, Ba = (gt, Et) => {
        const yn = Pe(gt), un = Et.split(" ");
        return Ie(yn) && Vr(un, (cr) => Id(yn, cr));
      }, Za = (gt) => {
        Ln(gt, (Et) => Fd(Fe.fromDom(Et), "display"));
      }, Eh = (gt) => {
        Ln(gt, (Et) => Kv(Fe.fromDom(Et), "display", "none"));
      }, e2 = (gt) => {
        const Et = Pe(gt);
        return Ie(Et) && na(Aa(Et, "display"), "none");
      }, t2 = (gt) => (gt || "mce_") + b++, oy = (gt) => {
        const Et = Pe(gt);
        return Ie(Et) ? Un(Et.dom) ? Et.dom.outerHTML : zm(Et) : "";
      }, sy = (gt, Et) => {
        Ln(gt, (yn) => {
          Un(yn) && (yn.outerHTML = Et);
        });
      }, wS = (gt, Et) => {
        const yn = xe(Et);
        return Ln(gt, (un) => {
          const cr = yn == null ? void 0 : yn.parentNode, So = yn == null ? void 0 : yn.nextSibling;
          return cr && (So ? cr.insertBefore(un, So) : cr.appendChild(un)), un;
        });
      }, n2 = (gt, Et, yn) => Ln(Et, (un) => {
        var cr;
        const So = be(Et) ? gt.cloneNode(!0) : gt;
        return yn && Ny(mw(un.childNodes), (Ha) => {
          So.appendChild(Ha);
        }), (cr = un.parentNode) === null || cr === void 0 || cr.replaceChild(So, un), un;
      }), TA = (gt, Et) => {
        if (gt.nodeName !== Et.toUpperCase()) {
          const yn = Jn(Et);
          return Ny(et(gt), (un) => {
            rt(yn, un.nodeName, Ke(gt, un.nodeName));
          }), n2(yn, gt, !0), yn;
        } else
          return gt;
      }, CD = (gt, Et) => {
        let yn = gt;
        for (; yn; ) {
          let un = Et;
          for (; un && yn !== un; )
            un = un.parentNode;
          if (yn === un)
            break;
          yn = yn.parentNode;
        }
        return !yn && gt.ownerDocument ? gt.ownerDocument.documentElement : yn;
      }, KE = (gt) => {
        if (Un(gt)) {
          const Et = gt.nodeName.toLowerCase() === "a" && !Ke(gt, "href") && Ke(gt, "id");
          if (Ke(gt, "name") || Ke(gt, "data-mce-bookmark") || Et)
            return !0;
        }
        return !1;
      }, xD = (gt, Et, yn) => {
        let un = 0;
        if (KE(gt))
          return !1;
        const cr = gt.firstChild;
        if (cr) {
          const So = new xs(cr, gt), Ha = J ? J.getWhitespaceElements() : {}, cc = Et || (J ? J.getNonEmptyElements() : null);
          let Oc = cr;
          do {
            if (Un(Oc)) {
              const a2 = Oc.getAttribute("data-mce-bogus");
              if (a2) {
                Oc = So.next(a2 === "all");
                continue;
              }
              const i2 = Oc.nodeName.toLowerCase();
              if (cc && cc[i2]) {
                if (i2 === "br") {
                  un++, Oc = So.next();
                  continue;
                }
                return !1;
              }
              if (KE(Oc))
                return !1;
            }
            if (im(Oc) || Qt(Oc) && !Bp(Oc.data) && (!(yn != null && yn.includeZwsp) || !Vm(Oc.data)) || Qt(Oc) && Oc.parentNode && Ha[Oc.parentNode.nodeName] && Bp(Oc.data))
              return !1;
            Oc = So.next();
          } while (Oc);
        }
        return un <= 1;
      }, ES = () => e.createRange(), r2 = (gt, Et, yn) => {
        let un = ES(), cr, So;
        if (gt && Et && gt.parentNode && Et.parentNode) {
          const Ha = gt.parentNode;
          return un.setStart(Ha, Gm(gt)), un.setEnd(Et.parentNode, Gm(Et)), cr = un.extractContents(), un = ES(), un.setStart(Et.parentNode, Gm(Et) + 1), un.setEnd(Ha, Gm(gt) + 1), So = un.extractContents(), Ha.insertBefore(Gp(v1, cr, J), gt), yn ? Ha.insertBefore(yn, gt) : Ha.insertBefore(Et, gt), Ha.insertBefore(Gp(v1, So, J), gt), Js(gt), yn || Et;
        } else
          return;
      }, Eg = (gt, Et, yn, un) => {
        if (be(gt)) {
          let cr = gt.length;
          const So = [];
          for (; cr--; )
            So[cr] = Eg(gt[cr], Et, yn, un);
          return So;
        } else
          return n.collect && (gt === e || gt === l) && U.push([
            gt,
            Et,
            yn,
            un
          ]), ce.bind(gt, Et, yn, un || v1);
      }, ay = (gt, Et, yn) => {
        if (be(gt)) {
          let un = gt.length;
          const cr = [];
          for (; un--; )
            cr[un] = ay(gt[un], Et, yn);
          return cr;
        } else {
          if (U.length > 0 && (gt === e || gt === l)) {
            let un = U.length;
            for (; un--; ) {
              const [cr, So, Ha] = U[un];
              gt === cr && (!Et || Et === So) && (!yn || yn === Ha) && ce.unbind(cr, So, Ha);
            }
          }
          return ce.unbind(gt, Et, yn);
        }
      }, o2 = (gt, Et, yn) => ce.dispatch(gt, Et, yn), s2 = (gt, Et, yn) => ce.dispatch(gt, Et, yn), _A = (gt) => {
        if (gt && Ui(gt)) {
          const Et = gt.getAttribute("data-mce-contenteditable");
          return Et && Et !== "inherit" ? Et : gt.contentEditable !== "inherit" ? gt.contentEditable : null;
        } else
          return null;
      }, v1 = {
        doc: e,
        settings: n,
        win: l,
        files: f,
        stdMode: E,
        boxModel: N,
        styleSheetLoader: D,
        boundEvents: U,
        styles: te,
        schema: J,
        events: ce,
        isBlock: Re,
        root: null,
        clone: dt,
        getRoot: Ht,
        getViewPort: ln,
        getRect: rr,
        getSize: Mn,
        getParent: Cs,
        getParents: so,
        get: xe,
        getNext: Si,
        getPrev: Kl,
        select: wn,
        is: Fr,
        add: Qn,
        create: Jn,
        createHTML: To,
        createFragment: Ns,
        remove: Js,
        setStyle: Rt,
        getStyle: Kt,
        setStyles: Tt,
        removeAllAttribs: Cd,
        setAttrib: rt,
        setAttribs: Ho,
        getAttrib: Ke,
        getPos: Dn,
        parseStyle: xm,
        serializeStyle: ry,
        addStyle: xd,
        loadCSS: wg,
        addClass: _o,
        removeClass: Jo,
        hasClass: Ba,
        toggleClass: Ir,
        show: Za,
        hide: Eh,
        isHidden: e2,
        uniqueId: t2,
        setHTML: Ao,
        getOuterHTML: oy,
        setOuterHTML: sy,
        decode: pn,
        encode: kr,
        insertAfter: wS,
        replace: n2,
        rename: TA,
        findCommonAncestor: CD,
        run: Ln,
        getAttribs: et,
        isEmpty: xD,
        createRng: ES,
        nodeIndex: Gm,
        split: r2,
        bind: Eg,
        unbind: ay,
        fire: s2,
        dispatch: o2,
        getContentEditable: _A,
        getContentEditableParent: (gt) => {
          const Et = Ht();
          let yn = null;
          for (let un = gt; un && un !== Et && (yn = _A(un), yn === null); un = un.parentNode)
            ;
          return yn;
        },
        isEditable: (gt) => {
          if (Ie(gt)) {
            const Et = Un(gt) ? gt : gt.parentElement;
            return Ie(Et) && Ui(Et) && Rr(Fe.fromDom(Et));
          } else
            return !1;
        },
        destroy: () => {
          if (U.length > 0) {
            let gt = U.length;
            for (; gt--; ) {
              const [Et, yn, un] = U[gt];
              ce.unbind(Et, yn, un);
            }
          }
          fn(f, (gt, Et) => {
            D.unload(Et), delete f[Et];
          });
        },
        isChildOf: (gt, Et) => gt === Et || Et.contains(gt),
        dumpRng: (gt) => "startContainer: " + gt.startContainer.nodeName + ", startOffset: " + gt.startOffset + ", endContainer: " + gt.endContainer.nodeName + ", endOffset: " + gt.endOffset
      }, OA = QC(te, n, at(v1));
      return v1;
    };
    Is.DOM = Is(document), Is.nodeIndex = Gm;
    const Of = Is.DOM, ja = 0, XC = 1, ua = 2, Xg = 3;
    class Ti {
      constructor(n = {}) {
        this.states = {}, this.queue = [], this.scriptLoadedCallbacks = {}, this.queueLoadedCallbacks = [], this.loading = !1, this.settings = n;
      }
      _setReferrerPolicy(n) {
        this.settings.referrerPolicy = n;
      }
      loadScript(n) {
        return new Promise((s, l) => {
          const f = Of;
          let b;
          const E = () => {
            f.remove(U), b && (b.onerror = b.onload = b = null);
          }, N = () => {
            E(), s();
          }, D = () => {
            E(), l("Failed to load script: " + n);
          }, U = f.uniqueId();
          b = document.createElement("script"), b.id = U, b.type = "text/javascript", b.src = rn._addCacheSuffix(n), this.settings.referrerPolicy && f.setAttrib(b, "referrerpolicy", this.settings.referrerPolicy), b.onload = N, b.onerror = D, (document.getElementsByTagName("head")[0] || document.body).appendChild(b);
        });
      }
      isDone(n) {
        return this.states[n] === ua;
      }
      markDone(n) {
        this.states[n] = ua;
      }
      add(n) {
        const s = this;
        return s.queue.push(n), s.states[n] === void 0 && (s.states[n] = ja), new Promise((f, b) => {
          s.scriptLoadedCallbacks[n] || (s.scriptLoadedCallbacks[n] = []), s.scriptLoadedCallbacks[n].push({
            resolve: f,
            reject: b
          });
        });
      }
      load(n) {
        return this.add(n);
      }
      remove(n) {
        delete this.states[n], delete this.scriptLoadedCallbacks[n];
      }
      loadQueue() {
        const n = this.queue;
        return this.queue = [], this.loadScripts(n);
      }
      loadScripts(n) {
        const s = this, l = (D, U) => {
          gs(s.scriptLoadedCallbacks, U).each((J) => {
            ke(J, (te) => te[D](U));
          }), delete s.scriptLoadedCallbacks[U];
        }, f = (D) => {
          const U = ht(D, (J) => J.status === "rejected");
          return U.length > 0 ? Promise.reject(gr(U, ({ reason: J }) => be(J) ? J : [J])) : Promise.resolve();
        }, b = (D) => Promise.allSettled(St(D, (U) => s.states[U] === ua ? (l("resolve", U), Promise.resolve()) : s.states[U] === Xg ? (l("reject", U), Promise.reject(U)) : (s.states[U] = XC, s.loadScript(U).then(() => {
          s.states[U] = ua, l("resolve", U);
          const J = s.queue;
          return J.length > 0 ? (s.queue = [], b(J).then(f)) : Promise.resolve();
        }, () => (s.states[U] = Xg, l("reject", U), Promise.reject(U)))))), E = (D) => (s.loading = !0, b(D).then((U) => {
          s.loading = !1;
          const J = s.queueLoadedCallbacks.shift();
          return oe.from(J).each(cn), f(U);
        })), N = Pd(n);
        return s.loading ? new Promise((D, U) => {
          s.queueLoadedCallbacks.push(() => {
            E(N).then(D, U);
          });
        }) : E(N);
      }
    }
    Ti.ScriptLoader = new Ti();
    const wa = (e) => {
      let n = e;
      return {
        get: () => n,
        set: (f) => {
          n = f;
        }
      };
    }, dd = (e, n) => {
      const s = e.indexOf(n);
      return s !== -1 && e.indexOf(n, s + 1) > s;
    }, hw = (e) => me(e) && lr(e, "raw"), oc = (e) => be(e) && e.length > 1, Ry = {}, Sb = wa("en"), Zm = () => gs(Ry, Sb.get()), Af = {
      getData: () => Yr(Ry, (e) => ({ ...e })),
      setCode: (e) => {
        e && Sb.set(e);
      },
      getCode: () => Sb.get(),
      add: (e, n) => {
        let s = Ry[e];
        s || (Ry[e] = s = {});
        const l = St(Co(n), (f) => f.toLowerCase());
        fn(n, (f, b) => {
          const E = b.toLowerCase();
          E !== b && dd(l, E) ? (lr(n, E) || (s[E] = f), s[b] = f) : s[E] = f;
        });
      },
      translate: (e) => {
        const n = Zm().getOr({}), s = (E) => Ce(E) ? Object.prototype.toString.call(E) : l(E) ? "" : "" + E, l = (E) => E === "" || E === null || E === void 0, f = (E) => {
          const N = s(E);
          return lr(n, N) ? s(n[N]) : gs(n, N.toLowerCase()).map(s).getOr(N);
        }, b = (E) => E.replace(/{context:\w+}$/, "");
        if (l(e))
          return "";
        if (hw(e))
          return s(e.raw);
        if (oc(e)) {
          const E = e.slice(1), N = f(e[0]).replace(/\{([0-9]+)\}/g, (D, U) => lr(E, U) ? s(E[U]) : D);
          return b(N);
        }
        return b(f(e));
      },
      isRtl: () => Zm().bind((e) => gs(e, "_dir")).exists((e) => e === "rtl"),
      hasCode: (e) => lr(Ry, e)
    }, wl = () => {
      const e = [], n = {}, s = {}, l = [], f = (xe, Pe) => {
        const Ke = ht(l, (et) => et.name === xe && et.state === Pe);
        ke(Ke, (et) => et.resolve());
      }, b = (xe) => lr(n, xe), E = (xe) => lr(s, xe), N = (xe) => {
        if (s[xe])
          return s[xe].instance;
      }, D = (xe, Pe) => {
        const Ke = Af.getCode(), et = "," + (Pe || "") + ",";
        !Ke || Pe && et.indexOf("," + Ke + ",") === -1 || Ti.ScriptLoader.add(n[xe] + "/langs/" + Ke + ".js");
      }, U = (xe, Pe) => {
        wl.languageLoad !== !1 && (b(xe) ? D(xe, Pe) : Re(xe, "loaded").then(() => D(xe, Pe)));
      }, J = (xe, Pe) => (e.push(Pe), s[xe] = { instance: Pe }, f(xe, "added"), Pe), te = (xe) => {
        delete n[xe], delete s[xe];
      }, ce = (xe, Pe) => G(Pe) ? G(xe) ? {
        prefix: "",
        resource: Pe,
        suffix: ""
      } : {
        prefix: xe.prefix,
        resource: Pe,
        suffix: xe.suffix
      } : Pe, Oe = (xe, Pe) => {
        if (n[xe])
          return Promise.resolve();
        let Ke = G(Pe) ? Pe : Pe.prefix + Pe.resource + Pe.suffix;
        Ke.indexOf("/") !== 0 && Ke.indexOf("://") === -1 && (Ke = wl.baseURL + "/" + Ke), n[xe] = Ke.substring(0, Ke.lastIndexOf("/"));
        const et = () => (f(xe, "loaded"), Promise.resolve());
        return s[xe] ? et() : Ti.ScriptLoader.add(Ke).then(et);
      }, Re = (xe, Pe = "added") => Pe === "added" && E(xe) || Pe === "loaded" && b(xe) ? Promise.resolve() : new Promise((Ke) => {
        l.push({
          name: xe,
          state: Pe,
          resolve: Ke
        });
      });
      return {
        items: e,
        urls: n,
        lookup: s,
        get: N,
        requireLangPack: U,
        add: J,
        remove: te,
        createUrl: ce,
        load: Oe,
        waitFor: Re
      };
    };
    wl.languageLoad = !0, wl.baseURL = "", wl.PluginManager = wl(), wl.ThemeManager = wl(), wl.ModelManager = wl();
    const V2 = (e) => {
      const n = wa(oe.none()), s = () => n.get().each(e);
      return {
        clear: () => {
          s(), n.set(oe.none());
        },
        isSet: () => n.get().isSome(),
        get: () => n.get(),
        set: (N) => {
          s(), n.set(oe.some(N));
        }
      };
    }, U2 = (e) => {
      const n = wa(oe.none()), s = () => n.get().each((N) => clearInterval(N));
      return {
        clear: () => {
          s(), n.set(oe.none());
        },
        isSet: () => n.get().isSome(),
        get: () => n.get(),
        set: (N) => {
          s(), n.set(oe.some(setInterval(N, e)));
        }
      };
    }, Kh = () => {
      const e = V2(Lt);
      return {
        ...e,
        on: (s) => e.get().each(s)
      };
    }, Py = (e, n) => {
      let s = null;
      return {
        cancel: () => {
          q(s) || (clearTimeout(s), s = null);
        },
        throttle: (...b) => {
          q(s) && (s = setTimeout(() => {
            s = null, e.apply(null, b);
          }, n));
        }
      };
    }, n0 = (e, n) => {
      let s = null;
      const l = () => {
        q(s) || (clearTimeout(s), s = null);
      };
      return {
        cancel: l,
        throttle: (...b) => {
          l(), s = setTimeout(() => {
            s = null, e.apply(null, b);
          }, n);
        }
      };
    }, r0 = at("mce-annotation"), Km = at("data-mce-annotation"), Eb = at("data-mce-annotation-uid"), Yh = at("data-mce-annotation-active"), Jg = at("data-mce-annotation-classes"), ev = at("data-mce-annotation-attrs"), ex = (e) => (n) => Je(n, e), Ma = (e, n) => {
      const s = e.selection.getRng(), l = Fe.fromDom(s.startContainer), f = Fe.fromDom(e.getBody()), b = n.fold(() => "." + r0(), (D) => `[${Km()}="${D}"]`), E = Du(l, s.startOffset).getOr(l);
      return au(E, b, ex(f)).bind((D) => ri(D, `${Eb()}`).bind((U) => ri(D, `${Km()}`).map((J) => {
        const te = nx(e, U);
        return {
          uid: U,
          name: J,
          elements: te
        };
      })));
    }, tx = (e) => Mi(e) && Id(e, r0()), Cb = (e, n) => Da(e, "data-mce-bogus") || rw(e, '[data-mce-bogus="all"]', ex(n)), nx = (e, n) => {
      const s = Fe.fromDom(e.getBody()), l = Vi(s, `[${Eb()}="${n}"]`);
      return ht(l, (f) => !Cb(f, s));
    }, o0 = (e, n) => {
      const s = Fe.fromDom(e.getBody()), l = Vi(s, `[${Km()}="${n}"]`), f = {};
      return ke(l, (b) => {
        if (!Cb(b, s)) {
          const E = Ji(b, Eb()), N = gs(f, E).getOr([]);
          f[E] = N.concat([b]);
        }
      }), f;
    }, sl = (e, n) => {
      const s = wa({}), l = () => ({
        listeners: [],
        previous: Kh()
      }), f = (te, ce) => {
        b(te, (Oe) => (ce(Oe), Oe));
      }, b = (te, ce) => {
        const Oe = s.get(), Re = gs(Oe, te).getOrThunk(l), xe = ce(Re);
        Oe[te] = xe, s.set(Oe);
      }, E = (te, ce, Oe) => {
        f(te, (Re) => {
          ke(Re.listeners, (xe) => xe(!0, te, {
            uid: ce,
            nodes: St(Oe, (Pe) => Pe.dom)
          }));
        });
      }, N = (te) => {
        f(te, (ce) => {
          ke(ce.listeners, (Oe) => Oe(!1, te));
        });
      }, D = (te, ce) => {
        ke(nx(e, te), (Oe) => {
          ce ? is(Oe, Yh(), "true") : Vs(Oe, Yh());
        });
      }, U = n0(() => {
        const te = uo(n.getNames());
        ke(te, (ce) => {
          b(ce, (Oe) => {
            const Re = Oe.previous.get();
            return Ma(e, oe.some(ce)).fold(() => {
              Re.each((xe) => {
                N(ce), Oe.previous.clear(), D(xe, !1);
              });
            }, ({ uid: xe, name: Pe, elements: Ke }) => {
              na(Re, xe) || (Re.each((et) => D(et, !1)), E(Pe, xe, Ke), Oe.previous.set(xe), D(xe, !0));
            }), {
              previous: Oe.previous,
              listeners: Oe.listeners
            };
          });
        });
      }, 30);
      return e.on("remove", () => {
        U.cancel();
      }), e.on("NodeChange", () => {
        U.throttle();
      }), { addListener: (te, ce) => {
        b(te, (Oe) => ({
          previous: Oe.previous,
          listeners: Oe.listeners.concat([ce])
        }));
      } };
    }, Hu = (e, n) => {
      const s = Km(), l = (b) => oe.from(b.attr(s)).bind(n.lookup), f = (b) => {
        var E, N;
        b.attr(Eb(), null), b.attr(Km(), null), b.attr(Yh(), null);
        const D = oe.from(b.attr(ev())).map((ce) => ce.split(",")).getOr([]), U = oe.from(b.attr(Jg())).map((ce) => ce.split(",")).getOr([]);
        ke(D, (ce) => b.attr(ce, null));
        const J = (N = (E = b.attr("class")) === null || E === void 0 ? void 0 : E.split(" ")) !== null && N !== void 0 ? N : [], te = pc(J, [r0()].concat(U));
        b.attr("class", te.length > 0 ? te.join(" ") : null), b.attr(Jg(), null), b.attr(ev(), null);
      };
      e.serializer.addTempAttr(Yh()), e.serializer.addAttributeFilter(s, (b) => {
        for (const E of b)
          l(E).each((N) => {
            N.persistent === !1 && (E.name === "span" ? E.unwrap() : f(E));
          });
      });
    }, rx = () => {
      const e = {};
      return {
        register: (f, b) => {
          e[f] = {
            name: f,
            settings: b
          };
        },
        lookup: (f) => gs(e, f).map((b) => b.settings),
        getNames: () => Co(e)
      };
    };
    let tv = 0;
    const nv = (e) => {
      const s = (/* @__PURE__ */ new Date()).getTime(), l = Math.floor(Math.random() * 1e9);
      return tv++, e + "_" + l + tv + String(s);
    }, W2 = (e, n) => {
      ke(n, (s) => {
        nd(e, s);
      });
    }, ox = (e, n) => {
      ke(n, (s) => {
        wc(e, s);
      });
    }, gw = (e, n) => Fe.fromDom(e.dom.cloneNode(n)), zu = (e) => gw(e, !1), s0 = (e) => gw(e, !0), qa = (e, n) => {
      const s = Fe.fromTag(n), l = cf(e);
      return ru(s, l), s;
    }, fm = (e, n) => {
      const s = qa(e, n);
      tl(e, s);
      const l = ga(e);
      return Vo(s, l), mo(e), s;
    }, xb = (e, n, s = He) => {
      const l = new xs(e, n), f = (b) => {
        let E;
        do
          E = l[b]();
        while (E && !Qt(E) && !s(E));
        return oe.from(E).filter(Qt);
      };
      return {
        current: () => oe.from(l.current()).filter(Qt),
        next: () => f("next"),
        prev: () => f("prev"),
        prev2: () => f("prev2")
      };
    }, Qh = (e, n) => {
      const s = n || ((E) => e.isBlock(E) || Mo(E) || ro(E)), l = (E, N, D, U) => {
        if (Qt(E)) {
          const J = U(E, N, E.data);
          if (J !== -1)
            return oe.some({
              container: E,
              offset: J
            });
        }
        return D().bind((J) => l(J.container, J.offset, D, U));
      };
      return {
        backwards: (E, N, D, U) => {
          const J = xb(E, U ?? e.getRoot(), s);
          return l(E, N, () => J.prev().map((te) => ({
            container: te,
            offset: te.length
          })), D).getOrNull();
        },
        forwards: (E, N, D, U) => {
          const J = xb(E, U ?? e.getRoot(), s);
          return l(E, N, () => J.next().map((te) => ({
            container: te,
            offset: 0
          })), D).getOrNull();
        }
      };
    }, rv = Math.round, ov = (e) => e ? {
      left: rv(e.left),
      top: rv(e.top),
      bottom: rv(e.bottom),
      right: rv(e.right),
      width: rv(e.width),
      height: rv(e.height)
    } : {
      left: 0,
      top: 0,
      bottom: 0,
      right: 0,
      width: 0,
      height: 0
    }, th = (e, n) => (e = ov(e), n || (e.left = e.left + e.width), e.right = e.left, e.width = 0, e), sx = (e, n) => e.left === n.left && e.top === n.top && e.bottom === n.bottom && e.right === n.right, sv = (e, n, s) => e >= 0 && e <= Math.min(n.height, s.height) / 2, Xh = (e, n) => {
      const s = Math.min(n.height / 2, e.height / 2);
      return e.bottom - s < n.top ? !0 : e.top > n.bottom ? !1 : sv(n.top - e.bottom, e, n);
    }, Jh = (e, n) => e.top > n.bottom ? !0 : e.bottom < n.top ? !1 : sv(n.bottom - e.top, e, n), vw = (e, n, s) => n >= e.left && n <= e.right && s >= e.top && s <= e.bottom, j2 = (e) => Ye(e, (n, s) => n.fold(() => oe.some(s), (l) => {
      const f = Math.min(s.left, l.left), b = Math.min(s.top, l.top), E = Math.max(s.right, l.right), N = Math.max(s.bottom, l.bottom);
      return oe.some({
        top: b,
        right: E,
        bottom: N,
        left: f,
        width: E - f,
        height: N - b
      });
    }), oe.none()), bw = (e, n, s) => {
      const l = Math.max(Math.min(n, e.left + e.width), e.left), f = Math.max(Math.min(s, e.top + e.height), e.top);
      return Math.sqrt((n - l) * (n - l) + (s - f) * (s - f));
    }, q2 = (e, n) => Math.max(0, Math.min(e.bottom, n.bottom) - Math.max(e.top, n.top)), a0 = (e, n, s) => Math.min(Math.max(e, n), s), Tb = (e) => {
      const n = e.startContainer, s = e.startOffset;
      return n === e.endContainer && n.hasChildNodes() && e.endOffset === s + 1 ? n.childNodes[s] : null;
    }, Vu = (e, n) => {
      if (Un(e) && e.hasChildNodes()) {
        const s = e.childNodes, l = a0(n, 0, s.length - 1);
        return s[l];
      } else
        return e;
    }, ax = (e, n) => {
      if (!(n < 0 && Un(e) && e.hasChildNodes()))
        return Vu(e, n);
    }, _b = new RegExp("[-----------------------------------------------------------------------------------------------------------------------------------]"), ix = (e) => G(e) && e.charCodeAt(0) >= 768 && _b.test(e), G2 = (...e) => (n) => {
      for (let s = 0; s < e.length; s++)
        if (e[s](n))
          return !0;
      return !1;
    }, Dy = (...e) => (n) => {
      for (let s = 0; s < e.length; s++)
        if (!e[s](n))
          return !1;
      return !0;
    }, eg = Un, i0 = oo, po = om("display", "block table"), Uu = om("float", "left right"), mm = Dy(eg, i0, vt(Uu)), Ob = vt(om("white-space", "pre pre-line pre-wrap")), ds = Qt, Ab = Mo, c0 = Is.nodeIndex, bi = ax, pm = (e) => e ? e.createRange() : Is.DOM.createRng(), nh = (e) => G(e) && /[\r\n\t ]/.test(e), l0 = (e) => !!e.setStart && !!e.setEnd, $y = (e) => {
      const n = e.startContainer, s = e.startOffset;
      if (nh(e.toString()) && Ob(n.parentNode) && Qt(n)) {
        const l = n.data;
        if (nh(l[s - 1]) || nh(l[s + 1]))
          return !0;
      }
      return !1;
    }, Iy = (e) => {
      const n = e.ownerDocument, s = pm(n), l = n.createTextNode(xo), f = e.parentNode;
      f.insertBefore(l, e), s.setStart(l, 0), s.setEnd(l, 1);
      const b = ov(s.getBoundingClientRect());
      return f.removeChild(l), b;
    }, yw = (e) => {
      const n = e.startContainer, s = e.endContainer, l = e.startOffset, f = e.endOffset;
      if (n === s && Qt(s) && l === 0 && f === 1) {
        const b = e.cloneRange();
        return b.setEndAfter(s), qd(b);
      } else
        return null;
    }, u0 = (e) => e.left === 0 && e.right === 0 && e.top === 0 && e.bottom === 0, qd = (e) => {
      var n;
      let s;
      const l = e.getClientRects();
      return l.length > 0 ? s = ov(l[0]) : s = ov(e.getBoundingClientRect()), !l0(e) && Ab(e) && u0(s) ? Iy(e) : u0(s) && l0(e) && (n = yw(e)) !== null && n !== void 0 ? n : s;
    }, kf = (e, n) => {
      const s = th(e, n);
      return s.width = 1, s.right = s.left + 1, s;
    }, Z2 = (e) => {
      const n = [], s = (E) => {
        E.height !== 0 && (n.length > 0 && sx(E, n[n.length - 1]) || n.push(E));
      }, l = (E, N) => {
        const D = pm(E.ownerDocument);
        if (N < E.data.length) {
          if (ix(E.data[N]))
            return;
          if (ix(E.data[N - 1]) && (D.setStart(E, N), D.setEnd(E, N + 1), !$y(D))) {
            s(kf(qd(D), !1));
            return;
          }
        }
        N > 0 && (D.setStart(E, N - 1), D.setEnd(E, N), $y(D) || s(kf(qd(D), !1))), N < E.data.length && (D.setStart(E, N), D.setEnd(E, N + 1), $y(D) || s(kf(qd(D), !0)));
      }, f = e.container(), b = e.offset();
      if (ds(f))
        return l(f, b), n;
      if (eg(f))
        if (e.isAtEnd()) {
          const E = bi(f, b);
          ds(E) && l(E, E.data.length), mm(E) && !Ab(E) && s(kf(qd(E), !1));
        } else {
          const E = bi(f, b);
          if (ds(E) && l(E, 0), mm(E) && e.isAtEnd())
            return s(kf(qd(E), !1)), n;
          const N = bi(e.container(), e.offset() - 1);
          mm(N) && !Ab(N) && (po(N) || po(E) || !mm(E)) && s(kf(qd(N), !1)), mm(E) && s(kf(qd(E), !0));
        }
      return n;
    }, yt = (e, n, s) => {
      const l = () => (ds(e), n === 0), f = () => ds(e) ? n >= e.data.length : n >= e.childNodes.length, b = () => {
        const J = pm(e.ownerDocument);
        return J.setStart(e, n), J.setEnd(e, n), J;
      }, E = () => (s || (s = Z2(yt(e, n))), s), N = () => E().length > 0, D = (J) => J && e === J.container() && n === J.offset(), U = (J) => bi(e, J ? n - 1 : n);
      return {
        container: at(e),
        offset: at(n),
        toRange: b,
        getClientRects: E,
        isVisible: N,
        isAtStart: l,
        isAtEnd: f,
        isEqual: D,
        getNode: U
      };
    };
    yt.fromRangeStart = (e) => yt(e.startContainer, e.startOffset), yt.fromRangeEnd = (e) => yt(e.endContainer, e.endOffset), yt.after = (e) => yt(e.parentNode, c0(e) + 1), yt.before = (e) => yt(e.parentNode, c0(e)), yt.isAbove = (e, n) => bs(br(n.getClientRects()), hs(e.getClientRects()), Xh).getOr(!1), yt.isBelow = (e, n) => bs(hs(n.getClientRects()), br(e.getClientRects()), Jh).getOr(!1), yt.isAtStart = (e) => e ? e.isAtStart() : !1, yt.isAtEnd = (e) => e ? e.isAtEnd() : !1, yt.isTextPosition = (e) => e ? Qt(e.container()) : !1, yt.isElementPosition = (e) => !yt.isTextPosition(e);
    const av = (e, n) => {
      Qt(n) && n.data.length === 0 && e.remove(n);
    }, iv = (e, n, s) => {
      n.insertNode(s), av(e, s.previousSibling), av(e, s.nextSibling);
    }, fd = (e, n, s) => {
      const l = oe.from(s.firstChild), f = oe.from(s.lastChild);
      n.insertNode(s), l.each((b) => av(e, b.previousSibling)), f.each((b) => av(e, b.nextSibling));
    }, Sw = (e, n, s) => {
      Ws(s) ? fd(e, n, s) : iv(e, n, s);
    }, sa = Qt, d0 = ad, rh = Is.nodeIndex, ww = (e) => {
      const n = e.parentNode;
      return d0(n) ? ww(n) : n;
    }, f0 = (e) => e ? vc(e.childNodes, (n, s) => (d0(s) && s.nodeName !== "BR" ? n = n.concat(f0(s)) : n.push(s), n), []) : [], Ew = (e, n) => {
      let s = e;
      for (; (s = s.previousSibling) && sa(s); )
        n += s.data.length;
      return n;
    }, My = (e) => (n) => e === n, kb = (e) => {
      let n, s;
      n = f0(ww(e)), s = ea(n, My(e), e), n = n.slice(0, s + 1);
      const l = vc(n, (f, b, E) => (sa(b) && sa(n[E - 1]) && f++, f), 0);
      return n = Sp(n, Ua([e.nodeName])), s = ea(n, My(e), e), s - l;
    }, Cw = (e) => (sa(e) ? "text()" : e.nodeName.toLowerCase()) + "[" + kb(e) + "]", K2 = (e, n, s) => {
      const l = [];
      for (let f = n.parentNode; f && f !== e && !(s && s(f)); f = f.parentNode)
        l.push(f);
      return l;
    }, Ga = (e, n) => {
      let s = [], l = n.container(), f = n.offset(), b;
      if (sa(l))
        b = Ew(l, f);
      else {
        const N = l.childNodes;
        f >= N.length ? (b = "after", f = N.length - 1) : b = "before", l = N[f];
      }
      s.push(Cw(l));
      let E = K2(e, l);
      return E = Sp(E, vt(ad)), s = s.concat(Nl(E, (N) => Cw(N))), s.reverse().join("/") + "," + b;
    }, Wi = (e, n, s) => {
      let l = f0(e);
      return l = Sp(l, (f, b) => !sa(f) || !sa(l[b - 1])), l = Sp(l, Ua([n])), l[s];
    }, Mc = (e, n) => {
      let s = e, l = 0;
      for (; sa(s); ) {
        const f = s.data.length;
        if (n >= l && n <= l + f) {
          e = s, n = n - l;
          break;
        }
        if (!sa(s.nextSibling)) {
          e = s, n = f;
          break;
        }
        l += f, s = s.nextSibling;
      }
      return sa(e) && n > e.data.length && (n = e.data.length), yt(e, n);
    }, ji = (e, n) => {
      if (!n)
        return null;
      const s = n.split(","), l = s[0].split("/"), f = s.length > 1 ? s[1] : "before", b = vc(l, (E, N) => {
        const D = /([\w\-\(\)]+)\[([0-9]+)\]/.exec(N);
        return D ? (D[1] === "text()" && (D[1] = "#text"), Wi(E, D[1], parseInt(D[2], 10))) : null;
      }, e);
      if (!b)
        return null;
      if (!sa(b) && b.parentNode) {
        let E;
        return f === "after" ? E = rh(b) + 1 : E = rh(b), yt(b.parentNode, E);
      }
      return Mc(b, parseInt(f, 10));
    }, Br = ro, El = (e, n, s) => {
      let l = e(n.data.slice(0, s)).length;
      for (let f = n.previousSibling; f && Qt(f); f = f.previousSibling)
        l += e(f.data).length;
      return l;
    }, Os = (e, n, s, l, f) => {
      const b = f ? l.startContainer : l.endContainer;
      let E = f ? l.startOffset : l.endOffset;
      const N = [], D = e.getRoot();
      if (Qt(b))
        N.push(s ? El(n, b, E) : E);
      else {
        let U = 0;
        const J = b.childNodes;
        E >= J.length && J.length && (U = 1, E = Math.max(0, J.length - 1)), N.push(e.nodeIndex(J[E], s) + U);
      }
      for (let U = b; U && U !== D; U = U.parentNode)
        N.push(e.nodeIndex(U, s));
      return N;
    }, qi = (e, n, s, l) => {
      const f = n.dom, b = Os(f, e, s, l, !0), E = n.isForward(), N = Mp(l) ? { isFakeCaret: !0 } : {};
      if (n.isCollapsed())
        return {
          start: b,
          forward: E,
          ...N
        };
      {
        const D = Os(f, e, s, l, !1);
        return {
          start: b,
          end: D,
          forward: E,
          ...N
        };
      }
    }, Fy = (e, n, s) => {
      let l = 0;
      return rn.each(e.select(n), (f) => {
        if (f.getAttribute("data-mce-bogus") !== "all") {
          if (f === s)
            return !1;
          l++;
          return;
        }
      }), l;
    }, Ym = (e, n) => {
      let s = n ? e.startContainer : e.endContainer, l = n ? e.startOffset : e.endOffset;
      if (Un(s) && s.nodeName === "TR") {
        const f = s.childNodes;
        s = f[Math.min(n ? l : l - 1, f.length - 1)], s && (l = n ? 0 : s.childNodes.length, n ? e.setStart(s, l) : e.setEnd(s, l));
      }
    }, Ly = (e) => (Ym(e, !0), Ym(e, !1), e), xw = (e, n) => {
      if (Un(e) && (e = Vu(e, n), Br(e)))
        return e;
      if (Xn(e)) {
        Qt(e) && tn(e) && (e = e.parentNode);
        let s = e.previousSibling;
        if (Br(s) || (s = e.nextSibling, Br(s)))
          return s;
      }
    }, cx = (e) => xw(e.startContainer, e.startOffset) || xw(e.endContainer, e.endOffset), m0 = (e, n, s) => {
      const l = s.getNode(), f = s.getRng();
      if (l.nodeName === "IMG" || Br(l)) {
        const E = l.nodeName;
        return {
          name: E,
          index: Fy(s.dom, E, l)
        };
      }
      const b = cx(f);
      if (b) {
        const E = b.tagName;
        return {
          name: E,
          index: Fy(s.dom, E, b)
        };
      }
      return qi(e, s, n, f);
    }, Tw = (e) => {
      const n = e.getRng();
      return {
        start: Ga(e.dom.getRoot(), yt.fromRangeStart(n)),
        end: Ga(e.dom.getRoot(), yt.fromRangeEnd(n)),
        forward: e.isForward()
      };
    }, _w = (e) => ({
      rng: e.getRng(),
      forward: e.isForward()
    }), Y2 = (e, n, s) => {
      const l = {
        "data-mce-type": "bookmark",
        id: n,
        style: "overflow:hidden;line-height:0px"
      };
      return s ? e.create("span", l, "&#xFEFF;") : e.create("span", l);
    }, Qm = (e, n) => {
      const s = e.dom;
      let l = e.getRng();
      const f = s.uniqueId(), b = e.isCollapsed(), E = e.getNode(), N = E.nodeName, D = e.isForward();
      if (N === "IMG")
        return {
          name: N,
          index: Fy(s, N, E)
        };
      const U = Ly(l.cloneRange());
      if (!b) {
        U.collapse(!1);
        const te = Y2(s, f + "_end", n);
        Sw(s, U, te);
      }
      l = Ly(l), l.collapse(!0);
      const J = Y2(s, f + "_start", n);
      return Sw(s, l, J), e.moveToBookmark({
        id: f,
        keep: !0,
        forward: D
      }), {
        id: f,
        forward: D
      };
    }, lx = (e, n, s = !1) => n === 2 ? m0(de, s, e) : n === 3 ? Tw(e) : n ? _w(e) : Qm(e, !1), oh = Ne(m0, _n, !0), li = (e) => {
      const n = (b) => b(e), s = at(e), l = () => f, f = {
        tag: !0,
        inner: e,
        fold: (b, E) => E(e),
        isValue: ut,
        isError: He,
        map: (b) => gu.value(b(e)),
        mapError: l,
        bind: n,
        exists: n,
        forall: n,
        getOr: s,
        or: l,
        getOrThunk: s,
        orThunk: l,
        getOrDie: s,
        each: (b) => {
          b(e);
        },
        toOptional: () => oe.some(e)
      };
      return f;
    }, Gi = (e) => {
      const n = () => s, s = {
        tag: !1,
        inner: e,
        fold: (l, f) => l(e),
        isValue: He,
        isError: ut,
        map: n,
        mapError: (l) => gu.error(l(e)),
        bind: n,
        exists: He,
        forall: ut,
        getOr: _n,
        or: _n,
        getOrThunk: xt,
        orThunk: xt,
        getOrDie: Gt(String(e)),
        each: Lt,
        toOptional: oe.none
      };
      return s;
    }, gu = {
      value: li,
      error: Gi,
      fromOption: (e, n) => e.fold(() => Gi(n), li)
    }, hm = { generate: (e) => {
      if (!be(e))
        throw new Error("cases must be an array");
      if (e.length === 0)
        throw new Error("there must be at least one case");
      const n = [], s = {};
      return ke(e, (l, f) => {
        const b = Co(l);
        if (b.length !== 1)
          throw new Error("one and only one name per case");
        const E = b[0], N = l[E];
        if (s[E] !== void 0)
          throw new Error("duplicate key detected:" + E);
        if (E === "cata")
          throw new Error("cannot have a case named cata (sorry)");
        if (!be(N))
          throw new Error("case arguments must be an array");
        n.push(E), s[E] = (...D) => {
          const U = D.length;
          if (U !== N.length)
            throw new Error("Wrong number of arguments to case " + E + ". Expected " + N.length + " (" + N + "), got " + U);
          return {
            fold: (...te) => {
              if (te.length !== e.length)
                throw new Error("Wrong number of arguments to fold. Expected " + e.length + ", got " + te.length);
              return te[f].apply(null, D);
            },
            match: (te) => {
              const ce = Co(te);
              if (n.length !== ce.length)
                throw new Error("Wrong number of arguments to match. Expected: " + n.join(",") + `
Actual: ` + ce.join(","));
              if (!Vr(n, (Re) => Ge(ce, Re)))
                throw new Error("Not all branches were specified when using match. Specified: " + ce.join(", ") + `
Required: ` + n.join(", "));
              return te[E].apply(null, D);
            },
            log: (te) => {
              console.log(te, {
                constructors: n,
                constructor: E,
                params: D
              });
            }
          };
        };
      }), s;
    } };
    hm.generate([
      {
        bothErrors: [
          "error1",
          "error2"
        ]
      },
      {
        firstError: [
          "error1",
          "value2"
        ]
      },
      {
        secondError: [
          "value1",
          "error2"
        ]
      },
      {
        bothValues: [
          "value1",
          "value2"
        ]
      }
    ]);
    const mn = (e) => {
      const n = [], s = [];
      return ke(e, (l) => {
        l.fold((f) => {
          n.push(f);
        }, (f) => {
          s.push(f);
        });
      }), {
        errors: n,
        values: s
      };
    }, Ow = (e) => e.type === "inline-command" || e.type === "inline-format", Zi = (e) => e.type === "block-command" || e.type === "block-format", Aw = (e) => {
      const n = (l) => gu.error({
        message: l,
        pattern: e
      }), s = (l, f, b) => {
        if (e.format !== void 0) {
          let E;
          if (be(e.format)) {
            if (!Vr(e.format, G))
              return n(l + " pattern has non-string items in the `format` array");
            E = e.format;
          } else if (G(e.format))
            E = [e.format];
          else
            return n(l + " pattern has non-string `format` parameter");
          return gu.value(f(E));
        } else
          return e.cmd !== void 0 ? G(e.cmd) ? gu.value(b(e.cmd, e.value)) : n(l + " pattern has non-string `cmd` parameter") : n(l + " pattern is missing both `format` and `cmd` parameters");
      };
      if (!me(e))
        return n("Raw pattern is not an object");
      if (!G(e.start))
        return n("Raw pattern is missing `start` parameter");
      if (e.end !== void 0) {
        if (!G(e.end))
          return n("Inline pattern has non-string `end` parameter");
        if (e.start.length === 0 && e.end.length === 0)
          return n("Inline pattern has empty `start` and `end` parameters");
        let l = e.start, f = e.end;
        return f.length === 0 && (f = l, l = ""), s("Inline", (b) => ({
          type: "inline-format",
          start: l,
          end: f,
          format: b
        }), (b, E) => ({
          type: "inline-command",
          start: l,
          end: f,
          cmd: b,
          value: E
        }));
      } else
        return e.replacement !== void 0 ? G(e.replacement) ? e.start.length === 0 ? n("Replacement pattern has empty `start` parameter") : gu.value({
          type: "inline-command",
          start: "",
          end: e.start,
          cmd: "mceInsertContent",
          value: e.replacement
        }) : n("Replacement pattern has non-string `replacement` parameter") : e.start.length === 0 ? n("Block pattern has empty `start` parameter") : s("Block", (l) => ({
          type: "block-format",
          start: e.start,
          format: l[0]
        }), (l, f) => ({
          type: "block-command",
          start: e.start,
          cmd: l,
          value: f
        }));
    }, tg = (e) => ht(e, Zi), By = (e) => ht(e, Ow), vu = (e, n) => ({
      inlinePatterns: By(e),
      blockPatterns: tg(e),
      dynamicPatternsLookup: n
    }), ux = (e) => {
      const n = mn(St(e, Aw));
      return ke(n.errors, (s) => console.error(s.message, s.pattern)), n.values;
    }, Hy = (e) => (n) => {
      const s = e(n);
      return ux(s);
    }, Fa = Lr().deviceType, gm = Fa.isTouch(), zy = Is.DOM, Xm = (e) => {
      const n = e.indexOf("=") > 0 ? e.split(/[;,](?![^=;,]*(?:[;,]|$))/) : e.split(",");
      return Ye(n, (s, l) => {
        const f = l.split("="), b = f[0], E = f.length > 1 ? f[1] : b;
        return s[Xu(b)] = Xu(E), s;
      }, {});
    }, Nf = (e) => ue(e, RegExp), Fn = (e) => (n) => n.options.get(e), md = (e) => G(e) || me(e), kw = (e, n = "") => (s) => {
      const l = G(s);
      if (l)
        if (s.indexOf("=") !== -1) {
          const f = Xm(s);
          return {
            value: gs(f, e.id).getOr(n),
            valid: l
          };
        } else
          return {
            value: s,
            valid: l
          };
      else
        return {
          valid: !1,
          message: "Must be a string."
        };
    }, Jm = (e) => {
      const n = e.options.register;
      n("id", {
        processor: "string",
        default: e.id
      }), n("selector", { processor: "string" }), n("target", { processor: "object" }), n("suffix", { processor: "string" }), n("cache_suffix", { processor: "string" }), n("base_url", { processor: "string" }), n("referrer_policy", {
        processor: "string",
        default: ""
      }), n("language_load", {
        processor: "boolean",
        default: !0
      }), n("inline", {
        processor: "boolean",
        default: !1
      }), n("iframe_attrs", {
        processor: "object",
        default: {}
      }), n("doctype", {
        processor: "string",
        default: "<!DOCTYPE html>"
      }), n("document_base_url", {
        processor: "string",
        default: e.documentBaseUrl
      }), n("body_id", {
        processor: kw(e, "tinymce"),
        default: "tinymce"
      }), n("body_class", {
        processor: kw(e),
        default: ""
      }), n("content_security_policy", {
        processor: "string",
        default: ""
      }), n("br_in_pre", {
        processor: "boolean",
        default: !0
      }), n("forced_root_block", {
        processor: (s) => {
          const l = G(s) && $o(s);
          return l ? {
            value: s,
            valid: l
          } : {
            valid: !1,
            message: "Must be a non-empty string."
          };
        },
        default: "p"
      }), n("forced_root_block_attrs", {
        processor: "object",
        default: {}
      }), n("newline_behavior", {
        processor: (s) => {
          const l = Ge([
            "block",
            "linebreak",
            "invert",
            "default"
          ], s);
          return l ? {
            value: s,
            valid: l
          } : {
            valid: !1,
            message: "Must be one of: block, linebreak, invert or default."
          };
        },
        default: "default"
      }), n("br_newline_selector", {
        processor: "string",
        default: ".mce-toc h2,figcaption,caption"
      }), n("no_newline_selector", {
        processor: "string",
        default: ""
      }), n("keep_styles", {
        processor: "boolean",
        default: !0
      }), n("end_container_on_empty_block", {
        processor: (s) => Te(s) ? {
          valid: !0,
          value: s
        } : G(s) ? {
          valid: !0,
          value: s
        } : {
          valid: !1,
          message: "Must be boolean or a string"
        },
        default: "blockquote"
      }), n("font_size_style_values", {
        processor: "string",
        default: "xx-small,x-small,small,medium,large,x-large,xx-large"
      }), n("font_size_legacy_values", {
        processor: "string",
        default: "xx-small,small,medium,large,x-large,xx-large,300%"
      }), n("font_size_classes", {
        processor: "string",
        default: ""
      }), n("automatic_uploads", {
        processor: "boolean",
        default: !0
      }), n("images_reuse_filename", {
        processor: "boolean",
        default: !1
      }), n("images_replace_blob_uris", {
        processor: "boolean",
        default: !0
      }), n("icons", {
        processor: "string",
        default: ""
      }), n("icons_url", {
        processor: "string",
        default: ""
      }), n("images_upload_url", {
        processor: "string",
        default: ""
      }), n("images_upload_base_path", {
        processor: "string",
        default: ""
      }), n("images_upload_credentials", {
        processor: "boolean",
        default: !1
      }), n("images_upload_handler", { processor: "function" }), n("language", {
        processor: "string",
        default: "en"
      }), n("language_url", {
        processor: "string",
        default: ""
      }), n("entity_encoding", {
        processor: "string",
        default: "named"
      }), n("indent", {
        processor: "boolean",
        default: !0
      }), n("indent_before", {
        processor: "string",
        default: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist"
      }), n("indent_after", {
        processor: "string",
        default: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist"
      }), n("indent_use_margin", {
        processor: "boolean",
        default: !1
      }), n("indentation", {
        processor: "string",
        default: "40px"
      }), n("content_css", {
        processor: (s) => {
          const l = s === !1 || G(s) || sn(s, G);
          return l ? G(s) ? {
            value: St(s.split(","), Xu),
            valid: l
          } : be(s) ? {
            value: s,
            valid: l
          } : s === !1 ? {
            value: [],
            valid: l
          } : {
            value: s,
            valid: l
          } : {
            valid: !1,
            message: "Must be false, a string or an array of strings."
          };
        },
        default: Fw(e) ? [] : ["default"]
      }), n("content_style", { processor: "string" }), n("content_css_cors", {
        processor: "boolean",
        default: !1
      }), n("font_css", {
        processor: (s) => {
          const l = G(s) || sn(s, G);
          return l ? {
            value: be(s) ? s : St(s.split(","), Xu),
            valid: l
          } : {
            valid: !1,
            message: "Must be a string or an array of strings."
          };
        },
        default: []
      }), n("inline_boundaries", {
        processor: "boolean",
        default: !0
      }), n("inline_boundaries_selector", {
        processor: "string",
        default: "a[href],code,span.mce-annotation"
      }), n("object_resizing", {
        processor: (s) => {
          const l = Te(s) || G(s);
          return l ? s === !1 || Fa.isiPhone() || Fa.isiPad() ? {
            value: "",
            valid: l
          } : {
            value: s === !0 ? "table,img,figure.image,div,video,iframe" : s,
            valid: l
          } : {
            valid: !1,
            message: "Must be boolean or a string"
          };
        },
        default: !gm
      }), n("resize_img_proportional", {
        processor: "boolean",
        default: !0
      }), n("event_root", { processor: "object" }), n("service_message", { processor: "string" }), n("theme", {
        processor: (s) => s === !1 || G(s) || Ce(s),
        default: "silver"
      }), n("theme_url", { processor: "string" }), n("formats", { processor: "object" }), n("format_empty_lines", {
        processor: "boolean",
        default: !1
      }), n("format_noneditable_selector", {
        processor: "string",
        default: ""
      }), n("preview_styles", {
        processor: (s) => {
          const l = s === !1 || G(s);
          return l ? {
            value: s === !1 ? "" : s,
            valid: l
          } : {
            valid: !1,
            message: "Must be false or a string"
          };
        },
        default: "font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow"
      }), n("custom_ui_selector", {
        processor: "string",
        default: ""
      }), n("hidden_input", {
        processor: "boolean",
        default: !0
      }), n("submit_patch", {
        processor: "boolean",
        default: !0
      }), n("encoding", { processor: "string" }), n("add_form_submit_trigger", {
        processor: "boolean",
        default: !0
      }), n("add_unload_trigger", {
        processor: "boolean",
        default: !0
      }), n("custom_undo_redo_levels", {
        processor: "number",
        default: 0
      }), n("disable_nodechange", {
        processor: "boolean",
        default: !1
      }), n("readonly", {
        processor: "boolean",
        default: !1
      }), n("editable_root", {
        processor: "boolean",
        default: !0
      }), n("plugins", {
        processor: "string[]",
        default: []
      }), n("external_plugins", { processor: "object" }), n("forced_plugins", { processor: "string[]" }), n("model", {
        processor: "string",
        default: e.hasPlugin("rtc") ? "plugin" : "dom"
      }), n("model_url", { processor: "string" }), n("block_unsupported_drop", {
        processor: "boolean",
        default: !0
      }), n("visual", {
        processor: "boolean",
        default: !0
      }), n("visual_table_class", {
        processor: "string",
        default: "mce-item-table"
      }), n("visual_anchor_class", {
        processor: "string",
        default: "mce-item-anchor"
      }), n("iframe_aria_text", {
        processor: "string",
        default: "Rich Text Area. Press ALT-0 for help."
      }), n("setup", { processor: "function" }), n("init_instance_callback", { processor: "function" }), n("url_converter", {
        processor: "function",
        default: e.convertURL
      }), n("url_converter_scope", {
        processor: "object",
        default: e
      }), n("urlconverter_callback", { processor: "function" }), n("allow_conditional_comments", {
        processor: "boolean",
        default: !1
      }), n("allow_html_data_urls", {
        processor: "boolean",
        default: !1
      }), n("allow_svg_data_urls", { processor: "boolean" }), n("allow_html_in_named_anchor", {
        processor: "boolean",
        default: !1
      }), n("allow_script_urls", {
        processor: "boolean",
        default: !1
      }), n("allow_unsafe_link_target", {
        processor: "boolean",
        default: !1
      }), n("convert_fonts_to_spans", {
        processor: "boolean",
        default: !0,
        deprecated: !0
      }), n("fix_list_elements", {
        processor: "boolean",
        default: !1
      }), n("preserve_cdata", {
        processor: "boolean",
        default: !1
      }), n("remove_trailing_brs", {
        processor: "boolean",
        default: !0
      }), n("pad_empty_with_br", {
        processor: "boolean",
        default: !1
      }), n("inline_styles", {
        processor: "boolean",
        default: !0,
        deprecated: !0
      }), n("element_format", {
        processor: "string",
        default: "html"
      }), n("entities", { processor: "string" }), n("schema", {
        processor: "string",
        default: "html5"
      }), n("convert_urls", {
        processor: "boolean",
        default: !0
      }), n("relative_urls", {
        processor: "boolean",
        default: !0
      }), n("remove_script_host", {
        processor: "boolean",
        default: !0
      }), n("custom_elements", { processor: "string" }), n("extended_valid_elements", { processor: "string" }), n("invalid_elements", { processor: "string" }), n("invalid_styles", { processor: md }), n("valid_children", { processor: "string" }), n("valid_classes", { processor: md }), n("valid_elements", { processor: "string" }), n("valid_styles", { processor: md }), n("verify_html", {
        processor: "boolean",
        default: !0
      }), n("auto_focus", { processor: (s) => G(s) || s === !0 }), n("browser_spellcheck", {
        processor: "boolean",
        default: !1
      }), n("protect", { processor: "array" }), n("images_file_types", {
        processor: "string",
        default: "jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp"
      }), n("deprecation_warnings", {
        processor: "boolean",
        default: !0
      }), n("a11y_advanced_options", {
        processor: "boolean",
        default: !1
      }), n("api_key", { processor: "string" }), n("paste_block_drop", {
        processor: "boolean",
        default: !1
      }), n("paste_data_images", {
        processor: "boolean",
        default: !0
      }), n("paste_preprocess", { processor: "function" }), n("paste_postprocess", { processor: "function" }), n("paste_webkit_styles", {
        processor: "string",
        default: "none"
      }), n("paste_remove_styles_if_webkit", {
        processor: "boolean",
        default: !0
      }), n("paste_merge_formats", {
        processor: "boolean",
        default: !0
      }), n("smart_paste", {
        processor: "boolean",
        default: !0
      }), n("paste_as_text", {
        processor: "boolean",
        default: !1
      }), n("paste_tab_spaces", {
        processor: "number",
        default: 4
      }), n("text_patterns", {
        processor: (s) => sn(s, me) || s === !1 ? {
          value: ux(s === !1 ? [] : s),
          valid: !0
        } : {
          valid: !1,
          message: "Must be an array of objects or false."
        },
        default: [
          {
            start: "*",
            end: "*",
            format: "italic"
          },
          {
            start: "**",
            end: "**",
            format: "bold"
          },
          {
            start: "#",
            format: "h1"
          },
          {
            start: "##",
            format: "h2"
          },
          {
            start: "###",
            format: "h3"
          },
          {
            start: "####",
            format: "h4"
          },
          {
            start: "#####",
            format: "h5"
          },
          {
            start: "######",
            format: "h6"
          },
          {
            start: "1. ",
            cmd: "InsertOrderedList"
          },
          {
            start: "* ",
            cmd: "InsertUnorderedList"
          },
          {
            start: "- ",
            cmd: "InsertUnorderedList"
          }
        ]
      }), n("text_patterns_lookup", {
        processor: (s) => Ce(s) ? {
          value: Hy(s),
          valid: !0
        } : {
          valid: !1,
          message: "Must be a single function"
        },
        default: (s) => []
      }), n("noneditable_class", {
        processor: "string",
        default: "mceNonEditable"
      }), n("editable_class", {
        processor: "string",
        default: "mceEditable"
      }), n("noneditable_regexp", {
        processor: (s) => sn(s, Nf) ? {
          value: s,
          valid: !0
        } : Nf(s) ? {
          value: [s],
          valid: !0
        } : {
          valid: !1,
          message: "Must be a RegExp or an array of RegExp."
        },
        default: []
      }), n("table_tab_navigation", {
        processor: "boolean",
        default: !0
      }), n("highlight_on_focus", {
        processor: "boolean",
        default: !1
      }), n("xss_sanitization", {
        processor: "boolean",
        default: !0
      }), n("details_initial_state", {
        processor: (s) => {
          const l = Ge([
            "inherited",
            "collapsed",
            "expanded"
          ], s);
          return l ? {
            value: s,
            valid: l
          } : {
            valid: !1,
            message: "Must be one of: inherited, collapsed, or expanded."
          };
        },
        default: "inherited"
      }), n("details_serialized_state", {
        processor: (s) => {
          const l = Ge([
            "inherited",
            "collapsed",
            "expanded"
          ], s);
          return l ? {
            value: s,
            valid: l
          } : {
            valid: !1,
            message: "Must be one of: inherited, collapsed, or expanded."
          };
        },
        default: "inherited"
      }), n("init_content_sync", {
        processor: "boolean",
        default: !1
      }), n("newdocument_content", {
        processor: "string",
        default: ""
      }), n("force_hex_color", {
        processor: (s) => {
          const l = [
            "always",
            "rgb_only",
            "off"
          ], f = Ge(l, s);
          return f ? {
            value: s,
            valid: f
          } : {
            valid: !1,
            message: `Must be one of: ${l.join(", ")}.`
          };
        },
        default: "off"
      }), n("sandbox_iframes", {
        processor: "boolean",
        default: !1
      }), n("convert_unsafe_embeds", {
        processor: "boolean",
        default: !1
      }), e.on("ScriptsLoaded", () => {
        n("directionality", {
          processor: "string",
          default: Af.isRtl() ? "rtl" : void 0
        }), n("placeholder", {
          processor: "string",
          default: zy.getAttrib(e.getElement(), "placeholder")
        });
      });
    }, Uo = Fn("iframe_attrs"), Nw = Fn("doctype"), pd = Fn("document_base_url"), p0 = Fn("body_id"), X2 = Fn("body_class"), aa = Fn("content_security_policy"), J2 = Fn("br_in_pre"), al = Fn("forced_root_block"), ng = Fn("forced_root_block_attrs"), e_ = Fn("newline_behavior"), t_ = Fn("br_newline_selector"), Rw = Fn("no_newline_selector"), n_ = Fn("keep_styles"), dx = Fn("end_container_on_empty_block"), fx = Fn("automatic_uploads"), Vy = Fn("images_reuse_filename"), mx = Fn("images_replace_blob_uris"), Pw = Fn("icons"), cv = Fn("icons_url"), r_ = Fn("images_upload_url"), o_ = Fn("images_upload_base_path"), Dw = Fn("images_upload_credentials"), $w = Fn("images_upload_handler"), sh = Fn("content_css_cors"), Gr = Fn("referrer_policy"), Iw = Fn("language"), Cl = Fn("language_url"), h0 = Fn("indent_use_margin"), Fc = Fn("indentation"), bu = Fn("content_css"), g0 = Fn("content_style"), px = Fn("font_css"), s_ = Fn("directionality"), hx = Fn("inline_boundaries_selector"), Nb = Fn("object_resizing"), gx = Fn("resize_img_proportional"), Gk = Fn("placeholder"), ah = Fn("event_root"), a_ = Fn("service_message"), Rb = Fn("theme"), i_ = Fn("theme_url"), v0 = Fn("model"), Mw = Fn("model_url"), lv = Fn("inline_boundaries"), c_ = Fn("formats"), vx = Fn("preview_styles"), bx = Fn("format_empty_lines"), vm = Fn("format_noneditable_selector"), yx = Fn("custom_ui_selector"), Fw = Fn("inline"), l_ = Fn("hidden_input"), Sx = Fn("submit_patch"), ep = Fn("add_form_submit_trigger"), Pb = Fn("add_unload_trigger"), Db = Fn("custom_undo_redo_levels"), b0 = Fn("disable_nodechange"), Uy = Fn("readonly"), Gd = Fn("editable_root"), $b = Fn("content_css_cors"), Wy = Fn("plugins"), rg = Fn("external_plugins"), y0 = Fn("block_unsupported_drop"), u_ = Fn("visual"), d_ = Fn("visual_table_class"), wx = Fn("visual_anchor_class"), f_ = Fn("iframe_aria_text"), Lw = Fn("setup"), m_ = Fn("init_instance_callback"), p_ = Fn("urlconverter_callback"), Ex = Fn("auto_focus"), h_ = Fn("browser_spellcheck"), Cx = Fn("protect"), g_ = Fn("paste_block_drop"), S0 = Fn("paste_data_images"), v_ = Fn("paste_preprocess"), xx = Fn("paste_postprocess"), Ib = Fn("newdocument_content"), Bw = Fn("paste_webkit_styles"), Hw = Fn("paste_remove_styles_if_webkit"), zw = Fn("paste_merge_formats"), w0 = Fn("smart_paste"), E0 = Fn("paste_as_text"), Tx = Fn("paste_tab_spaces"), C0 = Fn("allow_html_data_urls"), x0 = Fn("text_patterns"), b_ = Fn("text_patterns_lookup"), jy = Fn("noneditable_class"), _x = Fn("editable_class"), y_ = Fn("noneditable_regexp"), Vw = Fn("preserve_cdata"), hd = Fn("highlight_on_focus"), og = Fn("xss_sanitization"), S_ = Fn("init_content_sync"), Uw = (e) => e.options.isSet("text_patterns_lookup"), w_ = (e) => rn.explode(e.options.get("font_size_style_values")), E_ = (e) => rn.explode(e.options.get("font_size_classes")), Ww = (e) => e.options.get("encoding") === "xml", Ox = (e) => rn.explode(e.options.get("images_file_types")), jw = Fn("table_tab_navigation"), Tc = Fn("details_initial_state"), Zk = Fn("details_serialized_state"), Mb = Fn("force_hex_color"), T0 = Fn("sandbox_iframes"), qw = Un, Gw = Qt, Ax = (e) => {
      const n = e.parentNode;
      n && n.removeChild(e);
    }, kx = (e) => {
      const n = de(e);
      return {
        count: e.length - n.length,
        text: n
      };
    }, ih = (e) => {
      let n;
      for (; (n = e.data.lastIndexOf(M)) !== -1; )
        e.deleteData(n, 1);
    }, uv = (e, n) => (Ki(e), n), C_ = (e, n) => {
      const s = kx(e.data.substr(0, n.offset())), l = kx(e.data.substr(n.offset()));
      return (s.text + l.text).length > 0 ? (ih(e), yt(e, n.offset() - s.count)) : n;
    }, x_ = (e, n) => {
      const s = n.container(), l = wo(Ps(s.childNodes), e).map((f) => f < n.offset() ? yt(s, n.offset() - 1) : n).getOr(n);
      return Ki(e), l;
    }, qy = (e, n) => Gw(e) && n.container() === e ? C_(e, n) : uv(e, n), Zw = (e, n) => n.container() === e.parentNode ? x_(e, n) : uv(e, n), Nx = (e, n) => yt.isTextPosition(n) ? qy(e, n) : Zw(e, n), Ki = (e) => {
      qw(e) && Xn(e) && (Pr(e) ? e.removeAttribute("data-mce-caret") : Ax(e)), Gw(e) && (ih(e), e.data.length === 0 && Ax(e));
    }, Rx = ro, Kw = Ts, Kk = $p, Fb = "*[contentEditable=false],video,audio,embed,object", T_ = (e, n, s) => {
      const l = th(n.getBoundingClientRect(), s);
      let f, b;
      if (e.tagName === "BODY") {
        const N = e.ownerDocument.documentElement;
        f = e.scrollLeft || N.scrollLeft, b = e.scrollTop || N.scrollTop;
      } else {
        const N = e.getBoundingClientRect();
        f = e.scrollLeft - N.left, b = e.scrollTop - N.top;
      }
      l.left += f, l.right += f, l.top += b, l.bottom += b, l.width = 1;
      let E = n.offsetWidth - n.clientWidth;
      return E > 0 && (s && (E *= -1), l.left += E, l.right += E), l;
    }, Px = (e) => {
      var n, s;
      const l = Vi(Fe.fromDom(e), Fb);
      for (let f = 0; f < l.length; f++) {
        const b = l[f].dom;
        let E = b.previousSibling;
        if (uu(E)) {
          const N = E.data;
          N.length === 1 ? (n = E.parentNode) === null || n === void 0 || n.removeChild(E) : E.deleteData(N.length - 1, 1);
        }
        E = b.nextSibling, Ic(E) && (E.data.length === 1 ? (s = E.parentNode) === null || s === void 0 || s.removeChild(E) : E.deleteData(0, 1));
      }
    }, Yw = (e, n, s, l) => {
      const f = Kh();
      let b, E;
      const N = al(e), D = e.dom, U = (xe, Pe) => {
        let Ke;
        if (J(), Kk(Pe))
          return null;
        if (s(Pe)) {
          const et = zl(N, Pe, xe), rt = T_(n, Pe, xe);
          D.setStyle(et, "top", rt.top), E = et;
          const dt = D.create("div", {
            class: "mce-visual-caret",
            "data-mce-bogus": "all"
          });
          D.setStyles(dt, { ...rt }), D.add(n, dt), f.set({
            caret: dt,
            element: Pe,
            before: xe
          }), xe && D.addClass(dt, "mce-visual-caret-before"), te(), Ke = Pe.ownerDocument.createRange(), Ke.setStart(et, 0), Ke.setEnd(et, 0);
        } else
          return E = la(Pe, xe), Ke = Pe.ownerDocument.createRange(), _0(E.nextSibling) ? (Ke.setStart(E, 0), Ke.setEnd(E, 0)) : (Ke.setStart(E, 1), Ke.setEnd(E, 1)), Ke;
        return Ke;
      }, J = () => {
        Px(n), E && (Ki(E), E = null), f.on((xe) => {
          D.remove(xe.caret), f.clear();
        }), b && (clearInterval(b), b = void 0);
      }, te = () => {
        b = setInterval(() => {
          f.on((xe) => {
            l() ? D.toggleClass(xe.caret, "mce-visual-caret-hidden") : D.addClass(xe.caret, "mce-visual-caret-hidden");
          });
        }, 500);
      };
      return {
        show: U,
        hide: J,
        getCss: () => ".mce-visual-caret {position: absolute;background-color: black;background-color: currentcolor;}.mce-visual-caret-hidden {display: none;}*[data-mce-caret] {position: absolute;left: -1000px;right: auto;top: 0;margin: 0;padding: 0;}",
        reposition: () => {
          f.on((xe) => {
            const Pe = T_(n, xe.element, xe.before);
            D.setStyles(xe.caret, { ...Pe });
          });
        },
        destroy: () => clearInterval(b)
      };
    }, Gy = () => kn.browser.isFirefox(), _0 = (e) => Rx(e) || Kw(e), Lb = (e) => (_0(e) || gf(e) && Gy()) && Xo(Fe.fromDom(e)).exists(Rr), __ = Dc, sg = ro, Dx = Ts, ag = om("display", "block table table-cell table-caption list-item"), ig = Xn, S = tn, T = Un, F = Qt, ee = oo, ge = (e) => e > 0, De = (e) => e < 0, Qe = (e, n) => {
      let s;
      for (; s = e(n); )
        if (!S(s))
          return s;
      return null;
    }, it = (e, n, s, l, f) => {
      const b = new xs(e, l), E = sg(e) || S(e);
      let N;
      if (De(n)) {
        if (E && (N = Qe(b.prev.bind(b), !0), s(N)))
          return N;
        for (; N = Qe(b.prev.bind(b), f); )
          if (s(N))
            return N;
      }
      if (ge(n)) {
        if (E && (N = Qe(b.next.bind(b), !0), s(N)))
          return N;
        for (; N = Qe(b.next.bind(b), f); )
          if (s(N))
            return N;
      }
      return null;
    }, At = (e, n) => {
      const s = (f) => __(f.dom), l = (f) => f.dom === n;
      return Ss(Fe.fromDom(e), s, l).map((f) => f.dom).getOr(n);
    }, vn = (e, n) => {
      for (; e && e !== n; ) {
        if (ag(e))
          return e;
        e = e.parentNode;
      }
      return null;
    }, gn = (e, n, s) => vn(e.container(), s) === vn(n.container(), s), Nn = (e, n) => {
      if (!n)
        return oe.none();
      const s = n.container(), l = n.offset();
      return T(s) ? oe.from(s.childNodes[l + e]) : oe.none();
    }, ir = (e, n) => {
      var s;
      const f = ((s = n.ownerDocument) !== null && s !== void 0 ? s : document).createRange();
      return e ? (f.setStartBefore(n), f.setEndBefore(n)) : (f.setStartAfter(n), f.setEndAfter(n)), f;
    }, Dr = (e, n, s) => vn(n, e) === vn(s, e), io = (e, n, s) => {
      const l = e ? "previousSibling" : "nextSibling";
      let f = s;
      for (; f && f !== n; ) {
        let b = f[l];
        if (b && ig(b) && (b = b[l]), sg(b) || Dx(b)) {
          if (Dr(n, b, f))
            return b;
          break;
        }
        if (ee(b))
          break;
        f = f.parentNode;
      }
      return null;
    }, Bo = Ne(ir, !0), eo = Ne(ir, !1), fs = (e, n, s) => {
      let l;
      const f = Ne(io, !0, n), b = Ne(io, !1, n), E = s.startContainer, N = s.startOffset;
      if (tn(E)) {
        const D = F(E) ? E.parentNode : E, U = D.getAttribute("data-mce-caret");
        if (U === "before" && (l = D.nextSibling, Lb(l)))
          return Bo(l);
        if (U === "after" && (l = D.previousSibling, Lb(l)))
          return eo(l);
      }
      if (!s.collapsed)
        return s;
      if (Qt(E)) {
        if (ig(E)) {
          if (e === 1) {
            if (l = b(E), l)
              return Bo(l);
            if (l = f(E), l)
              return eo(l);
          }
          if (e === -1) {
            if (l = f(E), l)
              return eo(l);
            if (l = b(E), l)
              return Bo(l);
          }
          return s;
        }
        if (uu(E) && N >= E.data.length - 1)
          return e === 1 && (l = b(E), l) ? Bo(l) : s;
        if (Ic(E) && N <= 1)
          return e === -1 && (l = f(E), l) ? eo(l) : s;
        if (N === E.data.length)
          return l = b(E), l ? Bo(l) : s;
        if (N === 0)
          return l = f(E), l ? eo(l) : s;
      }
      return s;
    }, As = (e, n) => Nn(e ? 0 : -1, n).filter(sg), Lc = (e, n, s) => {
      const l = fs(e, n, s);
      return e === -1 ? yt.fromRangeStart(l) : yt.fromRangeEnd(l);
    }, xl = (e) => oe.from(e.getNode()).map(Fe.fromDom), Zd = (e) => oe.from(e.getNode(!0)).map(Fe.fromDom), sc = (e, n) => {
      let s = n;
      for (; s = e(s); )
        if (s.isVisible())
          return s;
      return s;
    }, Kd = (e, n) => {
      const s = gn(e, n);
      return !s && Mo(e.getNode()) ? !0 : s;
    };
    var Ms;
    (function(e) {
      e[e.Backwards = -1] = "Backwards", e[e.Forwards = 1] = "Forwards";
    })(Ms || (Ms = {}));
    const O_ = ro, dv = Qt, Yk = Un, $x = Mo, Bb = oo, Wl = oa, O0 = fu, Qw = (e, n) => {
      const s = [];
      let l = e;
      for (; l && l !== n; )
        s.push(l), l = l.parentNode;
      return s;
    }, A0 = (e, n) => e.hasChildNodes() && n < e.childNodes.length ? e.childNodes[n] : null, A_ = (e, n) => {
      if (ge(e)) {
        if (Bb(n.previousSibling) && !dv(n.previousSibling))
          return yt.before(n);
        if (dv(n))
          return yt(n, 0);
      }
      if (De(e)) {
        if (Bb(n.nextSibling) && !dv(n.nextSibling))
          return yt.after(n);
        if (dv(n))
          return yt(n, n.data.length);
      }
      return De(e) ? $x(n) ? yt.before(n) : yt.after(n) : yt.before(n);
    }, k0 = (e, n) => {
      const s = n.nextSibling;
      return s && Bb(s) ? dv(s) ? yt(s, 0) : yt.before(s) : Zy(Ms.Forwards, yt.after(n), e);
    }, Zy = (e, n, s) => {
      let l, f, b, E;
      if (!Yk(s) || !n)
        return null;
      if (n.isEqual(yt.after(s)) && s.lastChild) {
        if (E = yt.after(s.lastChild), De(e) && Bb(s.lastChild) && Yk(s.lastChild))
          return $x(s.lastChild) ? yt.before(s.lastChild) : E;
      } else
        E = n;
      const N = E.container();
      let D = E.offset();
      if (dv(N)) {
        if (De(e) && D > 0)
          return yt(N, --D);
        if (ge(e) && D < N.length)
          return yt(N, ++D);
        l = N;
      } else {
        if (De(e) && D > 0 && (f = A0(N, D - 1), Bb(f)))
          return !Wl(f) && (b = it(f, e, O0, f), b) ? dv(b) ? yt(b, b.data.length) : yt.after(b) : dv(f) ? yt(f, f.data.length) : yt.before(f);
        if (ge(e) && D < N.childNodes.length && (f = A0(N, D), Bb(f)))
          return $x(f) ? k0(s, f) : !Wl(f) && (b = it(f, e, O0, f), b) ? dv(b) ? yt(b, 0) : yt.before(b) : dv(f) ? yt(f, 0) : yt.after(f);
        l = f || E.getNode();
      }
      if (l && (ge(e) && E.isAtEnd() || De(e) && E.isAtStart()) && (l = it(l, e, ut, s, !0), O0(l, s)))
        return A_(e, l);
      f = l && it(l, e, O0, s);
      const U = bc(ht(Qw(N, s), O_));
      return U && (!f || !U.contains(f)) ? (ge(e) ? E = yt.after(U) : E = yt.before(U), E) : f ? A_(e, f) : null;
    }, ch = (e) => ({
      next: (n) => Zy(Ms.Forwards, n, e),
      prev: (n) => Zy(Ms.Backwards, n, e)
    }), gI = (e, n, s) => {
      const l = e ? yt.before(s) : yt.after(s);
      return il(e, n, l);
    }, vI = (e) => Mo(e) ? yt.before(e) : yt.after(e), Hb = (e) => yt.isTextPosition(e) ? e.offset() === 0 : oo(e.getNode()), N0 = (e) => {
      if (yt.isTextPosition(e)) {
        const n = e.container();
        return e.offset() === n.data.length;
      } else
        return oo(e.getNode(!0));
    }, Ix = (e, n) => !yt.isTextPosition(e) && !yt.isTextPosition(n) && e.getNode() === n.getNode(!0), cg = (e) => !yt.isTextPosition(e) && Mo(e.getNode()), k_ = (e, n, s) => e ? !Ix(n, s) && !cg(n) && N0(n) && Hb(s) : !Ix(s, n) && Hb(n) && N0(s), il = (e, n, s) => {
      const l = ch(n);
      return oe.from(e ? l.next(s) : l.prev(s));
    }, fv = (e, n, s) => il(e, n, s).bind((l) => gn(s, l, n) && k_(e, s, l) ? il(e, n, l) : oe.some(l)), tp = (e, n, s, l) => fv(e, n, s).bind((f) => l(f) ? tp(e, n, f, l) : oe.some(f)), R0 = (e, n) => {
      const s = e ? n.firstChild : n.lastChild;
      return Qt(s) ? oe.some(yt(s, e ? 0 : s.data.length)) : s ? oo(s) ? oe.some(e ? yt.before(s) : vI(s)) : gI(e, n, s) : oe.none();
    }, yu = Ne(il, !0), gd = Ne(il, !1), Wu = Ne(R0, !0), np = Ne(R0, !1), Mx = "_mce_caret", Rf = (e) => Un(e) && e.id === Mx, Ky = (e, n) => {
      let s = n;
      for (; s && s !== e; ) {
        if (Rf(s))
          return s;
        s = s.parentNode;
      }
      return null;
    }, N_ = (e) => G(e.start), bI = (e) => lr(e, "rng"), Qk = (e) => lr(e, "id"), Xw = (e) => lr(e, "name"), Xk = (e) => rn.isArray(e.start), Jw = (e) => !Xw(e) && Te(e.forward) ? e.forward : !0, Fx = (e, n) => (Un(n) && e.isBlock(n) && !n.innerHTML && (n.innerHTML = '<br data-mce-bogus="1" />'), n), yI = (e, n) => {
      const s = oe.from(ji(e.getRoot(), n.start)), l = oe.from(ji(e.getRoot(), n.end));
      return bs(s, l, (f, b) => {
        const E = e.createRng();
        return E.setStart(f.container(), f.offset()), E.setEnd(b.container(), b.offset()), {
          range: E,
          forward: Jw(n)
        };
      });
    }, Jk = (e, n) => {
      var s;
      const f = ((s = e.ownerDocument) !== null && s !== void 0 ? s : document).createTextNode(M);
      e.appendChild(f), n.setStart(f, 0), n.setEnd(f, 0);
    }, SI = (e) => !e.hasChildNodes(), i5 = (e, n) => np(e).fold(He, (s) => (n.setStart(s.container(), s.offset()), n.setEnd(s.container(), s.offset()), !0)), eN = (e, n, s) => SI(n) && Ky(e, n) ? (Jk(n, s), !0) : !1, bo = (e, n, s, l) => {
      const f = s[n ? "start" : "end"], b = e.getRoot();
      if (f) {
        let E = b, N = f[0];
        for (let D = f.length - 1; E && D >= 1; D--) {
          const U = E.childNodes;
          if (eN(b, E, l))
            return !0;
          if (f[D] > U.length - 1)
            return eN(b, E, l) ? !0 : i5(E, l);
          E = U[f[D]];
        }
        Qt(E) && (N = Math.min(f[0], E.data.length)), Un(E) && (N = Math.min(f[0], E.childNodes.length)), n ? l.setStart(E, N) : l.setEnd(E, N);
      }
      return !0;
    }, lh = (e) => Qt(e) && e.data.length > 0, Yy = (e, n, s) => {
      const l = e.get(s.id + "_" + n), f = l == null ? void 0 : l.parentNode, b = s.keep;
      if (l && f) {
        let E, N;
        if (n === "start" ? b ? l.hasChildNodes() ? (E = l.firstChild, N = 1) : lh(l.nextSibling) ? (E = l.nextSibling, N = 0) : lh(l.previousSibling) ? (E = l.previousSibling, N = l.previousSibling.data.length) : (E = f, N = e.nodeIndex(l) + 1) : (E = f, N = e.nodeIndex(l)) : b ? l.hasChildNodes() ? (E = l.firstChild, N = 1) : lh(l.previousSibling) ? (E = l.previousSibling, N = l.previousSibling.data.length) : (E = f, N = e.nodeIndex(l)) : (E = f, N = e.nodeIndex(l)), !b) {
          const D = l.previousSibling, U = l.nextSibling;
          rn.each(rn.grep(l.childNodes), (te) => {
            Qt(te) && (te.data = te.data.replace(/\uFEFF/g, ""));
          });
          let J;
          for (; J = e.get(s.id + "_" + n); )
            e.remove(J, !0);
          if (Qt(U) && Qt(D) && !kn.browser.isOpera()) {
            const te = D.data.length;
            D.appendData(U.data), e.remove(U), E = D, N = te;
          }
        }
        return oe.some(yt(E, N));
      } else
        return oe.none();
    }, R_ = (e, n) => {
      const s = e.createRng();
      return bo(e, !0, n, s) && bo(e, !1, n, s) ? oe.some({
        range: s,
        forward: Jw(n)
      }) : oe.none();
    }, tN = (e, n) => {
      const s = Yy(e, "start", n), l = Yy(e, "end", n);
      return bs(s, l.or(s), (f, b) => {
        const E = e.createRng();
        return E.setStart(Fx(e, f.container()), f.offset()), E.setEnd(Fx(e, b.container()), b.offset()), {
          range: E,
          forward: Jw(n)
        };
      });
    }, eE = (e, n) => oe.from(e.select(n.name)[n.index]).map((s) => {
      const l = e.createRng();
      return l.selectNode(s), {
        range: l,
        forward: !0
      };
    }), wI = (e, n) => {
      const s = e.dom;
      if (n) {
        if (Xk(n))
          return R_(s, n);
        if (N_(n))
          return yI(s, n);
        if (Qk(n))
          return tN(s, n);
        if (Xw(n))
          return eE(s, n);
        if (bI(n))
          return oe.some({
            range: n.rng,
            forward: Jw(n)
          });
      }
      return oe.none();
    }, P0 = (e, n, s) => lx(e, n, s), Lx = (e, n) => {
      wI(e, n).each(({ range: s, forward: l }) => {
        e.setRng(s, l);
      });
    }, Pf = (e) => Un(e) && e.tagName === "SPAN" && e.getAttribute("data-mce-type") === "bookmark", Bx = ((e) => (n) => e === n)(xo), D0 = (e) => e !== "" && ` \f
\r	\v`.indexOf(e) !== -1, zb = (e) => !D0(e) && !Bx(e) && !ka(e), Hx = (e) => {
      const n = [];
      if (e)
        for (let s = 0; s < e.rangeCount; s++)
          n.push(e.getRangeAt(s));
      return n;
    }, zx = (e) => gr(e, (n) => {
      const s = Tb(n);
      return s ? [Fe.fromDom(s)] : [];
    }), Qy = (e) => Hx(e).length > 1, EI = (e) => ht(zx(e), vl), nN = (e) => Vi(e, "td[data-mce-selected],th[data-mce-selected]"), CI = (e, n) => {
      const s = nN(n);
      return s.length > 0 ? s : EI(e);
    }, $0 = (e) => CI(Hx(e.selection.getSel()), Fe.fromDom(e.getBody())), mv = (e, n) => su(e, "table", n), xI = (e) => {
      const n = e.startContainer, s = e.startOffset;
      return Qt(n) ? s === 0 ? oe.some(Fe.fromDom(n)) : oe.none() : oe.from(n.childNodes[s]).map(Fe.fromDom);
    }, TI = (e) => {
      const n = e.endContainer, s = e.endOffset;
      return Qt(n) ? s === n.data.length ? oe.some(Fe.fromDom(n)) : oe.none() : oe.from(n.childNodes[s - 1]).map(Fe.fromDom);
    }, rN = (e) => ys(e).fold(at([e]), (n) => [e].concat(rN(n))), P_ = (e) => ou(e).fold(at([e]), (n) => no(n) === "br" ? $a(n).map((s) => [e].concat(P_(s))).getOr([]) : [e].concat(P_(n))), D_ = (e, n) => bs(xI(n), TI(n), (s, l) => {
      const f = Bt(rN(e), Ne(Je, s)), b = Bt(P_(e), Ne(Je, l));
      return f.isSome() && b.isSome();
    }).getOr(!1), $_ = (e, n, s, l) => {
      const f = s, b = new xs(s, f), E = es(e.schema.getMoveCaretBeforeOnEnterElements(), (D, U) => !Ge([
        "td",
        "th",
        "table"
      ], U.toLowerCase()));
      let N = s;
      do {
        if (Qt(N) && rn.trim(N.data).length !== 0) {
          l ? n.setStart(N, 0) : n.setEnd(N, N.data.length);
          return;
        }
        if (E[N.nodeName]) {
          l ? n.setStartBefore(N) : N.nodeName === "BR" ? n.setEndBefore(N) : n.setEndAfter(N);
          return;
        }
      } while (N = l ? b.next() : b.prev());
      f.nodeName === "BODY" && (l ? n.setStart(f, 0) : n.setEnd(f, f.childNodes.length));
    }, Vx = (e) => {
      const n = e.selection.getSel();
      return Ie(n) && n.rangeCount > 0;
    }, Vb = (e, n) => {
      const s = $0(e);
      s.length > 0 ? ke(s, (l) => {
        const f = l.dom, b = e.dom.createRng();
        b.setStartBefore(f), b.setEndAfter(f), n(b, !0);
      }) : n(e.selection.getRng(), !1);
    }, oN = (e, n, s) => {
      const l = Qm(e, n);
      s(l), e.moveToBookmark(l);
    }, tE = (e) => pt(e == null ? void 0 : e.nodeType), I_ = (e) => Un(e) && !Pf(e) && !Rf(e) && !ad(e), _I = (e, n) => {
      if (I_(n) && !/^(TD|TH)$/.test(n.nodeName)) {
        const s = e.getAttrib(n, "data-mce-selected"), l = parseInt(s, 10);
        return !isNaN(l) && l > 0;
      } else
        return !1;
    }, nE = (e, n, s) => {
      const { selection: l, dom: f } = e, b = l.getNode(), E = ro(b);
      oN(l, !0, () => {
        n();
      }), E && ro(b) && f.isChildOf(b, e.getBody()) ? e.selection.select(b) : s(l.getStart()) && OI(f, l);
    }, OI = (e, n) => {
      var s, l;
      const f = n.getRng(), { startContainer: b, startOffset: E } = f, N = n.getNode();
      if (!_I(e, N) && Un(b)) {
        const D = b.childNodes, U = e.getRoot();
        let J;
        if (E < D.length) {
          const te = D[E];
          J = new xs(te, (s = e.getParent(te, e.isBlock)) !== null && s !== void 0 ? s : U);
        } else {
          const te = D[D.length - 1];
          J = new xs(te, (l = e.getParent(te, e.isBlock)) !== null && l !== void 0 ? l : U), J.next(!0);
        }
        for (let te = J.current(); te; te = J.next()) {
          if (e.getContentEditable(te) === "false")
            return;
          if (Qt(te) && !_i(te)) {
            f.setStart(te, 0), n.setRng(f);
            return;
          }
        }
      }
    }, Pn = (e, n, s) => {
      if (e) {
        const l = n ? "nextSibling" : "previousSibling";
        for (e = s ? e : e[l]; e; e = e[l])
          if (Un(e) || !_i(e))
            return e;
      }
    }, ac = (e, n) => !!e.getTextBlockElements()[n.nodeName.toLowerCase()] || Jr(e, n), pv = (e, n, s) => e.schema.isValidChild(n, s), _i = (e, n = !1) => {
      if (Ie(e) && Qt(e)) {
        const s = n ? e.data.replace(/ /g, "") : e.data;
        return Bp(s);
      } else
        return !1;
    }, bm = (e) => Ie(e) && Qt(e) && e.length === 0, Ux = (e, n) => {
      const s = "[data-mce-cef-wrappable]", l = vm(e), f = ei(l) ? s : `${s},${l}`;
      return Bl(Fe.fromDom(n), f);
    }, rE = (e, n) => {
      const s = e.dom;
      return I_(n) && s.getContentEditable(n) === "false" && Ux(e, n) && s.select('[contenteditable="true"]', n).length === 0;
    }, uh = (e, n) => Ce(e) ? e(n) : (Ie(n) && (e = e.replace(/%(\w+)/g, (s, l) => n[l] || s)), e), Wx = (e, n) => (e = e || "", n = n || "", e = "" + (e.nodeName || e), n = "" + (n.nodeName || n), e.toLowerCase() === n.toLowerCase()), jx = (e, n) => {
      if (je(e))
        return null;
      {
        let s = String(e);
        return (n === "color" || n === "backgroundColor") && (s = Bu(s)), n === "fontWeight" && e === 700 && (s = "bold"), n === "fontFamily" && (s = s.replace(/[\'\"]/g, "").replace(/,\s+/g, ",")), s;
      }
    }, I0 = (e, n, s) => {
      const l = e.getStyle(n, s);
      return jx(l, s);
    }, sN = (e, n) => {
      let s;
      return e.getParent(n, (l) => Un(l) ? (s = e.getStyle(l, "text-decoration"), !!s && s !== "none") : !1), s;
    }, oE = (e, n, s) => e.getParents(n, s, e.getRoot()), M_ = (e, n, s) => {
      const l = e.formatter.get(n);
      return Ie(l) && qt(l, s);
    }, F_ = (e, n) => M_(e, n, (l) => {
      const f = (b) => Ce(b) || b.length > 1 && b.charAt(0) === "%";
      return qt([
        "styles",
        "attributes"
      ], (b) => gs(l, b).exists((E) => {
        const N = be(E) ? E : Xl(E);
        return qt(N, f);
      }));
    }), AI = (e, n, s) => {
      const l = [
        "inline",
        "block",
        "selector",
        "attributes",
        "styles",
        "classes"
      ], f = (b) => es(b, (E, N) => qt(l, (D) => D === N));
      return M_(e, n, (b) => {
        const E = f(b);
        return M_(e, s, (N) => {
          const D = f(N);
          return Jl(E, D);
        });
      });
    }, dh = (e) => Ei(e, "block"), qx = (e) => dh(e) && e.wrapper === !0, M0 = (e) => dh(e) && e.wrapper !== !0, Tl = (e) => Ei(e, "selector"), Yi = (e) => Ei(e, "inline"), Gx = (e) => Tl(e) && Yi(e) && na(gs(e, "mixed"), !0), sE = (e) => Tl(e) && e.expand !== !1 && !Yi(e), Zx = (e) => {
      const n = [];
      let s = e;
      for (; s; ) {
        if (Qt(s) && s.data !== M || s.childNodes.length > 1)
          return [];
        Un(s) && n.push(s), s = s.firstChild;
      }
      return n;
    }, aE = (e) => Zx(e).length > 0, iE = (e) => Rf(e.dom) && aE(e.dom), F0 = Pf, aN = oE, cE = _i, iN = ac, cN = (e) => Mo(e) && e.getAttribute("data-mce-bogus") && !e.nextSibling, lN = (e, n) => {
      let s = n;
      for (; s; ) {
        if (Un(s) && e.getContentEditable(s))
          return e.getContentEditable(s) === "false" ? s : n;
        s = s.parentNode;
      }
      return n;
    }, ym = (e, n, s, l) => {
      const f = n.data;
      if (e) {
        for (let b = s; b > 0; b--)
          if (l(f.charAt(b - 1)))
            return b;
      } else
        for (let b = s; b < f.length; b++)
          if (l(f.charAt(b)))
            return b;
      return -1;
    }, jl = (e, n, s) => ym(e, n, s, (l) => Bx(l) || D0(l)), rp = (e, n, s) => ym(e, n, s, zb), vd = (e, n, s, l, f, b) => {
      let E;
      const N = e.getParent(s, e.isBlock) || n, D = (J, te, ce) => {
        const Oe = Qh(e), Re = f ? Oe.backwards : Oe.forwards;
        return oe.from(Re(J, te, (xe, Pe) => F0(xe.parentNode) ? -1 : (E = xe, ce(f, xe, Pe)), N));
      };
      return D(s, l, jl).bind((J) => b ? D(J.container, J.offset + (f ? -1 : 0), rp) : oe.some(J)).orThunk(() => E ? oe.some({
        container: E,
        offset: f ? 0 : E.length
      }) : oe.none());
    }, lE = (e, n, s, l, f) => {
      const b = l[f];
      Qt(l) && ei(l.data) && b && (l = b);
      const E = aN(e, l);
      for (let N = 0; N < E.length; N++)
        for (let D = 0; D < n.length; D++) {
          const U = n[D];
          if (!(Ie(U.collapsed) && U.collapsed !== s.collapsed) && Tl(U) && e.is(E[N], U.selector))
            return E[N];
        }
      return l;
    }, Kx = (e, n, s, l) => {
      var f;
      let b = s;
      const E = e.getRoot(), N = n[0];
      if (dh(N) && (b = N.wrapper ? null : e.getParent(s, N.block, E)), !b) {
        const D = (f = e.getParent(s, "LI,TD,TH,SUMMARY")) !== null && f !== void 0 ? f : E;
        b = e.getParent(Qt(s) ? s.parentNode : s, (U) => U !== E && iN(e.schema, U), D);
      }
      if (b && dh(N) && N.wrapper && (b = aN(e, b, "ul,ol").reverse()[0] || b), !b)
        for (b = s; b && b[l] && !e.isBlock(b[l]) && (b = b[l], !Wx(b, "br")); )
          ;
      return b || s;
    }, uN = (e, n, s, l) => {
      const f = s.parentNode;
      return Ie(s[l]) ? !1 : f === n || je(f) || e.isBlock(f) ? !0 : uN(e, n, f, l);
    }, uE = (e, n, s, l, f) => {
      let b = s;
      const E = f ? "previousSibling" : "nextSibling", N = e.getRoot();
      if (Qt(s) && !cE(s) && (f ? l > 0 : l < s.data.length))
        return s;
      for (; b; ) {
        if (!n[0].block_expand && e.isBlock(b))
          return b;
        for (let D = b[E]; D; D = D[E]) {
          const U = Qt(D) && !uN(e, N, D, E);
          if (!F0(D) && !cN(D) && !cE(D, U))
            return b;
        }
        if (b === N || b.parentNode === N) {
          s = b;
          break;
        }
        b = b.parentNode;
      }
      return s;
    }, kI = (e) => F0(e.parentNode) || F0(e), hv = (e, n, s, l = !1) => {
      let { startContainer: f, startOffset: b, endContainer: E, endOffset: N } = n;
      const D = s[0];
      return Un(f) && f.hasChildNodes() && (f = Vu(f, b), Qt(f) && (b = 0)), Un(E) && E.hasChildNodes() && (E = Vu(E, n.collapsed ? N : N - 1), Qt(E) && (N = E.data.length)), f = lN(e, f), E = lN(e, E), kI(f) && (f = F0(f) ? f : f.parentNode, n.collapsed ? f = f.previousSibling || f : f = f.nextSibling || f, Qt(f) && (b = n.collapsed ? f.length : 0)), kI(E) && (E = F0(E) ? E : E.parentNode, n.collapsed ? E = E.nextSibling || E : E = E.previousSibling || E, Qt(E) && (N = n.collapsed ? 0 : E.length)), n.collapsed && (vd(e, e.getRoot(), f, b, !0, l).each(({ container: te, offset: ce }) => {
        f = te, b = ce;
      }), vd(e, e.getRoot(), E, N, !1, l).each(({ container: te, offset: ce }) => {
        E = te, N = ce;
      })), (Yi(D) || D.block_expand) && ((!Yi(D) || !Qt(f) || b === 0) && (f = uE(e, s, f, b, !0)), (!Yi(D) || !Qt(E) || N === E.data.length) && (E = uE(e, s, E, N, !1))), sE(D) && (f = lE(e, s, n, f, "previousSibling"), E = lE(e, s, n, E, "nextSibling")), (dh(D) || Tl(D)) && (f = Kx(e, s, f, "previousSibling"), E = Kx(e, s, E, "nextSibling"), dh(D) && (e.isBlock(f) || (f = uE(e, s, f, b, !0)), e.isBlock(E) || (E = uE(e, s, E, N, !1)))), Un(f) && f.parentNode && (b = e.nodeIndex(f), f = f.parentNode), Un(E) && E.parentNode && (N = e.nodeIndex(E) + 1, E = E.parentNode), {
        startContainer: f,
        startOffset: b,
        endContainer: E,
        endOffset: N
      };
    }, dE = (e, n, s) => {
      var l;
      const f = n.startOffset, b = Vu(n.startContainer, f), E = n.endOffset, N = Vu(n.endContainer, E - 1), D = (Pe) => {
        const Ke = Pe[0];
        Qt(Ke) && Ke === b && f >= Ke.data.length && Pe.splice(0, 1);
        const et = Pe[Pe.length - 1];
        return E === 0 && Pe.length > 0 && et === N && Qt(et) && Pe.splice(Pe.length - 1, 1), Pe;
      }, U = (Pe, Ke, et) => {
        const rt = [];
        for (; Pe && Pe !== et; Pe = Pe[Ke])
          rt.push(Pe);
        return rt;
      }, J = (Pe, Ke) => e.getParent(Pe, (et) => et.parentNode === Ke, Ke), te = (Pe, Ke, et) => {
        const rt = et ? "nextSibling" : "previousSibling";
        for (let dt = Pe, Ht = dt.parentNode; dt && dt !== Ke; dt = Ht) {
          Ht = dt.parentNode;
          const ln = U(dt === Pe ? dt : dt[rt], rt);
          ln.length && (et || ln.reverse(), s(D(ln)));
        }
      };
      if (b === N)
        return s(D([b]));
      const ce = (l = e.findCommonAncestor(b, N)) !== null && l !== void 0 ? l : e.getRoot();
      if (e.isChildOf(b, N))
        return te(b, ce, !0);
      if (e.isChildOf(N, b))
        return te(N, ce);
      const Oe = J(b, ce) || b, Re = J(N, ce) || N;
      te(b, Oe, !0);
      const xe = U(Oe === b ? Oe : Oe.nextSibling, "nextSibling", Re === N ? Re.nextSibling : Re);
      xe.length && s(D(xe)), te(N, Re);
    }, L_ = [
      'pre[class*=language-][contenteditable="false"]',
      "figure.image",
      "div[data-ephox-embed-iri]",
      "div.tiny-pageembed",
      "div.mce-toc",
      "div[data-mce-toc]"
    ], dN = (e) => hi(e) && lu(e) === M, fN = (e, n, s, l) => Qo(n).fold(() => "skipping", (f) => l === "br" || dN(n) ? "valid" : tx(n) ? "existing" : Rf(n.dom) ? "caret" : qt(L_, (b) => Bl(n, b)) ? "valid-block" : !pv(e, s, l) || !pv(e, no(f), s) ? "invalid-child" : "valid"), B_ = (e, n) => {
      const s = hv(e.dom, n, [{ inline: "span" }]);
      n.setStart(s.startContainer, s.startOffset), n.setEnd(s.endContainer, s.endOffset), e.selection.setRng(n);
    }, Yx = (e, n, s, l, f, b) => {
      const { uid: E = n, ...N } = s;
      nd(e, r0()), is(e, `${Eb()}`, E), is(e, `${Km()}`, l);
      const { attributes: D = {}, classes: U = [] } = f(E, N);
      if (ru(e, D), W2(e, U), b) {
        U.length > 0 && is(e, `${Jg()}`, U.join(","));
        const J = Co(D);
        J.length > 0 && is(e, `${ev()}`, J.join(","));
      }
    }, Fs = (e) => {
      wc(e, r0()), Vs(e, `${Eb()}`), Vs(e, `${Km()}`), Vs(e, `${Yh()}`);
      const n = ri(e, `${ev()}`).map((l) => l.split(",")).getOr([]), s = ri(e, `${Jg()}`).map((l) => l.split(",")).getOr([]);
      ke(n, (l) => Vs(e, l)), ox(e, s), Vs(e, `${Jg()}`), Vs(e, `${ev()}`);
    }, gv = (e, n, s, l, f) => {
      const b = Fe.fromTag("span", e);
      return Yx(b, n, s, l, f, !1), b;
    }, mN = (e, n, s, l, f, b) => {
      const E = [], N = gv(e.getDoc(), s, b, l, f), D = Kh(), U = () => {
        D.clear();
      }, J = () => D.get().getOrThunk(() => {
        const Re = zu(N);
        return E.push(Re), D.set(Re), Re;
      }), te = (Re) => {
        ke(Re, ce);
      }, ce = (Re) => {
        switch (fN(e, Re, "span", no(Re))) {
          case "invalid-child": {
            U();
            const Pe = ga(Re);
            te(Pe), U();
            break;
          }
          case "valid-block": {
            U(), Yx(Re, s, b, l, f, !0);
            break;
          }
          case "valid": {
            const Pe = J();
            zg(Re, Pe);
            break;
          }
        }
      }, Oe = (Re) => {
        const xe = St(Re, Fe.fromDom);
        te(xe);
      };
      return dE(e.dom, n, (Re) => {
        U(), Oe(Re);
      }), E;
    }, H_ = (e, n, s, l) => {
      e.undoManager.transact(() => {
        const f = e.selection, b = f.getRng(), E = $0(e).length > 0, N = nv("mce-annotation");
        if (b.collapsed && !E && B_(e, b), f.getRng().collapsed && !E) {
          const D = gv(e.getDoc(), N, l, n, s.decorate);
          cu(D, xo), f.getRng().insertNode(D.dom), f.select(D.dom);
        } else
          oN(f, !1, () => {
            Vb(e, (D) => {
              mN(e, D, N, n, s.decorate, l);
            });
          });
      });
    }, z_ = (e) => {
      const n = rx();
      Hu(e, n);
      const s = sl(e, n), l = Fl("span"), f = (b) => {
        ke(b, (E) => {
          l(E) ? zi(E) : Fs(E);
        });
      };
      return {
        register: (b, E) => {
          n.register(b, E);
        },
        annotate: (b, E) => {
          n.lookup(b).each((N) => {
            H_(e, b, N, E);
          });
        },
        annotationChanged: (b, E) => {
          s.addListener(b, E);
        },
        remove: (b) => {
          Ma(e, oe.some(b)).each(({ elements: E }) => {
            const N = e.selection.getBookmark();
            f(E), e.selection.moveToBookmark(N);
          });
        },
        removeAll: (b) => {
          const E = e.selection.getBookmark();
          fn(o0(e, b), (N, D) => {
            f(N);
          }), e.selection.moveToBookmark(E);
        },
        getAll: (b) => {
          const E = o0(e, b);
          return Yr(E, (N) => St(N, (D) => D.dom));
        }
      };
    }, Xy = (e) => ({
      getBookmark: Ne(P0, e),
      moveToBookmark: Ne(Lx, e)
    });
    Xy.isBookmarkNode = Pf;
    const V_ = (e, n, s) => s.collapsed ? !1 : qt(s.getClientRects(), (l) => vw(l, e, n)), U_ = (e, n) => e.dispatch("PreProcess", n), NI = (e, n) => e.dispatch("PostProcess", n), L0 = (e) => {
      e.dispatch("remove");
    }, B0 = (e) => {
      e.dispatch("detach");
    }, W_ = (e, n) => {
      e.dispatch("SwitchMode", { mode: n });
    }, j_ = (e, n, s, l, f) => {
      e.dispatch("ObjectResizeStart", {
        target: n,
        width: s,
        height: l,
        origin: f
      });
    }, op = (e, n, s, l, f) => {
      e.dispatch("ObjectResized", {
        target: n,
        width: s,
        height: l,
        origin: f
      });
    }, Ub = (e) => {
      e.dispatch("PreInit");
    }, RI = (e) => {
      e.dispatch("PostRender");
    }, fE = (e) => {
      e.dispatch("Init");
    }, PI = (e, n) => {
      e.dispatch("PlaceholderToggle", { state: n });
    }, Yd = (e, n, s) => {
      e.dispatch(n, s);
    }, ql = (e, n, s, l) => {
      e.dispatch("FormatApply", {
        format: n,
        node: s,
        vars: l
      });
    }, Jy = (e, n, s, l) => {
      e.dispatch("FormatRemove", {
        format: n,
        node: s,
        vars: l
      });
    }, c5 = (e, n) => e.dispatch("BeforeSetContent", n), pN = (e, n) => e.dispatch("SetContent", n), DI = (e, n) => e.dispatch("BeforeGetContent", n), ho = (e, n) => e.dispatch("GetContent", n), q_ = (e, n) => {
      e.dispatch("AutocompleterStart", n);
    }, hN = (e, n) => {
      e.dispatch("AutocompleterUpdate", n);
    }, G_ = (e) => {
      e.dispatch("AutocompleterEnd");
    }, $I = (e, n, s) => e.dispatch("PastePreProcess", {
      content: n,
      internal: s
    }), II = (e, n, s) => e.dispatch("PastePostProcess", {
      node: n,
      internal: s
    }), gN = (e, n) => e.dispatch("PastePlainTextToggle", { state: n }), MI = (e, n) => e.dispatch("EditableRootStateChange", { state: n }), zn = {
      BACKSPACE: 8,
      DELETE: 46,
      DOWN: 40,
      ENTER: 13,
      ESC: 27,
      LEFT: 37,
      RIGHT: 39,
      SPACEBAR: 32,
      TAB: 9,
      UP: 38,
      PAGE_UP: 33,
      PAGE_DOWN: 34,
      END: 35,
      HOME: 36,
      modifierPressed: (e) => e.shiftKey || e.ctrlKey || e.altKey || zn.metaKeyPressed(e),
      metaKeyPressed: (e) => kn.os.isMacOS() || kn.os.isiOS() ? e.metaKey : e.ctrlKey && !e.altKey
    }, Wb = "data-mce-selected", vN = "table,img,figure.image,hr,video,span.mce-preview-object,details", mE = Math.abs, pE = Math.round, FI = {
      nw: [
        0,
        0,
        -1,
        -1
      ],
      ne: [
        1,
        0,
        1,
        -1
      ],
      se: [
        1,
        1,
        1,
        1
      ],
      sw: [
        0,
        1,
        -1,
        1
      ]
    }, l5 = (e) => e.type === "longpress" || e.type.indexOf("touch") === 0, u5 = (e, n) => {
      const s = n.dom, l = n.getDoc(), f = document, b = n.getBody();
      let E, N, D, U, J, te, ce, Oe, Re, xe, Pe, Ke, et, rt, dt, Ht, ln;
      const Dn = (pn) => Ie(pn) && (ya(pn) || s.is(pn, "figure.image")), Rt = (pn) => Ts(pn) || s.hasClass(pn, "mce-preview-object"), Tt = (pn, kr) => {
        if (l5(pn)) {
          const To = pn.touches[0];
          return Dn(pn.target) && !V_(To.clientX, To.clientY, kr);
        } else
          return Dn(pn.target) && !V_(pn.clientX, pn.clientY, kr);
      }, Kt = (pn) => {
        const kr = pn.target;
        Tt(pn, n.selection.getRng()) && !pn.isDefaultPrevented() && n.selection.select(kr);
      }, Mn = (pn) => s.hasClass(pn, "mce-preview-object") && Ie(pn.firstElementChild) ? [
        pn,
        pn.firstElementChild
      ] : s.is(pn, "figure.image") ? [pn.querySelector("img")] : [pn], rr = (pn) => {
        const kr = Nb(n);
        return !kr || pn.getAttribute("data-mce-resize") === "false" || pn === n.getBody() ? !1 : s.hasClass(pn, "mce-preview-object") && Ie(pn.firstElementChild) ? Bl(Fe.fromDom(pn.firstElementChild), kr) : Bl(Fe.fromDom(pn), kr);
      }, Fr = (pn) => Rt(pn) ? s.create("img", { src: kn.transparentSrc }) : pn.cloneNode(!0), so = (pn, kr, To) => {
        if (Ie(To)) {
          const Ns = Mn(pn);
          ke(Ns, (Js) => {
            Js.style[kr] || !n.schema.isValid(Js.nodeName.toLowerCase(), kr) ? s.setStyle(Js, kr, To) : s.setAttrib(Js, kr, "" + To);
          });
        }
      }, Cs = (pn, kr, To) => {
        so(pn, "width", kr), so(pn, "height", To);
      }, Xs = (pn) => {
        let kr, To, Ns, Js, Cd;
        kr = pn.screenX - te, To = pn.screenY - ce, rt = kr * U[2] + xe, dt = To * U[3] + Pe, rt = rt < 5 ? 5 : rt, dt = dt < 5 ? 5 : dt, (Dn(E) || Rt(E)) && gx(n) !== !1 ? Ns = !zn.modifierPressed(pn) : Ns = zn.modifierPressed(pn), Ns && (mE(kr) > mE(To) ? (dt = pE(rt * Ke), rt = pE(dt / Ke)) : (rt = pE(dt / Ke), dt = pE(rt * Ke))), Cs(N, rt, dt), Js = U.startPos.x + kr, Cd = U.startPos.y + To, Js = Js > 0 ? Js : 0, Cd = Cd > 0 ? Cd : 0, s.setStyles(D, {
          left: Js,
          top: Cd,
          display: "block"
        }), D.innerHTML = rt + " &times; " + dt, U[2] < 0 && N.clientWidth <= rt && s.setStyle(N, "left", Oe + (xe - rt)), U[3] < 0 && N.clientHeight <= dt && s.setStyle(N, "top", Re + (Pe - dt)), kr = b.scrollWidth - Ht, To = b.scrollHeight - ln, kr + To !== 0 && s.setStyles(D, {
          left: Js - kr,
          top: Cd - To
        }), et || (j_(n, E, xe, Pe, "corner-" + U.name), et = !0);
      }, Si = () => {
        const pn = et;
        et = !1, pn && (so(E, "width", rt), so(E, "height", dt)), s.unbind(l, "mousemove", Xs), s.unbind(l, "mouseup", Si), f !== l && (s.unbind(f, "mousemove", Xs), s.unbind(f, "mouseup", Si)), s.remove(N), s.remove(D), s.remove(J), Kl(E), pn && (op(n, E, rt, dt, "corner-" + U.name), s.setAttrib(E, "style", s.getAttrib(E, "style"))), n.nodeChanged();
      }, Kl = (pn) => {
        Ao();
        const kr = s.getPos(pn, b), To = kr.x, Ns = kr.y, Js = pn.getBoundingClientRect(), Cd = Js.width || Js.right - Js.left, xm = Js.height || Js.bottom - Js.top;
        E !== pn && (wn(), E = pn, rt = dt = 0);
        const ry = n.dispatch("ObjectSelected", { target: pn });
        rr(pn) && !ry.isDefaultPrevented() ? fn(FI, (xd, wg) => {
          const Ir = (Jo) => {
            const Ba = Mn(E)[0];
            te = Jo.screenX, ce = Jo.screenY, xe = Ba.clientWidth, Pe = Ba.clientHeight, Ke = Pe / xe, U = xd, U.name = wg, U.startPos = {
              x: Cd * xd[0] + To,
              y: xm * xd[1] + Ns
            }, Ht = b.scrollWidth, ln = b.scrollHeight, J = s.add(b, "div", {
              class: "mce-resize-backdrop",
              "data-mce-bogus": "all"
            }), s.setStyles(J, {
              position: "fixed",
              left: "0",
              top: "0",
              width: "100%",
              height: "100%"
            }), N = Fr(E), s.addClass(N, "mce-clonedresizable"), s.setAttrib(N, "data-mce-bogus", "all"), N.contentEditable = "false", s.setStyles(N, {
              left: To,
              top: Ns,
              margin: 0
            }), Cs(N, Cd, xm), N.removeAttribute(Wb), b.appendChild(N), s.bind(l, "mousemove", Xs), s.bind(l, "mouseup", Si), f !== l && (s.bind(f, "mousemove", Xs), s.bind(f, "mouseup", Si)), D = s.add(b, "div", {
              class: "mce-resize-helper",
              "data-mce-bogus": "all"
            }, xe + " &times; " + Pe);
          };
          let _o = s.get("mceResizeHandle" + wg);
          _o && s.remove(_o), _o = s.add(b, "div", {
            id: "mceResizeHandle" + wg,
            "data-mce-bogus": "all",
            class: "mce-resizehandle",
            unselectable: !0,
            style: "cursor:" + wg + "-resize; margin:0; padding:0"
          }), s.bind(_o, "mousedown", (Jo) => {
            Jo.stopImmediatePropagation(), Jo.preventDefault(), Ir(Jo);
          }), xd.elm = _o, s.setStyles(_o, {
            left: Cd * xd[0] + To - _o.offsetWidth / 2,
            top: xm * xd[1] + Ns - _o.offsetHeight / 2
          });
        }) : wn(!1);
      }, ll = Py(Kl, 0), wn = (pn = !0) => {
        ll.cancel(), Ao(), E && pn && E.removeAttribute(Wb), fn(FI, (kr, To) => {
          const Ns = s.get("mceResizeHandle" + To);
          Ns && (s.unbind(Ns), s.remove(Ns));
        });
      }, Ln = (pn, kr) => s.isChildOf(pn, kr), Ho = (pn) => {
        if (et || n.removed || n.composing)
          return;
        const kr = pn.type === "mousedown" ? pn.target : e.getNode(), To = au(Fe.fromDom(kr), vN).map((Js) => Js.dom).filter((Js) => s.isEditable(Js.parentElement) || Js.nodeName === "IMG" && s.isEditable(Js)).getOrUndefined(), Ns = Ie(To) ? s.getAttrib(To, Wb, "1") : "1";
        if (ke(s.select(`img[${Wb}],hr[${Wb}]`), (Js) => {
          Js.removeAttribute(Wb);
        }), Ie(To) && Ln(To, b) && n.hasFocus()) {
          Qn();
          const Js = e.getStart(!0);
          if (Ln(Js, To) && Ln(e.getEnd(!0), To)) {
            s.setAttrib(To, Wb, Ns), ll.throttle(To);
            return;
          }
        }
        wn();
      }, Ao = () => {
        fn(FI, (pn) => {
          pn.elm && (s.unbind(pn.elm), delete pn.elm);
        });
      }, Qn = () => {
        try {
          n.getDoc().execCommand("enableObjectResizing", !1, "false");
        } catch {
        }
      };
      return n.on("init", () => {
        Qn(), n.on("NodeChange ResizeEditor ResizeWindow ResizeContent drop", Ho), n.on("keyup compositionend", (pn) => {
          E && E.nodeName === "TABLE" && Ho(pn);
        }), n.on("hide blur", wn), n.on("contextmenu longpress", Kt, !0);
      }), n.on("remove", Ao), {
        isResizable: rr,
        showResizeRect: Kl,
        hideResizeRect: wn,
        updateResizeRect: Ho,
        destroy: () => {
          ll.cancel(), E = N = J = null;
        }
      };
    }, Eq = (e, n) => {
      n.fold((s) => {
        e.setStartBefore(s.dom);
      }, (s, l) => {
        e.setStart(s.dom, l);
      }, (s) => {
        e.setStartAfter(s.dom);
      });
    }, LI = (e, n) => {
      n.fold((s) => {
        e.setEndBefore(s.dom);
      }, (s, l) => {
        e.setEnd(s.dom, l);
      }, (s) => {
        e.setEndAfter(s.dom);
      });
    }, bN = (e, n, s) => {
      const l = e.document.createRange();
      return Eq(l, n), LI(l, s), l;
    }, yr = (e, n, s, l, f) => {
      const b = e.document.createRange();
      return b.setStart(n.dom, s), b.setEnd(l.dom, f), b;
    }, vv = hm.generate([
      {
        ltr: [
          "start",
          "soffset",
          "finish",
          "foffset"
        ]
      },
      {
        rtl: [
          "start",
          "soffset",
          "finish",
          "foffset"
        ]
      }
    ]), yN = (e, n, s) => n(Fe.fromDom(s.startContainer), s.startOffset, Fe.fromDom(s.endContainer), s.endOffset), BI = (e, n) => n.match({
      domRange: (s) => ({
        ltr: at(s),
        rtl: oe.none
      }),
      relative: (s, l) => ({
        ltr: Qu(() => bN(e, s, l)),
        rtl: Qu(() => oe.some(bN(e, l, s)))
      }),
      exact: (s, l, f, b) => ({
        ltr: Qu(() => yr(e, s, l, f, b)),
        rtl: Qu(() => oe.some(yr(e, f, b, s, l)))
      })
    }), hE = (e, n) => {
      const s = n.ltr();
      return s.collapsed ? n.rtl().filter((f) => f.collapsed === !1).map((f) => vv.rtl(Fe.fromDom(f.endContainer), f.endOffset, Fe.fromDom(f.startContainer), f.startOffset)).getOrThunk(() => yN(e, vv.ltr, s)) : yN(e, vv.ltr, s);
    }, HI = (e, n) => {
      const s = BI(e, n);
      return hE(e, s);
    };
    vv.ltr, vv.rtl;
    const Z_ = { create: (e, n, s, l) => ({
      start: e,
      soffset: n,
      finish: s,
      foffset: l
    }) }, wN = (e, n, s) => {
      var l, f;
      return oe.from((f = (l = e.dom).caretPositionFromPoint) === null || f === void 0 ? void 0 : f.call(l, n, s)).bind((b) => {
        if (b.offsetNode === null)
          return oe.none();
        const E = e.dom.createRange();
        return E.setStart(b.offsetNode, b.offset), E.collapse(), oe.some(E);
      });
    }, Qx = (e, n, s) => {
      var l, f;
      return oe.from((f = (l = e.dom).caretRangeFromPoint) === null || f === void 0 ? void 0 : f.call(l, n, s));
    }, zI = (() => document.caretPositionFromPoint ? wN : document.caretRangeFromPoint ? Qx : oe.none)(), VI = (e, n, s) => {
      const l = Fe.fromDom(e.document);
      return zI(l, n, s).map((f) => Z_.create(Fe.fromDom(f.startContainer), f.startOffset, Fe.fromDom(f.endContainer), f.endOffset));
    }, H0 = hm.generate([
      { before: ["element"] },
      {
        on: [
          "element",
          "offset"
        ]
      },
      { after: ["element"] }
    ]), K_ = (e, n, s, l) => e.fold(n, s, l), EN = (e) => e.fold(_n, _n, _n), UI = H0.before, WI = H0.on, Xx = H0.after, lg = {
      before: UI,
      on: WI,
      after: Xx,
      cata: K_,
      getStart: EN
    }, Jx = hm.generate([
      { domRange: ["rng"] },
      {
        relative: [
          "startSitu",
          "finishSitu"
        ]
      },
      {
        exact: [
          "start",
          "soffset",
          "finish",
          "foffset"
        ]
      }
    ]), Wo = (e) => Jx.exact(e.start, e.soffset, e.finish, e.foffset), jI = (e) => e.match({
      domRange: (n) => Fe.fromDom(n.startContainer),
      relative: (n, s) => lg.getStart(n),
      exact: (n, s, l, f) => n
    }), bv = Jx.domRange, ug = Jx.relative, eT = Jx.exact, Df = (e) => {
      const n = jI(e);
      return No(n);
    }, tT = Z_.create, yv = {
      domRange: bv,
      relative: ug,
      exact: eT,
      exactFromRange: Wo,
      getWin: Df,
      range: tT
    }, z0 = (e, n) => {
      const s = no(e);
      return s === "input" ? lg.after(e) : Ge([
        "br",
        "img"
      ], s) ? n === 0 ? lg.before(e) : lg.after(e) : lg.on(e, n);
    }, gE = (e, n) => {
      const s = e.fold(lg.before, z0, lg.after), l = n.fold(lg.before, z0, lg.after);
      return yv.relative(s, l);
    }, Y_ = (e, n, s, l) => {
      const f = z0(e, n), b = z0(s, l);
      return yv.relative(f, b);
    }, qI = (e) => e.match({
      domRange: (n) => {
        const s = Fe.fromDom(n.startContainer), l = Fe.fromDom(n.endContainer);
        return Y_(s, n.startOffset, l, n.endOffset);
      },
      relative: gE,
      exact: Y_
    }), Q_ = (e, n) => {
      const l = (n || document).createDocumentFragment();
      return ke(e, (f) => {
        l.appendChild(f.dom);
      }), Fe.fromDom(l);
    }, GI = (e) => {
      const n = yv.getWin(e).dom, s = (f, b, E, N) => yr(n, f, b, E, N), l = qI(e);
      return HI(n, l).match({
        ltr: s,
        rtl: s
      });
    }, yo = (e, n, s) => VI(e, n, s), $f = (e, n, s) => {
      const l = No(Fe.fromDom(s));
      return yo(l.dom, e, n).map((f) => {
        const b = s.createRange();
        return b.setStart(f.start.dom, f.soffset), b.setEnd(f.finish.dom, f.foffset), b;
      }).getOrUndefined();
    }, Sv = (e, n) => Ie(e) && Ie(n) && e.startContainer === n.startContainer && e.startOffset === n.startOffset && e.endContainer === n.endContainer && e.endOffset === n.endOffset, ZI = (e, n, s) => {
      let l = e;
      for (; l && l !== n; ) {
        if (s(l))
          return l;
        l = l.parentNode;
      }
      return null;
    }, V0 = (e, n, s) => ZI(e, n, s) !== null, Po = (e, n, s) => V0(e, n, (l) => l.nodeName === s), KI = (e, n) => Xn(e) && !V0(e, n, Rf), X_ = (e, n, s) => {
      const l = n.parentNode;
      if (l) {
        const f = new xs(n, e.getParent(l, e.isBlock) || e.getRoot());
        let b;
        for (; b = f[s ? "prev" : "next"](); )
          if (Mo(b))
            return !0;
      }
      return !1;
    }, h = (e, n) => {
      var s;
      return ((s = e.previousSibling) === null || s === void 0 ? void 0 : s.nodeName) === n;
    }, w = (e, n) => {
      let s = n;
      for (; s && s !== e; ) {
        if (ro(s))
          return !0;
        s = s.parentNode;
      }
      return !1;
    }, A = (e, n, s, l, f) => {
      const b = e.getRoot(), E = e.schema.getNonEmptyElements(), N = f.parentNode;
      let D, U;
      if (!N)
        return oe.none();
      const J = e.getParent(N, e.isBlock) || b;
      if (l && Mo(f) && n && e.isEmpty(J))
        return oe.some(yt(N, e.nodeIndex(f)));
      const te = new xs(f, J);
      for (; U = te[l ? "prev" : "next"](); ) {
        if (e.getContentEditableParent(U) === "false" || KI(U, b))
          return oe.none();
        if (Qt(U) && U.data.length > 0)
          return Po(U, b, "A") ? oe.none() : oe.some(yt(U, l ? U.data.length : 0));
        if (e.isBlock(U) || E[U.nodeName.toLowerCase()])
          return oe.none();
        D = U;
      }
      return im(D) ? oe.none() : s && D ? oe.some(yt(D, 0)) : oe.none();
    }, P = (e, n, s, l) => {
      const f = e.getRoot();
      let b, E = !1, N = s ? l.startContainer : l.endContainer, D = s ? l.startOffset : l.endOffset;
      const U = Un(N) && D === N.childNodes.length, J = e.schema.getNonEmptyElements();
      let te = s;
      if (Xn(N))
        return oe.none();
      if (Un(N) && D > N.childNodes.length - 1 && (te = !1), Mu(N) && (N = f, D = 0), N === f) {
        if (te && (b = N.childNodes[D > 0 ? D - 1 : 0], b && (Xn(b) || J[b.nodeName] || gf(b))))
          return oe.none();
        if (N.hasChildNodes()) {
          if (D = Math.min(!te && D > 0 ? D - 1 : D, N.childNodes.length - 1), N = N.childNodes[D], D = Qt(N) && U ? N.data.length : 0, !n && N === f.lastChild && gf(N) || w(f, N) || Xn(N) || Mt(N))
            return oe.none();
          if (N.hasChildNodes() && !gf(N)) {
            b = N;
            const ce = new xs(N, f);
            do {
              if (ro(b) || Xn(b)) {
                E = !1;
                break;
              }
              if (Qt(b) && b.data.length > 0) {
                D = te ? 0 : b.data.length, N = b, E = !0;
                break;
              }
              if (J[b.nodeName.toLowerCase()] && !si(b)) {
                D = e.nodeIndex(b), N = b.parentNode, te || D++, E = !0;
                break;
              }
            } while (b = te ? ce.next() : ce.prev());
          }
        }
      }
      return n && (Qt(N) && D === 0 && A(e, U, n, !0, N).each((ce) => {
        N = ce.container(), D = ce.offset(), E = !0;
      }), Un(N) && (b = N.childNodes[D], b || (b = N.childNodes[D - 1]), b && Mo(b) && !h(b, "A") && !X_(e, b, !1) && !X_(e, b, !0) && A(e, U, n, !0, b).each((ce) => {
        N = ce.container(), D = ce.offset(), E = !0;
      }))), te && !n && Qt(N) && D === N.data.length && A(e, U, n, !1, N).each((ce) => {
        N = ce.container(), D = ce.offset(), E = !0;
      }), E && N ? oe.some(yt(N, D)) : oe.none();
    }, V = (e, n) => {
      const s = n.collapsed, l = n.cloneRange(), f = yt.fromRangeStart(n);
      return P(e, s, !0, l).each((b) => {
        (!s || !yt.isAbove(f, b)) && l.setStart(b.container(), b.offset());
      }), s || P(e, s, !1, l).each((b) => {
        l.setEnd(b.container(), b.offset());
      }), s && l.collapse(!0), Sv(n, l) ? oe.none() : oe.some(l);
    }, K = (e, n) => e.splitText(n), ie = (e) => {
      let n = e.startContainer, s = e.startOffset, l = e.endContainer, f = e.endOffset;
      if (n === l && Qt(n)) {
        if (s > 0 && s < n.data.length)
          if (l = K(n, s), n = l.previousSibling, f > s) {
            f = f - s;
            const b = K(l, f).previousSibling;
            n = l = b, f = b.data.length, s = 0;
          } else
            f = 0;
      } else if (Qt(n) && s > 0 && s < n.data.length && (n = K(n, s), s = 0), Qt(l) && f > 0 && f < l.data.length) {
        const b = K(l, f).previousSibling;
        l = b, f = b.data.length;
      }
      return {
        startContainer: n,
        startOffset: s,
        endContainer: l,
        endOffset: f
      };
    }, ve = (e) => ({
      walk: (b, E) => dE(e, b, E),
      split: ie,
      expand: (b, E = { type: "word" }) => {
        if (E.type === "word") {
          const N = hv(e, b, [{ inline: "span" }]), D = e.createRng();
          return D.setStart(N.startContainer, N.startOffset), D.setEnd(N.endContainer, N.endOffset), D;
        }
        return b;
      },
      normalize: (b) => V(e, b).fold(He, (E) => (b.setStart(E.startContainer, E.startOffset), b.setEnd(E.endContainer, E.endOffset), !0))
    });
    ve.compareRanges = Sv, ve.getCaretRangeFromPoint = $f, ve.getSelectedNode = Tb, ve.getNode = Vu;
    const Ue = ((e, n) => {
      const s = (N, D) => {
        if (!pt(D) && !D.match(/^[0-9]+$/))
          throw new Error(e + ".set accepts only positive integer values. Value was " + D);
        const U = N.dom;
        mf(U) && (U.style[e] = D + "px");
      }, l = (N) => {
        const D = n(N);
        if (D <= 0 || D === null) {
          const U = va(N, e);
          return parseFloat(U) || 0;
        }
        return D;
      }, f = l, b = (N, D) => Ye(D, (U, J) => {
        const te = va(N, J), ce = te === void 0 ? 0 : parseInt(te, 10);
        return isNaN(ce) ? U : U + ce;
      }, 0);
      return {
        set: s,
        get: l,
        getOuter: f,
        aggregate: b,
        max: (N, D, U) => {
          const J = b(N, U);
          return D > J ? D - J : 0;
        }
      };
    })("height", (e) => {
      const n = e.dom;
      return rm(e) ? n.getBoundingClientRect().height : n.offsetHeight;
    }), ct = (e) => Ue.get(e), Yt = () => Fe.fromDom(document), On = (e, n) => e.view(n).fold(at([]), (l) => {
      const f = e.owner(l), b = On(e, f);
      return [l].concat(b);
    }), Tn = (e, n) => {
      const s = n.owner(e);
      return On(n, s);
    };
    var $t = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      view: (e) => {
        var n;
        return (e.dom === document ? oe.none() : oe.from((n = e.dom.defaultView) === null || n === void 0 ? void 0 : n.frameElement)).map(Fe.fromDom);
      },
      owner: (e) => er(e)
    });
    const Gn = (e) => {
      const n = Yt(), s = Wn(n), l = Tn(e, $t), f = Ut(e), b = bn(l, (E, N) => {
        const D = Ut(N);
        return {
          left: E.left + D.left,
          top: E.top + D.top
        };
      }, {
        left: 0,
        top: 0
      });
      return X(b.left + f.left + s.left, b.top + f.top + s.top);
    }, Or = (e) => no(e) === "textarea", jr = (e, n) => e.dispatch("ScrollIntoView", n).isDefaultPrevented(), da = (e, n) => {
      e.dispatch("AfterScrollIntoView", n);
    }, _c = (e, n) => {
      const s = ga(e);
      if (s.length === 0 || Or(e))
        return {
          element: e,
          offset: n
        };
      if (n < s.length && !Or(s[n]))
        return {
          element: s[n],
          offset: 0
        };
      {
        const l = s[s.length - 1];
        return Or(l) ? {
          element: e,
          offset: n
        } : no(l) === "img" ? {
          element: l,
          offset: 1
        } : hi(l) ? {
          element: l,
          offset: lu(l).length
        } : {
          element: l,
          offset: ga(l).length
        };
      }
    }, ui = (e, n) => {
      const s = We(e), l = ct(e);
      return {
        element: e,
        bottom: s.top + l,
        height: l,
        pos: s,
        cleanup: n
      };
    }, bd = (e, n) => {
      const s = _c(e, n), l = Fe.fromHtml('<span data-mce-bogus="all" style="display: inline-block;">' + M + "</span>");
      return ba(s.element, l), ui(l, () => mo(l));
    }, e1 = (e) => ui(Fe.fromDom(e), Lt), t1 = (e, n, s, l) => {
      Su(e, (f, b) => nT(e, n, s, l), s);
    }, J_ = (e, n, s, l, f) => {
      const b = {
        elm: l.element.dom,
        alignToTop: f
      };
      if (jr(e, b))
        return;
      const E = Wn(n).top;
      s(e, n, E, l, f), da(e, b);
    }, nT = (e, n, s, l) => {
      const f = Fe.fromDom(e.getBody()), b = Fe.fromDom(e.getDoc());
      $s(f);
      const E = bd(Fe.fromDom(s.startContainer), s.startOffset);
      J_(e, b, n, E, l), E.cleanup();
    }, ks = (e, n, s, l) => {
      const f = Fe.fromDom(e.getDoc());
      J_(e, f, s, e1(n), l);
    }, Su = (e, n, s) => {
      const l = s.startContainer, f = s.startOffset, b = s.endContainer, E = s.endOffset;
      n(Fe.fromDom(l), Fe.fromDom(b));
      const N = e.dom.createRng();
      N.setStart(l, f), N.setEnd(b, E), e.selection.setRng(s);
    }, _l = (e, n, s, l, f) => {
      const b = n.pos;
      if (l)
        xr(b.left, b.top, f);
      else {
        const E = b.top - s + n.height;
        xr(-e.getBody().getBoundingClientRect().left, E, f);
      }
    }, If = (e, n, s, l, f, b) => {
      const E = l + s, N = f.pos.top, D = f.bottom, U = D - N >= l;
      N < s ? _l(e, f, l, b !== !1, n) : N > E ? _l(e, f, l, U ? b !== !1 : b === !0, n) : D > E && !U && _l(e, f, l, b === !0, n);
    }, Qd = (e, n, s, l, f) => {
      const b = No(n).dom.innerHeight;
      If(e, n, s, b, l, f);
    }, jb = (e, n, s, l, f) => {
      const b = No(n).dom.innerHeight;
      If(e, n, s, b, l, f);
      const E = Gn(l.element), N = ra(window);
      E.top < N.y ? wr(l.element, f !== !1) : E.top > N.bottom && wr(l.element, f === !0);
    }, ju = (e, n, s) => t1(e, Qd, n, s), eO = (e, n, s) => ks(e, n, Qd, s), vE = (e, n, s) => t1(e, jb, n, s), dg = (e, n, s) => ks(e, n, jb, s), Gl = (e, n, s) => {
      (e.inline ? eO : dg)(e, n, s);
    }, bE = (e, n, s) => {
      (e.inline ? ju : vE)(e, n, s);
    }, CN = (e, n = !1) => e.dom.focus({ preventScroll: n }), xN = (e) => {
      const n = Cc(e).dom;
      return e.dom === n.activeElement;
    }, U0 = (e = Yt()) => oe.from(e.dom.activeElement).map(Fe.fromDom), TN = (e) => U0(Cc(e)).filter((n) => e.dom.contains(n.dom)), rT = (e, n) => {
      const s = hi(n) ? lu(n).length : ga(n).length + 1;
      return e > s ? s : e < 0 ? 0 : e;
    }, _N = (e) => yv.range(e.start, rT(e.soffset, e.start), e.finish, rT(e.foffset, e.finish)), n1 = (e, n) => !pf(n.dom) && (Wt(e, n) || Je(e, n)), d5 = (e) => (n) => n1(e, n.start) && n1(e, n.finish), Cq = (e) => e.inline || kn.browser.isFirefox(), xq = (e) => yv.range(Fe.fromDom(e.startContainer), e.startOffset, Fe.fromDom(e.endContainer), e.endOffset), Tq = (e) => {
      const n = e.getSelection();
      return (!n || n.rangeCount === 0 ? oe.none() : oe.from(n.getRangeAt(0))).map(xq);
    }, _q = (e) => {
      const n = No(e);
      return Tq(n.dom).filter(d5(e));
    }, f5 = (e, n) => oe.from(n).filter(d5(e)).map(_N), m5 = (e) => {
      const n = document.createRange();
      try {
        return n.setStart(e.start.dom, e.soffset), n.setEnd(e.finish.dom, e.foffset), oe.some(n);
      } catch {
        return oe.none();
      }
    }, oT = (e) => {
      const n = Cq(e) ? _q(Fe.fromDom(e.getBody())) : oe.none();
      e.bookmark = n.isSome() ? n : e.bookmark;
    }, YI = (e) => (e.bookmark ? e.bookmark : oe.none()).bind((s) => f5(Fe.fromDom(e.getBody()), s)).bind(m5), Oq = (e) => {
      YI(e).each((n) => e.selection.setRng(n));
    }, h5 = { isEditorUIElement: (e) => {
      const n = e.className.toString();
      return n.indexOf("tox-") !== -1 || n.indexOf("mce-") !== -1;
    } }, g5 = (e, n) => (pt(n) || (n = 0), setTimeout(e, n)), v5 = (e, n) => (pt(n) || (n = 0), setInterval(e, n)), sp = {
      setEditorTimeout: (e, n, s) => g5(() => {
        e.removed || n();
      }, s),
      setEditorInterval: (e, n, s) => {
        const l = v5(() => {
          e.removed ? clearInterval(l) : n();
        }, s);
        return l;
      }
    }, Aq = (e) => e.type === "nodechange" && e.selectionChange, kq = (e, n) => {
      const s = () => {
        n.throttle();
      };
      Is.DOM.bind(document, "mouseup", s), e.on("remove", () => {
        Is.DOM.unbind(document, "mouseup", s);
      });
    }, Nq = (e, n) => {
      e.on("mouseup touchend", (s) => {
        n.throttle();
      });
    }, Rq = (e, n) => {
      Nq(e, n), e.on("keyup NodeChange AfterSetSelectionRange", (s) => {
        Aq(s) || oT(e);
      });
    }, ON = (e) => {
      const n = Py(() => {
        oT(e);
      }, 0);
      e.on("init", () => {
        e.inline && kq(e, n), Rq(e, n);
      }), e.on("remove", () => {
        n.cancel();
      });
    };
    let yE;
    const AN = Is.DOM, b5 = (e) => Un(e) && h5.isEditorUIElement(e), kN = (e) => {
      const n = e.classList;
      return n !== void 0 ? n.contains("tox-edit-area") || n.contains("tox-edit-area__iframe") || n.contains("mce-content-body") : !1;
    }, NN = (e, n) => {
      const s = yx(e);
      return AN.getParent(n, (f) => b5(f) || (s ? e.dom.is(f, s) : !1)) !== null;
    }, QI = (e) => {
      try {
        const n = Cc(Fe.fromDom(e.getElement()));
        return U0(n).fold(() => document.body, (s) => s.dom);
      } catch {
        return document.body;
      }
    }, Pq = (e, n) => {
      const s = n.editor;
      ON(s);
      const l = (f, b) => {
        if (hd(f) && f.inline !== !0) {
          const E = Fe.fromDom(f.getContainer());
          b(E, "tox-edit-focus");
        }
      };
      s.on("focusin", () => {
        const f = e.focusedEditor;
        kN(QI(s)) && l(s, nd), f !== s && (f && f.dispatch("blur", { focusedEditor: s }), e.setActive(s), e.focusedEditor = s, s.dispatch("focus", { blurredEditor: f }), s.focus(!0));
      }), s.on("focusout", () => {
        sp.setEditorTimeout(s, () => {
          const f = e.focusedEditor;
          (!kN(QI(s)) || f !== s) && l(s, wc), !NN(s, QI(s)) && f === s && (s.dispatch("blur", { focusedEditor: null }), e.focusedEditor = null);
        });
      }), yE || (yE = (f) => {
        const b = e.activeEditor;
        b && df(f).each((E) => {
          const N = E;
          N.ownerDocument === document && N !== document.body && !NN(b, N) && e.focusedEditor === b && (b.dispatch("blur", { focusedEditor: null }), e.focusedEditor = null);
        });
      }, AN.bind(document, "focusin", yE));
    }, Dq = (e, n) => {
      e.focusedEditor === n.editor && (e.focusedEditor = null), !e.activeEditor && yE && (AN.unbind(document, "focusin", yE), yE = null);
    }, $q = (e) => {
      e.on("AddEditor", Ne(Pq, e)), e.on("RemoveEditor", Ne(Dq, e));
    }, Iq = (e, n) => e.dom.getParent(n, (s) => e.dom.getContentEditable(s) === "true"), Mq = (e) => e.collapsed ? oe.from(Vu(e.startContainer, e.startOffset)).map(Fe.fromDom) : oe.none(), Fq = (e, n) => Mq(n).bind((s) => rl(s) ? oe.some(s) : Wt(e, s) ? oe.none() : oe.some(e)), y5 = (e, n) => {
      Fq(Fe.fromDom(e.getBody()), n).bind((s) => Wu(s.dom)).fold(() => {
        e.selection.normalize();
      }, (s) => e.selection.setRng(s.toRange()));
    }, XI = (e) => {
      if (e.setActive)
        try {
          e.setActive();
        } catch {
          e.focus();
        }
      else
        e.focus();
    }, Lq = (e) => xN(e) || TN(e).isSome(), Bq = (e) => Ie(e.iframeElement) && xN(Fe.fromDom(e.iframeElement)), RN = (e) => {
      const n = e.getBody();
      return n && Lq(Fe.fromDom(n));
    }, S5 = (e) => {
      const n = Cc(Fe.fromDom(e.getElement()));
      return U0(n).filter((s) => !kN(s.dom) && NN(e, s.dom)).isSome();
    }, W0 = (e) => e.inline ? RN(e) : Bq(e), w5 = (e) => W0(e) || S5(e), Hq = (e) => {
      const n = e.selection, s = e.getBody();
      let l = n.getRng();
      e.quirks.refreshContentEditable(), Ie(e.bookmark) && !W0(e) && YI(e).each((b) => {
        e.selection.setRng(b), l = b;
      });
      const f = Iq(e, n.getNode());
      if (f && e.dom.isChildOf(f, s)) {
        XI(f), y5(e, l), JI(e);
        return;
      }
      e.inline || (kn.browser.isOpera() || XI(s), e.getWin().focus()), (kn.browser.isFirefox() || e.inline) && (XI(s), y5(e, l)), JI(e);
    }, JI = (e) => e.editorManager.setActive(e), zq = (e, n) => {
      e.removed || (n ? JI(e) : Hq(e));
    }, E5 = (e, n) => n.collapsed ? e.isEditable(n.startContainer) : e.isEditable(n.startContainer) && e.isEditable(n.endContainer), C5 = (e, n, s, l, f) => {
      const b = s ? n.startContainer : n.endContainer, E = s ? n.startOffset : n.endOffset;
      return oe.from(b).map(Fe.fromDom).map((N) => !l || !n.collapsed ? Du(N, f(N, E)).getOr(N) : N).bind((N) => Mi(N) ? oe.some(N) : Qo(N).filter(Mi)).map((N) => N.dom).getOr(e);
    }, eM = (e, n, s = !1) => C5(e, n, !0, s, (l, f) => Math.min(ec(l), f)), x5 = (e, n, s = !1) => C5(e, n, !1, s, (l, f) => f > 0 ? f - 1 : f), tM = (e, n) => {
      const s = e;
      for (; e && Qt(e) && e.length === 0; )
        e = n ? e.nextSibling : e.previousSibling;
      return e || s;
    }, T5 = (e, n) => {
      if (!n)
        return e;
      let s = n.startContainer, l = n.endContainer;
      const f = n.startOffset, b = n.endOffset;
      let E = n.commonAncestorContainer;
      n.collapsed || (s === l && b - f < 2 && s.hasChildNodes() && (E = s.childNodes[f]), Qt(s) && Qt(l) && (s.length === f ? s = tM(s.nextSibling, !0) : s = s.parentNode, b === 0 ? l = tM(l.previousSibling, !1) : l = l.parentNode, s && s === l && (E = s)));
      const N = Qt(E) ? E.parentNode : E;
      return Ui(N) ? N : e;
    }, Vq = (e, n, s, l) => {
      const f = [], b = e.getRoot(), E = e.getParent(s || eM(b, n, n.collapsed), e.isBlock), N = e.getParent(l || x5(b, n, n.collapsed), e.isBlock);
      if (E && E !== b && f.push(E), E && N && E !== N) {
        let D;
        const U = new xs(E, b);
        for (; (D = U.next()) && D !== N; )
          e.isBlock(D) && f.push(D);
      }
      return N && E !== N && N !== b && f.push(N), f;
    }, Uq = (e, n, s) => oe.from(n).bind((l) => oe.from(l.parentNode).map((f) => {
      const b = e.nodeIndex(l), E = e.createRng();
      return E.setStart(f, b), E.setEnd(f, b + 1), s && ($_(e, E, l, !0), $_(e, E, l, !1)), E;
    })), nM = (e, n) => St(n, (s) => {
      const l = e.dispatch("GetSelectionRange", { range: s });
      return l.range !== s ? l.range : s;
    }), Wq = (e) => no(e) === "img" ? 1 : Wh(e).fold(() => ga(e).length, (n) => n.length), jq = (e) => Wh(e).filter((n) => n.trim().length !== 0 || n.indexOf(xo) > -1).isSome(), qq = (e) => zs(e) && Ji(e, "contenteditable") === "false", Gq = [
      "img",
      "br"
    ], _5 = (e) => jq(e) || Ge(Gq, no(e)) || qq(e), Zq = (e) => Ci(e, _5), Kq = (e) => Yq(e, _5), Yq = (e, n) => {
      const s = (l) => {
        const f = ga(l);
        for (let b = f.length - 1; b >= 0; b--) {
          const E = f[b];
          if (n(E))
            return oe.some(E);
          const N = s(E);
          if (N.isSome())
            return N;
        }
        return oe.none();
      };
      return s(e);
    }, O5 = "[data-mce-autocompleter]", Qq = (e, n) => {
      if (A5(Fe.fromDom(e.getBody())).isNone()) {
        const s = Fe.fromHtml('<span data-mce-autocompleter="1" data-mce-bogus="1"></span>', e.getDoc());
        Ys(s, Fe.fromDom(n.extractContents())), n.insertNode(s.dom), Qo(s).each((l) => l.dom.normalize()), Kq(s).map((l) => {
          e.selection.setCursorLocation(l.dom, Wq(l));
        });
      }
    }, Xq = (e) => au(e, O5), A5 = (e) => Li(e, O5), Jq = (e, n) => A5(n).each((s) => {
      const l = e.selection.getBookmark();
      zi(s), e.selection.moveToBookmark(l);
    }), eG = {
      "#text": 3,
      "#comment": 8,
      "#cdata": 4,
      "#pi": 7,
      "#doctype": 10,
      "#document-fragment": 11
    }, PN = (e, n, s) => {
      const l = s ? "lastChild" : "firstChild", f = s ? "prev" : "next";
      if (e[l])
        return e[l];
      if (e !== n) {
        let b = e[f];
        if (b)
          return b;
        for (let E = e.parent; E && E !== n; E = E.parent)
          if (b = E[f], b)
            return b;
      }
    }, tG = (e) => {
      var n;
      const s = (n = e.value) !== null && n !== void 0 ? n : "";
      if (!Bp(s))
        return !1;
      const l = e.parent;
      return !(l && (l.name !== "span" || l.attr("style")) && /^[ ]+$/.test(s));
    }, ar = (e) => {
      const n = e.name === "a" && !e.attr("href") && e.attr("id");
      return e.attr("name") || e.attr("id") && !e.firstChild || e.attr("data-mce-bookmark") || n;
    };
    class yd {
      static create(n, s) {
        const l = new yd(n, eG[n] || 1);
        return s && fn(s, (f, b) => {
          l.attr(b, f);
        }), l;
      }
      constructor(n, s) {
        this.name = n, this.type = s, s === 1 && (this.attributes = [], this.attributes.map = {});
      }
      replace(n) {
        const s = this;
        return n.parent && n.remove(), s.insert(n, s), s.remove(), s;
      }
      attr(n, s) {
        const l = this;
        if (!G(n))
          return Ie(n) && fn(n, (b, E) => {
            l.attr(E, b);
          }), l;
        const f = l.attributes;
        if (f) {
          if (s !== void 0) {
            if (s === null) {
              if (n in f.map) {
                delete f.map[n];
                let b = f.length;
                for (; b--; )
                  if (f[b].name === n)
                    return f.splice(b, 1), l;
              }
              return l;
            }
            if (n in f.map) {
              let b = f.length;
              for (; b--; )
                if (f[b].name === n) {
                  f[b].value = s;
                  break;
                }
            } else
              f.push({
                name: n,
                value: s
              });
            return f.map[n] = s, l;
          }
          return f.map[n];
        }
      }
      clone() {
        const n = this, s = new yd(n.name, n.type), l = n.attributes;
        if (l) {
          const f = [];
          f.map = {};
          for (let b = 0, E = l.length; b < E; b++) {
            const N = l[b];
            N.name !== "id" && (f[f.length] = {
              name: N.name,
              value: N.value
            }, f.map[N.name] = N.value);
          }
          s.attributes = f;
        }
        return s.value = n.value, s;
      }
      wrap(n) {
        const s = this;
        return s.parent && (s.parent.insert(n, s), n.append(s)), s;
      }
      unwrap() {
        const n = this;
        for (let s = n.firstChild; s; ) {
          const l = s.next;
          n.insert(s, n, !0), s = l;
        }
        n.remove();
      }
      remove() {
        const n = this, s = n.parent, l = n.next, f = n.prev;
        return s && (s.firstChild === n ? (s.firstChild = l, l && (l.prev = null)) : f && (f.next = l), s.lastChild === n ? (s.lastChild = f, f && (f.next = null)) : l && (l.prev = f), n.parent = n.next = n.prev = null), n;
      }
      append(n) {
        const s = this;
        n.parent && n.remove();
        const l = s.lastChild;
        return l ? (l.next = n, n.prev = l, s.lastChild = n) : s.lastChild = s.firstChild = n, n.parent = s, n;
      }
      insert(n, s, l) {
        n.parent && n.remove();
        const f = s.parent || this;
        return l ? (s === f.firstChild ? f.firstChild = n : s.prev && (s.prev.next = n), n.prev = s.prev, n.next = s, s.prev = n) : (s === f.lastChild ? f.lastChild = n : s.next && (s.next.prev = n), n.next = s.next, n.prev = s, s.next = n), n.parent = f, n;
      }
      getAll(n) {
        const s = this, l = [];
        for (let f = s.firstChild; f; f = PN(f, s))
          f.name === n && l.push(f);
        return l;
      }
      children() {
        const n = this, s = [];
        for (let l = n.firstChild; l; l = l.next)
          s.push(l);
        return s;
      }
      empty() {
        const n = this;
        if (n.firstChild) {
          const s = [];
          for (let f = n.firstChild; f; f = PN(f, n))
            s.push(f);
          let l = s.length;
          for (; l--; ) {
            const f = s[l];
            f.parent = f.firstChild = f.lastChild = f.next = f.prev = null;
          }
        }
        return n.firstChild = n.lastChild = null, n;
      }
      isEmpty(n, s = {}, l) {
        var f;
        const b = this;
        let E = b.firstChild;
        if (ar(b))
          return !1;
        if (E)
          do {
            if (E.type === 1) {
              if (E.attr("data-mce-bogus"))
                continue;
              if (n[E.name] || ar(E))
                return !1;
            }
            if (E.type === 8 || E.type === 3 && !tG(E) || E.type === 3 && E.parent && s[E.parent.name] && Bp((f = E.value) !== null && f !== void 0 ? f : "") || l && l(E))
              return !1;
          } while (E = PN(E, b));
        return !0;
      }
      walk(n) {
        return PN(this, null, n);
      }
    }
    const k5 = rn.makeMap("NOSCRIPT STYLE SCRIPT XMP IFRAME NOEMBED NOFRAMES PLAINTEXT", " "), N5 = (e) => G(e.nodeValue) && e.nodeValue.includes(M), DN = (e) => `${e.length === 0 ? "" : `${St(e, (n) => `[${n}]`).join(",")},`}[data-mce-bogus="all"]`, nG = (e, n) => n.querySelectorAll(DN(e)), R5 = (e) => document.createTreeWalker(e, NodeFilter.SHOW_COMMENT, (n) => N5(n) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP), P5 = (e) => document.createTreeWalker(e, NodeFilter.SHOW_TEXT, (n) => {
      if (N5(n)) {
        const s = n.parentNode;
        return s && lr(k5, s.nodeName) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      } else
        return NodeFilter.FILTER_SKIP;
    }), rG = (e) => R5(e).nextNode() !== null, oG = (e) => P5(e).nextNode() !== null, $N = (e, n) => n.querySelector(DN(e)) !== null, D5 = (e, n) => {
      ke(nG(e, n), (s) => {
        const l = Fe.fromDom(s);
        Ji(l, "data-mce-bogus") === "all" ? mo(l) : ke(e, (f) => {
          Da(l, f) && Vs(l, f);
        });
      });
    }, sG = (e) => {
      let n = e.nextNode();
      for (; n !== null; )
        n.nodeValue = null, n = e.nextNode();
    }, aG = z(sG, R5), $r = z(sG, P5), $5 = (e, n) => {
      const s = [
        {
          condition: Ne($N, n),
          action: Ne(D5, n)
        },
        {
          condition: rG,
          action: aG
        },
        {
          condition: oG,
          action: $r
        }
      ];
      let l = e, f = !1;
      return ke(s, ({ condition: b, action: E }) => {
        b(l) && (f || (l = e.cloneNode(!0), f = !0), E(l));
      }), l;
    }, Hr = (e) => {
      const n = Vi(e, "[data-mce-bogus]");
      ke(n, (s) => {
        Ji(s, "data-mce-bogus") === "all" ? mo(s) : ld(s) ? (ba(s, Fe.fromText(jg)), mo(s)) : zi(s);
      });
    }, rM = (e) => {
      const n = Vi(e, "input");
      ke(n, (s) => {
        Vs(s, "name");
      });
    }, xce = (e, n) => {
      const s = al(e), l = new RegExp(`^(<${s}[^>]*>(&nbsp;|&#160;|\\s||<br \\/>|)<\\/${s}>[\r
]*|<br \\/>[\r
]*)$`);
      return n.replace(l, "");
    }, Tce = (e, n) => {
      const s = e.getDoc(), l = Cc(Fe.fromDom(e.getBody())), f = Fe.fromTag("div", s);
      is(f, "data-mce-bogus", "all"), Hi(f, {
        position: "fixed",
        left: "-9999999px",
        top: "0"
      }), cu(f, n.innerHTML), Hr(f), rM(f);
      const b = wy(l);
      Ys(b, f);
      const E = de(f.dom.innerText);
      return mo(f), E;
    }, iG = (e, n, s) => {
      let l;
      return n.format === "raw" ? l = rn.trim(de($5(s, e.serializer.getTempAttrs()).innerHTML)) : n.format === "text" ? l = Tce(e, s) : n.format === "tree" ? l = e.serializer.serialize(s, n) : l = xce(e, e.serializer.serialize(s, n)), n.format !== "text" && !vi(Fe.fromDom(s)) && G(l) ? rn.trim(l) : l;
    }, _ce = (e, n) => oe.from(e.getBody()).fold(at(n.format === "tree" ? new yd("body", 11) : ""), (s) => iG(e, n, s)), cG = rn.makeMap, I5 = (e) => {
      const n = [];
      e = e || {};
      const s = e.indent, l = cG(e.indent_before || ""), f = cG(e.indent_after || ""), b = Yg.getEncodeFunc(e.entity_encoding || "raw", e.entities), E = e.element_format !== "xhtml";
      return {
        start: (N, D, U) => {
          if (s && l[N] && n.length > 0) {
            const J = n[n.length - 1];
            J.length > 0 && J !== `
` && n.push(`
`);
          }
          if (n.push("<", N), D)
            for (let J = 0, te = D.length; J < te; J++) {
              const ce = D[J];
              n.push(" ", ce.name, '="', b(ce.value, !0), '"');
            }
          if (!U || E ? n[n.length] = ">" : n[n.length] = " />", U && s && f[N] && n.length > 0) {
            const J = n[n.length - 1];
            J.length > 0 && J !== `
` && n.push(`
`);
          }
        },
        end: (N) => {
          let D;
          n.push("</", N, ">"), s && f[N] && n.length > 0 && (D = n[n.length - 1], D.length > 0 && D !== `
` && n.push(`
`));
        },
        text: (N, D) => {
          N.length > 0 && (n[n.length] = D ? N : b(N));
        },
        cdata: (N) => {
          n.push("<![CDATA[", N, "]]>");
        },
        comment: (N) => {
          n.push("<!--", N, "-->");
        },
        pi: (N, D) => {
          D ? n.push("<?", N, " ", b(D), "?>") : n.push("<?", N, "?>"), s && n.push(`
`);
        },
        doctype: (N) => {
          n.push("<!DOCTYPE", N, ">", s ? `
` : "");
        },
        reset: () => {
          n.length = 0;
        },
        getContent: () => n.join("").replace(/\n$/, "")
      };
    }, j0 = (e = {}, n = jm()) => {
      const s = I5(e);
      return e.validate = "validate" in e ? e.validate : !0, { serialize: (f) => {
        const b = e.validate, E = {
          3: (D) => {
            var U;
            s.text((U = D.value) !== null && U !== void 0 ? U : "", D.raw);
          },
          8: (D) => {
            var U;
            s.comment((U = D.value) !== null && U !== void 0 ? U : "");
          },
          7: (D) => {
            s.pi(D.name, D.value);
          },
          10: (D) => {
            var U;
            s.doctype((U = D.value) !== null && U !== void 0 ? U : "");
          },
          4: (D) => {
            var U;
            s.cdata((U = D.value) !== null && U !== void 0 ? U : "");
          },
          11: (D) => {
            let U = D;
            if (U = U.firstChild)
              do
                N(U);
              while (U = U.next);
          }
        };
        s.reset();
        const N = (D) => {
          var U;
          const J = E[D.type];
          if (J)
            J(D);
          else {
            const te = D.name, ce = te in n.getVoidElements();
            let Oe = D.attributes;
            if (b && Oe && Oe.length > 1) {
              const Re = [];
              Re.map = {};
              const xe = n.getElementRule(D.name);
              if (xe) {
                for (let Pe = 0, Ke = xe.attributesOrder.length; Pe < Ke; Pe++) {
                  const et = xe.attributesOrder[Pe];
                  if (et in Oe.map) {
                    const rt = Oe.map[et];
                    Re.map[et] = rt, Re.push({
                      name: et,
                      value: rt
                    });
                  }
                }
                for (let Pe = 0, Ke = Oe.length; Pe < Ke; Pe++) {
                  const et = Oe[Pe].name;
                  if (!(et in Re.map)) {
                    const rt = Oe.map[et];
                    Re.map[et] = rt, Re.push({
                      name: et,
                      value: rt
                    });
                  }
                }
                Oe = Re;
              }
            }
            if (s.start(te, Oe, ce), wf(te))
              G(D.value) && s.text(D.value, !0), s.end(te);
            else if (!ce) {
              let Re = D.firstChild;
              if (Re) {
                (te === "pre" || te === "textarea") && Re.type === 3 && ((U = Re.value) === null || U === void 0 ? void 0 : U[0]) === `
` && s.text(`
`, !0);
                do
                  N(Re);
                while (Re = Re.next);
              }
              s.end(te);
            }
          }
        };
        return f.type === 1 && !e.inner ? N(f) : f.type === 3 ? E[3](f) : E[11](f), s.getContent();
      } };
    }, Er = /* @__PURE__ */ new Set();
    ke([
      "margin",
      "margin-left",
      "margin-right",
      "margin-top",
      "margin-bottom",
      "padding",
      "padding-left",
      "padding-right",
      "padding-top",
      "padding-bottom",
      "border",
      "border-width",
      "border-style",
      "border-color",
      "background",
      "background-attachment",
      "background-clip",
      "background-color",
      "background-image",
      "background-origin",
      "background-position",
      "background-repeat",
      "background-size",
      "float",
      "position",
      "left",
      "right",
      "top",
      "bottom",
      "z-index",
      "display",
      "transform",
      "width",
      "max-width",
      "min-width",
      "height",
      "max-height",
      "min-height",
      "overflow",
      "overflow-x",
      "overflow-y",
      "text-overflow",
      "vertical-align",
      "transition",
      "transition-delay",
      "transition-duration",
      "transition-property",
      "transition-timing-function"
    ], (n) => {
      Er.add(n);
    });
    const M5 = [
      "font",
      "text-decoration",
      "text-emphasis"
    ], oM = (e, n) => Co(e.parseStyle(e.getAttrib(n, "style"))), lG = (e) => Er.has(e), tO = (e, n) => Vr(oM(e, n), (s) => !lG(s)), F5 = (e) => ht(e, (n) => qt(M5, (s) => Gs(n, s))), uG = (e, n, s) => {
      const l = oM(e, n), f = oM(e, s), b = (E) => {
        var N, D;
        const U = (N = e.getStyle(n, E)) !== null && N !== void 0 ? N : "", J = (D = e.getStyle(s, E)) !== null && D !== void 0 ? D : "";
        return $o(U) && $o(J) && U !== J;
      };
      return qt(l, (E) => {
        const N = (D) => qt(D, (U) => U === E);
        if (!N(f) && N(M5)) {
          const D = F5(f);
          return qt(D, b);
        } else
          return b(E);
      });
    }, L5 = (e, n, s) => oe.from(s.container()).filter(Qt).exists((l) => {
      const f = e ? 0 : -1;
      return n(l.data.charAt(s.offset() + f));
    }), sM = Ne(L5, !0, D0), IN = Ne(L5, !1, D0), dG = (e) => {
      const n = e.container();
      return Qt(n) && (n.data.length === 0 || W(n.data) && Xy.isBookmarkNode(n.parentNode));
    }, SE = (e, n) => (s) => Nn(e ? 0 : -1, s).filter(n).isSome(), fG = (e) => ya(e) && va(Fe.fromDom(e), "display") === "block", B5 = (e) => ro(e) && !Xv(e), mG = SE(!0, fG), pG = SE(!1, fG), nO = SE(!0, Ts), sT = SE(!1, Ts), H5 = SE(!0, gf), Zr = SE(!1, gf), r1 = SE(!0, B5), wv = SE(!1, B5), z5 = (e) => e.slice(0, -1), V5 = (e, n, s) => Wt(n, e) ? z5(Rp(e, (l) => s(l) || Je(l, n))) : [], aM = (e, n) => V5(e, n, He), qb = (e, n) => [e].concat(aM(e, n)), MN = (e, n, s) => tp(e, n, s, dG), hG = (e) => (n) => e.isBlock(no(n)), iM = (e, n, s) => Bt(qb(Fe.fromDom(n.container()), e), hG(s)), U5 = (e, n, s, l) => MN(e, n.dom, s).forall((f) => iM(n, s, l).fold(() => !gn(f, s, n.dom), (b) => !gn(f, s, n.dom) && Wt(b, Fe.fromDom(f.container())))), W5 = (e, n, s, l) => iM(n, s, l).fold(() => MN(e, n.dom, s).forall((f) => !gn(f, s, n.dom)), (f) => MN(e, f.dom, s).isNone()), cM = Ne(W5, !1), j5 = Ne(W5, !0), gG = Ne(U5, !1), vG = Ne(U5, !0), bG = (e) => xl(e).exists(ld), FN = (e, n, s, l) => {
      const f = ht(qb(Fe.fromDom(s.container()), n), (E) => l.isBlock(no(E))), b = br(f).getOr(n);
      return il(e, b.dom, s).filter(bG);
    }, rO = (e, n, s) => xl(n).exists(ld) || FN(!0, e, n, s).isSome(), oO = (e, n, s) => Zd(n).exists(ld) || FN(!1, e, n, s).isSome(), yG = Ne(FN, !1), SG = Ne(FN, !0), q5 = (e) => yt.isTextPosition(e) && !e.isAtStart() && !e.isAtEnd(), G5 = (e, n, s) => {
      const l = ht(qb(Fe.fromDom(n.container()), e), (f) => s.isBlock(no(f)));
      return br(l).getOr(e);
    }, Z5 = (e, n, s) => q5(n) ? IN(n) : IN(n) || gd(G5(e, n, s).dom, n).exists(IN), K5 = (e, n, s) => q5(n) ? sM(n) : sM(n) || yu(G5(e, n, s).dom, n).exists(sM), wG = (e) => Ge([
      "pre",
      "pre-wrap"
    ], e), lM = (e) => xl(e).bind((n) => Fi(n, Mi)).exists((n) => wG(va(n, "white-space"))), Y5 = (e, n) => gd(e.dom, n).isNone(), EG = (e, n) => yu(e.dom, n).isNone(), CG = (e, n, s) => Y5(e, n) || EG(e, n) || cM(e, n, s) || j5(e, n, s) || oO(e, n, s) || rO(e, n, s), wE = (e) => Ie(e) && ro(e) && ag(e), Q5 = (e, n) => (s) => wE(new xs(s, e)[n]()), X5 = (e, n) => {
      const s = yu(e.dom, n).getOr(n), l = Q5(e.dom, "next");
      return n.isAtEnd() && (l(n.container()) || l(s.container()));
    }, xG = (e, n) => {
      const s = gd(e.dom, n).getOr(n), l = Q5(e.dom, "prev");
      return n.isAtStart() && (l(n.container()) || l(s.container()));
    }, J5 = (e, n, s) => lM(n) ? !1 : CG(e, n, s) || Z5(e, n, s) || K5(e, n, s), aT = (e, n, s) => lM(n) ? !1 : cM(e, n, s) || gG(e, n, s) || oO(e, n, s) || Z5(e, n, s) || xG(e, n), e6 = (e) => {
      const n = e.container(), s = e.offset();
      return Qt(n) && s < n.data.length ? yt(n, s + 1) : e;
    }, iT = (e, n, s) => lM(n) ? !1 : j5(e, n, s) || vG(e, n, s) || rO(e, n, s) || K5(e, n, s) || X5(e, n), LN = (e, n, s) => aT(e, n, s) || iT(e, e6(n), s), Sd = (e, n) => Bx(e.charAt(n)), t6 = (e, n) => D0(e.charAt(n)), TG = (e) => {
      const n = e.container();
      return Qt(n) && Hs(n.data, xo);
    }, _G = (e) => {
      const n = e.split("");
      return St(n, (s, l) => Bx(s) && l > 0 && l < n.length - 1 && zb(n[l - 1]) && zb(n[l + 1]) ? " " : s).join("");
    }, n6 = (e, n, s, l) => {
      const f = n.data, b = yt(n, 0);
      return !s && Sd(f, 0) && !LN(e, b, l) ? (n.data = " " + f.slice(1), !0) : s && t6(f, 0) && aT(e, b, l) ? (n.data = xo + f.slice(1), !0) : !1;
    }, OG = (e) => {
      const n = e.data, s = _G(n);
      return s !== n ? (e.data = s, !0) : !1;
    }, q0 = (e, n, s, l) => {
      const f = n.data, b = yt(n, f.length - 1);
      return !s && Sd(f, f.length - 1) && !LN(e, b, l) ? (n.data = f.slice(0, -1) + " ", !0) : s && t6(f, f.length - 1) && iT(e, b, l) ? (n.data = f.slice(0, -1) + xo, !0) : !1;
    }, AG = (e, n, s) => {
      const l = n.container();
      if (!Qt(l))
        return oe.none();
      if (TG(n)) {
        const f = n6(e, l, !1, s) || OG(l) || q0(e, l, !1, s);
        return Ur(f, n);
      } else if (LN(e, n, s)) {
        const f = n6(e, l, !0, s) || q0(e, l, !0, s);
        return Ur(f, n);
      } else
        return oe.none();
    }, kG = (e) => {
      const n = Fe.fromDom(e.getBody());
      e.selection.isCollapsed() && AG(n, yt.fromRangeStart(e.selection.getRng()), e.schema).each((s) => {
        e.selection.setRng(s.toRange());
      });
    }, La = (e, n, s, l) => {
      if (s === 0)
        return;
      const f = Fe.fromDom(e), b = Ss(f, (U) => l.isBlock(no(U))).getOr(f), E = e.data.slice(n, n + s), N = n + s >= e.data.length && iT(b, yt(e, e.data.length), l), D = n === 0 && aT(b, yt(e, 0), l);
      e.replaceData(n, s, Hp(E, 4, D, N));
    }, EE = (e, n, s) => {
      const l = e.data.slice(n), f = l.length - Ju(l).length;
      La(e, n, f, s);
    }, r6 = (e, n, s) => {
      const l = e.data.slice(0, n), f = l.length - ed(l).length;
      La(e, n - f, f, s);
    }, cl = (e, n, s, l, f = !0) => {
      const b = ed(e.data).length, E = f ? e : n, N = f ? n : e;
      return f ? E.appendData(N.data) : E.insertData(0, N.data), mo(Fe.fromDom(N)), l && EE(E, b, s), E;
    }, NG = (e, n) => {
      const s = e.container(), l = e.offset();
      return !yt.isTextPosition(e) && s === n.parentNode && l > yt.before(n).offset();
    }, RG = (e, n) => NG(n, e) ? yt(n.container(), n.offset() - 1) : n, o1 = (e) => Qt(e) ? yt(e, 0) : yt.before(e), ms = (e) => Qt(e) ? yt(e, e.data.length) : yt.after(e), uM = (e) => oo(e.previousSibling) ? oe.some(ms(e.previousSibling)) : e.previousSibling ? np(e.previousSibling) : oe.none(), dM = (e) => oo(e.nextSibling) ? oe.some(o1(e.nextSibling)) : e.nextSibling ? Wu(e.nextSibling) : oe.none(), PG = (e, n) => oe.from(n.previousSibling ? n.previousSibling : n.parentNode).bind((s) => gd(e, yt.before(s))).orThunk(() => yu(e, yt.after(n))), DG = (e, n) => yu(e, yt.after(n)).orThunk(() => gd(e, yt.before(n))), $G = (e, n) => uM(n).orThunk(() => dM(n)).orThunk(() => PG(e, n)), Sm = (e, n) => dM(n).orThunk(() => uM(n)).orThunk(() => DG(e, n)), fg = (e, n, s) => e ? Sm(n, s) : $G(n, s), o6 = (e, n, s) => fg(e, n, s).map(Ne(RG, s)), BN = (e, n, s) => {
      s.fold(() => {
        e.focus();
      }, (l) => {
        e.selection.setRng(l.toRange(), n);
      });
    }, fM = (e) => (n) => n.dom === e, HN = (e, n) => n && lr(e.schema.getBlockElements(), no(n)), s6 = (e, n) => {
      if (Na(e)) {
        const s = Fe.fromHtml('<br data-mce-bogus="1">');
        return n ? ke(ga(e), (l) => {
          iE(l) || mo(l);
        }) : $u(e), Ys(e, s), oe.some(yt.before(s.dom));
      } else
        return oe.none();
    }, sO = (e, n, s, l) => {
      const f = $a(e).filter(hi), b = Hl(e).filter(hi);
      return mo(e), Dd(f, b, n, (E, N, D) => {
        const U = E.dom, J = N.dom, te = U.data.length;
        return cl(U, J, s, l), D.container() === J ? yt(U, te) : D;
      }).orThunk(() => (l && (f.each((E) => r6(E.dom, E.dom.length, s)), b.each((E) => EE(E.dom, 0, s))), n));
    }, zN = (e, n) => lr(e.schema.getTextInlineElements(), no(n)), s1 = (e, n, s, l = !0, f = !1) => {
      const b = o6(n, e.getBody(), s.dom), E = Ss(s, Ne(HN, e), fM(e.getBody())), N = sO(s, b, e.schema, zN(e, s));
      e.dom.isEmpty(e.getBody()) ? (e.setContent(""), e.selection.setCursorLocation()) : E.bind((D) => s6(D, f)).fold(() => {
        l && BN(e, n, N);
      }, (D) => {
        l && BN(e, n, oe.some(D));
      });
    }, a6 = /[\u0591-\u07FF\uFB1D-\uFDFF\uFE70-\uFEFC]/, aO = (e) => a6.test(e), CE = (e, n) => Bl(Fe.fromDom(n), hx(e)) && !Jr(e.schema, n) && e.dom.isEditable(n), i6 = (e) => {
      var n;
      return Is.DOM.getStyle(e, "direction", !0) === "rtl" || aO((n = e.textContent) !== null && n !== void 0 ? n : "");
    }, Ev = (e, n, s) => ht(Is.DOM.getParents(s.container(), "*", n), e), Ol = (e, n, s) => {
      const l = Ev(e, n, s);
      return oe.from(l[l.length - 1]);
    }, iO = (e, n, s) => {
      const l = vn(n, e), f = vn(s, e);
      return Ie(l) && l === f;
    }, fh = (e) => Lo(e) || _s(e), mh = (e, n) => {
      const s = n.container(), l = n.offset();
      return e ? Sn(s) ? Qt(s.nextSibling) ? yt(s.nextSibling, 0) : yt.after(s) : Lo(n) ? yt(s, l + 1) : n : Sn(s) ? Qt(s.previousSibling) ? yt(s.previousSibling, s.previousSibling.data.length) : yt.before(s) : _s(n) ? yt(s, l - 1) : n;
    }, js = Ne(mh, !0), c6 = Ne(mh, !1), G0 = (e, n) => {
      const s = (l) => l.stopImmediatePropagation();
      e.on("beforeinput input", s, !0), e.getDoc().execCommand(n), e.off("beforeinput input", s);
    }, cO = (e) => {
      e.execCommand("delete");
    }, VN = (e) => G0(e, "Delete"), mM = (e) => G0(e, "ForwardDelete"), pM = (e) => (n) => na(Qo(n), e, Je), IG = (e) => lt(e) || Fu(e), cT = (e, n) => Wt(e, n) ? Fi(n, IG, pM(e)) : oe.none(), hM = (e, n = !0) => {
      e.dom.isEmpty(e.getBody()) && e.setContent("", { no_selection: !n });
    }, gM = (e, n, s) => bs(Wu(s), np(s), (l, f) => {
      const b = mh(!0, l), E = mh(!1, f), N = mh(!1, n);
      return e ? yu(s, N).exists((D) => D.isEqual(E) && n.isEqual(b)) : gd(s, N).exists((D) => D.isEqual(b) && n.isEqual(E));
    }).getOr(!0), vM = (e) => (jv(e) ? $a(e) : ou(e)).bind(vM).orThunk(() => oe.some(e)), UN = (e, n, s, l = !0) => {
      var f;
      n.deleteContents();
      const b = vM(s).getOr(s), E = Fe.fromDom((f = e.dom.getParent(b.dom, e.dom.isBlock)) !== null && f !== void 0 ? f : s.dom);
      if (E.dom === e.getBody() ? hM(e, l) : Na(E) && (vf(E), l && e.selection.setCursorLocation(E.dom, 0)), !Je(s, E)) {
        const N = na(Qo(E), s) ? [] : qv(E);
        ke(N.concat(ga(s)), (D) => {
          !Je(D, E) && !Wt(D, E) && Na(D) && mo(D);
        });
      }
    }, l6 = (e, n, s) => Ss(e, n, s).isSome(), WN = (e, n) => Hg(e, n).isSome(), u6 = (e, n) => Ci(e, n).isSome(), MG = (e) => (n) => Je(e, n), bM = (e) => Vi(e, "td,th"), d6 = (e, n) => mv(Fe.fromDom(e), n), FG = (e) => bs(e.startTable, e.endTable, (n, s) => {
      const l = u6(n, (b) => Je(b, s)), f = u6(s, (b) => Je(b, n));
      return !l && !f ? e : {
        ...e,
        startTable: l ? oe.none() : e.startTable,
        endTable: f ? oe.none() : e.endTable,
        isSameTable: !1,
        isMultiTable: !1
      };
    }).getOr(e), f6 = (e) => FG(e), LG = (e, n) => {
      const s = d6(e.startContainer, n), l = d6(e.endContainer, n), f = s.isSome(), b = l.isSome(), E = bs(s, l, Je).getOr(!1);
      return f6({
        startTable: s,
        endTable: l,
        isStartInTable: f,
        isEndInTable: b,
        isSameTable: E,
        isMultiTable: !E && f && b
      });
    }, yM = (e, n) => ({
      start: e,
      end: n
    }), m6 = (e, n, s) => ({
      rng: e,
      table: n,
      cells: s
    }), lO = hm.generate([
      {
        singleCellTable: [
          "rng",
          "cell"
        ]
      },
      { fullTable: ["table"] },
      {
        partialTable: [
          "cells",
          "outsideDetails"
        ]
      },
      {
        multiTable: [
          "startTableCells",
          "endTableCells",
          "betweenRng"
        ]
      }
    ]), uO = (e, n) => au(Fe.fromDom(e), "td,th", n), lT = (e) => !Je(e.start, e.end), p6 = (e, n) => mv(e.start, n).bind((s) => mv(e.end, n).bind((l) => Ur(Je(s, l), s))), BG = (e, n) => !lT(e) && p6(e, n).exists((s) => {
      const l = s.dom.rows;
      return l.length === 1 && l[0].cells.length === 1;
    }), h6 = (e, n) => {
      const s = uO(e.startContainer, n), l = uO(e.endContainer, n);
      return bs(s, l, yM);
    }, HG = (e) => (n) => mv(n, e).bind((s) => hs(bM(s)).map((l) => yM(n, l))), g6 = (e) => (n) => mv(n, e).bind((s) => br(bM(s)).map((l) => yM(l, n))), Mf = (e) => (n) => p6(n, e).map((s) => m6(n, s, bM(s))), v6 = (e, n, s, l) => {
      if (s.collapsed || !e.forall(lT))
        return oe.none();
      if (n.isSameTable) {
        const f = e.bind(Mf(l));
        return oe.some({
          start: f,
          end: f
        });
      } else {
        const f = uO(s.startContainer, l), b = uO(s.endContainer, l), E = f.bind(HG(l)).bind(Mf(l)), N = b.bind(g6(l)).bind(Mf(l));
        return oe.some({
          start: E,
          end: N
        });
      }
    }, SM = (e, n) => $n(e, (s) => Je(s, n)), dO = (e) => bs(SM(e.cells, e.rng.start), SM(e.cells, e.rng.end), (n, s) => e.cells.slice(n, s + 1)), wM = (e, n, s) => e.exists((l) => BG(l, s) && D_(l.start, n)), EM = (e, n) => {
      const { startTable: s, endTable: l } = n, f = e.cloneRange();
      return s.each((b) => f.setStartAfter(b.dom)), l.each((b) => f.setEndBefore(b.dom)), f;
    }, b6 = (e, n, s, l) => v6(e, n, s, l).bind(({ start: f, end: b }) => f.or(b)).bind((f) => {
      const { isSameTable: b } = n, E = dO(f).getOr([]);
      if (b && f.cells.length === E.length)
        return oe.some(lO.fullTable(f.table));
      if (E.length > 0) {
        if (b)
          return oe.some(lO.partialTable(E, oe.none()));
        {
          const N = EM(s, n);
          return oe.some(lO.partialTable(E, oe.some({
            ...n,
            rng: N
          })));
        }
      } else
        return oe.none();
    }), zG = (e, n, s, l) => v6(e, n, s, l).bind(({ start: f, end: b }) => {
      const E = f.bind(dO).getOr([]), N = b.bind(dO).getOr([]);
      if (E.length > 0 && N.length > 0) {
        const D = EM(s, n);
        return oe.some(lO.multiTable(E, N, D));
      } else
        return oe.none();
    }), VG = (e, n) => {
      const s = MG(e), l = h6(n, s), f = LG(n, s);
      return wM(l, n, s) ? l.map((b) => lO.singleCellTable(n, b.start)) : f.isMultiTable ? zG(l, f, n, s) : b6(l, f, n, s);
    }, jN = (e) => ke(e, (n) => {
      Vs(n, "contenteditable"), vf(n);
    }), y6 = (e, n) => oe.from(e.dom.getParent(n, e.dom.isBlock)).map(Fe.fromDom), mg = (e, n, s) => {
      s.each((l) => {
        n ? mo(l) : (vf(l), e.selection.setCursorLocation(l.dom, 0));
      });
    }, CM = (e, n, s, l) => {
      const f = s.cloneRange();
      l ? (f.setStart(s.startContainer, s.startOffset), f.setEndAfter(n.dom.lastChild)) : (f.setStartBefore(n.dom.firstChild), f.setEnd(s.endContainer, s.endOffset)), TM(e, f, n, !1).each((b) => b());
    }, S6 = (e) => {
      const n = $0(e), s = Fe.fromDom(e.selection.getNode());
      $p(s.dom) && Na(s) ? e.selection.setCursorLocation(s.dom, 0) : e.selection.collapse(!0), n.length > 1 && qt(n, (l) => Je(l, s)) && is(s, "data-mce-selected", "1");
    }, UG = (e, n, s) => oe.some(() => {
      const l = e.selection.getRng(), f = s.bind(({ rng: b, isStartInTable: E }) => {
        const N = y6(e, E ? b.endContainer : b.startContainer);
        b.deleteContents(), mg(e, E, N.filter(Na));
        const D = E ? n[0] : n[n.length - 1];
        return CM(e, D, l, E), Na(D) ? oe.none() : oe.some(E ? n.slice(1) : n.slice(0, -1));
      }).getOr(n);
      jN(f), S6(e);
    }), xM = (e, n, s, l) => oe.some(() => {
      const f = e.selection.getRng(), b = n[0], E = s[s.length - 1];
      CM(e, b, f, !0), CM(e, E, f, !1);
      const N = Na(b) ? n : n.slice(1), D = Na(E) ? s : s.slice(0, -1);
      jN(N.concat(D)), l.deleteContents(), S6(e);
    }), TM = (e, n, s, l = !0) => oe.some(() => {
      UN(e, n, s, l);
    }), uT = (e, n) => oe.some(() => s1(e, !1, n)), WG = (e, n, s) => VG(n, s).bind((l) => l.fold(Ne(TM, e), Ne(uT, e), Ne(UG, e), Ne(xM, e))), dT = (e, n) => mO(e, n), ph = (e, n, s, l) => xE(n, l).fold(() => WG(e, n, s), (f) => dT(e, f)), fO = (e, n, s) => {
      const l = Fe.fromDom(e.getBody()), f = e.selection.getRng();
      return s.length !== 0 ? UG(e, s, oe.none()) : ph(e, l, f, n);
    }, Ls = (e, n) => Bt(qb(n, e), vl), xE = (e, n) => Bt(qb(n, e), Fl("caption")), w6 = (e, n, s, l, f) => fv(s, e.getBody(), f).bind((b) => Ls(n, Fe.fromDom(b.getNode())).bind((E) => Je(E, l) ? oe.none() : oe.some(Lt))), mO = (e, n) => oe.some(() => {
      vf(n), e.selection.setCursorLocation(n.dom, 0);
    }), _M = (e, n, s, l) => Wu(e.dom).bind((f) => np(e.dom).map((b) => n ? s.isEqual(f) && l.isEqual(b) : s.isEqual(b) && l.isEqual(f))).getOr(!0), OM = (e, n) => mO(e, n), AM = (e, n, s) => xE(e, Fe.fromDom(s.getNode())).fold(() => oe.some(Lt), (l) => Ur(!Je(l, n), Lt)), kM = (e, n, s, l, f) => fv(s, e.getBody(), f).fold(() => oe.some(Lt), (b) => _M(l, s, f, b) ? OM(e, l) : AM(n, l, b)), qN = (e, n, s, l) => {
      const f = yt.fromRangeStart(e.selection.getRng());
      return Ls(s, l).bind((b) => Na(b) ? mO(e, b) : w6(e, s, n, b, f));
    }, NM = (e, n, s, l) => {
      const f = yt.fromRangeStart(e.selection.getRng());
      return Na(l) ? mO(e, l) : kM(e, s, n, l, f);
    }, RM = (e, n) => e ? H5(n) : Zr(n), E6 = (e, n) => {
      const s = yt.fromRangeStart(e.selection.getRng());
      return RM(n, s) || il(n, e.getBody(), s).exists((l) => RM(n, l));
    }, C6 = (e, n, s) => {
      const l = Fe.fromDom(e.getBody());
      return xE(l, s).fold(() => qN(e, n, l, s).orThunk(() => Ur(E6(e, n), Lt)), (f) => NM(e, n, l, f));
    }, GN = (e, n) => {
      const s = Fe.fromDom(e.selection.getStart(!0)), l = $0(e);
      return e.selection.isCollapsed() && l.length === 0 ? C6(e, n, s) : fO(e, s, l);
    }, Z0 = (e, n) => {
      let s = n;
      for (; s && s !== e; ) {
        if (Dc(s) || ro(s))
          return s;
        s = s.parentNode;
      }
      return null;
    }, fT = [
      "data-ephox-",
      "data-mce-",
      "data-alloy-",
      "data-snooker-",
      "_"
    ], x6 = rn.each, pO = (e) => {
      const n = e.dom, s = new Set(e.serializer.getTempAttrs()), l = (b, E) => {
        if (b.nodeName !== E.nodeName || b.nodeType !== E.nodeType)
          return !1;
        const N = (U) => {
          const J = {};
          return x6(n.getAttribs(U), (te) => {
            const ce = te.nodeName.toLowerCase();
            ce !== "style" && !f(ce) && (J[ce] = n.getAttrib(U, ce));
          }), J;
        }, D = (U, J) => {
          for (const te in U)
            if (lr(U, te)) {
              const ce = J[te];
              if (Le(ce) || U[te] !== ce)
                return !1;
              delete J[te];
            }
          for (const te in J)
            if (lr(J, te))
              return !1;
          return !0;
        };
        return Un(b) && Un(E) && (!D(N(b), N(E)) || !D(n.parseStyle(n.getAttrib(b, "style")), n.parseStyle(n.getAttrib(E, "style")))) ? !1 : !Pf(b) && !Pf(E);
      }, f = (b) => qt(fT, (E) => Gs(b, E)) || s.has(b);
      return {
        compare: l,
        isAttributeInternal: f
      };
    }, T6 = (e) => [
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6"
    ].includes(e.name), jG = (e) => e.name === "summary", _6 = (e, n) => {
      let s = e;
      for (; s = s.walk(); )
        n(s);
    }, PM = (e, n, s, l) => {
      const f = s.name;
      for (let b = 0, E = e.length; b < E; b++) {
        const N = e[b];
        if (N.name === f) {
          const D = l.nodes[f];
          D ? D.nodes.push(s) : l.nodes[f] = {
            filter: N,
            nodes: [s]
          };
        }
      }
      if (s.attributes)
        for (let b = 0, E = n.length; b < E; b++) {
          const N = n[b], D = N.name;
          if (D in s.attributes.map) {
            const U = l.attributes[D];
            U ? U.nodes.push(s) : l.attributes[D] = {
              filter: N,
              nodes: [s]
            };
          }
        }
    }, O6 = (e, n, s) => {
      const l = {
        nodes: {},
        attributes: {}
      };
      return s.firstChild && _6(s, (f) => {
        PM(e, n, f, l);
      }), l;
    }, hO = (e, n) => {
      const s = (l, f) => {
        fn(l, (b) => {
          const E = Ps(b.nodes);
          ke(b.filter.callbacks, (N) => {
            for (let D = E.length - 1; D >= 0; D--) {
              const U = E[D];
              (!(f ? U.attr(b.filter.name) !== void 0 : U.name === b.filter.name) || je(U.parent)) && E.splice(D, 1);
            }
            E.length > 0 && N(E, b.filter.name, n);
          });
        });
      };
      s(e.nodes, !1), s(e.attributes, !0);
    }, DM = (e, n, s, l = {}) => {
      const f = O6(e, n, s);
      hO(f, l);
    }, ZN = (e, n, s, l) => {
      if ((e.pad_empty_with_br || n.insert) && s(l)) {
        const b = new yd("br", 1);
        n.insert && b.attr("data-mce-bogus", "1"), l.empty().append(b);
      } else
        l.empty().append(new yd("#text", 3)).value = xo;
    }, A6 = (e) => {
      var n;
      return $M(e, "#text") && ((n = e == null ? void 0 : e.firstChild) === null || n === void 0 ? void 0 : n.value) === xo;
    }, $M = (e, n) => {
      const s = e == null ? void 0 : e.firstChild;
      return Ie(s) && s === e.lastChild && s.name === n;
    }, k6 = (e, n) => {
      const s = e.getElementRule(n.name);
      return (s == null ? void 0 : s.paddEmpty) === !0;
    }, mT = (e, n, s, l) => l.isEmpty(n, s, (f) => k6(e, f)), N6 = (e, n) => Ie(e) && (n(e) || e.name === "br"), R6 = (e) => {
      let n;
      for (let s = e; s; s = s.parent) {
        const l = s.attr("contenteditable");
        if (l === "false")
          break;
        l === "true" && (n = s);
      }
      return oe.from(n);
    }, KN = (e, n, s = e.parent) => {
      if (n.getSpecialElements()[e.name])
        e.empty().remove();
      else {
        const l = e.children();
        for (const f of l)
          s && !n.isValidChild(s.name, f.name) && KN(f, n, s);
        e.unwrap();
      }
    }, YN = (e, n, s, l = Lt) => {
      const f = n.getTextBlockElements(), b = n.getNonEmptyElements(), E = n.getWhitespaceElements(), N = rn.makeMap("tr,td,th,tbody,thead,tfoot,table,summary"), D = /* @__PURE__ */ new Set(), U = (J) => J !== s && !N[J.name];
      for (let J = 0; J < e.length; J++) {
        const te = e[J];
        let ce, Oe, Re;
        if (!te.parent || D.has(te))
          continue;
        if (f[te.name] && te.parent.name === "li") {
          let Pe = te.next;
          for (; Pe && f[Pe.name]; ) {
            Pe.name = "li", D.add(Pe), te.parent.insert(Pe, te.parent);
            Pe = Pe.next;
          }
          te.unwrap();
          continue;
        }
        const xe = [te];
        for (ce = te.parent; ce && !n.isValidChild(ce.name, te.name) && U(ce); ce = ce.parent)
          xe.push(ce);
        if (ce && xe.length > 1)
          if (QN(n, te, ce))
            KN(te, n);
          else {
            xe.reverse(), Oe = xe[0].clone(), l(Oe);
            let Pe = Oe;
            for (let Ke = 0; Ke < xe.length - 1; Ke++) {
              n.isValidChild(Pe.name, xe[Ke].name) && Ke > 0 ? (Re = xe[Ke].clone(), l(Re), Pe.append(Re)) : Re = Pe;
              for (let et = xe[Ke].firstChild; et && et !== xe[Ke + 1]; ) {
                const rt = et.next;
                Re.append(et), et = rt;
              }
              Pe = Re;
            }
            mT(n, b, E, Oe) ? ce.insert(te, xe[0], !0) : (ce.insert(Oe, xe[0], !0), ce.insert(te, Oe)), ce = xe[0], (mT(n, b, E, ce) || $M(ce, "br")) && ce.empty().remove();
          }
        else if (te.parent) {
          if (te.name === "li") {
            let Pe = te.prev;
            if (Pe && (Pe.name === "ul" || Pe.name === "ol")) {
              Pe.append(te);
              continue;
            }
            if (Pe = te.next, Pe && (Pe.name === "ul" || Pe.name === "ol") && Pe.firstChild) {
              Pe.insert(te, Pe.firstChild, !0);
              continue;
            }
            const Ke = new yd("ul", 1);
            l(Ke), te.wrap(Ke);
            continue;
          }
          if (n.isValidChild(te.parent.name, "div") && n.isValidChild("div", te.name)) {
            const Pe = new yd("div", 1);
            l(Pe), te.wrap(Pe);
          } else
            KN(te, n);
        }
      }
    }, IM = (e, n) => {
      let s = e;
      for (; s; ) {
        if (s.name === n)
          return !0;
        s = s.parent;
      }
      return !1;
    }, QN = (e, n, s = n.parent) => s ? e.children[n.name] && !e.isValidChild(s.name, n.name) || n.name === "a" && IM(s, "a") ? !0 : jG(s) && T6(n) ? !((s == null ? void 0 : s.firstChild) === n && (s == null ? void 0 : s.lastChild) === n) : !1 : !1, P6 = (e, n, s, l) => {
      const f = document.createRange();
      return f.setStart(e, n), f.setEnd(s, l), f;
    }, D6 = (e) => {
      const n = yt.fromRangeStart(e), s = yt.fromRangeEnd(e), l = e.commonAncestorContainer;
      return il(!1, l, s).map((f) => !gn(n, s, l) && gn(n, f, l) ? P6(n.container(), n.offset(), f.container(), f.offset()) : e).getOr(e);
    }, XN = (e) => e.collapsed ? e : D6(e), $6 = (e) => Ie(e.firstChild) && e.firstChild === e.lastChild, I6 = (e) => e.name === "br" || e.value === xo, MM = (e, n) => e.getBlockElements()[n.name] && $6(n) && I6(n.firstChild), JN = (e, n) => {
      const s = e.getNonEmptyElements();
      return Ie(n) && (n.isEmpty(s) || MM(e, n));
    }, eR = (e, n) => {
      let s = n.firstChild, l = n.lastChild;
      return s && s.name === "meta" && (s = s.next), l && l.attr("id") === "mce_marker" && (l = l.prev), JN(e, l) && (l = l == null ? void 0 : l.prev), !s || s !== l ? !1 : s.name === "ul" || s.name === "ol";
    }, tR = (e) => {
      var n, s;
      const l = e.firstChild, f = e.lastChild;
      return l && l.nodeName === "META" && ((n = l.parentNode) === null || n === void 0 || n.removeChild(l)), f && f.id === "mce_marker" && ((s = f.parentNode) === null || s === void 0 || s.removeChild(f)), e;
    }, M6 = (e, n, s) => {
      const l = n.serialize(s), f = e.createFragment(l);
      return tR(f);
    }, nR = (e) => {
      var n;
      return ht((n = e == null ? void 0 : e.childNodes) !== null && n !== void 0 ? n : [], (s) => s.nodeName === "LI");
    }, FM = (e) => e.data === xo || Mo(e), gO = (e) => Ie(e == null ? void 0 : e.firstChild) && e.firstChild === e.lastChild && FM(e.firstChild), LM = (e) => !e.firstChild || gO(e), F6 = (e) => e.length > 0 && LM(e[e.length - 1]) ? e.slice(0, -1) : e, K0 = (e, n) => {
      const s = e.getParent(n, e.isBlock);
      return s && s.nodeName === "LI" ? s : null;
    }, BM = (e, n) => !!K0(e, n), HM = (e, n) => {
      const s = n.cloneRange(), l = n.cloneRange();
      return s.setStartBefore(e), l.setEndAfter(e), [
        s.cloneContents(),
        l.cloneContents()
      ];
    }, vO = (e, n) => {
      const s = yt.before(e), f = ch(n).next(s);
      return f ? f.toRange() : null;
    }, a1 = (e, n) => {
      const s = yt.after(e), f = ch(n).prev(s);
      return f ? f.toRange() : null;
    }, L6 = (e, n, s, l) => {
      const f = HM(e, l), b = e.parentNode;
      return b && (b.insertBefore(f[0], e), rn.each(n, (E) => {
        b.insertBefore(E, e);
      }), b.insertBefore(f[1], e), b.removeChild(e)), a1(n[n.length - 1], s);
    }, qG = (e, n, s) => {
      const l = e.parentNode;
      return l && rn.each(n, (f) => {
        l.insertBefore(f, e);
      }), vO(e, s);
    }, B6 = (e, n, s, l) => (l.insertAfter(n.reverse(), e), a1(n[0], s)), H6 = (e, n, s, l) => {
      const f = M6(n, e, l), b = K0(n, s.startContainer), E = F6(nR(f.firstChild)), N = 1, D = 2, U = n.getRoot(), J = (te) => {
        const ce = yt.fromRangeStart(s), Oe = ch(n.getRoot()), Re = te === N ? Oe.prev(ce) : Oe.next(ce), xe = Re == null ? void 0 : Re.getNode();
        return xe ? K0(n, xe) !== b : !0;
      };
      return b ? J(N) ? qG(b, E, U) : J(D) ? B6(b, E, U, n) : L6(b, E, U, s) : null;
    }, GG = ["pre"], Oce = (e, n, s, l) => {
      var f;
      const b = n.firstChild, E = n.lastChild, N = E.attr("data-mce-type") === "bookmark" ? E.prev : E, D = b === N, U = Ge(GG, b.name);
      if (D && U) {
        const J = b.attr("contenteditable") !== "false", te = ((f = e.getParent(s, e.isBlock)) === null || f === void 0 ? void 0 : f.nodeName.toLowerCase()) === b.name, ce = oe.from(Z0(l, s)).forall(Dc);
        return J && te && ce;
      } else
        return !1;
    }, zM = $p, VM = (e, n, s) => {
      if (Ie(s)) {
        const l = e.getParent(n.endContainer, zM);
        return s === l && D_(Fe.fromDom(s), n);
      } else
        return !1;
    }, Cv = (e, n, s) => {
      var l;
      if (s.getAttribute("data-mce-bogus") === "all")
        (l = s.parentNode) === null || l === void 0 || l.insertBefore(e.dom.createFragment(n), s);
      else {
        const f = s.firstChild, b = s.lastChild;
        !f || f === b && f.nodeName === "BR" ? e.dom.setHTML(s, n) : e.selection.setContent(n, { no_events: !0 });
      }
    }, UM = (e, n, s) => {
      oe.from(e.getParent(n, "td,th")).map(Fe.fromDom).each((l) => sr(l, s));
    }, rR = (e, n) => {
      const s = e.schema.getTextInlineElements(), l = e.dom;
      if (n) {
        const f = e.getBody(), b = pO(e);
        rn.each(l.select("*[data-mce-fragment]"), (E) => {
          if (Ie(s[E.nodeName.toLowerCase()]) && tO(l, E)) {
            for (let D = E.parentElement; Ie(D) && D !== f && !uG(l, E, D); D = D.parentElement)
              if (b.compare(D, E)) {
                l.remove(E, !0);
                break;
              }
          }
        });
      }
    }, WM = (e) => {
      let n = e;
      for (; n = n.walk(); )
        n.type === 1 && n.attr("data-mce-fragment", "1");
    }, ZG = (e) => {
      rn.each(e.getElementsByTagName("*"), (n) => {
        n.removeAttribute("data-mce-fragment");
      });
    }, z6 = (e) => !!e.getAttribute("data-mce-fragment"), KG = (e, n) => Ie(n) && !e.schema.getVoidElements()[n.nodeName], V6 = (e, n) => {
      var s, l, f;
      let b;
      const E = e.dom, N = e.selection;
      if (!n)
        return;
      N.scrollIntoView(n);
      const D = Z0(e.getBody(), n);
      if (D && E.getContentEditable(D) === "false") {
        E.remove(n), N.select(D);
        return;
      }
      let U = E.createRng();
      const J = n.previousSibling;
      if (Qt(J)) {
        U.setStart(J, (l = (s = J.nodeValue) === null || s === void 0 ? void 0 : s.length) !== null && l !== void 0 ? l : 0);
        const Oe = n.nextSibling;
        Qt(Oe) && (J.appendData(Oe.data), (f = Oe.parentNode) === null || f === void 0 || f.removeChild(Oe));
      } else
        U.setStartBefore(n), U.setEndBefore(n);
      const te = (Oe) => {
        let Re = yt.fromRangeStart(Oe);
        return Re = ch(e.getBody()).next(Re), Re == null ? void 0 : Re.toRange();
      }, ce = E.getParent(n, E.isBlock);
      if (E.remove(n), ce && E.isEmpty(ce)) {
        const Oe = zM(ce);
        $u(Fe.fromDom(ce)), U.setStart(ce, 0), U.setEnd(ce, 0), !Oe && !z6(ce) && (b = te(U)) ? (U = b, E.remove(ce)) : E.add(ce, E.create("br", Oe ? {} : { "data-mce-bogus": "1" }));
      }
      N.setRng(U);
    }, jM = (e) => {
      const n = e.dom, s = XN(e.selection.getRng());
      e.selection.setRng(s);
      const l = n.getParent(s.startContainer, zM);
      VM(n, s, l) ? TM(e, s, Fe.fromDom(l)) : s.startContainer === s.endContainer && s.endOffset - s.startOffset === 1 && Qt(s.startContainer.childNodes[s.startOffset]) ? s.deleteContents() : e.getDoc().execCommand("Delete", !1);
    }, YG = (e) => {
      for (let n = e; n; n = n.walk())
        if (n.attr("id") === "mce_marker")
          return oe.some(n);
      return oe.none();
    }, U6 = (e, n, s) => {
      var l;
      return qt(s.children(), T6) && ((l = e.getParent(n, e.isBlock)) === null || l === void 0 ? void 0 : l.nodeName) === "SUMMARY";
    }, QG = (e, n, s) => {
      var l, f;
      const b = e.selection, E = e.dom, N = e.parser, D = s.merge, U = j0({ validate: !0 }, e.schema), J = '<span id="mce_marker" data-mce-type="bookmark">&#xFEFF;</span>';
      s.preserve_zwsp || (n = de(n)), n.indexOf("{$caret}") === -1 && (n += "{$caret}"), n = n.replace(/\{\$caret\}/, J);
      let te = b.getRng();
      const ce = te.startContainer, Oe = e.getBody();
      ce === Oe && b.isCollapsed() && E.isBlock(Oe.firstChild) && KG(e, Oe.firstChild) && E.isEmpty(Oe.firstChild) && (te = E.createRng(), te.setStart(Oe.firstChild, 0), te.setEnd(Oe.firstChild, 0), b.setRng(te)), b.isCollapsed() || jM(e);
      const Re = b.getNode(), xe = {
        context: Re.nodeName.toLowerCase(),
        data: s.data,
        insert: !0
      }, Pe = N.parse(n, xe);
      if (s.paste === !0 && eR(e.schema, Pe) && BM(E, Re))
        return te = H6(U, E, b.getRng(), Pe), te && b.setRng(te), n;
      s.paste === !0 && Oce(E, Pe, Re, e.getBody()) && ((l = Pe.firstChild) === null || l === void 0 || l.unwrap()), WM(Pe);
      let Ke = Pe.lastChild;
      if (Ke && Ke.attr("id") === "mce_marker") {
        const et = Ke;
        for (Ke = Ke.prev; Ke; Ke = Ke.walk(!0))
          if (Ke.type === 3 || !E.isBlock(Ke.name)) {
            Ke.parent && e.schema.isValidChild(Ke.parent.name, "span") && Ke.parent.insert(et, Ke, Ke.name === "br");
            break;
          }
      }
      if (e._selectionOverrides.showBlockCaretContainer(Re), !xe.invalid && !U6(E, Re, Pe))
        n = U.serialize(Pe), Cv(e, n, Re);
      else {
        e.selection.setContent(J);
        let et = b.getNode(), rt;
        const dt = e.getBody();
        for (Mu(et) ? et = rt = dt : rt = et; rt && rt !== dt; )
          et = rt, rt = rt.parentNode;
        n = et === dt ? dt.innerHTML : E.getOuterHTML(et);
        const Ht = N.parse(n), ln = YG(Ht), Dn = ln.bind(R6).getOr(Ht);
        ln.each((Mn) => Mn.replace(Pe));
        const Rt = Pe.children(), Tt = (f = Pe.parent) !== null && f !== void 0 ? f : Ht;
        Pe.unwrap();
        const Kt = ht(Rt, (Mn) => QN(e.schema, Mn, Tt));
        YN(Kt, e.schema, Dn), DM(N.getNodeFilters(), N.getAttributeFilters(), Ht), n = U.serialize(Ht), et === dt ? E.setHTML(dt, n) : E.setOuterHTML(et, n);
      }
      return rR(e, D), V6(e, E.get("mce_marker")), ZG(e.getBody()), UM(E, b.getStart(), e.schema), rb(e.schema, e.getBody(), b.getStart()), n;
    }, Y0 = (e) => e instanceof yd, W6 = (e) => {
      W0(e) && Wu(e.getBody()).each((n) => {
        const s = n.getNode(), l = gf(s) ? Wu(s).getOr(n) : n;
        e.selection.setRng(l.toRange());
      });
    }, qM = (e, n, s) => {
      e.dom.setHTML(e.getBody(), n), s !== !0 && W6(e);
    }, j6 = (e, n, s, l) => {
      if (s = de(s), s.length === 0 || /^\s+$/.test(s)) {
        const f = '<br data-mce-bogus="1">';
        n.nodeName === "TABLE" ? s = "<tr><td>" + f + "</td></tr>" : /^(UL|OL)$/.test(n.nodeName) && (s = "<li>" + f + "</li>");
        const b = al(e);
        return e.schema.isValidChild(n.nodeName.toLowerCase(), b.toLowerCase()) ? (s = f, s = e.dom.createHTML(b, ng(e), s)) : s || (s = f), qM(e, s, l.no_selection), {
          content: s,
          html: s
        };
      } else {
        l.format !== "raw" && (s = j0({ validate: !1 }, e.schema).serialize(e.parser.parse(s, {
          isRootContent: !0,
          insert: !0
        })));
        const f = vi(Fe.fromDom(n)) ? s : rn.trim(s);
        return qM(e, f, l.no_selection), {
          content: f,
          html: f
        };
      }
    }, XG = (e, n, s, l) => {
      DM(e.parser.getNodeFilters(), e.parser.getAttributeFilters(), s);
      const f = j0({ validate: !1 }, e.schema).serialize(s), b = de(vi(Fe.fromDom(n)) ? f : rn.trim(f));
      return qM(e, b, l.no_selection), {
        content: s,
        html: b
      };
    }, JG = (e, n, s) => oe.from(e.getBody()).map((l) => Y0(n) ? XG(e, l, n, s) : j6(e, l, n, s)).getOr({
      content: n,
      html: Y0(s.content) ? "" : s.content
    }), q6 = (e) => Ce(e) ? e : He, eZ = (e, n, s) => {
      let l = e.dom;
      const f = q6(s);
      for (; l.parentNode; ) {
        l = l.parentNode;
        const b = Fe.fromDom(l), E = n(b);
        if (E.isSome())
          return E;
        if (f(b))
          break;
      }
      return oe.none();
    }, GM = (e, n, s) => {
      const l = n(e), f = q6(s);
      return l.orThunk(() => f(e) ? oe.none() : eZ(e, n, f));
    }, oR = Wx, G6 = (e, n, s) => {
      const l = e.formatter.get(s);
      if (l)
        for (let f = 0; f < l.length; f++) {
          const b = l[f];
          if (Tl(b) && b.inherit === !1 && e.dom.is(n, b.selector))
            return !0;
        }
      return !1;
    }, bO = (e, n, s, l, f) => {
      const b = e.dom.getRoot();
      if (n === b)
        return !1;
      const E = e.dom.getParent(n, (N) => G6(e, N, s) ? !0 : N.parentNode === b || !!Zb(e, N, s, l, !0));
      return !!Zb(e, E, s, l, f);
    }, Gb = (e, n, s) => Yi(s) && oR(n, s.inline) || dh(s) && oR(n, s.block) ? !0 : Tl(s) ? Un(n) && e.is(n, s.selector) : !1, Z6 = (e, n, s, l, f, b) => {
      const E = s[l], N = l === "attributes";
      if (Ce(s.onmatch))
        return s.onmatch(n, s, l);
      if (E) {
        if (Xf(E)) {
          for (let D = 0; D < E.length; D++)
            if (N ? e.getAttrib(n, E[D]) : I0(e, n, E[D]))
              return !0;
        } else
          for (const D in E)
            if (lr(E, D)) {
              const U = N ? e.getAttrib(n, D) : I0(e, n, D), J = uh(E[D], b), te = je(U) || ei(U);
              if (te && je(J))
                continue;
              if (f && te && !s.exact || (!f || s.exact) && !oR(U, jx(J, D)))
                return !1;
            }
      }
      return !0;
    }, Zb = (e, n, s, l, f) => {
      const b = e.formatter.get(s), E = e.dom;
      if (b && Un(n))
        for (let N = 0; N < b.length; N++) {
          const D = b[N];
          if (Gb(e.dom, n, D) && Z6(E, n, D, "attributes", f, l) && Z6(E, n, D, "styles", f, l)) {
            const U = D.classes;
            if (U) {
              for (let J = 0; J < U.length; J++)
                if (!e.dom.hasClass(n, uh(U[J], l)))
                  return;
            }
            return D;
          }
        }
    }, pT = (e, n, s, l, f) => {
      if (l)
        return bO(e, l, n, s, f);
      if (l = e.selection.getNode(), bO(e, l, n, s, f))
        return !0;
      const b = e.selection.getStart();
      return !!(b !== l && bO(e, b, n, s, f));
    }, K6 = (e, n, s) => {
      const l = [], f = {}, b = e.selection.getStart();
      return e.dom.getParent(b, (E) => {
        for (let N = 0; N < n.length; N++) {
          const D = n[N];
          !f[D] && Zb(e, E, D, s) && (f[D] = !0, l.push(D));
        }
      }, e.dom.getRoot()), l;
    }, Y6 = (e, n) => {
      const s = (f) => Je(f, Fe.fromDom(e.getBody())), l = (f, b) => Zb(e, f.dom, b) ? oe.some(b) : oe.none();
      return oe.from(e.selection.getStart(!0)).bind((f) => GM(Fe.fromDom(f), (b) => qo(n, (E) => l(b, E)), s)).getOrNull();
    }, tZ = (e, n) => {
      const s = e.formatter.get(n), l = e.dom;
      if (s && e.selection.isEditable()) {
        const f = e.selection.getStart(), b = oE(l, f);
        for (let E = s.length - 1; E >= 0; E--) {
          const N = s[E];
          if (!Tl(N))
            return !0;
          for (let D = b.length - 1; D >= 0; D--)
            if (l.is(b[D], N.selector))
              return !0;
        }
      }
      return !1;
    }, Q6 = (e, n, s) => Ye(s, (l, f) => {
      const b = F_(e, f);
      return e.formatter.matchNode(n, f, {}, b) ? l.concat([f]) : l;
    }, []), yO = M, TE = (e, n) => e.importNode(n, !0), ZM = (e) => {
      if (e) {
        const n = new xs(e, e);
        for (let s = n.current(); s; s = n.next())
          if (Qt(s))
            return s;
      }
      return null;
    }, sR = (e) => {
      const n = Fe.fromTag("span");
      return ru(n, {
        id: Mx,
        "data-mce-bogus": "1",
        "data-mce-type": "format-caret"
      }), e && Ys(n, Fe.fromText(yO)), n;
    }, X6 = (e) => {
      const n = ZM(e);
      return n && n.data.charAt(0) === yO && n.deleteData(0, 1), n;
    }, hT = (e, n, s) => {
      const l = e.dom, f = e.selection;
      if (aE(n))
        s1(e, !1, Fe.fromDom(n), s, !0);
      else {
        const b = f.getRng(), E = l.getParent(n, l.isBlock), N = b.startContainer, D = b.startOffset, U = b.endContainer, J = b.endOffset, te = X6(n);
        l.remove(n, !0), N === te && D > 0 && b.setStart(te, D - 1), U === te && J > 0 && b.setEnd(te, J - 1), E && l.isEmpty(E) && vf(Fe.fromDom(E)), f.setRng(b);
      }
    }, aR = (e, n, s) => {
      const l = e.dom, f = e.selection;
      if (n)
        hT(e, n, s);
      else if (n = Ky(e.getBody(), f.getStart()), !n)
        for (; n = l.get(Mx); )
          hT(e, n, s);
    }, nZ = (e, n, s) => {
      var l, f;
      const b = e.dom, E = b.getParent(s, Ne(ac, e.schema));
      E && b.isEmpty(E) ? (l = s.parentNode) === null || l === void 0 || l.replaceChild(n, s) : (Cy(Fe.fromDom(s)), b.isEmpty(s) ? (f = s.parentNode) === null || f === void 0 || f.replaceChild(n, s) : b.insertAfter(n, s));
    }, KM = (e, n) => (e.appendChild(n), n), J6 = (e, n) => {
      var s;
      const l = bn(e, (b, E) => KM(b, E.cloneNode(!1)), n), f = (s = l.ownerDocument) !== null && s !== void 0 ? s : document;
      return KM(l, f.createTextNode(yO));
    }, rZ = (e, n, s, l, f, b) => {
      const E = e.formatter, N = e.dom, D = ht(Co(E.get()), (te) => te !== l && !Hs(te, "removeformat")), U = Q6(e, s, D);
      if (ht(U, (te) => !AI(e, te, l)).length > 0) {
        const te = s.cloneNode(!1);
        return N.add(n, te), E.remove(l, f, te, b), N.remove(te), oe.some(te);
      } else
        return oe.none();
    }, iR = (e, n, s) => {
      let l;
      const f = e.selection, b = e.formatter.get(n);
      if (!b)
        return;
      const E = f.getRng();
      let N = E.startOffset;
      const U = E.startContainer.nodeValue;
      l = Ky(e.getBody(), f.getStart());
      const J = /[^\s\u00a0\u00ad\u200b\ufeff]/;
      if (U && N > 0 && N < U.length && J.test(U.charAt(N)) && J.test(U.charAt(N - 1))) {
        const te = f.getBookmark();
        E.collapse(!0);
        let ce = hv(e.dom, E, b);
        ce = ie(ce), e.formatter.apply(n, s, ce), f.moveToBookmark(te);
      } else {
        let te = l ? ZM(l) : null;
        (!l || (te == null ? void 0 : te.data) !== yO) && (l = TE(e.getDoc(), sR(!0).dom), te = l.firstChild, E.insertNode(l), N = 1), e.formatter.apply(n, s, l), f.setCursorLocation(te, N);
      }
    }, e8 = (e, n, s, l) => {
      const f = e.dom, b = e.selection;
      let E = !1;
      const N = e.formatter.get(n);
      if (!N)
        return;
      const D = b.getRng(), U = D.startContainer, J = D.startOffset;
      let te = U;
      Qt(U) && (J !== U.data.length && (E = !0), te = te.parentNode);
      const ce = [];
      let Oe;
      for (; te; ) {
        if (Zb(e, te, n, s, l)) {
          Oe = te;
          break;
        }
        te.nextSibling && (E = !0), ce.push(te), te = te.parentNode;
      }
      if (Oe)
        if (E) {
          const Re = b.getBookmark();
          D.collapse(!0);
          let xe = hv(f, D, N, !0);
          xe = ie(xe), e.formatter.remove(n, s, xe, l), b.moveToBookmark(Re);
        } else {
          const Re = Ky(e.getBody(), Oe), xe = Ie(Re) ? f.getParents(Oe.parentNode, ut, Re) : [], Pe = sR(!1).dom;
          nZ(e, Pe, Re ?? Oe);
          const Ke = rZ(e, Pe, Oe, n, s, l), et = J6([
            ...ce,
            ...Ke.toArray(),
            ...xe
          ], Pe);
          Re && hT(e, Re, Ie(Re)), b.setCursorLocation(et, 1), f.isEmpty(Oe) && f.remove(Oe);
        }
    }, YM = (e, n, s) => {
      const l = e.selection, f = e.getBody();
      aR(e, null, s), (n === 8 || n === 46) && l.isCollapsed() && l.getStart().innerHTML === yO && aR(e, Ky(f, l.getStart()), !0), (n === 37 || n === 39) && aR(e, Ky(f, l.getStart()), !0);
    }, oZ = (e) => Qt(e) && Ac(e.data, xo), sZ = (e) => {
      e.on("mouseup keydown", (n) => {
        YM(e, n.keyCode, oZ(e.selection.getRng().endContainer));
      });
    }, QM = (e) => {
      const n = sR(!1), s = J6(e, n.dom);
      return {
        caretContainer: n,
        caretPosition: yt(s, 0)
      };
    }, cR = (e, n) => {
      const { caretContainer: s, caretPosition: l } = QM(n);
      return ba(Fe.fromDom(e), s), mo(Fe.fromDom(e)), l;
    }, t8 = (e, n) => {
      const { caretContainer: s, caretPosition: l } = QM(n);
      return e.insertNode(s.dom), l;
    }, n8 = (e, n) => {
      if (Rf(n.dom))
        return !1;
      const s = e.schema.getTextInlineElements();
      return lr(s, no(n)) && !Rf(n.dom) && !ad(n.dom);
    }, SO = {}, r8 = Ua(["pre"]), lR = (e, n) => {
      SO[e] || (SO[e] = []), SO[e].push(n);
    }, i1 = (e, n) => {
      lr(SO, e) && ke(SO[e], (s) => {
        s(n);
      });
    };
    lR("pre", (e) => {
      const n = e.selection.getRng(), s = (f) => (b) => {
        const E = b.previousSibling;
        return r8(E) && Ge(f, E);
      }, l = (f, b) => {
        const E = Fe.fromDom(b), N = er(E).dom;
        mo(E), Vo(Fe.fromDom(f), [
          Fe.fromTag("br", N),
          Fe.fromTag("br", N),
          ...ga(E)
        ]);
      };
      if (!n.collapsed) {
        const f = e.selection.getSelectedBlocks(), b = ht(ht(f, r8), s(f));
        ke(b, (E) => {
          l(E.previousSibling, E);
        });
      }
    });
    const o8 = [
      "fontWeight",
      "fontStyle",
      "color",
      "fontSize",
      "fontFamily"
    ], XM = (e) => me(e.styles) && qt(Co(e.styles), (n) => Ge(o8, n)), Qi = (e) => Bt(e, (n) => Yi(n) && n.inline === "span" && XM(n)), uR = (e, n) => {
      const s = e.get(n);
      return be(s) ? Qi(s) : oe.none();
    }, dR = (e, n) => gd(n, yt.fromRangeStart(e)).isNone(), Kb = (e, n) => yu(n, yt.fromRangeEnd(e)).exists((s) => !Mo(s.getNode()) || yu(n, s).isSome()) === !1, JM = (e) => (n) => Wg(n) && e.isEditable(n), s8 = (e) => {
      const n = e.getSelectedBlocks(), s = e.getRng();
      if (e.isCollapsed())
        return [];
      if (n.length === 1)
        return dR(s, n[0]) && Kb(s, n[0]) ? n : [];
      {
        const l = br(n).filter((E) => dR(s, E)).toArray(), f = hs(n).filter((E) => Kb(s, E)).toArray(), b = n.slice(1, -1);
        return l.concat(b).concat(f);
      }
    }, wO = (e) => ht(s8(e), JM(e.dom)), a8 = (e) => ht(e.getSelectedBlocks(), JM(e.dom)), eF = rn.each, Q0 = (e) => Un(e) && !Pf(e) && !Rf(e) && !ad(e), i8 = (e, n) => {
      for (let s = e; s; s = s[n]) {
        if (Qt(s) && $o(s.data))
          return e;
        if (Un(s) && !Pf(s))
          return s;
      }
      return e;
    }, X0 = (e, n, s) => {
      const l = pO(e), f = Ui(n) && e.dom.isEditable(n), b = Ui(s) && e.dom.isEditable(s);
      if (f && b) {
        const E = i8(n, "previousSibling"), N = i8(s, "nextSibling");
        if (l.compare(E, N)) {
          for (let D = E.nextSibling; D && D !== N; ) {
            const U = D;
            D = D.nextSibling, E.appendChild(U);
          }
          return e.dom.remove(N), rn.each(rn.grep(N.childNodes), (D) => {
            E.appendChild(D);
          }), E;
        }
      }
      return s;
    }, c8 = (e, n, s, l) => {
      var f;
      if (l && n.merge_siblings !== !1) {
        const b = (f = X0(e, Pn(l), l)) !== null && f !== void 0 ? f : l;
        X0(e, b, Pn(b, !0));
      }
    }, J0 = (e, n, s) => {
      if (n.clear_child_styles) {
        const l = n.links ? "*:not(a)" : "*";
        eF(e.select(l, s), (f) => {
          Q0(f) && e.isEditable(f) && eF(n.styles, (b, E) => {
            e.setStyle(f, E, "");
          });
        });
      }
    }, wm = (e, n, s) => {
      eF(e.childNodes, (l) => {
        Q0(l) && (n(l) && s(l), l.hasChildNodes() && wm(l, n, s));
      });
    }, fR = (e, n) => {
      n.nodeName === "SPAN" && e.getAttribs(n).length === 0 && e.remove(n, !0);
    }, mR = (e, n) => (s) => !!(s && I0(e, s, n)), l8 = (e, n, s) => (l) => {
      e.setStyle(l, n, s), l.getAttribute("style") === "" && l.removeAttribute("style"), fR(e, l);
    }, _E = hm.generate([
      { keep: [] },
      { rename: ["name"] },
      { removed: [] }
    ]), pR = /^(src|href|style)$/, tF = rn.each, Em = Wx, hR = (e) => /^(TR|TH|TD)$/.test(e.nodeName), nF = (e, n, s) => e.isChildOf(n, s) && n !== s && !e.isBlock(s), gR = (e, n, s) => {
      let l = n[s ? "startContainer" : "endContainer"], f = n[s ? "startOffset" : "endOffset"];
      if (Un(l)) {
        const b = l.childNodes.length - 1;
        !s && f && f--, l = l.childNodes[f > b ? b : f];
      }
      return Qt(l) && s && f >= l.data.length && (l = new xs(l, e.getBody()).next() || l), Qt(l) && !s && f === 0 && (l = new xs(l, e.getBody()).prev() || l), l;
    }, vR = (e, n) => {
      const s = n ? "firstChild" : "lastChild", l = e[s];
      return hR(e) && l ? e.nodeName === "TR" && l[s] || l : e;
    }, c1 = (e, n, s, l) => {
      var f;
      const b = e.create(s, l);
      return (f = n.parentNode) === null || f === void 0 || f.insertBefore(b, n), b.appendChild(n), b;
    }, bR = (e, n, s, l, f) => {
      const b = Fe.fromDom(n), E = Fe.fromDom(e.create(l, f)), N = s ? oi(b) : Bg(b);
      return Vo(E, N), s ? (ba(b, E), od(E, b)) : (tl(b, E), Ys(E, b)), E.dom;
    }, aZ = (e, n) => n.links && e.nodeName === "A", rF = (e, n, s) => {
      const l = n.parentNode;
      let f;
      const b = e.dom, E = al(e);
      dh(s) && l === b.getRoot() && (!s.list_block || !Em(n, s.list_block)) && ke(Ps(n.childNodes), (N) => {
        pv(e, E, N.nodeName.toLowerCase()) ? f ? f.appendChild(N) : (f = c1(b, N, E), b.setAttribs(f, ng(e))) : f = null;
      }), !(Gx(s) && !Em(s.inline, n)) && b.remove(n, !0);
    }, u8 = (e, n, s) => pt(e) ? {
      name: n,
      value: null
    } : {
      name: e,
      value: uh(n, s)
    }, d8 = (e, n) => {
      e.getAttrib(n, "style") === "" && (n.removeAttribute("style"), n.removeAttribute("data-mce-style"));
    }, f8 = (e, n, s, l, f) => {
      let b = !1;
      tF(s.styles, (E, N) => {
        const {
          name: D,
          value: U
        } = u8(N, E, l), J = jx(U, D);
        (s.remove_similar || q(U) || !Un(f) || Em(I0(e, f, D), J)) && e.setStyle(n, D, ""), b = !0;
      }), b && d8(e, n);
    }, iZ = (e, n, s) => {
      n === "removeformat" ? ke(a8(e.selection), (l) => {
        ke(o8, (f) => e.dom.setStyle(l, f, "")), d8(e.dom, l);
      }) : uR(e.formatter, n).each((l) => {
        ke(a8(e.selection), (f) => f8(e.dom, f, l, s, null));
      });
    }, gT = (e, n, s, l, f) => {
      const b = e.dom, E = pO(e), N = e.schema;
      if (Yi(n) && ob(N, n.inline) && Jr(N, l) && l.parentElement === e.getBody())
        return rF(e, l, n), _E.removed();
      if (!n.ceFalseOverride && l && b.getContentEditableParent(l) === "false" || l && !Gb(b, l, n) && !aZ(l, n))
        return _E.keep();
      const D = l, U = n.preserve_attributes;
      if (Yi(n) && n.remove === "all" && be(U)) {
        const J = ht(b.getAttribs(D), (te) => Ge(U, te.name.toLowerCase()));
        if (b.removeAllAttribs(D), ke(J, (te) => b.setAttrib(D, te.name, te.value)), J.length > 0)
          return _E.rename("span");
      }
      if (n.remove !== "all") {
        f8(b, D, n, s, f), tF(n.attributes, (te, ce) => {
          const {
            name: Oe,
            value: Re
          } = u8(ce, te, s);
          if (n.remove_similar || q(Re) || !Un(f) || Em(b.getAttrib(f, Oe), Re)) {
            if (Oe === "class") {
              const xe = b.getAttrib(D, Oe);
              if (xe) {
                let Pe = "";
                if (ke(xe.split(/\s+/), (Ke) => {
                  /mce\-\w+/.test(Ke) && (Pe += (Pe ? " " : "") + Ke);
                }), Pe) {
                  b.setAttrib(D, Oe, Pe);
                  return;
                }
              }
            }
            if (pR.test(Oe) && D.removeAttribute("data-mce-" + Oe), Oe === "style" && Ua(["li"])(D) && b.getStyle(D, "list-style-type") === "none") {
              D.removeAttribute(Oe), b.setStyle(D, "list-style-type", "none");
              return;
            }
            Oe === "class" && D.removeAttribute("className"), D.removeAttribute(Oe);
          }
        }), tF(n.classes, (te) => {
          te = uh(te, s), (!Un(f) || b.hasClass(f, te)) && b.removeClass(D, te);
        });
        const J = b.getAttribs(D);
        for (let te = 0; te < J.length; te++) {
          const ce = J[te].nodeName;
          if (!E.isAttributeInternal(ce))
            return _E.keep();
        }
      }
      return n.remove !== "none" ? (rF(e, D, n), _E.removed()) : _E.keep();
    }, cZ = (e, n, s, l, f) => {
      let b;
      return n.parentNode && ke(oE(e.dom, n.parentNode).reverse(), (E) => {
        if (!b && Un(E) && E.id !== "_start" && E.id !== "_end") {
          const N = Zb(e, E, s, l, f);
          N && N.split !== !1 && (b = E);
        }
      }), b;
    }, m8 = (e, n, s, l) => gT(e, n, s, l, l).fold(at(l), (f) => (e.dom.createFragment().appendChild(l), e.dom.rename(l, f)), at(null)), oF = (e, n, s, l, f, b, E, N) => {
      var D, U;
      let J, te;
      const ce = e.dom;
      if (s) {
        const Oe = s.parentNode;
        for (let Re = l.parentNode; Re && Re !== Oe; Re = Re.parentNode) {
          let xe = ce.clone(Re, !1);
          for (let Pe = 0; Pe < n.length && (xe = m8(e, n[Pe], N, xe), xe !== null); Pe++)
            ;
          xe && (J && xe.appendChild(J), te || (te = xe), J = xe);
        }
        b && (!E.mixed || !ce.isBlock(s)) && (l = (D = ce.split(s, l)) !== null && D !== void 0 ? D : l), J && te && ((U = f.parentNode) === null || U === void 0 || U.insertBefore(J, f), te.appendChild(f), Yi(E) && c8(e, E, N, J));
      }
      return l;
    }, lZ = (e, n, s, l, f) => {
      const b = e.formatter.get(n), E = b[0], N = e.dom, D = e.selection, U = (xe) => {
        const Pe = cZ(e, xe, n, s, f);
        return oF(e, b, Pe, xe, xe, !0, E, s);
      }, J = (xe) => Pf(xe) && Un(xe) && (xe.id === "_start" || xe.id === "_end"), te = (xe) => qt(b, (Pe) => vT(e, Pe, s, xe, xe)), ce = (xe) => {
        const Pe = Ps(xe.childNodes), et = te(xe) || qt(b, (Ht) => Gb(N, xe, Ht)), rt = xe.parentNode;
        if (!et && Ie(rt) && sE(E) && te(rt), E.deep && Pe.length)
          for (let Ht = 0; Ht < Pe.length; Ht++)
            ce(Pe[Ht]);
        ke([
          "underline",
          "line-through",
          "overline"
        ], (Ht) => {
          Un(xe) && e.dom.getStyle(xe, "text-decoration") === Ht && xe.parentNode && sN(N, xe.parentNode) === Ht && vT(e, {
            deep: !1,
            exact: !0,
            inline: "span",
            styles: { textDecoration: Ht }
          }, void 0, xe);
        });
      }, Oe = (xe) => {
        const Pe = N.get(xe ? "_start" : "_end");
        if (Pe) {
          let Ke = Pe[xe ? "firstChild" : "lastChild"];
          return J(Ke) && (Ke = Ke[xe ? "firstChild" : "lastChild"]), Qt(Ke) && Ke.data.length === 0 && (Ke = xe ? Pe.previousSibling || Pe.nextSibling : Pe.nextSibling || Pe.previousSibling), N.remove(Pe, !0), Ke;
        } else
          return null;
      }, Re = (xe) => {
        let Pe, Ke, et = hv(N, xe, b, xe.collapsed);
        if (E.split) {
          if (et = ie(et), Pe = gR(e, et, !0), Ke = gR(e, et), Pe !== Ke) {
            if (Pe = vR(Pe, !0), Ke = vR(Ke, !1), nF(N, Pe, Ke)) {
              const dt = oe.from(Pe.firstChild).getOr(Pe);
              U(bR(N, dt, !0, "span", {
                id: "_start",
                "data-mce-type": "bookmark"
              })), Oe(!0);
              return;
            }
            if (nF(N, Ke, Pe)) {
              const dt = oe.from(Ke.lastChild).getOr(Ke);
              U(bR(N, dt, !1, "span", {
                id: "_end",
                "data-mce-type": "bookmark"
              })), Oe(!1);
              return;
            }
            Pe = c1(N, Pe, "span", {
              id: "_start",
              "data-mce-type": "bookmark"
            }), Ke = c1(N, Ke, "span", {
              id: "_end",
              "data-mce-type": "bookmark"
            });
            const rt = N.createRng();
            rt.setStartAfter(Pe), rt.setEndBefore(Ke), dE(N, rt, (dt) => {
              ke(dt, (Ht) => {
                !Pf(Ht) && !Pf(Ht.parentNode) && U(Ht);
              });
            }), U(Pe), U(Ke), Pe = Oe(!0), Ke = Oe();
          } else
            Pe = Ke = U(Pe);
          et.startContainer = Pe.parentNode ? Pe.parentNode : Pe, et.startOffset = N.nodeIndex(Pe), et.endContainer = Ke.parentNode ? Ke.parentNode : Ke, et.endOffset = N.nodeIndex(Ke) + 1;
        }
        dE(N, et, (rt) => {
          ke(rt, ce);
        });
      };
      if (l) {
        if (tE(l)) {
          const xe = N.createRng();
          xe.setStartBefore(l), xe.setEndAfter(l), Re(xe);
        } else
          Re(l);
        Jy(e, n, l, s);
        return;
      }
      !D.isCollapsed() || !Yi(E) || $0(e).length ? (nE(e, () => Vb(e, Re), (xe) => Yi(E) && pT(e, n, s, xe)), e.nodeChanged()) : e8(e, n, s, f), iZ(e, n, s), Jy(e, n, l, s);
    }, sF = (e, n, s, l, f) => {
      (l || e.selection.isEditable()) && lZ(e, n, s, l, f);
    }, vT = (e, n, s, l, f) => gT(e, n, s, l, f).fold(He, (b) => (e.dom.rename(l, b), !0), ut), p8 = rn.each, uZ = (e, n, s, l) => {
      const f = (b) => {
        if (Ui(b) && Un(b.parentNode) && e.isEditable(b)) {
          const E = sN(e, b.parentNode);
          e.getStyle(b, "color") && E ? e.setStyle(b, "text-decoration", E) : e.getStyle(b, "text-decoration") === E && e.setStyle(b, "text-decoration", null);
        }
      };
      n.styles && (n.styles.color || n.styles.textDecoration) && (rn.walk(l, f, "childNodes"), f(l));
    }, dZ = (e, n, s, l) => {
      if (n.styles && n.styles.backgroundColor) {
        const f = mR(e, "fontSize");
        wm(l, (b) => f(b) && e.isEditable(b), l8(e, "backgroundColor", uh(n.styles.backgroundColor, s)));
      }
    }, fZ = (e, n, s, l) => {
      if (Yi(n) && (n.inline === "sub" || n.inline === "sup")) {
        const f = mR(e, "fontSize");
        wm(l, (E) => f(E) && e.isEditable(E), l8(e, "fontSize", ""));
        const b = ht(e.select(n.inline === "sup" ? "sub" : "sup", l), e.isEditable);
        e.remove(b, !0);
      }
    }, mZ = (e, n, s, l) => {
      p8(n, (f) => {
        Yi(f) && p8(e.dom.select(f.inline, l), (b) => {
          Q0(b) && vT(e, f, s, b, f.exact ? b : null);
        }), J0(e.dom, f, l);
      });
    }, pZ = (e, n, s, l, f) => {
      const b = f.parentNode;
      Zb(e, b, s, l) && vT(e, n, l, f) || n.merge_with_parents && b && e.dom.getParent(b, (E) => Zb(e, E, s, l) ? (vT(e, n, l, f), !0) : !1);
    }, yR = rn.each, hZ = (e, n, s, l) => {
      if (bx(e) && Yi(n) && s.parentNode) {
        const f = GC(e.schema), b = WN(Fe.fromDom(s), (E) => Rf(E.dom));
        return Ei(f, l) && Na(Fe.fromDom(s.parentNode), !1) && !b;
      } else
        return !1;
    }, h8 = (e, n, s, l) => {
      if (yR(s.styles, (f, b) => {
        e.setStyle(n, b, uh(f, l));
      }), s.styles) {
        const f = e.getAttrib(n, "style");
        f && e.setAttrib(n, "data-mce-style", f);
      }
    }, gZ = (e, n, s, l) => {
      const f = e.formatter.get(n), b = f[0], E = !l && e.selection.isCollapsed(), N = e.dom, D = e.selection, U = (Re, xe = b) => {
        Ce(xe.onformat) && xe.onformat(Re, xe, s, l), h8(N, Re, xe, s), yR(xe.attributes, (Pe, Ke) => {
          N.setAttrib(Re, Ke, uh(Pe, s));
        }), yR(xe.classes, (Pe) => {
          const Ke = uh(Pe, s);
          N.hasClass(Re, Ke) || N.addClass(Re, Ke);
        });
      }, J = (Re, xe) => {
        let Pe = !1;
        return yR(Re, (Ke) => Tl(Ke) ? N.getContentEditable(xe) === "false" && !Ke.ceFalseOverride || Ie(Ke.collapsed) && Ke.collapsed !== E ? !0 : N.is(xe, Ke.selector) && !Rf(xe) ? (U(xe, Ke), Pe = !0, !1) : !0 : !1), Pe;
      }, te = (Re) => {
        if (G(Re)) {
          const xe = N.create(Re);
          return U(xe), xe;
        } else
          return null;
      }, ce = (Re, xe, Pe) => {
        const Ke = [];
        let et = !0;
        const rt = b.inline || b.block, dt = te(rt), Ht = (Rt) => qx(b) && Zb(e, Rt, n, s), ln = (Rt, Tt, Kt) => {
          const Mn = M0(b) && ac(e.schema, Rt) && pv(e, Tt, rt);
          return Kt && Mn;
        }, Dn = (Rt, Tt, Kt, Mn) => {
          const rr = Rt.nodeName.toLowerCase(), Fr = pv(e, rt, rr) && pv(e, Tt, rt), so = !Pe && Qt(Rt) && W(Rt.data), Cs = Rf(Rt), Xs = !Yi(b) || !Re.isBlock(Rt);
          return (Kt || Mn) && Fr && !so && !Cs && Xs;
        };
        dE(Re, xe, (Rt) => {
          let Tt;
          const Kt = (Mn) => {
            let rr = !1, Fr = et, so = !1;
            const Cs = Mn.parentNode, Xs = Cs.nodeName.toLowerCase(), Si = Re.getContentEditable(Mn);
            Ie(Si) && (Fr = et, et = Si === "true", rr = !0, so = rE(e, Mn));
            const Kl = et && !rr;
            if (Mo(Mn) && !hZ(e, b, Mn, Xs)) {
              Tt = null, dh(b) && Re.remove(Mn);
              return;
            }
            if (Ht(Mn)) {
              Tt = null;
              return;
            }
            if (ln(Mn, Xs, Kl)) {
              const ll = Re.rename(Mn, rt);
              U(ll), Ke.push(ll), Tt = null;
              return;
            }
            if (Tl(b)) {
              let ll = J(f, Mn);
              if (!ll && Ie(Cs) && sE(b) && (ll = J(f, Cs)), !Yi(b) || ll) {
                Tt = null;
                return;
              }
            }
            Ie(dt) && Dn(Mn, Xs, Kl, so) ? (Tt || (Tt = Re.clone(dt, !1), Cs.insertBefore(Tt, Mn), Ke.push(Tt)), so && rr && (et = Fr), Tt.appendChild(Mn)) : (Tt = null, ke(Ps(Mn.childNodes), Kt), rr && (et = Fr), Tt = null);
          };
          ke(Rt, Kt);
        }), b.links === !0 && ke(Ke, (Rt) => {
          const Tt = (Kt) => {
            Kt.nodeName === "A" && U(Kt, b), ke(Ps(Kt.childNodes), Tt);
          };
          Tt(Rt);
        }), ke(Ke, (Rt) => {
          const Tt = (rr) => {
            let Fr = 0;
            return ke(rr.childNodes, (so) => {
              !bm(so) && !Pf(so) && Fr++;
            }), Fr;
          }, Kt = (rr) => Bt(rr.childNodes, I_).filter((so) => Re.getContentEditable(so) !== "false" && Gb(Re, so, b)).map((so) => {
            const Cs = Re.clone(so, !1);
            return U(Cs), Re.replace(Cs, rr, !0), Re.remove(so, !0), Cs;
          }).getOr(rr), Mn = Tt(Rt);
          if ((Ke.length > 1 || !Re.isBlock(Rt)) && Mn === 0) {
            Re.remove(Rt, !0);
            return;
          }
          (Yi(b) || dh(b) && b.wrapper) && (!b.exact && Mn === 1 && (Rt = Kt(Rt)), mZ(e, f, s, Rt), pZ(e, b, n, s, Rt), dZ(Re, b, s, Rt), uZ(Re, b, s, Rt), fZ(Re, b, s, Rt), c8(e, b, s, Rt));
        });
      }, Oe = tE(l) ? l : D.getNode();
      if (N.getContentEditable(Oe) === "false" && !rE(e, Oe)) {
        l = Oe, J(f, l), ql(e, n, l, s);
        return;
      }
      if (b) {
        if (l)
          if (tE(l)) {
            if (!J(f, l)) {
              const Re = N.createRng();
              Re.setStartBefore(l), Re.setEndAfter(l), ce(N, hv(N, Re, f), !0);
            }
          } else
            ce(N, l, !0);
        else
          !E || !Yi(b) || $0(e).length ? (D.setRng(XN(D.getRng())), nE(e, () => {
            Vb(e, (Re, xe) => {
              const Pe = xe ? Re : hv(N, Re, f);
              ce(N, Pe, !1);
            });
          }, ut), e.nodeChanged()) : iR(e, n, s), uR(e.formatter, n).each((Re) => {
            ke(wO(e.selection), (xe) => h8(N, xe, Re, s));
          });
        i1(n, e);
      }
      ql(e, n, l, s);
    }, g8 = (e, n, s, l) => {
      (l || e.selection.isEditable()) && gZ(e, n, s, l);
    }, v8 = (e) => lr(e, "vars"), vZ = (e, n) => {
      e.set({}), n.on("NodeChange", (s) => {
        y8(n, s.element, e.get());
      }), n.on("FormatApply FormatRemove", (s) => {
        const l = oe.from(s.node).map((f) => tE(f) ? f : f.startContainer).bind((f) => Un(f) ? oe.some(f) : oe.from(f.parentElement)).getOrThunk(() => aF(n));
        y8(n, l, e.get());
      });
    }, aF = (e) => e.selection.getStart(), b8 = (e, n, s, l, f) => nn(n, (N) => {
      const D = e.formatter.matchNode(N, s, f ?? {}, l);
      return !Le(D);
    }, (N) => G6(e, N, s) ? !0 : l ? !1 : Ie(e.formatter.matchNode(N, s, f, !0))), OE = (e, n) => {
      const s = n ?? aF(e);
      return ht(oE(e.dom, s), (l) => Un(l) && !ad(l));
    }, y8 = (e, n, s) => {
      const l = OE(e, n);
      fn(s, (f, b) => {
        const E = (N) => {
          const D = b8(e, l, b, N.similar, v8(N) ? N.vars : void 0), U = D.isSome();
          if (N.state.get() !== U) {
            N.state.set(U);
            const J = D.getOr(n);
            v8(N) ? N.callback(U, {
              node: J,
              format: b,
              parents: l
            }) : ke(N.callbacks, (te) => te(U, {
              node: J,
              format: b,
              parents: l
            }));
          }
        };
        ke([
          f.withSimilar,
          f.withoutSimilar
        ], E), ke(f.withVars, E);
      });
    }, bZ = (e, n, s, l, f, b) => {
      const E = n.get();
      ke(s.split(","), (N) => {
        const D = gs(E, N).getOrThunk(() => {
          const J = {
            withSimilar: {
              state: wa(!1),
              similar: !0,
              callbacks: []
            },
            withoutSimilar: {
              state: wa(!1),
              similar: !1,
              callbacks: []
            },
            withVars: []
          };
          return E[N] = J, J;
        }), U = () => {
          const J = OE(e);
          return b8(e, J, N, f, b).isSome();
        };
        if (Le(b)) {
          const J = f ? D.withSimilar : D.withoutSimilar;
          J.callbacks.push(l), J.callbacks.length === 1 && J.state.set(U());
        } else
          D.withVars.push({
            state: wa(U()),
            similar: f,
            vars: b,
            callback: l
          });
      }), n.set(E);
    }, yZ = (e, n, s) => {
      const l = e.get();
      ke(n.split(","), (f) => gs(l, f).each((b) => {
        l[f] = {
          withSimilar: {
            ...b.withSimilar,
            callbacks: ht(b.withSimilar.callbacks, (E) => E !== s)
          },
          withoutSimilar: {
            ...b.withoutSimilar,
            callbacks: ht(b.withoutSimilar.callbacks, (E) => E !== s)
          },
          withVars: ht(b.withVars, (E) => E.callback !== s)
        };
      })), e.set(l);
    }, SZ = (e, n, s, l, f, b) => (bZ(e, n, s, l, f, b), { unbind: () => yZ(n, s, l) }), S8 = (e, n, s, l) => {
      const f = e.formatter.get(n);
      f && (pT(e, n, s, l) && (!("toggle" in f[0]) || f[0].toggle) ? sF(e, n, s, l) : g8(e, n, s, l));
    }, w8 = rn.explode, E8 = () => {
      const e = {};
      return {
        addFilter: (f, b) => {
          ke(w8(f), (E) => {
            lr(e, E) || (e[E] = {
              name: E,
              callbacks: []
            }), e[E].callbacks.push(b);
          });
        },
        getFilters: () => Xl(e),
        removeFilter: (f, b) => {
          ke(w8(f), (E) => {
            if (lr(e, E))
              if (Ie(b)) {
                const N = e[E], D = ht(N.callbacks, (U) => U !== b);
                D.length > 0 ? N.callbacks = D : delete e[E];
              } else
                delete e[E];
          });
        }
      };
    }, wZ = (e, n) => {
      ke(n, (s) => {
        e.attr(s, null);
      });
    }, EZ = (e, n, s) => {
      e.addNodeFilter("font", (l) => {
        ke(l, (f) => {
          const b = n.parse(f.attr("style")), E = f.attr("color"), N = f.attr("face"), D = f.attr("size");
          E && (b.color = E), N && (b["font-family"] = N), D && td(D).each((U) => {
            b["font-size"] = s[U - 1];
          }), f.name = "span", f.attr("style", n.serialize(b)), wZ(f, [
            "color",
            "face",
            "size"
          ]);
        });
      });
    }, CZ = (e, n, s) => {
      e.addNodeFilter("strike", (l) => {
        const f = n.type !== "html4";
        ke(l, (b) => {
          if (f)
            b.name = "s";
          else {
            const E = s.parse(b.attr("style"));
            E["text-decoration"] = "line-through", b.name = "span", b.attr("style", s.serialize(E));
          }
        });
      });
    }, xZ = (e, n, s) => {
      var l;
      const f = qm();
      n.convert_fonts_to_spans && EZ(e, f, rn.explode((l = n.font_size_legacy_values) !== null && l !== void 0 ? l : "")), CZ(e, s, f);
    }, TZ = (e, n, s) => {
      n.inline_styles && xZ(e, n, s);
    }, C8 = (e, n, s) => {
      n.addNodeFilter("br", (l, f, b) => {
        const E = rn.extend({}, s.getBlockElements()), N = s.getNonEmptyElements(), D = s.getWhitespaceElements();
        E.body = 1;
        const U = (J) => J.name in E || Ef(s, J);
        for (let J = 0, te = l.length; J < te; J++) {
          let ce = l[J], Oe = ce.parent;
          if (Oe && U(Oe) && ce === Oe.lastChild) {
            let Re = ce.prev;
            for (; Re; ) {
              const xe = Re.name;
              if (xe !== "span" || Re.attr("data-mce-type") !== "bookmark") {
                xe === "br" && (ce = null);
                break;
              }
              Re = Re.prev;
            }
            if (ce && (ce.remove(), mT(s, N, D, Oe))) {
              const xe = s.getElementRule(Oe.name);
              xe && (xe.removeEmpty ? Oe.remove() : xe.paddEmpty && ZN(e, b, U, Oe));
            }
          } else {
            let Re = ce;
            for (; Oe && Oe.firstChild === Re && Oe.lastChild === Re && (Re = Oe, !E[Oe.name]); )
              Oe = Oe.parent;
            if (Re === Oe) {
              const xe = new yd("#text", 3);
              xe.value = xo, ce.replace(xe);
            }
          }
        }
      });
    }, _Z = (e) => fetch(e).then((n) => n.ok ? n.blob() : Promise.reject()).catch(() => Promise.reject({
      message: `Cannot convert ${e} to Blob. Resource might not exist or is inaccessible.`,
      uriType: "blob"
    })), OZ = (e) => {
      const n = /([a-z0-9+\/=\s]+)/i.exec(e);
      return n ? n[1] : "";
    }, EO = (e) => {
      const [n, ...s] = e.split(","), l = s.join(","), f = /data:([^/]+\/[^;]+)(;.+)?/.exec(n);
      if (f) {
        const b = f[2] === ";base64", E = b ? OZ(l) : decodeURIComponent(l);
        return oe.some({
          type: f[1],
          data: E,
          base64Encoded: b
        });
      } else
        return oe.none();
    }, iF = (e, n, s = !0) => {
      let l = n;
      if (s)
        try {
          l = atob(n);
        } catch {
          return oe.none();
        }
      const f = new Uint8Array(l.length);
      for (let b = 0; b < f.length; b++)
        f[b] = l.charCodeAt(b);
      return oe.some(new Blob([f], { type: e }));
    }, Ace = (e) => new Promise((n, s) => {
      EO(e).bind(({ type: l, data: f, base64Encoded: b }) => iF(l, f, b)).fold(() => s("Invalid data URI"), n);
    }), CO = (e) => Gs(e, "blob:") ? _Z(e) : Gs(e, "data:") ? Ace(e) : Promise.reject("Unknown URI format"), cF = (e) => new Promise((n, s) => {
      const l = new FileReader();
      l.onloadend = () => {
        n(l.result);
      }, l.onerror = () => {
        var f;
        s((f = l.error) === null || f === void 0 ? void 0 : f.message);
      }, l.readAsDataURL(e);
    });
    let xO = 0;
    const TO = (e) => (e || "blobid") + xO++, lF = (e, n, s) => EO(e).bind(({ data: l, type: f, base64Encoded: b }) => {
      if (n && !b)
        return oe.none();
      {
        const E = b ? l : btoa(l);
        return s(E, f);
      }
    }), AZ = (e, n, s) => {
      const l = e.create(TO(), n, s);
      return e.add(l), l;
    }, x8 = (e, n, s = !1) => lF(n, s, (l, f) => oe.from(e.getByData(l, f)).orThunk(() => iF(f, l).map((b) => AZ(e, b, l)))), kce = (e, n) => {
      const s = () => Promise.reject("Invalid data URI");
      if (Gs(n, "blob:")) {
        const l = e.getByUri(n);
        return Ie(l) ? Promise.resolve(l) : CO(n).then((f) => cF(f).then((b) => lF(b, !1, (E) => oe.some(AZ(e, f, E))).getOrThunk(s)));
      } else
        return Gs(n, "data:") ? x8(e, n).fold(s, (l) => Promise.resolve(l)) : Promise.reject("Unknown image data format");
    }, kZ = (e) => Ie(e.attr("data-mce-bogus")), NZ = (e) => e.attr("src") === kn.transparentSrc || Ie(e.attr("data-mce-placeholder")), Nce = (e, n) => {
      const { blob_cache: s } = n;
      if (s) {
        const l = (f) => {
          const b = f.attr("src");
          NZ(f) || kZ(f) || je(b) || x8(s, b, !0).each((E) => {
            f.attr("src", E.blobUri());
          });
        };
        e.addAttributeFilter("src", (f) => ke(f, l));
      }
    }, uF = (e, n) => Gs(e, `${n}/`), T8 = (e, n, s, l, f) => {
      let b;
      Le(e) ? b = "iframe" : uF(e, "image") ? b = "img" : uF(e, "video") ? b = "video" : uF(e, "audio") ? b = "audio" : b = "iframe";
      const E = new yd(b, 1);
      return E.attr(b === "audio" ? { src: n } : {
        src: n,
        width: s,
        height: l
      }), (b === "audio" || b === "video") && E.attr("controls", ""), b === "iframe" && f && E.attr("sandbox", ""), E;
    }, RZ = (e, n) => {
      const s = e.schema;
      n.remove_trailing_brs && C8(n, e, s), e.addAttributeFilter("href", (f) => {
        let b = f.length;
        const E = (D) => D.split(" ").filter((J) => J.length > 0).concat(["noopener"]).sort().join(" "), N = (D) => {
          const U = D ? rn.trim(D) : "";
          return /\b(noopener)\b/g.test(U) ? U : E(U);
        };
        if (!n.allow_unsafe_link_target)
          for (; b--; ) {
            const D = f[b];
            D.name === "a" && D.attr("target") === "_blank" && D.attr("rel", N(D.attr("rel")));
          }
      }), n.allow_html_in_named_anchor || e.addAttributeFilter("id,name", (f) => {
        let b = f.length, E, N, D, U;
        for (; b--; )
          if (U = f[b], U.name === "a" && U.firstChild && !U.attr("href"))
            for (D = U.parent, E = U.lastChild; E && D; )
              N = E.prev, D.insert(E, U), E = N;
      }), n.fix_list_elements && e.addNodeFilter("ul,ol", (f) => {
        let b = f.length, E, N;
        for (; b--; )
          if (E = f[b], N = E.parent, N && (N.name === "ul" || N.name === "ol"))
            if (E.prev && E.prev.name === "li")
              E.prev.append(E);
            else {
              const D = new yd("li", 1);
              D.attr("style", "list-style-type: none"), E.wrap(D);
            }
      });
      const l = s.getValidClasses();
      n.validate && l && e.addAttributeFilter("class", (f) => {
        var b;
        let E = f.length;
        for (; E--; ) {
          const N = f[E], D = (b = N.attr("class")) !== null && b !== void 0 ? b : "", U = rn.explode(D, " ");
          let J = "";
          for (let te = 0; te < U.length; te++) {
            const ce = U[te];
            let Oe = !1, Re = l["*"];
            Re && Re[ce] && (Oe = !0), Re = l[N.name], !Oe && Re && Re[ce] && (Oe = !0), Oe && (J && (J += " "), J += ce);
          }
          J.length || (J = null), N.attr("class", J);
        }
      }), Nce(e, n), n.convert_unsafe_embeds && e.addNodeFilter("object,embed", (f) => ke(f, (b) => {
        b.replace(T8(b.attr("type"), b.name === "object" ? b.attr("data") : b.attr("src"), b.attr("width"), b.attr("height"), n.sandbox_iframes));
      })), n.sandbox_iframes && e.addNodeFilter("iframe", (f) => ke(f, (b) => b.attr("sandbox", "")));
    };
    /*! @license DOMPurify 3.1.7 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.1.7/LICENSE */
    const {
      entries: dF,
      setPrototypeOf: _8,
      isFrozen: SR,
      getPrototypeOf: O8,
      getOwnPropertyDescriptor: Bc
    } = Object;
    let {
      freeze: ap,
      seal: xv,
      create: PZ
    } = Object, {
      apply: A8,
      construct: ip
    } = typeof Reflect < "u" && Reflect;
    ap || (ap = function(n) {
      return n;
    }), xv || (xv = function(n) {
      return n;
    }), A8 || (A8 = function(n, s, l) {
      return n.apply(s, l);
    }), ip || (ip = function(n, s) {
      return new n(...s);
    });
    const AE = gh(Array.prototype.forEach), l1 = gh(Array.prototype.pop), pg = gh(Array.prototype.push), wR = gh(String.prototype.toLowerCase), fF = gh(String.prototype.toString), kE = gh(String.prototype.match), Yb = gh(String.prototype.replace), bT = gh(String.prototype.indexOf), k8 = gh(String.prototype.trim), hh = gh(Object.prototype.hasOwnProperty), Ff = gh(RegExp.prototype.test), yT = DZ(TypeError);
    function gh(e) {
      return function(n) {
        for (var s = arguments.length, l = new Array(s > 1 ? s - 1 : 0), f = 1; f < s; f++)
          l[f - 1] = arguments[f];
        return A8(e, n, l);
      };
    }
    function DZ(e) {
      return function() {
        for (var n = arguments.length, s = new Array(n), l = 0; l < n; l++)
          s[l] = arguments[l];
        return ip(e, s);
      };
    }
    function qs(e, n) {
      let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : wR;
      _8 && _8(e, null);
      let l = n.length;
      for (; l--; ) {
        let f = n[l];
        if (typeof f == "string") {
          const b = s(f);
          b !== f && (SR(n) || (n[l] = b), f = b);
        }
        e[f] = !0;
      }
      return e;
    }
    function $Z(e) {
      for (let n = 0; n < e.length; n++)
        hh(e, n) || (e[n] = null);
      return e;
    }
    function NE(e) {
      const n = PZ(null);
      for (const [s, l] of dF(e))
        hh(e, s) && (Array.isArray(l) ? n[s] = $Z(l) : l && typeof l == "object" && l.constructor === Object ? n[s] = NE(l) : n[s] = l);
      return n;
    }
    function _O(e, n) {
      for (; e !== null; ) {
        const l = Bc(e, n);
        if (l) {
          if (l.get)
            return gh(l.get);
          if (typeof l.value == "function")
            return gh(l.value);
        }
        e = O8(e);
      }
      function s() {
        return null;
      }
      return s;
    }
    const N8 = ap(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), mF = ap(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), ER = ap(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), IZ = ap(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), RE = ap(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), R8 = ap(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), P8 = ap(["#text"]), pF = ap(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), hF = ap(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), gF = ap(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), CR = ap(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), MZ = xv(/\{\{[\w\W]*|[\w\W]*\}\}/gm), D8 = xv(/<%[\w\W]*|[\w\W]*%>/gm), $8 = xv(/\${[\w\W]*}/gm), I8 = xv(/^data-[\-\w.\u00B7-\uFFFF]/), M8 = xv(/^aria-[\-\w]+$/), vF = xv(
      /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
      // eslint-disable-line no-useless-escape
    ), F8 = xv(/^(?:\w+script|data):/i), FZ = xv(
      /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
      // eslint-disable-line no-control-regex
    ), L8 = xv(/^html$/i), LZ = xv(/^[a-z][.\w]*(-[.\w]+)+$/i);
    var xR = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      MUSTACHE_EXPR: MZ,
      ERB_EXPR: D8,
      TMPLIT_EXPR: $8,
      DATA_ATTR: I8,
      ARIA_ATTR: M8,
      IS_ALLOWED_URI: vF,
      IS_SCRIPT_OR_DATA: F8,
      ATTR_WHITESPACE: FZ,
      DOCTYPE_NAME: L8,
      CUSTOM_ELEMENT: LZ
    });
    const u1 = {
      element: 1,
      attribute: 2,
      text: 3,
      cdataSection: 4,
      entityReference: 5,
      // Deprecated
      entityNode: 6,
      // Deprecated
      progressingInstruction: 7,
      comment: 8,
      document: 9,
      documentType: 10,
      documentFragment: 11,
      notation: 12
      // Deprecated
    }, B8 = function() {
      return typeof window > "u" ? null : window;
    }, H8 = function(n, s) {
      if (typeof n != "object" || typeof n.createPolicy != "function")
        return null;
      let l = null;
      const f = "data-tt-policy-suffix";
      s && s.hasAttribute(f) && (l = s.getAttribute(f));
      const b = "dompurify" + (l ? "#" + l : "");
      try {
        return n.createPolicy(b, {
          createHTML(E) {
            return E;
          },
          createScriptURL(E) {
            return E;
          }
        });
      } catch {
        return console.warn("TrustedTypes policy " + b + " could not be created."), null;
      }
    };
    function OO() {
      let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : B8();
      const n = (ao) => OO(ao);
      if (n.version = "3.1.7", n.removed = [], !e || !e.document || e.document.nodeType !== u1.document)
        return n.isSupported = !1, n;
      let {
        document: s
      } = e;
      const l = s, f = l.currentScript, {
        DocumentFragment: b,
        HTMLTemplateElement: E,
        Node: N,
        Element: D,
        NodeFilter: U,
        NamedNodeMap: J = e.NamedNodeMap || e.MozNamedAttrMap,
        HTMLFormElement: te,
        DOMParser: ce,
        trustedTypes: Oe
      } = e, Re = D.prototype, xe = _O(Re, "cloneNode"), Pe = _O(Re, "remove"), Ke = _O(Re, "nextSibling"), et = _O(Re, "childNodes"), rt = _O(Re, "parentNode");
      if (typeof E == "function") {
        const ao = s.createElement("template");
        ao.content && ao.content.ownerDocument && (s = ao.content.ownerDocument);
      }
      let dt, Ht = "";
      const {
        implementation: ln,
        createNodeIterator: Dn,
        createDocumentFragment: Rt,
        getElementsByTagName: Tt
      } = s, {
        importNode: Kt
      } = l;
      let Mn = {};
      n.isSupported = typeof dF == "function" && typeof rt == "function" && ln && ln.createHTMLDocument !== void 0;
      const {
        MUSTACHE_EXPR: rr,
        ERB_EXPR: Fr,
        TMPLIT_EXPR: so,
        DATA_ATTR: Cs,
        ARIA_ATTR: Xs,
        IS_SCRIPT_OR_DATA: Si,
        ATTR_WHITESPACE: Kl,
        CUSTOM_ELEMENT: ll
      } = xR;
      let {
        IS_ALLOWED_URI: wn
      } = xR, Ln = null;
      const Ho = qs({}, [...N8, ...mF, ...ER, ...RE, ...P8]);
      let Ao = null;
      const Qn = qs({}, [...pF, ...hF, ...gF, ...CR]);
      let Jn = Object.seal(PZ(null, {
        tagNameCheck: {
          writable: !0,
          configurable: !1,
          enumerable: !0,
          value: null
        },
        attributeNameCheck: {
          writable: !0,
          configurable: !1,
          enumerable: !0,
          value: null
        },
        allowCustomizedBuiltInElements: {
          writable: !0,
          configurable: !1,
          enumerable: !0,
          value: !1
        }
      })), pn = null, kr = null, To = !0, Ns = !0, Js = !1, Cd = !0, xm = !1, ry = !0, xd = !1, wg = !1, Ir = !1, _o = !1, Jo = !1, Ba = !1, Za = !0, Eh = !1;
      const e2 = "user-content-";
      let t2 = !0, oy = !1, sy = {}, wS = null;
      const n2 = qs({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
      let TA = null;
      const CD = qs({}, ["audio", "video", "img", "source", "image", "track"]);
      let KE = null;
      const xD = qs({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), ES = "http://www.w3.org/1998/Math/MathML", r2 = "http://www.w3.org/2000/svg", Eg = "http://www.w3.org/1999/xhtml";
      let ay = Eg, o2 = !1, s2 = null;
      const _A = qs({}, [ES, r2, Eg], fF);
      let YE = null;
      const _L = ["application/xhtml+xml", "text/html"], TD = "text/html";
      let Cu = null, CS = null;
      const v1 = s.createElement("form"), OA = function(_t) {
        return _t instanceof RegExp || _t instanceof Function;
      }, gt = function() {
        let _t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (!(CS && CS === _t)) {
          if ((!_t || typeof _t != "object") && (_t = {}), _t = NE(_t), YE = // eslint-disable-next-line unicorn/prefer-includes
          _L.indexOf(_t.PARSER_MEDIA_TYPE) === -1 ? TD : _t.PARSER_MEDIA_TYPE, Cu = YE === "application/xhtml+xml" ? fF : wR, Ln = hh(_t, "ALLOWED_TAGS") ? qs({}, _t.ALLOWED_TAGS, Cu) : Ho, Ao = hh(_t, "ALLOWED_ATTR") ? qs({}, _t.ALLOWED_ATTR, Cu) : Qn, s2 = hh(_t, "ALLOWED_NAMESPACES") ? qs({}, _t.ALLOWED_NAMESPACES, fF) : _A, KE = hh(_t, "ADD_URI_SAFE_ATTR") ? qs(
            NE(xD),
            // eslint-disable-line indent
            _t.ADD_URI_SAFE_ATTR,
            // eslint-disable-line indent
            Cu
            // eslint-disable-line indent
          ) : xD, TA = hh(_t, "ADD_DATA_URI_TAGS") ? qs(
            NE(CD),
            // eslint-disable-line indent
            _t.ADD_DATA_URI_TAGS,
            // eslint-disable-line indent
            Cu
            // eslint-disable-line indent
          ) : CD, wS = hh(_t, "FORBID_CONTENTS") ? qs({}, _t.FORBID_CONTENTS, Cu) : n2, pn = hh(_t, "FORBID_TAGS") ? qs({}, _t.FORBID_TAGS, Cu) : {}, kr = hh(_t, "FORBID_ATTR") ? qs({}, _t.FORBID_ATTR, Cu) : {}, sy = hh(_t, "USE_PROFILES") ? _t.USE_PROFILES : !1, To = _t.ALLOW_ARIA_ATTR !== !1, Ns = _t.ALLOW_DATA_ATTR !== !1, Js = _t.ALLOW_UNKNOWN_PROTOCOLS || !1, Cd = _t.ALLOW_SELF_CLOSE_IN_ATTR !== !1, xm = _t.SAFE_FOR_TEMPLATES || !1, ry = _t.SAFE_FOR_XML !== !1, xd = _t.WHOLE_DOCUMENT || !1, _o = _t.RETURN_DOM || !1, Jo = _t.RETURN_DOM_FRAGMENT || !1, Ba = _t.RETURN_TRUSTED_TYPE || !1, Ir = _t.FORCE_BODY || !1, Za = _t.SANITIZE_DOM !== !1, Eh = _t.SANITIZE_NAMED_PROPS || !1, t2 = _t.KEEP_CONTENT !== !1, oy = _t.IN_PLACE || !1, wn = _t.ALLOWED_URI_REGEXP || vF, ay = _t.NAMESPACE || Eg, Jn = _t.CUSTOM_ELEMENT_HANDLING || {}, _t.CUSTOM_ELEMENT_HANDLING && OA(_t.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Jn.tagNameCheck = _t.CUSTOM_ELEMENT_HANDLING.tagNameCheck), _t.CUSTOM_ELEMENT_HANDLING && OA(_t.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Jn.attributeNameCheck = _t.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), _t.CUSTOM_ELEMENT_HANDLING && typeof _t.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (Jn.allowCustomizedBuiltInElements = _t.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), xm && (Ns = !1), Jo && (_o = !0), sy && (Ln = qs({}, P8), Ao = [], sy.html === !0 && (qs(Ln, N8), qs(Ao, pF)), sy.svg === !0 && (qs(Ln, mF), qs(Ao, hF), qs(Ao, CR)), sy.svgFilters === !0 && (qs(Ln, ER), qs(Ao, hF), qs(Ao, CR)), sy.mathMl === !0 && (qs(Ln, RE), qs(Ao, gF), qs(Ao, CR))), _t.ADD_TAGS && (Ln === Ho && (Ln = NE(Ln)), qs(Ln, _t.ADD_TAGS, Cu)), _t.ADD_ATTR && (Ao === Qn && (Ao = NE(Ao)), qs(Ao, _t.ADD_ATTR, Cu)), _t.ADD_URI_SAFE_ATTR && qs(KE, _t.ADD_URI_SAFE_ATTR, Cu), _t.FORBID_CONTENTS && (wS === n2 && (wS = NE(wS)), qs(wS, _t.FORBID_CONTENTS, Cu)), t2 && (Ln["#text"] = !0), xd && qs(Ln, ["html", "head", "body"]), Ln.table && (qs(Ln, ["tbody"]), delete pn.tbody), _t.TRUSTED_TYPES_POLICY) {
            if (typeof _t.TRUSTED_TYPES_POLICY.createHTML != "function")
              throw yT('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
            if (typeof _t.TRUSTED_TYPES_POLICY.createScriptURL != "function")
              throw yT('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
            dt = _t.TRUSTED_TYPES_POLICY, Ht = dt.createHTML("");
          } else
            dt === void 0 && (dt = H8(Oe, f)), dt !== null && typeof Ht == "string" && (Ht = dt.createHTML(""));
          ap && ap(_t), CS = _t;
        }
      }, Et = qs({}, ["mi", "mo", "mn", "ms", "mtext"]), yn = qs({}, ["annotation-xml"]), un = qs({}, ["title", "style", "font", "a", "script"]), cr = qs({}, [...mF, ...ER, ...IZ]), So = qs({}, [...RE, ...R8]), Ha = function(_t) {
        let tr = rt(_t);
        (!tr || !tr.tagName) && (tr = {
          namespaceURI: ay,
          tagName: "template"
        });
        const Kr = wR(_t.tagName), lc = wR(tr.tagName);
        return s2[_t.namespaceURI] ? _t.namespaceURI === r2 ? tr.namespaceURI === Eg ? Kr === "svg" : tr.namespaceURI === ES ? Kr === "svg" && (lc === "annotation-xml" || Et[lc]) : !!cr[Kr] : _t.namespaceURI === ES ? tr.namespaceURI === Eg ? Kr === "math" : tr.namespaceURI === r2 ? Kr === "math" && yn[lc] : !!So[Kr] : _t.namespaceURI === Eg ? tr.namespaceURI === r2 && !yn[lc] || tr.namespaceURI === ES && !Et[lc] ? !1 : !So[Kr] && (un[Kr] || !cr[Kr]) : !!(YE === "application/xhtml+xml" && s2[_t.namespaceURI]) : !1;
      }, cc = function(_t) {
        pg(n.removed, {
          element: _t
        });
        try {
          rt(_t).removeChild(_t);
        } catch {
          Pe(_t);
        }
      }, Oc = function(_t, tr) {
        try {
          pg(n.removed, {
            attribute: tr.getAttributeNode(_t),
            from: tr
          });
        } catch {
          pg(n.removed, {
            attribute: null,
            from: tr
          });
        }
        if (tr.removeAttribute(_t), _t === "is" && !Ao[_t])
          if (_o || Jo)
            try {
              cc(tr);
            } catch {
            }
          else
            try {
              tr.setAttribute(_t, "");
            } catch {
            }
      }, a2 = function(_t) {
        let tr = null, Kr = null;
        if (Ir)
          _t = "<remove></remove>" + _t;
        else {
          const Td = kE(_t, /^[\r\n\t ]+/);
          Kr = Td && Td[0];
        }
        YE === "application/xhtml+xml" && ay === Eg && (_t = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + _t + "</body></html>");
        const lc = dt ? dt.createHTML(_t) : _t;
        if (ay === Eg)
          try {
            tr = new ce().parseFromString(lc, YE);
          } catch {
          }
        if (!tr || !tr.documentElement) {
          tr = ln.createDocument(ay, "template", null);
          try {
            tr.documentElement.innerHTML = o2 ? Ht : lc;
          } catch {
          }
        }
        const Jd = tr.body || tr.documentElement;
        return _t && Kr && Jd.insertBefore(s.createTextNode(Kr), Jd.childNodes[0] || null), ay === Eg ? Tt.call(tr, xd ? "html" : "body")[0] : xd ? tr.documentElement : Jd;
      }, i2 = function(_t) {
        return Dn.call(
          _t.ownerDocument || _t,
          _t,
          // eslint-disable-next-line no-bitwise
          U.SHOW_ELEMENT | U.SHOW_COMMENT | U.SHOW_TEXT | U.SHOW_PROCESSING_INSTRUCTION | U.SHOW_CDATA_SECTION,
          null
        );
      }, _D = function(_t) {
        return _t instanceof te && (typeof _t.nodeName != "string" || typeof _t.textContent != "string" || typeof _t.removeChild != "function" || !(_t.attributes instanceof J) || typeof _t.removeAttribute != "function" || typeof _t.setAttribute != "function" || typeof _t.namespaceURI != "string" || typeof _t.insertBefore != "function" || typeof _t.hasChildNodes != "function");
      }, OL = function(_t) {
        return typeof N == "function" && _t instanceof N;
      }, iy = function(_t, tr, Kr) {
        Mn[_t] && AE(Mn[_t], (lc) => {
          lc.call(n, tr, Kr, CS);
        });
      }, L9 = function(_t) {
        let tr = null;
        if (iy("beforeSanitizeElements", _t, null), _D(_t))
          return cc(_t), !0;
        const Kr = Cu(_t.nodeName);
        if (iy("uponSanitizeElement", _t, {
          tagName: Kr,
          allowedTags: Ln
        }), _t.hasChildNodes() && !OL(_t.firstElementChild) && Ff(/<[/\w]/g, _t.innerHTML) && Ff(/<[/\w]/g, _t.textContent) || _t.nodeType === u1.progressingInstruction || ry && _t.nodeType === u1.comment && Ff(/<[/\w]/g, _t.data))
          return cc(_t), !0;
        if (!Ln[Kr] || pn[Kr]) {
          if (!pn[Kr] && B9(Kr) && (Jn.tagNameCheck instanceof RegExp && Ff(Jn.tagNameCheck, Kr) || Jn.tagNameCheck instanceof Function && Jn.tagNameCheck(Kr)))
            return !1;
          if (t2 && !wS[Kr]) {
            const lc = rt(_t) || _t.parentNode, Jd = et(_t) || _t.childNodes;
            if (Jd && lc) {
              const Td = Jd.length;
              for (let Tm = Td - 1; Tm >= 0; --Tm) {
                const Cg = xe(Jd[Tm], !0);
                Cg.__removalCount = (_t.__removalCount || 0) + 1, lc.insertBefore(Cg, Ke(_t));
              }
            }
          }
          return cc(_t), !0;
        }
        return _t instanceof D && !Ha(_t) || (Kr === "noscript" || Kr === "noembed" || Kr === "noframes") && Ff(/<\/no(script|embed|frames)/i, _t.innerHTML) ? (cc(_t), !0) : (xm && _t.nodeType === u1.text && (tr = _t.textContent, AE([rr, Fr, so], (lc) => {
          tr = Yb(tr, lc, " ");
        }), _t.textContent !== tr && (pg(n.removed, {
          element: _t.cloneNode()
        }), _t.textContent = tr)), iy("afterSanitizeElements", _t, null), !1);
      }, AL = function(_t, tr, Kr) {
        if (Za && (tr === "id" || tr === "name") && (Kr in s || Kr in v1))
          return !1;
        if (!(Ns && !kr[tr] && Ff(Cs, tr))) {
          if (!(To && Ff(Xs, tr))) {
            if (!Ao[tr] || kr[tr]) {
              if (
                // First condition does a very basic check if a) it's basically a valid custom element tagname AND
                // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
                // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
                !(B9(_t) && (Jn.tagNameCheck instanceof RegExp && Ff(Jn.tagNameCheck, _t) || Jn.tagNameCheck instanceof Function && Jn.tagNameCheck(_t)) && (Jn.attributeNameCheck instanceof RegExp && Ff(Jn.attributeNameCheck, tr) || Jn.attributeNameCheck instanceof Function && Jn.attributeNameCheck(tr)) || // Alternative, second condition checks if it's an `is`-attribute, AND
                // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
                tr === "is" && Jn.allowCustomizedBuiltInElements && (Jn.tagNameCheck instanceof RegExp && Ff(Jn.tagNameCheck, Kr) || Jn.tagNameCheck instanceof Function && Jn.tagNameCheck(Kr)))
              )
                return !1;
            } else if (!KE[tr]) {
              if (!Ff(wn, Yb(Kr, Kl, ""))) {
                if (!((tr === "src" || tr === "xlink:href" || tr === "href") && _t !== "script" && bT(Kr, "data:") === 0 && TA[_t])) {
                  if (!(Js && !Ff(Si, Yb(Kr, Kl, "")))) {
                    if (Kr)
                      return !1;
                  }
                }
              }
            }
          }
        }
        return !0;
      }, B9 = function(_t) {
        return _t !== "annotation-xml" && kE(_t, ll);
      }, H9 = function(_t) {
        iy("beforeSanitizeAttributes", _t, null);
        const {
          attributes: tr
        } = _t;
        if (!tr)
          return;
        const Kr = {
          attrName: "",
          attrValue: "",
          keepAttr: !0,
          allowedAttributes: Ao
        };
        let lc = tr.length;
        for (; lc--; ) {
          const Jd = tr[lc], {
            name: Td,
            namespaceURI: Tm,
            value: Cg
          } = Jd, AA = Cu(Td);
          let ef = Td === "value" ? Cg : k8(Cg);
          const z9 = ef;
          if (Kr.attrName = AA, Kr.attrValue = ef, Kr.keepAttr = !0, Kr.forceKeepAttr = void 0, iy("uponSanitizeAttribute", _t, Kr), ef = Kr.attrValue, Kr.forceKeepAttr)
            continue;
          if (!Kr.keepAttr) {
            Oc(Td, _t);
            continue;
          }
          if (!Cd && Ff(/\/>/i, ef)) {
            Oc(Td, _t);
            continue;
          }
          xm && AE([rr, Fr, so], (U9) => {
            ef = Yb(ef, U9, " ");
          });
          const V9 = Cu(_t.nodeName);
          if (!AL(V9, AA, ef)) {
            Oc(Td, _t);
            continue;
          }
          if (Eh && (AA === "id" || AA === "name") && (Oc(Td, _t), ef = e2 + ef), ry && Ff(/((--!?|])>)|<\/(style|title)/i, ef)) {
            Oc(Td, _t);
            continue;
          }
          if (dt && typeof Oe == "object" && typeof Oe.getAttributeType == "function" && !Tm)
            switch (Oe.getAttributeType(V9, AA)) {
              case "TrustedHTML": {
                ef = dt.createHTML(ef);
                break;
              }
              case "TrustedScriptURL": {
                ef = dt.createScriptURL(ef);
                break;
              }
            }
          if (ef !== z9)
            try {
              Tm ? _t.setAttributeNS(Tm, Td, ef) : _t.setAttribute(Td, ef), _D(_t) ? cc(_t) : l1(n.removed);
            } catch {
            }
        }
        iy("afterSanitizeAttributes", _t, null);
      }, Mre = function ao(_t) {
        let tr = null;
        const Kr = i2(_t);
        for (iy("beforeSanitizeShadowDOM", _t, null); tr = Kr.nextNode(); )
          iy("uponSanitizeShadowNode", tr, null), !L9(tr) && (tr.content instanceof b && ao(tr.content), H9(tr));
        iy("afterSanitizeShadowDOM", _t, null);
      };
      return n.sanitize = function(ao) {
        let _t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, tr = null, Kr = null, lc = null, Jd = null;
        if (o2 = !ao, o2 && (ao = "<!-->"), typeof ao != "string" && !OL(ao))
          if (typeof ao.toString == "function") {
            if (ao = ao.toString(), typeof ao != "string")
              throw yT("dirty is not a string, aborting");
          } else
            throw yT("toString is not a function");
        if (!n.isSupported)
          return ao;
        if (wg || gt(_t), n.removed = [], typeof ao == "string" && (oy = !1), oy) {
          if (ao.nodeName) {
            const Cg = Cu(ao.nodeName);
            if (!Ln[Cg] || pn[Cg])
              throw yT("root node is forbidden and cannot be sanitized in-place");
          }
        } else if (ao instanceof N)
          tr = a2("<!---->"), Kr = tr.ownerDocument.importNode(ao, !0), Kr.nodeType === u1.element && Kr.nodeName === "BODY" || Kr.nodeName === "HTML" ? tr = Kr : tr.appendChild(Kr);
        else {
          if (!_o && !xm && !xd && // eslint-disable-next-line unicorn/prefer-includes
          ao.indexOf("<") === -1)
            return dt && Ba ? dt.createHTML(ao) : ao;
          if (tr = a2(ao), !tr)
            return _o ? null : Ba ? Ht : "";
        }
        tr && Ir && cc(tr.firstChild);
        const Td = i2(oy ? ao : tr);
        for (; lc = Td.nextNode(); )
          L9(lc) || (lc.content instanceof b && Mre(lc.content), H9(lc));
        if (oy)
          return ao;
        if (_o) {
          if (Jo)
            for (Jd = Rt.call(tr.ownerDocument); tr.firstChild; )
              Jd.appendChild(tr.firstChild);
          else
            Jd = tr;
          return (Ao.shadowroot || Ao.shadowrootmode) && (Jd = Kt.call(l, Jd, !0)), Jd;
        }
        let Tm = xd ? tr.outerHTML : tr.innerHTML;
        return xd && Ln["!doctype"] && tr.ownerDocument && tr.ownerDocument.doctype && tr.ownerDocument.doctype.name && Ff(L8, tr.ownerDocument.doctype.name) && (Tm = "<!DOCTYPE " + tr.ownerDocument.doctype.name + `>
` + Tm), xm && AE([rr, Fr, so], (Cg) => {
          Tm = Yb(Tm, Cg, " ");
        }), dt && Ba ? dt.createHTML(Tm) : Tm;
      }, n.setConfig = function() {
        let ao = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        gt(ao), wg = !0;
      }, n.clearConfig = function() {
        CS = null, wg = !1;
      }, n.isValidAttribute = function(ao, _t, tr) {
        CS || gt({});
        const Kr = Cu(ao), lc = Cu(_t);
        return AL(Kr, lc, tr);
      }, n.addHook = function(ao, _t) {
        typeof _t == "function" && (Mn[ao] = Mn[ao] || [], pg(Mn[ao], _t));
      }, n.removeHook = function(ao) {
        if (Mn[ao])
          return l1(Mn[ao]);
      }, n.removeHooks = function(ao) {
        Mn[ao] && (Mn[ao] = []);
      }, n.removeAllHooks = function() {
        Mn = {};
      }, n;
    }
    var z8 = OO();
    const V8 = rn.each, eS = rn.trim, bF = [
      "source",
      "protocol",
      "authority",
      "userInfo",
      "user",
      "password",
      "host",
      "port",
      "relative",
      "path",
      "directory",
      "file",
      "query",
      "anchor"
    ], U8 = {
      ftp: 21,
      http: 80,
      https: 443,
      mailto: 25
    }, AO = [
      "img",
      "video"
    ], W8 = (e, n) => Ie(e) ? !e : Ie(n) ? !Ge(AO, n) : !0, yF = (e) => {
      try {
        return decodeURIComponent(e);
      } catch {
        return unescape(e);
      }
    }, SF = (e, n, s) => {
      const l = yF(n).replace(/\s/g, "");
      return e.allow_script_urls ? !1 : /((java|vb)script|mhtml):/i.test(l) ? !0 : e.allow_html_data_urls ? !1 : /^data:image\//i.test(l) ? W8(e.allow_svg_data_urls, s) && /^data:image\/svg\+xml/i.test(l) : /^data:/i.test(l);
    };
    class vh {
      static parseDataUri(n) {
        let s;
        const l = decodeURIComponent(n).split(","), f = /data:([^;]+)/.exec(l[0]);
        return f && (s = f[1]), {
          type: s,
          data: l[1]
        };
      }
      static isDomSafe(n, s, l = {}) {
        if (l.allow_script_urls)
          return !0;
        {
          const f = Yg.decode(n).replace(/[\s\u0000-\u001F]+/g, "");
          return !SF(l, f, s);
        }
      }
      static getDocumentBaseUrl(n) {
        var s;
        let l;
        return n.protocol.indexOf("http") !== 0 && n.protocol !== "file:" ? l = (s = n.href) !== null && s !== void 0 ? s : "" : l = n.protocol + "//" + n.host + n.pathname, /^[^:]+:\/\/\/?[^\/]+\//.test(l) && (l = l.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, ""), /[\/\\]$/.test(l) || (l += "/")), l;
      }
      constructor(n, s = {}) {
        this.path = "", this.directory = "", n = eS(n), this.settings = s;
        const l = s.base_uri, f = this;
        if (/^([\w\-]+):([^\/]{2})/i.test(n) || /^\s*#/.test(n)) {
          f.source = n;
          return;
        }
        const b = n.indexOf("//") === 0;
        if (n.indexOf("/") === 0 && !b && (n = (l && l.protocol || "http") + "://mce_host" + n), !/^[\w\-]*:?\/\//.test(n)) {
          const N = l ? l.path : new vh(document.location.href).directory;
          if ((l == null ? void 0 : l.protocol) === "")
            n = "//mce_host" + f.toAbsPath(N, n);
          else {
            const D = /([^#?]*)([#?]?.*)/.exec(n);
            D && (n = (l && l.protocol || "http") + "://mce_host" + f.toAbsPath(N, D[1]) + D[2]);
          }
        }
        n = n.replace(/@@/g, "(mce_at)");
        const E = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?(\[[a-zA-Z0-9:.%]+\]|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(n);
        E && V8(bF, (N, D) => {
          let U = E[D];
          U && (U = U.replace(/\(mce_at\)/g, "@@")), f[N] = U;
        }), l && (f.protocol || (f.protocol = l.protocol), f.userInfo || (f.userInfo = l.userInfo), !f.port && f.host === "mce_host" && (f.port = l.port), (!f.host || f.host === "mce_host") && (f.host = l.host), f.source = ""), b && (f.protocol = "");
      }
      setPath(n) {
        const s = /^(.*?)\/?(\w+)?$/.exec(n);
        s && (this.path = s[0], this.directory = s[1], this.file = s[2]), this.source = "", this.getURI();
      }
      toRelative(n) {
        if (n === "./")
          return n;
        const s = new vh(n, { base_uri: this });
        if (s.host !== "mce_host" && this.host !== s.host && s.host || this.port !== s.port || this.protocol !== s.protocol && s.protocol !== "")
          return s.getURI();
        const l = this.getURI(), f = s.getURI();
        if (l === f || l.charAt(l.length - 1) === "/" && l.substr(0, l.length - 1) === f)
          return l;
        let b = this.toRelPath(this.path, s.path);
        return s.query && (b += "?" + s.query), s.anchor && (b += "#" + s.anchor), b;
      }
      toAbsolute(n, s) {
        const l = new vh(n, { base_uri: this });
        return l.getURI(s && this.isSameOrigin(l));
      }
      isSameOrigin(n) {
        if (this.host == n.host && this.protocol == n.protocol) {
          if (this.port == n.port)
            return !0;
          const s = this.protocol ? U8[this.protocol] : null;
          if (s && (this.port || s) == (n.port || s))
            return !0;
        }
        return !1;
      }
      toRelPath(n, s) {
        let l = 0, f = "", b, E;
        const N = n.substring(0, n.lastIndexOf("/")).split("/"), D = s.split("/");
        if (N.length >= D.length) {
          for (b = 0, E = N.length; b < E; b++)
            if (b >= D.length || N[b] !== D[b]) {
              l = b + 1;
              break;
            }
        }
        if (N.length < D.length) {
          for (b = 0, E = D.length; b < E; b++)
            if (b >= N.length || N[b] !== D[b]) {
              l = b + 1;
              break;
            }
        }
        if (l === 1)
          return s;
        for (b = 0, E = N.length - (l - 1); b < E; b++)
          f += "../";
        for (b = l - 1, E = D.length; b < E; b++)
          b !== l - 1 ? f += "/" + D[b] : f += D[b];
        return f;
      }
      toAbsPath(n, s) {
        let l = 0;
        const f = /\/$/.test(s) ? "/" : "", b = n.split("/"), E = s.split("/"), N = [];
        V8(b, (te) => {
          te && N.push(te);
        });
        const D = [];
        for (let te = E.length - 1; te >= 0; te--)
          if (!(E[te].length === 0 || E[te] === ".")) {
            if (E[te] === "..") {
              l++;
              continue;
            }
            if (l > 0) {
              l--;
              continue;
            }
            D.push(E[te]);
          }
        const U = N.length - l;
        let J;
        return U <= 0 ? J = Xr(D).join("/") : J = N.slice(0, U).join("/") + "/" + Xr(D).join("/"), J.indexOf("/") !== 0 && (J = "/" + J), f && J.lastIndexOf("/") !== J.length - 1 && (J += f), J;
      }
      getURI(n = !1) {
        let s;
        return (!this.source || n) && (s = "", n || (this.protocol ? s += this.protocol + "://" : s += "//", this.userInfo && (s += this.userInfo + "@"), this.host && (s += this.host), this.port && (s += ":" + this.port)), this.path && (s += this.path), this.query && (s += "?" + this.query), this.anchor && (s += "#" + this.anchor), this.source = s), this.source;
      }
    }
    const BZ = rn.makeMap("src,href,data,background,action,formaction,poster,xlink:href"), wF = "data-mce-type";
    let j8 = 0;
    const TR = (e, n, s, l, f) => {
      var b, E, N, D;
      const U = n.validate, J = s.getSpecialElements();
      e.nodeType === Nu && !n.allow_conditional_comments && /^\[if/i.test((b = e.nodeValue) !== null && b !== void 0 ? b : "") && (e.nodeValue = " " + e.nodeValue);
      const te = (E = f == null ? void 0 : f.tagName) !== null && E !== void 0 ? E : e.nodeName.toLowerCase();
      if (l !== "html" && s.isValid(l)) {
        Ie(f) && (f.allowedTags[te] = !0);
        return;
      }
      if (e.nodeType !== Ml || te === "body")
        return;
      const ce = Fe.fromDom(e), Oe = Da(ce, wF), Re = Ji(ce, "data-mce-bogus");
      if (!Oe && G(Re)) {
        Re === "all" ? mo(ce) : zi(ce);
        return;
      }
      const xe = s.getElementRule(te);
      if (U && !xe) {
        lr(J, te) ? mo(ce) : zi(ce);
        return;
      } else
        Ie(f) && (f.allowedTags[te] = !0);
      if (U && xe && !Oe) {
        if (ke((N = xe.attributesForced) !== null && N !== void 0 ? N : [], (Pe) => {
          is(ce, Pe.name, Pe.value === "{$uid}" ? `mce_${j8++}` : Pe.value);
        }), ke((D = xe.attributesDefault) !== null && D !== void 0 ? D : [], (Pe) => {
          Da(ce, Pe.name) || is(ce, Pe.name, Pe.value === "{$uid}" ? `mce_${j8++}` : Pe.value);
        }), xe.attributesRequired && !qt(xe.attributesRequired, (Pe) => Da(ce, Pe))) {
          zi(ce);
          return;
        }
        if (xe.removeEmptyAttrs && Ll(ce)) {
          zi(ce);
          return;
        }
        xe.outputName && xe.outputName !== te && fm(ce, xe.outputName);
      }
    }, HZ = (e, n, s, l, f) => {
      const b = e.tagName.toLowerCase(), { attrName: E, attrValue: N } = f;
      f.keepAttr = EF(n, s, l, b, E, N), f.keepAttr ? (f.allowedAttributes[E] = !0, G8(E, s) && (f.attrValue = E), n.allow_svg_data_urls && Gs(N, "data:image/svg+xml") && (f.forceKeepAttr = !0)) : q8(e, E) && (f.forceKeepAttr = !0);
    }, EF = (e, n, s, l, f, b) => s !== "html" && !wf(l) ? !0 : !(f in BZ && SF(e, b, l)) && (!e.validate || n.isValid(l, f) || Gs(f, "data-") || Gs(f, "aria-")), q8 = (e, n) => e.hasAttribute(wF) && (n === "id" || n === "class" || n === "style"), G8 = (e, n) => e in n.getBoolAttrs(), zZ = (e, n, s, l) => {
      const { attributes: f } = e;
      for (let b = f.length - 1; b >= 0; b--) {
        const E = f[b], N = E.name, D = E.value;
        !EF(n, s, l, e.tagName.toLowerCase(), N, D) && !q8(e, N) ? e.removeAttribute(N) : G8(N, s) && e.setAttribute(N, N);
      }
    }, VZ = (e, n, s) => {
      const l = z8();
      return l.addHook("uponSanitizeElement", (f, b) => {
        TR(f, e, n, s.track(f), b);
      }), l.addHook("uponSanitizeAttribute", (f, b) => {
        HZ(f, e, n, s.current(), b);
      }), l;
    }, UZ = (e, n) => {
      const l = { ...{
        IN_PLACE: !0,
        ALLOW_UNKNOWN_PROTOCOLS: !0,
        ALLOWED_TAGS: [
          "#comment",
          "#cdata-section",
          "body"
        ],
        ALLOWED_ATTR: [],
        SAFE_FOR_XML: !1
      } };
      return l.PARSER_MEDIA_TYPE = n, e.allow_script_urls ? l.ALLOWED_URI_REGEXP = /.*/ : e.allow_html_data_urls && (l.ALLOWED_URI_REGEXP = /^(?!(\w+script|mhtml):)/i), l;
    }, WZ = (e) => {
      const n = [
        "type",
        "href",
        "role",
        "arcrole",
        "title",
        "show",
        "actuate",
        "label",
        "from",
        "to"
      ].map((l) => `xlink:${l}`), s = {
        IN_PLACE: !0,
        USE_PROFILES: {
          html: !0,
          svg: !0,
          svgFilters: !0
        },
        ALLOWED_ATTR: n
      };
      return z8().sanitize(e, s), e.innerHTML;
    }, jZ = (e, n) => {
      const s = Wp();
      if (e.sanitize) {
        const l = VZ(e, n, s);
        return {
          sanitizeHtmlElement: (b, E) => {
            l.sanitize(b, UZ(e, E)), l.removed = [], s.reset();
          },
          sanitizeNamespaceElement: WZ
        };
      } else
        return {
          sanitizeHtmlElement: (b, E) => {
            const N = document.createNodeIterator(b, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT);
            let D;
            for (; D = N.nextNode(); ) {
              const U = s.track(D);
              TR(D, e, n, U), Un(D) && zZ(D, e, n, U);
            }
            s.reset();
          },
          sanitizeNamespaceElement: Lt
        };
    }, Z8 = rn.makeMap, K8 = rn.extend, kO = (e, n, s, l) => {
      const f = e.name, b = f in s && f !== "title" && f !== "textarea" && f !== "noscript", E = n.childNodes;
      for (let N = 0, D = E.length; N < D; N++) {
        const U = E[N], J = new yd(U.nodeName.toLowerCase(), U.nodeType);
        if (Un(U)) {
          const te = U.attributes;
          for (let ce = 0, Oe = te.length; ce < Oe; ce++) {
            const Re = te[ce];
            J.attr(Re.name, Re.value);
          }
          wf(J.name) && (l(U), J.value = U.innerHTML);
        } else
          Qt(U) ? (J.value = U.data, b && (J.raw = !0)) : (im(U) || H1(U) || am(U)) && (J.value = U.data);
        wf(J.name) || kO(J, U, s, l), e.append(J);
      }
    }, wd = (e, n, s) => {
      const l = [];
      for (let f = e, b = f; f; b = f, f = f.walk()) {
        const E = f;
        ke(n, (N) => N(E)), je(E.parent) && E !== e ? f = b : l.push(E);
      }
      for (let f = l.length - 1; f >= 0; f--) {
        const b = l[f];
        ke(s, (E) => E(b));
      }
    }, qZ = (e, n, s, l) => {
      const f = s.validate, b = n.getNonEmptyElements(), E = n.getWhitespaceElements(), N = K8(Z8("script,style,head,html,body,title,meta,param"), n.getBlockElements()), D = GC(n), U = /[ \t\r\n]+/g, J = /^[ \t\r\n]+/, te = /[ \t\r\n]+$/, ce = (et) => {
        let rt = et.parent;
        for (; Ie(rt); ) {
          if (rt.name in E)
            return !0;
          rt = rt.parent;
        }
        return !1;
      }, Oe = (et) => {
        let rt = et;
        for (; Ie(rt); ) {
          if (rt.name in D)
            return mT(n, b, E, rt);
          rt = rt.parent;
        }
        return !1;
      }, Re = (et) => et.name in N || Ef(n, et) || wf(et.name) && et.parent === e, xe = (et, rt) => {
        const dt = rt ? et.prev : et.next;
        return Ie(dt) || je(et.parent) ? !1 : Re(et.parent) && (et.parent !== e || l.isRootContent === !0);
      };
      return [
        (et) => {
          var rt;
          if (et.type === 3 && !ce(et)) {
            let dt = (rt = et.value) !== null && rt !== void 0 ? rt : "";
            dt = dt.replace(U, " "), (N6(et.prev, Re) || xe(et, !0)) && (dt = dt.replace(J, "")), dt.length === 0 ? et.remove() : et.value = dt;
          }
        },
        (et) => {
          var rt;
          if (et.type === 1) {
            const dt = n.getElementRule(et.name);
            if (f && dt) {
              const Ht = mT(n, b, E, et);
              dt.paddInEmptyBlock && Ht && Oe(et) ? ZN(s, l, Re, et) : dt.removeEmpty && Ht ? Re(et) ? et.remove() : et.unwrap() : dt.paddEmpty && (Ht || A6(et)) && ZN(s, l, Re, et);
            }
          } else if (et.type === 3 && !ce(et)) {
            let dt = (rt = et.value) !== null && rt !== void 0 ? rt : "";
            (et.next && Re(et.next) || xe(et, !1)) && (dt = dt.replace(te, "")), dt.length === 0 ? et.remove() : et.value = dt;
          }
        }
      ];
    }, _R = (e, n) => {
      var s;
      const l = (s = n.forced_root_block) !== null && s !== void 0 ? s : e.forced_root_block;
      return l === !1 ? "" : l === !0 ? "p" : l;
    }, hg = (e = {}, n = jm()) => {
      const s = E8(), l = E8(), f = {
        validate: !0,
        root_name: "body",
        sanitize: !0,
        ...e
      }, b = new DOMParser(), E = jZ(f, n), N = (rt, dt, Ht = "html") => {
        const ln = Ht === "xhtml" ? "application/xhtml+xml" : "text/html", Dn = lr(n.getSpecialElements(), dt.toLowerCase()), Rt = Dn ? `<${dt}>${rt}</${dt}>` : rt, Tt = Ht === "xhtml" ? `<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>${Rt}</body></html>` : `<body>${Rt}</body>`, Kt = b.parseFromString(Tt, ln).body;
        return E.sanitizeHtmlElement(Kt, ln), Dn ? Kt.firstChild : Kt;
      }, D = s.addFilter, U = s.getFilters, J = s.removeFilter, te = l.addFilter, ce = l.getFilters, Oe = l.removeFilter, Re = (rt, dt) => {
        QN(n, rt) && dt.push(rt);
      }, xe = (rt, dt) => {
        const Ht = G(dt.attr(wF)), ln = dt.type === 1 && !lr(rt, dt.name) && !Ef(n, dt) && !wf(dt.name);
        return dt.type === 3 || ln && !Ht;
      }, Pe = (rt, dt) => {
        const Ht = K8(Z8("script,style,head,html,body,title,meta,param"), n.getBlockElements()), ln = /^[ \t\r\n]+/, Dn = /[ \t\r\n]+$/;
        let Rt = rt.firstChild, Tt = null;
        const Kt = (Mn) => {
          var rr, Fr;
          Mn && (Rt = Mn.firstChild, Rt && Rt.type === 3 && (Rt.value = (rr = Rt.value) === null || rr === void 0 ? void 0 : rr.replace(ln, "")), Rt = Mn.lastChild, Rt && Rt.type === 3 && (Rt.value = (Fr = Rt.value) === null || Fr === void 0 ? void 0 : Fr.replace(Dn, "")));
        };
        if (n.isValidChild(rt.name, dt.toLowerCase())) {
          for (; Rt; ) {
            const Mn = Rt.next;
            xe(Ht, Rt) ? (Tt || (Tt = new yd(dt, 1), Tt.attr(f.forced_root_block_attrs), rt.insert(Tt, Rt)), Tt.append(Rt)) : (Kt(Tt), Tt = null), Rt = Mn;
          }
          Kt(Tt);
        }
      }, et = {
        schema: n,
        addAttributeFilter: te,
        getAttributeFilters: ce,
        removeAttributeFilter: Oe,
        addNodeFilter: D,
        getNodeFilters: U,
        removeNodeFilter: J,
        parse: (rt, dt = {}) => {
          var Ht;
          const ln = f.validate, Dn = (Ht = dt.context) !== null && Ht !== void 0 ? Ht : f.root_name, Rt = N(rt, Dn, dt.format);
          nb(n, Rt);
          const Tt = new yd(Dn, 11);
          kO(Tt, Rt, n.getSpecialElements(), E.sanitizeNamespaceElement), Rt.innerHTML = "";
          const [Kt, Mn] = qZ(Tt, n, f, dt), rr = [], Fr = ln ? (Si) => Re(Si, rr) : Lt, so = {
            nodes: {},
            attributes: {}
          }, Cs = (Si) => PM(U(), ce(), Si, so);
          if (wd(Tt, [
            Kt,
            Cs
          ], [
            Mn,
            Fr
          ]), rr.reverse(), ln && rr.length > 0)
            if (dt.context) {
              const {
                pass: Si,
                fail: Kl
              } = an(rr, (ll) => ll.parent === Tt);
              YN(Kl, n, Tt, Cs), dt.invalid = Si.length > 0;
            } else
              YN(rr, n, Tt, Cs);
          const Xs = _R(f, dt);
          return Xs && (Tt.name === "body" || dt.isRootContent) && Pe(Tt, Xs), dt.invalid || hO(so, dt), Tt;
        }
      };
      return RZ(et, f), TZ(et, f, n), et;
    }, Y8 = (e) => Y0(e) ? j0({ validate: !1 }).serialize(e) : e, Lf = (e, n, s) => {
      const l = Y8(e), f = n(l);
      if (f.isDefaultPrevented())
        return f;
      if (Y0(e))
        if (f.content !== l) {
          const b = hg({
            validate: !1,
            forced_root_block: !1,
            ...s
          }).parse(f.content, { context: e.name });
          return {
            ...f,
            content: b
          };
        } else
          return {
            ...f,
            content: e
          };
      else
        return f;
    }, tS = (e, n) => {
      if (n.no_events)
        return gu.value(n);
      {
        const s = DI(e, n);
        return s.isDefaultPrevented() ? gu.error(ho(e, {
          content: "",
          ...s
        }).content) : gu.value(s);
      }
    }, CF = (e, n, s) => s.no_events ? n : Lf(n, (f) => ho(e, {
      ...s,
      content: f
    }), {
      sanitize: og(e),
      sandbox_iframes: T0(e)
    }).content, xF = (e, n) => {
      if (n.no_events)
        return gu.value(n);
      {
        const s = Lf(n.content, (l) => c5(e, {
          ...n,
          content: l
        }), {
          sanitize: og(e),
          sandbox_iframes: T0(e)
        });
        return s.isDefaultPrevented() ? (pN(e, s), gu.error(void 0)) : gu.value(s);
      }
    }, OR = (e, n, s) => {
      s.no_events || pN(e, {
        ...s,
        content: n
      });
    }, TF = (e, n, s) => ({
      element: e,
      width: n,
      rows: s
    }), _F = (e, n) => ({
      element: e,
      cells: n
    }), NO = (e, n) => ({
      x: e,
      y: n
    }), AR = (e, n) => ri(e, n).bind(td).getOr(1), GZ = (e, n, s, l, f) => {
      const b = AR(f, "rowspan"), E = AR(f, "colspan"), N = e.rows;
      for (let D = s; D < s + b; D++) {
        N[D] || (N[D] = _F(s0(l), []));
        for (let U = n; U < n + E; U++) {
          const J = N[D].cells;
          J[U] = D === s && U === n ? f : zu(f);
        }
      }
    }, Q8 = (e, n, s) => {
      const l = e.rows;
      return !!(l[s] ? l[s].cells : [])[n];
    }, ZZ = (e, n, s) => {
      for (; Q8(e, n, s); )
        n++;
      return n;
    }, kR = (e) => Ye(e, (n, s) => s.cells.length > n ? s.cells.length : n, 0), NR = (e, n) => {
      const s = e.rows;
      for (let l = 0; l < s.length; l++) {
        const f = s[l].cells;
        for (let b = 0; b < f.length; b++)
          if (Je(f[b], n))
            return oe.some(NO(b, l));
      }
      return oe.none();
    }, X8 = (e, n, s, l, f) => {
      const b = [], E = e.rows;
      for (let N = s; N <= f; N++) {
        const D = E[N].cells, U = n < l ? D.slice(n, l + 1) : D.slice(l, n + 1);
        b.push(_F(E[N].element, U));
      }
      return b;
    }, KZ = (e, n, s) => {
      const l = n.x, f = n.y, b = s.x, E = s.y, N = f < E ? X8(e, l, f, b, E) : X8(e, l, E, b, f);
      return TF(e.element, kR(N), N);
    }, Qb = (e, n) => {
      const s = zu(e.element), l = Fe.fromTag("tbody");
      return Vo(l, n), Ys(s, l), s;
    }, OF = (e) => St(e.rows, (n) => {
      const s = St(n.cells, (f) => {
        const b = s0(f);
        return Vs(b, "colspan"), Vs(b, "rowspan"), b;
      }), l = zu(n.element);
      return Vo(l, s), l;
    }), YZ = (e) => {
      const n = TF(zu(e), 0, []);
      return ke(Vi(e, "tr"), (s, l) => {
        ke(Vi(s, "td,th"), (f, b) => {
          GZ(n, ZZ(n, b, l), l, s, f);
        });
      }), TF(n.element, kR(n.rows), n.rows);
    }, RR = (e) => Qb(e, OF(e)), AF = (e, n, s) => NR(e, n).bind((l) => NR(e, s).map((f) => KZ(e, l, f))), J8 = (e) => Bt(e, (n) => no(n) === "ul" || no(n) === "ol"), eH = (e, n) => Bt(e, (s) => no(s) === "li" && D_(s, n)).fold(at([]), (s) => J8(e).map((l) => {
      const f = Fe.fromTag(no(l)), b = es(rd(l), (E, N) => Gs(N, "list-style"));
      return Hi(f, b), [
        Fe.fromTag("li"),
        f
      ];
    }).getOr([])), tH = (e, n) => {
      const s = Ye(n, (l, f) => (Ys(f, l), f), e);
      return n.length > 0 ? Q_([s]) : s;
    }, QZ = (e) => Fu(e) ? Qo(e).filter(gl).fold(at([]), (n) => [
      e,
      n
    ]) : gl(e) ? [e] : [], XZ = (e, n, s) => {
      const l = Fe.fromDom(n.commonAncestorContainer), f = qb(l, e), b = ht(f, (D) => s.isWrapper(no(D))), E = eH(f, n), N = b.concat(E.length ? E : QZ(l));
      return St(N, zu);
    }, nH = () => Q_([]), JZ = (e, n, s) => tH(Fe.fromDom(n.cloneContents()), XZ(e, n, s)), eK = (e, n) => su(n, "table", Ne(Je, e)), rH = (e, n) => eK(e, n[0]).bind((s) => {
      const l = n[0], f = n[n.length - 1], b = YZ(s);
      return AF(b, l, f).map((E) => Q_([RR(E)]));
    }).getOrThunk(nH), tK = (e, n, s) => n.length > 0 && n[0].collapsed ? nH() : JZ(e, n[0], s), nK = (e, n, s) => {
      const l = CI(n, e);
      return l.length > 0 ? rH(e, l) : tK(e, n, s);
    }, PR = (e, n) => n >= 0 && n < e.length && D0(e.charAt(n)), kF = (e) => de(e.innerText), NF = (e) => e.map((n) => n.nodeName).getOr("div").toLowerCase(), RF = (e) => oe.from(e.selection.getRng()).map((n) => {
      var s;
      const l = oe.from(e.dom.getParent(n.commonAncestorContainer, e.dom.isBlock)), f = e.getBody(), b = NF(l), E = Fe.fromDom(n.cloneContents());
      Hr(E), rM(E);
      const N = e.dom.add(f, b, {
        "data-mce-bogus": "all",
        style: "overflow: hidden; opacity: 0;"
      }, E.dom), D = kF(N), U = de((s = N.textContent) !== null && s !== void 0 ? s : "");
      if (e.dom.remove(N), PR(U, 0) || PR(U, U.length - 1)) {
        const J = l.getOr(f), te = kF(J), ce = te.indexOf(D);
        if (ce === -1)
          return D;
        {
          const Oe = PR(te, ce - 1), Re = PR(te, ce + D.length);
          return (Oe ? " " : "") + D + (Re ? " " : "");
        }
      } else
        return D;
    }).getOr(""), oH = (e, n) => {
      const s = e.selection.getRng(), l = e.dom.create("body"), f = e.selection.getSel(), b = nM(e, Hx(f)), E = n.contextual ? nK(Fe.fromDom(e.getBody()), b, e.schema).dom : s.cloneContents();
      return E && l.appendChild(E), e.selection.serializer.serialize(l, n);
    }, PF = (e, n) => {
      if (n.format === "text")
        return RF(e);
      {
        const s = oH(e, n);
        return n.format === "tree" ? s : e.selection.isCollapsed() ? "" : s;
      }
    }, sH = (e, n) => ({
      ...e,
      format: n,
      get: !0,
      selection: !0,
      getInner: !0
    }), aH = (e, n, s = {}) => {
      const l = sH(s, n);
      return tS(e, l).fold(_n, (f) => {
        const b = PF(e, f);
        return CF(e, b, f);
      });
    }, RO = 0, DF = 1, $F = 2, iH = (e, n) => {
      const s = e.length + n.length + 2, l = new Array(s), f = new Array(s), b = (J, te, ce) => ({
        start: J,
        end: te,
        diag: ce
      }), E = (J, te, ce, Oe, Re) => {
        const xe = D(J, te, ce, Oe);
        if (xe === null || xe.start === te && xe.diag === te - Oe || xe.end === J && xe.diag === J - ce) {
          let Pe = J, Ke = ce;
          for (; Pe < te || Ke < Oe; )
            Pe < te && Ke < Oe && e[Pe] === n[Ke] ? (Re.push([
              RO,
              e[Pe]
            ]), ++Pe, ++Ke) : te - J > Oe - ce ? (Re.push([
              $F,
              e[Pe]
            ]), ++Pe) : (Re.push([
              DF,
              n[Ke]
            ]), ++Ke);
        } else {
          E(J, xe.start, ce, xe.start - xe.diag, Re);
          for (let Pe = xe.start; Pe < xe.end; ++Pe)
            Re.push([
              RO,
              e[Pe]
            ]);
          E(xe.end, te, xe.end - xe.diag, Oe, Re);
        }
      }, N = (J, te, ce, Oe) => {
        let Re = J;
        for (; Re - te < Oe && Re < ce && e[Re] === n[Re - te]; )
          ++Re;
        return b(J, Re, te);
      }, D = (J, te, ce, Oe) => {
        const Re = te - J, xe = Oe - ce;
        if (Re === 0 || xe === 0)
          return null;
        const Pe = Re - xe, Ke = xe + Re, et = (Ke % 2 === 0 ? Ke : Ke + 1) / 2;
        l[1 + et] = J, f[1 + et] = te + 1;
        let rt, dt, Ht, ln, Dn;
        for (rt = 0; rt <= et; ++rt) {
          for (dt = -rt; dt <= rt; dt += 2) {
            for (Ht = dt + et, dt === -rt || dt !== rt && l[Ht - 1] < l[Ht + 1] ? l[Ht] = l[Ht + 1] : l[Ht] = l[Ht - 1] + 1, ln = l[Ht], Dn = ln - J + ce - dt; ln < te && Dn < Oe && e[ln] === n[Dn]; )
              l[Ht] = ++ln, ++Dn;
            if (Pe % 2 !== 0 && Pe - rt <= dt && dt <= Pe + rt && f[Ht - Pe] <= l[Ht])
              return N(f[Ht - Pe], dt + J - ce, te, Oe);
          }
          for (dt = Pe - rt; dt <= Pe + rt; dt += 2) {
            for (Ht = dt + et - Pe, dt === Pe - rt || dt !== Pe + rt && f[Ht + 1] <= f[Ht - 1] ? f[Ht] = f[Ht + 1] - 1 : f[Ht] = f[Ht - 1], ln = f[Ht] - 1, Dn = ln - J + ce - dt; ln >= J && Dn >= ce && e[ln] === n[Dn]; )
              f[Ht] = ln--, Dn--;
            if (Pe % 2 === 0 && -rt <= dt && dt <= rt && f[Ht] <= l[Ht + Pe])
              return N(f[Ht], dt + J - ce, te, Oe);
          }
        }
        return null;
      }, U = [];
      return E(0, e.length, 0, n.length, U), U;
    }, IF = (e) => Un(e) ? e.outerHTML : Qt(e) ? Yg.encodeRaw(e.data, !1) : im(e) ? "<!--" + e.data + "-->" : "", MF = (e) => {
      let n;
      const s = document.createElement("div"), l = document.createDocumentFragment();
      for (e && (s.innerHTML = e); n = s.firstChild; )
        l.appendChild(n);
      return l;
    }, rK = (e, n, s) => {
      const l = MF(n);
      if (e.hasChildNodes() && s < e.childNodes.length) {
        const f = e.childNodes[s];
        e.insertBefore(l, f);
      } else
        e.appendChild(l);
    }, DR = (e, n) => {
      if (e.hasChildNodes() && n < e.childNodes.length) {
        const s = e.childNodes[n];
        e.removeChild(s);
      }
    }, oK = (e, n) => {
      let s = 0;
      ke(e, (l) => {
        l[0] === RO ? s++ : l[0] === DF ? (rK(n, l[1], s), s++) : l[0] === $F && DR(n, s);
      });
    }, sK = (e, n) => ht(St(Ps(e.childNodes), n ? z(de, IF) : IF), (s) => s.length > 0), aK = (e, n) => {
      const s = St(Ps(n.childNodes), IF);
      return oK(iH(s, e), n), n;
    }, cH = Qu(() => document.implementation.createHTMLDocument("undo")), lH = (e) => e.querySelector("iframe") !== null, iK = (e) => ({
      type: "fragmented",
      fragments: e,
      content: "",
      bookmark: null,
      beforeBookmark: null
    }), cK = (e) => ({
      type: "complete",
      fragments: null,
      content: e,
      bookmark: null,
      beforeBookmark: null
    }), $R = (e) => {
      const n = e.serializer.getTempAttrs(), s = $5(e.getBody(), n);
      return lH(s) ? iK(sK(s, !0)) : cK(de(s.innerHTML));
    }, FF = (e, n, s) => {
      const l = s ? n.beforeBookmark : n.bookmark;
      n.type === "fragmented" ? aK(n.fragments, e.getBody()) : e.setContent(n.content, {
        format: "raw",
        no_selection: Ie(l) && Xk(l) ? !l.isFakeCaret : !0
      }), l && (e.selection.moveToBookmark(l), e.selection.scrollIntoView());
    }, LF = (e) => e.type === "fragmented" ? e.fragments.join("") : e.content, BF = (e) => {
      const n = Fe.fromTag("body", cH());
      return cu(n, LF(e)), ke(Vi(n, "*[data-mce-bogus]"), zi), ye(n);
    }, Rce = (e, n) => LF(e) === LF(n), lK = (e, n) => BF(e) === BF(n), HF = (e, n) => !e || !n ? !1 : Rce(e, n) ? !0 : lK(e, n), zF = (e) => e.get() === 0, IR = (e, n, s) => {
      zF(s) && (e.typing = n);
    }, uH = (e, n) => {
      e.typing && (IR(e, !1, n), e.add());
    }, uK = (e) => {
      e.typing && (e.typing = !1, e.add());
    }, dK = (e, n, s) => {
      zF(n) && s.set(oh(e.selection));
    }, dH = (e, n, s, l, f, b, E) => {
      const N = $R(e), D = rn.extend(b || {}, N);
      if (!zF(l) || e.removed)
        return null;
      const U = n.data[s.get()];
      if (e.dispatch("BeforeAddUndo", {
        level: D,
        lastLevel: U,
        originalEvent: E
      }).isDefaultPrevented() || U && HF(U, D))
        return null;
      n.data[s.get()] && f.get().each((ce) => {
        n.data[s.get()].beforeBookmark = ce;
      });
      const J = Db(e);
      if (J && n.data.length > J) {
        for (let ce = 0; ce < n.data.length - 1; ce++)
          n.data[ce] = n.data[ce + 1];
        n.data.length--, s.set(n.data.length);
      }
      D.bookmark = oh(e.selection), s.get() < n.data.length - 1 && (n.data.length = s.get() + 1), n.data.push(D), s.set(n.data.length - 1);
      const te = {
        level: D,
        lastLevel: U,
        originalEvent: E
      };
      return s.get() > 0 ? (e.setDirty(!0), e.dispatch("AddUndo", te), e.dispatch("change", te)) : e.dispatch("AddUndo", te), D;
    }, fK = (e, n, s) => {
      n.data = [], s.set(0), n.typing = !1, e.dispatch("ClearUndos");
    }, mK = (e, n, s, l, f) => {
      if (n.transact(l)) {
        const b = n.data[s.get()].bookmark, E = n.data[s.get() - 1];
        FF(e, E, !0), n.transact(f) && (n.data[s.get() - 1].beforeBookmark = b);
      }
    }, pK = (e, n, s) => {
      let l;
      return n.get() < s.length - 1 && (n.set(n.get() + 1), l = s[n.get()], FF(e, l, !1), e.setDirty(!0), e.dispatch("Redo", { level: l })), l;
    }, hK = (e, n, s, l) => {
      let f;
      return n.typing && (n.add(), n.typing = !1, IR(n, !1, s)), l.get() > 0 && (l.set(l.get() - 1), f = n.data[l.get()], FF(e, f, !0), e.setDirty(!0), e.dispatch("Undo", { level: f })), f;
    }, gK = (e) => {
      e.clear(), e.add();
    }, Pce = (e, n, s) => s.get() > 0 || n.typing && n.data[0] && !HF($R(e), n.data[0]), Dce = (e, n) => n.get() < e.data.length - 1 && !e.typing, vK = (e, n, s) => (uH(e, n), e.beforeChange(), e.ignore(s), e.add()), bK = (e, n) => {
      try {
        e.set(e.get() + 1), n();
      } finally {
        e.set(e.get() - 1);
      }
    }, $ce = (e, n) => {
      const s = e.dom, l = Ie(n) ? n : e.getBody();
      ke(s.select("table,a", l), (f) => {
        switch (f.nodeName) {
          case "TABLE":
            const b = d_(e), E = s.getAttrib(f, "border");
            (!E || E === "0") && e.hasVisual ? s.addClass(f, b) : s.removeClass(f, b);
            break;
          case "A":
            if (!s.getAttrib(f, "href")) {
              const N = s.getAttrib(f, "name") || f.id, D = wx(e);
              N && e.hasVisual ? s.addClass(f, D) : s.removeClass(f, D);
            }
            break;
        }
      }), e.dispatch("VisualAid", {
        element: n,
        hasVisual: e.hasVisual
      });
    }, fH = (e) => ({
      init: { bindEvents: Lt },
      undoManager: {
        beforeChange: (n, s) => dK(e, n, s),
        add: (n, s, l, f, b, E) => dH(e, n, s, l, f, b, E),
        undo: (n, s, l) => hK(e, n, s, l),
        redo: (n, s) => pK(e, n, s),
        clear: (n, s) => fK(e, n, s),
        reset: (n) => gK(n),
        hasUndo: (n, s) => Pce(e, n, s),
        hasRedo: (n, s) => Dce(n, s),
        transact: (n, s, l) => vK(n, s, l),
        ignore: (n, s) => bK(n, s),
        extra: (n, s, l, f) => mK(e, n, s, l, f)
      },
      formatter: {
        match: (n, s, l, f) => pT(e, n, s, l, f),
        matchAll: (n, s) => K6(e, n, s),
        matchNode: (n, s, l, f) => Zb(e, n, s, l, f),
        canApply: (n) => tZ(e, n),
        closest: (n) => Y6(e, n),
        apply: (n, s, l) => g8(e, n, s, l),
        remove: (n, s, l, f) => sF(e, n, s, l, f),
        toggle: (n, s, l) => S8(e, n, s, l),
        formatChanged: (n, s, l, f, b) => SZ(e, n, s, l, f, b)
      },
      editor: {
        getContent: (n) => _ce(e, n),
        setContent: (n, s) => JG(e, n, s),
        insertContent: (n, s) => QG(e, n, s),
        addVisual: (n) => $ce(e, n)
      },
      selection: { getContent: (n, s) => aH(e, n, s) },
      autocompleter: {
        addDecoration: (n) => Qq(e, n),
        removeDecoration: () => Jq(e, Fe.fromDom(e.getBody()))
      },
      raw: { getModel: () => oe.none() }
    }), yi = (e) => {
      const n = (U) => me(U) ? U : {}, { init: s, undoManager: l, formatter: f, editor: b, selection: E, autocompleter: N, raw: D } = e;
      return {
        init: { bindEvents: s.bindEvents },
        undoManager: {
          beforeChange: l.beforeChange,
          add: l.add,
          undo: l.undo,
          redo: l.redo,
          clear: l.clear,
          reset: l.reset,
          hasUndo: l.hasUndo,
          hasRedo: l.hasRedo,
          transact: (U, J, te) => l.transact(te),
          ignore: (U, J) => l.ignore(J),
          extra: (U, J, te, ce) => l.extra(te, ce)
        },
        formatter: {
          match: (U, J, te, ce) => f.match(U, n(J), ce),
          matchAll: f.matchAll,
          matchNode: f.matchNode,
          canApply: (U) => f.canApply(U),
          closest: (U) => f.closest(U),
          apply: (U, J, te) => f.apply(U, n(J)),
          remove: (U, J, te, ce) => f.remove(U, n(J)),
          toggle: (U, J, te) => f.toggle(U, n(J)),
          formatChanged: (U, J, te, ce, Oe) => f.formatChanged(J, te, ce, Oe)
        },
        editor: {
          getContent: (U) => b.getContent(U),
          setContent: (U, J) => ({
            content: b.setContent(U, J),
            html: ""
          }),
          insertContent: (U, J) => (b.insertContent(U), ""),
          addVisual: b.addVisual
        },
        selection: { getContent: (U, J) => E.getContent(J) },
        autocompleter: {
          addDecoration: N.addDecoration,
          removeDecoration: N.removeDecoration
        },
        raw: { getModel: () => oe.some(D.getRawModel()) }
      };
    }, VF = () => {
      const e = at(null), n = at("");
      return {
        init: { bindEvents: Lt },
        undoManager: {
          beforeChange: Lt,
          add: e,
          undo: e,
          redo: e,
          clear: Lt,
          reset: Lt,
          hasUndo: He,
          hasRedo: He,
          transact: e,
          ignore: Lt,
          extra: Lt
        },
        formatter: {
          match: He,
          matchAll: at([]),
          matchNode: at(void 0),
          canApply: He,
          closest: n,
          apply: Lt,
          remove: Lt,
          toggle: Lt,
          formatChanged: at({ unbind: Lt })
        },
        editor: {
          getContent: n,
          setContent: at({
            content: "",
            html: ""
          }),
          insertContent: at(""),
          addVisual: Lt
        },
        selection: { getContent: n },
        autocompleter: {
          addDecoration: Lt,
          removeDecoration: Lt
        },
        raw: { getModel: at(oe.none()) }
      };
    }, d1 = (e) => lr(e.plugins, "rtc"), yK = (e) => gs(e.plugins, "rtc").bind((n) => oe.from(n.setup)), SK = (e) => {
      const n = e;
      return yK(e).fold(() => (n.rtcInstance = fH(e), oe.none()), (s) => (n.rtcInstance = VF(), oe.some(() => s().then((l) => (n.rtcInstance = yi(l), l.rtc.isRemote)))));
    }, nS = (e) => e.rtcInstance ? e.rtcInstance : fH(e), Hc = (e) => {
      const n = e.rtcInstance;
      if (n)
        return n;
      throw new Error("Failed to get RTC instance not yet initialized.");
    }, Ice = (e, n, s) => {
      Hc(e).undoManager.beforeChange(n, s);
    }, wu = (e, n, s, l, f, b, E) => Hc(e).undoManager.add(n, s, l, f, b, E), mH = (e, n, s, l) => Hc(e).undoManager.undo(n, s, l), pH = (e, n, s) => Hc(e).undoManager.redo(n, s), hH = (e, n, s) => {
      Hc(e).undoManager.clear(n, s);
    }, wK = (e, n) => {
      Hc(e).undoManager.reset(n);
    }, EK = (e, n, s) => Hc(e).undoManager.hasUndo(n, s), MR = (e, n, s) => Hc(e).undoManager.hasRedo(n, s), CK = (e, n, s, l) => Hc(e).undoManager.transact(n, s, l), UF = (e, n, s) => {
      Hc(e).undoManager.ignore(n, s);
    }, xK = (e, n, s, l, f) => {
      Hc(e).undoManager.extra(n, s, l, f);
    }, gH = (e, n, s, l, f) => Hc(e).formatter.match(n, s, l, f), vH = (e, n, s) => Hc(e).formatter.matchAll(n, s), WF = (e, n, s, l, f) => Hc(e).formatter.matchNode(n, s, l, f), bH = (e, n) => Hc(e).formatter.canApply(n), jF = (e, n) => Hc(e).formatter.closest(n), TK = (e, n, s, l) => {
      Hc(e).formatter.apply(n, s, l);
    }, _K = (e, n, s, l, f) => {
      Hc(e).formatter.remove(n, s, l, f);
    }, OK = (e, n, s, l) => {
      Hc(e).formatter.toggle(n, s, l);
    }, bh = (e, n, s, l, f, b) => Hc(e).formatter.formatChanged(n, s, l, f, b), AK = (e, n) => nS(e).editor.getContent(n), kK = (e, n, s) => nS(e).editor.setContent(n, s), NK = (e, n, s) => nS(e).editor.insertContent(n, s), RK = (e, n, s) => Hc(e).selection.getContent(n, s), PK = (e, n) => Hc(e).editor.addVisual(n), qF = (e) => Hc(e).init.bindEvents(), DK = (e, n) => Hc(e).autocompleter.addDecoration(n), $K = (e) => Hc(e).autocompleter.removeDecoration(), IK = (e, n = {}) => {
      const s = n.format ? n.format : "html";
      return RK(e, s, n);
    }, PO = (e) => e.dom.length === 0 ? (mo(e), oe.none()) : oe.some(e), MK = (e, n) => e.filter((s) => Xy.isBookmarkNode(s.dom)).bind(n ? Hl : $a), FK = (e, n, s, l, f) => {
      const b = e.dom, E = n.dom, N = l ? b.length : E.length;
      l ? (cl(b, E, f, !1, !l), s.setStart(E, N)) : (cl(E, b, f, !1, !l), s.setEnd(E, N));
    }, yH = (e, n, s) => {
      Qo(e).each((l) => {
        const f = e.dom;
        n && aT(l, yt(f, 0), s) ? EE(f, 0, s) : !n && iT(l, yt(f, f.length), s) && r6(f, f.length, s);
      });
    }, FR = (e, n, s, l, f) => {
      e.bind((b) => ((l ? r6 : EE)(b.dom, l ? b.dom.length : 0, f), n.filter(hi).map((N) => FK(b, N, s, l, f)))).orThunk(() => MK(n, l).or(n).filter(hi).map((E) => yH(E, l, f)));
    }, LK = (e, n, s) => {
      const l = oe.from(n.firstChild).map(Fe.fromDom), f = oe.from(n.lastChild).map(Fe.fromDom);
      e.deleteContents(), e.insertNode(n);
      const b = l.bind($a).filter(hi).bind(PO), E = f.bind(Hl).filter(hi).bind(PO);
      FR(b, l, e, !0, s), FR(E, f, e, !1, s), e.collapse(!1);
    }, BK = (e, n) => ({
      format: "html",
      ...e,
      set: !0,
      selection: !0,
      content: n
    }), Mce = (e, n) => {
      if (n.format !== "raw") {
        const s = e.selection.getRng(), l = e.dom.getParent(s.commonAncestorContainer, e.dom.isBlock), f = l ? { context: l.nodeName.toLowerCase() } : {}, b = e.parser.parse(n.content, {
          forced_root_block: !1,
          ...f,
          ...n
        });
        return j0({ validate: !1 }, e.schema).serialize(b);
      } else
        return n.content;
    }, HK = (e, n, s = {}) => {
      const l = BK(s, n);
      xF(e, l).each((f) => {
        const b = Mce(e, f), E = e.selection.getRng();
        LK(E, E.createContextualFragment(b), e.schema), e.selection.setRng(E), bE(e, E), OR(e, b, f);
      });
    }, SH = (e, n, s) => {
      if (lr(e, n)) {
        const l = ht(e[n], (f) => f !== s);
        l.length === 0 ? delete e[n] : e[n] = l;
      }
    };
    var wH = (e, n) => {
      let s, l;
      const f = (N, D) => Bt(D, (U) => e.is(U, N)), b = (N) => e.getParents(N, void 0, e.getRoot()), E = () => {
        s = {}, l = {}, n.on("NodeChange", (N) => {
          const D = N.element, U = b(D), J = {};
          fn(s, (te, ce) => {
            f(ce, U).each((Oe) => {
              l[ce] || (ke(te, (Re) => {
                Re(!0, {
                  node: Oe,
                  selector: ce,
                  parents: U
                });
              }), l[ce] = te), J[ce] = te;
            });
          }), fn(l, (te, ce) => {
            J[ce] || (delete l[ce], ke(te, (Oe) => {
              Oe(!1, {
                node: D,
                selector: ce,
                parents: U
              });
            }));
          });
        });
      };
      return {
        selectorChangedWithUnbind: (N, D) => (s || E(), s[N] || (s[N] = []), s[N].push(D), f(N, b(n.selection.getStart())).each(() => {
          l[N] = s[N];
        }), {
          unbind: () => {
            SH(s, N, D), SH(l, N, D);
          }
        })
      };
    };
    const GF = (e) => !!(e && e.ownerDocument) && Wt(Fe.fromDom(e.ownerDocument), Fe.fromDom(e)), zK = (e) => e ? GF(e.startContainer) && GF(e.endContainer) : !1, rS = (e, n, s, l) => {
      let f, b;
      const { selectorChangedWithUnbind: E } = wH(e, l), N = (wn, Ln) => {
        const Ho = e.createRng();
        Ie(wn) && Ie(Ln) ? (Ho.setStart(wn, Ln), Ho.setEnd(wn, Ln), dt(Ho), Ke(!1)) : ($_(e, Ho, l.getBody(), !0), dt(Ho));
      }, D = (wn) => IK(l, wn), U = (wn, Ln) => HK(l, wn, Ln), J = (wn) => eM(l.getBody(), rt(), wn), te = (wn) => x5(l.getBody(), rt(), wn), ce = (wn, Ln) => Kl.getBookmark(wn, Ln), Oe = (wn) => Kl.moveToBookmark(wn), Re = (wn, Ln) => (Uq(e, wn, Ln).each(dt), wn), xe = () => {
        const wn = rt(), Ln = et();
        return !wn || wn.item ? !1 : wn.compareEndPoints ? wn.compareEndPoints("StartToEnd", wn) === 0 : !Ln || wn.collapsed;
      }, Pe = () => {
        const wn = rt(), Ln = l.getBody().querySelectorAll('[data-mce-selected="1"]');
        return Ln.length > 0 ? Vr(Ln, (Ho) => e.isEditable(Ho.parentElement)) : E5(e, wn);
      }, Ke = (wn) => {
        const Ln = rt();
        Ln.collapse(!!wn), dt(Ln);
      }, et = () => n.getSelection ? n.getSelection() : n.document.selection, rt = () => {
        let wn;
        const Ln = (Ao, Qn, Jn) => {
          try {
            return Qn.compareBoundaryPoints(Ao, Jn);
          } catch {
            return -1;
          }
        }, Ho = n.document;
        if (Ie(l.bookmark) && !W0(l)) {
          const Ao = YI(l);
          if (Ao.isSome())
            return Ao.map((Qn) => nM(l, [Qn])[0]).getOr(Ho.createRange());
        }
        try {
          const Ao = et();
          Ao && !pf(Ao.anchorNode) && (Ao.rangeCount > 0 ? wn = Ao.getRangeAt(0) : wn = Ho.createRange(), wn = nM(l, [wn])[0]);
        } catch {
        }
        if (wn || (wn = Ho.createRange()), Mu(wn.startContainer) && wn.collapsed) {
          const Ao = e.getRoot();
          wn.setStart(Ao, 0), wn.setEnd(Ao, 0);
        }
        return f && b && (Ln(wn.START_TO_START, wn, f) === 0 && Ln(wn.END_TO_END, wn, f) === 0 ? wn = b : (f = null, b = null)), wn;
      }, dt = (wn, Ln) => {
        if (!zK(wn))
          return;
        const Ho = et();
        if (wn = l.dispatch("SetSelectionRange", {
          range: wn,
          forward: Ln
        }).range, Ho) {
          b = wn;
          try {
            Ho.removeAllRanges(), Ho.addRange(wn);
          } catch {
          }
          Ln === !1 && Ho.extend && (Ho.collapse(wn.endContainer, wn.endOffset), Ho.extend(wn.startContainer, wn.startOffset)), f = Ho.rangeCount > 0 ? Ho.getRangeAt(0) : null;
        }
        if (!wn.collapsed && wn.startContainer === wn.endContainer && (Ho != null && Ho.setBaseAndExtent) && wn.endOffset - wn.startOffset < 2 && wn.startContainer.hasChildNodes()) {
          const Qn = wn.startContainer.childNodes[wn.startOffset];
          Qn && Qn.nodeName === "IMG" && (Ho.setBaseAndExtent(wn.startContainer, wn.startOffset, wn.endContainer, wn.endOffset), (Ho.anchorNode !== wn.startContainer || Ho.focusNode !== wn.endContainer) && Ho.setBaseAndExtent(Qn, 0, Qn, 1));
        }
        l.dispatch("AfterSetSelectionRange", {
          range: wn,
          forward: Ln
        });
      }, Ht = (wn) => (U(e.getOuterHTML(wn)), wn), ln = () => T5(l.getBody(), rt()), Dn = (wn, Ln) => Vq(e, rt(), wn, Ln), Rt = () => {
        const wn = et(), Ln = wn == null ? void 0 : wn.anchorNode, Ho = wn == null ? void 0 : wn.focusNode;
        if (!wn || !Ln || !Ho || pf(Ln) || pf(Ho))
          return !0;
        const Ao = e.createRng(), Qn = e.createRng();
        try {
          Ao.setStart(Ln, wn.anchorOffset), Ao.collapse(!0), Qn.setStart(Ho, wn.focusOffset), Qn.collapse(!0);
        } catch {
          return !0;
        }
        return Ao.compareBoundaryPoints(Ao.START_TO_START, Qn) <= 0;
      }, Si = {
        dom: e,
        win: n,
        serializer: s,
        editor: l,
        expand: (wn = { type: "word" }) => dt(ve(e).expand(rt(), wn)),
        collapse: Ke,
        setCursorLocation: N,
        getContent: D,
        setContent: U,
        getBookmark: ce,
        moveToBookmark: Oe,
        select: Re,
        isCollapsed: xe,
        isEditable: Pe,
        isForward: Rt,
        setNode: Ht,
        getNode: ln,
        getSel: et,
        setRng: dt,
        getRng: rt,
        getStart: J,
        getEnd: te,
        getSelectedBlocks: Dn,
        normalize: () => {
          const wn = rt(), Ln = et();
          if (!Qy(Ln) && Vx(l)) {
            const Ho = V(e, wn);
            return Ho.each((Ao) => {
              dt(Ao, Rt());
            }), Ho.getOr(wn);
          }
          return wn;
        },
        selectorChanged: (wn, Ln) => (E(wn, Ln), Si),
        selectorChangedWithUnbind: E,
        getScrollContainer: () => {
          let wn, Ln = e.getRoot();
          for (; Ln && Ln.nodeName !== "BODY"; ) {
            if (Ln.scrollHeight > Ln.clientHeight) {
              wn = Ln;
              break;
            }
            Ln = Ln.parentNode;
          }
          return wn;
        },
        scrollIntoView: (wn, Ln) => {
          Ie(wn) ? Gl(l, wn, Ln) : bE(l, rt(), Ln);
        },
        placeCaretAt: (wn, Ln) => dt($f(wn, Ln, l.getDoc())),
        getBoundingClientRect: () => {
          const wn = rt();
          return wn.collapsed ? yt.fromRangeStart(wn).getClientRects()[0] : wn.getBoundingClientRect();
        },
        destroy: () => {
          n = f = b = null, ll.destroy();
        }
      }, Kl = Xy(Si), ll = u5(Si, l);
      return Si.bookmarkManager = Kl, Si.controlSelection = ll, Si;
    }, ST = (e, n, s) => {
      e.addAttributeFilter("data-mce-tabindex", (l, f) => {
        let b = l.length;
        for (; b--; ) {
          const E = l[b];
          E.attr("tabindex", E.attr("data-mce-tabindex")), E.attr(f, null);
        }
      }), e.addAttributeFilter("src,href,style", (l, f) => {
        const b = "data-mce-" + f, E = n.url_converter, N = n.url_converter_scope;
        let D = l.length;
        for (; D--; ) {
          const U = l[D];
          let J = U.attr(b);
          J !== void 0 ? (U.attr(f, J.length > 0 ? J : null), U.attr(b, null)) : (J = U.attr(f), f === "style" ? J = s.serializeStyle(s.parseStyle(J), U.name) : E && (J = E.call(N, J, f, U.name)), U.attr(f, J.length > 0 ? J : null));
        }
      }), e.addAttributeFilter("class", (l) => {
        let f = l.length;
        for (; f--; ) {
          const b = l[f];
          let E = b.attr("class");
          E && (E = E.replace(/(?:^|\s)mce-item-\w+(?!\S)/g, ""), b.attr("class", E.length > 0 ? E : null));
        }
      }), e.addAttributeFilter("data-mce-type", (l, f, b) => {
        let E = l.length;
        for (; E--; ) {
          const N = l[E];
          N.attr("data-mce-type") === "bookmark" && !b.cleanup && (oe.from(N.firstChild).exists((U) => {
            var J;
            return !W((J = U.value) !== null && J !== void 0 ? J : "");
          }) ? N.unwrap() : N.remove());
        }
      }), e.addNodeFilter("script,style", (l, f) => {
        var b;
        const E = (D) => D.replace(/(<!--\[CDATA\[|\]\]-->)/g, `
`).replace(/^[\r\n]*|[\r\n]*$/g, "").replace(/^\s*((<!--)?(\s*\/\/)?\s*<!\[CDATA\[|(<!--\s*)?\/\*\s*<!\[CDATA\[\s*\*\/|(\/\/)?\s*<!--|\/\*\s*<!--\s*\*\/)\s*[\r\n]*/gi, "").replace(/\s*(\/\*\s*\]\]>\s*\*\/(-->)?|\s*\/\/\s*\]\]>(-->)?|\/\/\s*(-->)?|\]\]>|\/\*\s*-->\s*\*\/|\s*-->\s*)\s*$/g, "");
        let N = l.length;
        for (; N--; ) {
          const D = l[N], U = D.firstChild, J = (b = U == null ? void 0 : U.value) !== null && b !== void 0 ? b : "";
          if (f === "script") {
            const te = D.attr("type");
            te && D.attr("type", te === "mce-no/type" ? null : te.replace(/^mce\-/, "")), n.element_format === "xhtml" && U && J.length > 0 && (U.value = `// <![CDATA[
` + E(J) + `
// ]]>`);
          } else
            n.element_format === "xhtml" && U && J.length > 0 && (U.value = `<!--
` + E(J) + `
-->`);
        }
      }), e.addNodeFilter("#comment", (l) => {
        let f = l.length;
        for (; f--; ) {
          const b = l[f], E = b.value;
          n.preserve_cdata && (E == null ? void 0 : E.indexOf("[CDATA[")) === 0 ? (b.name = "#cdata", b.type = 4, b.value = s.decode(E.replace(/^\[CDATA\[|\]\]$/g, ""))) : (E == null ? void 0 : E.indexOf("mce:protected ")) === 0 && (b.name = "#text", b.type = 3, b.raw = !0, b.value = unescape(E).substr(14));
        }
      }), e.addNodeFilter("xml:namespace,input", (l, f) => {
        let b = l.length;
        for (; b--; ) {
          const E = l[b];
          E.type === 7 ? E.remove() : E.type === 1 && f === "input" && !E.attr("type") && E.attr("type", "text");
        }
      }), e.addAttributeFilter("data-mce-type", (l) => {
        ke(l, (f) => {
          f.attr("data-mce-type") === "format-caret" && (f.isEmpty(e.schema.getNonEmptyElements()) ? f.remove() : f.unwrap());
        });
      }), e.addAttributeFilter("data-mce-src,data-mce-href,data-mce-style,data-mce-selected,data-mce-expando,data-mce-block,data-mce-type,data-mce-resize,data-mce-placeholder", (l, f) => {
        let b = l.length;
        for (; b--; )
          l[b].attr(f, null);
      }), n.remove_trailing_brs && C8(n, e, e.schema);
    }, DO = (e) => {
      const n = (l) => (l == null ? void 0 : l.name) === "br", s = e.lastChild;
      if (n(s)) {
        const l = s.prev;
        n(l) && (s.remove(), l.remove());
      }
    }, EH = (e, n, s) => {
      let l;
      const f = e.dom;
      let b = n.cloneNode(!0);
      const E = document.implementation;
      if (E.createHTMLDocument) {
        const N = E.createHTMLDocument("");
        rn.each(b.nodeName === "BODY" ? b.childNodes : [b], (D) => {
          N.body.appendChild(N.importNode(D, !0));
        }), b.nodeName !== "BODY" ? b = N.body.firstChild : b = N.body, l = f.doc, f.doc = N;
      }
      return U_(e, {
        ...s,
        node: b
      }), l && (f.doc = l), b;
    }, CH = (e, n) => Ie(e) && e.hasEventListeners("PreProcess") && !n.no_events, VK = (e, n, s) => CH(e, s) ? EH(e, n, s) : n, xH = (e, n, s) => {
      rn.inArray(n, s) === -1 && (e.addAttributeFilter(s, (l, f) => {
        let b = l.length;
        for (; b--; )
          l[b].attr(f, null);
      }), n.push(s));
    }, UK = (e, n, s) => !n.no_events && e ? NI(e, {
      ...n,
      content: s
    }).content : s, WK = (e, n, s) => {
      const l = de(s.getInner ? n.innerHTML : e.getOuterHTML(n));
      return s.selection || vi(Fe.fromDom(n)) ? l : rn.trim(l);
    }, jK = (e, n, s) => {
      const l = s.selection ? {
        forced_root_block: !1,
        ...s
      } : s, f = e.parse(n, l);
      return DO(f), f;
    }, qK = (e, n, s) => j0(e, n).serialize(s), TH = (e, n, s, l, f) => {
      const b = qK(n, s, l);
      return UK(e, f, b);
    }, GK = (e, n) => {
      const s = ["data-mce-selected"], l = {
        entity_encoding: "named",
        remove_trailing_brs: !0,
        pad_empty_with_br: !1,
        ...e
      }, f = n && n.dom ? n.dom : Is.DOM, b = n && n.schema ? n.schema : jm(l), E = hg(l, b);
      ST(E, l, f);
      const N = (D, U = {}) => {
        const J = {
          format: "html",
          ...U
        }, te = VK(n, D, J), ce = WK(f, te, J), Oe = jK(E, ce, J);
        return J.format === "tree" ? Oe : TH(n, l, b, Oe, J);
      };
      return {
        schema: b,
        addNodeFilter: E.addNodeFilter,
        addAttributeFilter: E.addAttributeFilter,
        serialize: N,
        addRules: b.addValidElements,
        setRules: b.setValidElements,
        addTempAttr: Ne(xH, E, s),
        getTempAttrs: at(s),
        getNodeFilters: E.getNodeFilters,
        getAttributeFilters: E.getAttributeFilters,
        removeNodeFilter: E.removeNodeFilter,
        removeAttributeFilter: E.removeAttributeFilter
      };
    }, _H = (e, n) => {
      const s = GK(e, n);
      return {
        schema: s.schema,
        addNodeFilter: s.addNodeFilter,
        addAttributeFilter: s.addAttributeFilter,
        serialize: s.serialize,
        addRules: s.addRules,
        setRules: s.setRules,
        addTempAttr: s.addTempAttr,
        getTempAttrs: s.getTempAttrs,
        getNodeFilters: s.getNodeFilters,
        getAttributeFilters: s.getAttributeFilters,
        removeNodeFilter: s.removeNodeFilter,
        removeAttributeFilter: s.removeAttributeFilter
      };
    }, $O = "html", OH = (e, n) => ({
      ...e,
      format: n,
      get: !0,
      getInner: !0
    }), AH = (e, n = {}) => {
      const s = n.format ? n.format : $O, l = OH(n, s);
      return tS(e, l).fold(_n, (f) => {
        const b = AK(e, f);
        return CF(e, b, f);
      });
    }, ZK = "html", KK = (e, n) => ({
      format: ZK,
      ...e,
      set: !0,
      content: n
    }), ZF = (e, n, s = {}) => {
      const l = KK(s, n);
      return xF(e, l).map((f) => {
        const b = kK(e, f.content, f);
        return OR(e, b.html, f), b.content;
      }).getOr(n);
    }, kH = "autoresize_on_init,content_editable_state,padd_empty_with_br,block_elements,boolean_attributes,editor_deselector,editor_selector,elements,file_browser_callback_types,filepicker_validator_handler,force_hex_style_colors,force_p_newlines,gecko_spellcheck,images_dataimg_filter,media_scripts,mode,move_caret_before_on_enter_elements,non_empty_elements,self_closing_elements,short_ended_elements,special,spellchecker_select_languages,spellchecker_whitelist,tab_focus,tabfocus_elements,table_responsive_width,text_block_elements,text_inline_elements,toolbar_drawer,types,validate,whitespace_elements,paste_enable_default_filters,paste_filter_drop,paste_word_valid_elements,paste_retain_style_properties,paste_convert_word_fake_lists".split(","), YK = "template_cdate_classes,template_mdate_classes,template_selected_content_classes,template_preview_replace_values,template_replace_values,templates,template_cdate_format,template_mdate_format".split(","), QK = "bbcode,colorpicker,contextmenu,fullpage,legacyoutput,spellchecker,textcolor".split(","), NH = [
      {
        name: "template",
        replacedWith: "Advanced Template"
      },
      { name: "rtc" }
    ], RH = (e, n) => {
      const s = ht(n, (l) => lr(e, l));
      return uo(s);
    }, Fce = (e) => {
      const n = RH(e, kH), s = e.forced_root_block;
      return (s === !1 || s === "") && n.push("forced_root_block (false only)"), uo(n);
    }, Tv = (e) => RH(e, YK), LR = (e, n) => {
      const s = rn.makeMap(e.plugins, " "), f = ht(n, (b) => lr(s, b));
      return uo(f);
    }, XK = (e) => LR(e, QK), JK = (e) => LR(e, NH.map((n) => n.name)), eY = (e, n) => {
      const s = Fce(e), l = XK(n), f = l.length > 0, b = s.length > 0, E = n.theme === "mobile";
      if (f || b || E) {
        const N = `
- `, D = E ? `

Themes:${N}mobile` : "", U = f ? `

Plugins:${N}${l.join(N)}` : "", J = b ? `

Options:${N}${s.join(N)}` : "";
        console.warn("The following deprecated features are currently enabled and have been removed in TinyMCE 6.0. These features will no longer work and should be removed from the TinyMCE configuration. See https://www.tiny.cloud/docs/tinymce/6/migration-from-5x/ for more information." + D + U + J);
      }
    }, tY = (e) => Bt(NH, (n) => n.name === e).fold(() => e, (n) => n.replacedWith ? `${e}, replaced by ${n.replacedWith}` : e), ps = (e, n) => {
      const s = Tv(e), l = JK(n), f = l.length > 0, b = s.length > 0;
      if (f || b) {
        const E = `
- `, N = f ? `

Plugins:${E}${l.map(tY).join(E)}` : "", D = b ? `

Options:${E}${s.join(E)}` : "";
        console.warn("The following deprecated features are currently enabled but will be removed soon." + N + D);
      }
    }, Lce = (e, n) => {
      eY(e, n), ps(e, n);
    }, BR = Is.DOM, nY = (e) => {
      BR.setStyle(e.id, "display", e.orgDisplay);
    }, Ea = (e) => oe.from(e).each((n) => n.destroy()), rY = (e) => {
      const n = e;
      n.contentAreaContainer = n.formElement = n.container = n.editorContainer = null, n.bodyElement = n.contentDocument = n.contentWindow = null, n.iframeElement = n.targetElm = null;
      const s = e.selection;
      if (s) {
        const l = s.dom;
        n.selection = s.win = s.dom = l.doc = null;
      }
    }, IO = (e) => {
      const n = e.formElement;
      n && (n._mceOldSubmit && (n.submit = n._mceOldSubmit, delete n._mceOldSubmit), BR.unbind(n, "submit reset", e.formEventDelegate));
    }, oY = (e) => {
      if (!e.removed) {
        const { _selectionOverrides: n, editorUpload: s } = e, l = e.getBody(), f = e.getElement();
        l && e.save({ is_removing: !0 }), e.removed = !0, e.unbindAllNativeEvents(), e.hasHiddenInput && Ie(f == null ? void 0 : f.nextSibling) && BR.remove(f.nextSibling), L0(e), e.editorManager.remove(e), !e.inline && l && nY(e), B0(e), BR.remove(e.getContainer()), Ea(n), Ea(s), e.destroy();
      }
    }, sY = (e, n) => {
      const { selection: s, dom: l } = e;
      if (!e.destroyed) {
        if (!n && !e.removed) {
          e.remove();
          return;
        }
        n || (e.editorManager.off("beforeunload", e._beforeUnload), e.theme && e.theme.destroy && e.theme.destroy(), Ea(s), Ea(l)), IO(e), rY(e), e.destroyed = !0;
      }
    }, MO = (() => {
      const e = {};
      return {
        add: (f, b) => {
          e[f] = b;
        },
        get: (f) => e[f] ? e[f] : { icons: {} },
        has: (f) => lr(e, f)
      };
    })(), yh = wl.ModelManager, Bf = (e, n) => n.dom[e], wT = (e, n) => parseInt(va(n, e), 10), oS = Ne(Bf, "clientWidth"), Xb = Ne(Bf, "clientHeight"), FO = Ne(wT, "margin-top"), KF = Ne(wT, "margin-left"), YF = (e) => e.dom.getBoundingClientRect(), PH = (e, n, s) => {
      const l = oS(e), f = Xb(e);
      return n >= 0 && s >= 0 && n <= l && s <= f;
    }, DH = (e, n, s, l) => {
      const f = YF(n), b = e ? f.left + n.dom.clientLeft + KF(n) : 0, E = e ? f.top + n.dom.clientTop + FO(n) : 0, N = s - b, D = l - E;
      return {
        x: N,
        y: D
      };
    }, aY = (e, n, s) => {
      const l = Fe.fromDom(e.getBody()), f = e.inline ? l : Qr(l), b = DH(e.inline, f, n, s);
      return PH(f, b.x, b.y);
    }, iY = (e) => oe.from(e).map(Fe.fromDom), $H = (e) => {
      const n = e.inline ? e.getBody() : e.getContentAreaContainer();
      return iY(n).map(rm).getOr(!1);
    };
    var IH = () => {
      const e = () => {
        throw new Error("Theme did not provide a NotificationManager implementation.");
      };
      return {
        open: e,
        close: e,
        getArgs: e
      };
    };
    const QF = (e) => {
      const n = [], s = () => {
        const ce = e.theme;
        return ce && ce.getNotificationManagerImpl ? ce.getNotificationManagerImpl() : IH();
      }, l = () => oe.from(n[0]), f = (ce, Oe) => ce.type === Oe.type && ce.text === Oe.text && !ce.progressBar && !ce.timeout && !Oe.progressBar && !Oe.timeout, b = () => {
        ke(n, (ce) => {
          ce.reposition();
        });
      }, E = (ce) => {
        n.push(ce);
      }, N = (ce) => {
        $n(n, (Oe) => Oe === ce).each((Oe) => {
          n.splice(Oe, 1);
        });
      }, D = (ce, Oe = !0) => e.removed || !$H(e) ? {} : (Oe && e.dispatch("BeforeOpenNotification", { notification: ce }), Bt(n, (Re) => f(s().getArgs(Re), ce)).getOrThunk(() => {
        e.editorManager.setActive(e);
        const Re = s().open(ce, () => {
          N(Re), b(), w5(e) && l().fold(() => e.focus(), (xe) => CN(Fe.fromDom(xe.getEl())));
        });
        return E(Re), b(), e.dispatch("OpenNotification", { notification: { ...Re } }), Re;
      })), U = () => {
        l().each((ce) => {
          s().close(ce), N(ce), b();
        });
      }, J = at(n);
      return ((ce) => {
        ce.on("SkinLoaded", () => {
          const Oe = a_(ce);
          Oe && D({
            text: Oe,
            type: "warning",
            timeout: 0
          }, !1), b();
        }), ce.on("show ResizeEditor ResizeWindow NodeChange", () => {
          requestAnimationFrame(b);
        }), ce.on("remove", () => {
          ke(n.slice(), (Oe) => {
            s().close(Oe);
          });
        });
      })(e), {
        open: D,
        close: U,
        getNotifications: J
      };
    }, PE = wl.PluginManager, f1 = wl.ThemeManager;
    var Hce = () => {
      const e = () => {
        throw new Error("Theme did not provide a WindowManager implementation.");
      };
      return {
        open: e,
        openUrl: e,
        alert: e,
        confirm: e,
        close: e
      };
    };
    const MH = (e) => {
      let n = [];
      const s = () => {
        const xe = e.theme;
        return xe && xe.getWindowManagerImpl ? xe.getWindowManagerImpl() : Hce();
      }, l = (xe, Pe) => (...Ke) => Pe ? Pe.apply(xe, Ke) : void 0, f = (xe) => {
        e.dispatch("OpenWindow", { dialog: xe });
      }, b = (xe) => {
        e.dispatch("CloseWindow", { dialog: xe });
      }, E = (xe) => {
        n.push(xe), f(xe);
      }, N = (xe) => {
        b(xe), n = ht(n, (Pe) => Pe !== xe), n.length === 0 && e.focus();
      }, D = () => oe.from(n[n.length - 1]), U = (xe) => {
        e.editorManager.setActive(e), oT(e), e.ui.show();
        const Pe = xe();
        return E(Pe), Pe;
      }, J = (xe, Pe) => U(() => s().open(xe, Pe, N)), te = (xe) => U(() => s().openUrl(xe, N)), ce = (xe, Pe, Ke) => {
        const et = s();
        et.alert(xe, l(Ke || et, Pe));
      }, Oe = (xe, Pe, Ke) => {
        const et = s();
        et.confirm(xe, l(Ke || et, Pe));
      }, Re = () => {
        D().each((xe) => {
          s().close(xe), N(xe);
        });
      };
      return e.on("remove", () => {
        ke(n, (xe) => {
          s().close(xe);
        });
      }), {
        open: J,
        openUrl: te,
        alert: ce,
        confirm: Oe,
        close: Re
      };
    }, cY = (e, n) => {
      e.notificationManager.open({
        type: "error",
        text: n
      });
    }, HR = (e, n) => {
      e._skinLoaded ? cY(e, n) : e.on("SkinLoaded", () => {
        cY(e, n);
      });
    }, lY = (e, n) => {
      HR(e, Af.translate([
        "Failed to upload image: {0}",
        n
      ]));
    }, cp = (e, n, s) => {
      Yd(e, n, { message: s }), console.error(s);
    }, zR = (e, n, s) => s ? `Failed to load ${e}: ${s} from url ${n}` : `Failed to load ${e} url: ${n}`, zce = (e, n, s) => {
      cp(e, "PluginLoadError", zR("plugin", n, s));
    }, uY = (e, n, s) => {
      cp(e, "IconsLoadError", zR("icons", n, s));
    }, LO = (e, n, s) => {
      cp(e, "LanguageLoadError", zR("language", n, s));
    }, dY = (e, n, s) => {
      cp(e, "ThemeLoadError", zR("theme", n, s));
    }, FH = (e, n, s) => {
      cp(e, "ModelLoadError", zR("model", n, s));
    }, LH = (e, n, s) => {
      const l = Af.translate([
        "Failed to initialize plugin: {0}",
        n
      ]);
      Yd(e, "PluginLoadError", { message: l }), BO(l, s), HR(e, l);
    }, BO = (e, ...n) => {
      const s = window.console;
      s && (s.error ? s.error(e, ...n) : s.log(e, ...n));
    }, fY = (e) => /^[a-z0-9\-]+$/i.test(e), XF = (e) => "content/" + e + "/content.css", sS = (e) => tinymce.Resource.has(XF(e)), mY = (e) => BH(e, bu(e)), pY = (e) => BH(e, px(e)), BH = (e, n) => {
      const s = e.editorManager.baseURL + "/skins/content", f = `content${e.editorManager.suffix}.css`;
      return St(n, (b) => sS(b) ? b : fY(b) && !e.inline ? `${s}/${b}/${f}` : e.documentBaseURI.toAbsolute(b));
    }, hY = (e) => {
      e.contentCSS = e.contentCSS.concat(mY(e), pY(e));
    }, gY = (e) => e ? Ps(e.getElementsByTagName("img")) : [], vY = (e, n) => {
      const s = {};
      return { findAll: (f, b = ut) => {
        const E = ht(gY(f), (D) => {
          const U = D.src;
          return D.hasAttribute("data-mce-bogus") || D.hasAttribute("data-mce-placeholder") || !U || U === kn.transparentSrc ? !1 : Gs(U, "blob:") ? !e.isUploaded(U) && b(D) : Gs(U, "data:") ? b(D) : !1;
        }), N = St(E, (D) => {
          const U = D.src;
          if (lr(s, U))
            return s[U].then((J) => G(J) ? J : {
              image: D,
              blobInfo: J.blobInfo
            });
          {
            const J = kce(n, U).then((te) => (delete s[U], {
              image: D,
              blobInfo: te
            })).catch((te) => (delete s[U], te));
            return s[U] = J, J;
          }
        });
        return Promise.all(N);
      } };
    }, HH = () => {
      let s = {};
      const l = (ce, Oe) => ({
        status: ce,
        resultUri: Oe
      }), f = (ce) => ce in s;
      return {
        hasBlobUri: f,
        getResultUri: (ce) => {
          const Oe = s[ce];
          return Oe ? Oe.resultUri : null;
        },
        isPending: (ce) => f(ce) ? s[ce].status === 1 : !1,
        isUploaded: (ce) => f(ce) ? s[ce].status === 2 : !1,
        markPending: (ce) => {
          s[ce] = l(1, null);
        },
        markUploaded: (ce, Oe) => {
          s[ce] = l(2, Oe);
        },
        removeFailed: (ce) => {
          delete s[ce];
        },
        destroy: () => {
          s = {};
        }
      };
    };
    let bY = 0;
    const yY = () => {
      const e = () => Math.round(Math.random() * 4294967295).toString(36);
      return "s" + (/* @__PURE__ */ new Date()).getTime().toString(36) + e() + e() + e();
    }, VR = (e) => e + bY++ + yY(), SY = () => {
      let e = [];
      const n = (te) => ({
        "image/jpeg": "jpg",
        "image/jpg": "jpg",
        "image/gif": "gif",
        "image/png": "png",
        "image/apng": "apng",
        "image/avif": "avif",
        "image/svg+xml": "svg",
        "image/webp": "webp",
        "image/bmp": "bmp",
        "image/tiff": "tiff"
      })[te.toLowerCase()] || "dat", s = (te, ce, Oe, Re, xe) => {
        if (G(te))
          return l({
            id: te,
            name: Re,
            filename: xe,
            blob: ce,
            base64: Oe
          });
        if (me(te))
          return l(te);
        throw new Error("Unknown input type");
      }, l = (te) => {
        if (!te.blob || !te.base64)
          throw new Error("blob and base64 representations of the image are required for BlobInfo to be created");
        const ce = te.id || VR("blobid"), Oe = te.name || ce, Re = te.blob;
        return {
          id: at(ce),
          name: at(Oe),
          filename: at(te.filename || Oe + "." + n(Re.type)),
          blob: at(Re),
          base64: at(te.base64),
          blobUri: at(te.blobUri || URL.createObjectURL(Re)),
          uri: at(te.uri)
        };
      }, f = (te) => {
        E(te.id()) || e.push(te);
      }, b = (te) => Bt(e, te).getOrUndefined(), E = (te) => b((ce) => ce.id() === te);
      return {
        create: s,
        add: f,
        get: E,
        getByUri: (te) => b((ce) => ce.blobUri() === te),
        getByData: (te, ce) => b((Oe) => Oe.base64() === te && Oe.blob().type === ce),
        findFirst: b,
        removeByUri: (te) => {
          e = ht(e, (ce) => ce.blobUri() === te ? (URL.revokeObjectURL(ce.blobUri()), !1) : !0);
        },
        destroy: () => {
          ke(e, (te) => {
            URL.revokeObjectURL(te.blobUri());
          }), e = [];
        }
      };
    }, wY = (e, n) => {
      const s = {}, l = (xe, Pe) => xe ? xe.replace(/\/$/, "") + "/" + Pe.replace(/^\//, "") : Pe, f = (xe, Pe) => new Promise((Ke, et) => {
        const rt = new XMLHttpRequest();
        rt.open("POST", n.url), rt.withCredentials = n.credentials, rt.upload.onprogress = (Ht) => {
          Pe(Ht.loaded / Ht.total * 100);
        }, rt.onerror = () => {
          et("Image upload failed due to a XHR Transport error. Code: " + rt.status);
        }, rt.onload = () => {
          if (rt.status < 200 || rt.status >= 300) {
            et("HTTP Error: " + rt.status);
            return;
          }
          const Ht = JSON.parse(rt.responseText);
          if (!Ht || !G(Ht.location)) {
            et("Invalid JSON: " + rt.responseText);
            return;
          }
          Ke(l(n.basePath, Ht.location));
        };
        const dt = new FormData();
        dt.append("file", xe.blob(), xe.filename()), rt.send(dt);
      }), b = Ce(n.handler) ? n.handler : f, E = () => new Promise((xe) => {
        xe([]);
      }), N = (xe, Pe) => ({
        url: Pe,
        blobInfo: xe,
        status: !0
      }), D = (xe, Pe) => ({
        url: "",
        blobInfo: xe,
        status: !1,
        error: Pe
      }), U = (xe, Pe) => {
        rn.each(s[xe], (Ke) => {
          Ke(Pe);
        }), delete s[xe];
      }, J = (xe, Pe, Ke) => (e.markPending(xe.blobUri()), new Promise((et) => {
        let rt, dt;
        try {
          const Ht = () => {
            rt && (rt.close(), dt = Lt);
          }, ln = (Rt) => {
            Ht(), e.markUploaded(xe.blobUri(), Rt), U(xe.blobUri(), N(xe, Rt)), et(N(xe, Rt));
          }, Dn = (Rt) => {
            Ht(), e.removeFailed(xe.blobUri()), U(xe.blobUri(), D(xe, Rt)), et(D(xe, Rt));
          };
          dt = (Rt) => {
            Rt < 0 || Rt > 100 || oe.from(rt).orThunk(() => oe.from(Ke).map(xt)).each((Tt) => {
              rt = Tt, Tt.progressBar.value(Rt);
            });
          }, Pe(xe, dt).then(ln, (Rt) => {
            Dn(G(Rt) ? { message: Rt } : Rt);
          });
        } catch (Ht) {
          et(D(xe, Ht));
        }
      })), te = (xe) => xe === f, ce = (xe) => {
        const Pe = xe.blobUri();
        return new Promise((Ke) => {
          s[Pe] = s[Pe] || [], s[Pe].push(Ke);
        });
      }, Oe = (xe, Pe) => (xe = rn.grep(xe, (Ke) => !e.isUploaded(Ke.blobUri())), Promise.all(rn.map(xe, (Ke) => e.isPending(Ke.blobUri()) ? ce(Ke) : J(Ke, b, Pe))));
      return { upload: (xe, Pe) => !n.url && te(b) ? E() : Oe(xe, Pe) };
    }, EY = (e) => () => e.notificationManager.open({
      text: e.translate("Image uploading..."),
      type: "info",
      timeout: -1,
      progressBar: !0
    }), ET = (e, n) => wY(n, {
      url: r_(e),
      basePath: o_(e),
      credentials: Dw(e),
      handler: $w(e)
    }), CY = (e) => {
      const n = HH(), s = ET(e, n);
      return { upload: (l, f = !0) => s.upload(l, f ? EY(e) : void 0) };
    }, JF = (e, n) => e.dom.isEmpty(n.dom) && Ie(e.schema.getTextBlockElements()[no(n)]), xY = (e) => (n) => {
      JF(e, n) && Ys(n, Fe.fromHtml('<br data-mce-bogus="1" />'));
    }, TY = (e) => {
      const n = SY();
      let s, l;
      const f = HH(), b = [], E = (rt) => (dt) => e.selection ? rt(dt) : [], N = (rt) => rt + (rt.indexOf("?") === -1 ? "?" : "&") + (/* @__PURE__ */ new Date()).getTime(), D = (rt, dt, Ht) => {
        let ln = 0;
        do
          ln = rt.indexOf(dt, ln), ln !== -1 && (rt = rt.substring(0, ln) + Ht + rt.substr(ln + dt.length), ln += Ht.length - dt.length + 1);
        while (ln !== -1);
        return rt;
      }, U = (rt, dt, Ht) => {
        const ln = `src="${Ht}"${Ht === kn.transparentSrc ? ' data-mce-placeholder="1"' : ""}`;
        return rt = D(rt, `src="${dt}"`, ln), rt = D(rt, 'data-mce-src="' + dt + '"', 'data-mce-src="' + Ht + '"'), rt;
      }, J = (rt, dt) => {
        ke(e.undoManager.data, (Ht) => {
          Ht.type === "fragmented" ? Ht.fragments = St(Ht.fragments, (ln) => U(ln, rt, dt)) : Ht.content = U(Ht.content, rt, dt);
        });
      }, te = (rt, dt) => {
        const Ht = e.convertURL(dt, "src");
        J(rt.src, dt), ru(Fe.fromDom(rt), {
          src: Vy(e) ? N(dt) : dt,
          "data-mce-src": Ht
        });
      }, ce = () => (s || (s = ET(e, f)), Pe().then(E((rt) => {
        const dt = St(rt, (Ht) => Ht.blobInfo);
        return s.upload(dt, EY(e)).then(E((Ht) => {
          const ln = [];
          let Dn = !1;
          const Rt = St(Ht, (Tt, Kt) => {
            const { blobInfo: Mn, image: rr } = rt[Kt];
            let Fr = !1;
            return Tt.status && mx(e) ? (Tt.url && !Hs(rr.src, Tt.url) && (Dn = !0), n.removeByUri(rr.src), d1(e) || te(rr, Tt.url)) : Tt.error && (Tt.error.remove && (J(rr.src, kn.transparentSrc), ln.push(rr), Fr = !0), lY(e, Tt.error.message)), {
              element: rr,
              status: Tt.status,
              uploadUri: Tt.url,
              blobInfo: Mn,
              removed: Fr
            };
          });
          return ln.length > 0 && !d1(e) ? e.undoManager.transact(() => {
            ke(sd(ln), (Tt) => {
              const Kt = Qo(Tt);
              mo(Tt), Kt.each(xY(e)), n.removeByUri(Tt.dom.src);
            });
          }) : Dn && e.undoManager.dispatchChange(), Rt;
        }));
      }))), Oe = () => fx(e) ? ce() : Promise.resolve([]), Re = (rt) => Vr(b, (dt) => dt(rt)), xe = (rt) => {
        b.push(rt);
      }, Pe = () => (l || (l = vY(f, n)), l.findAll(e.getBody(), Re).then(E((rt) => {
        const dt = ht(rt, (Ht) => G(Ht) ? (HR(e, Ht), !1) : Ht.uriType !== "blob");
        return d1(e) || ke(dt, (Ht) => {
          J(Ht.image.src, Ht.blobInfo.blobUri()), Ht.image.src = Ht.blobInfo.blobUri(), Ht.image.removeAttribute("data-mce-src");
        }), dt;
      }))), Ke = () => {
        n.destroy(), f.destroy(), l = s = null;
      }, et = (rt) => rt.replace(/src="(blob:[^"]+)"/g, (dt, Ht) => {
        const ln = f.getResultUri(Ht);
        if (ln)
          return 'src="' + ln + '"';
        let Dn = n.getByUri(Ht);
        return Dn || (Dn = Ye(e.editorManager.get(), (Rt, Tt) => Rt || Tt.editorUpload && Tt.editorUpload.blobCache.getByUri(Ht), void 0)), Dn ? 'src="data:' + Dn.blob().type + ";base64," + Dn.base64() + '"' : dt;
      });
      return e.on("SetContent", () => {
        fx(e) ? Oe() : Pe();
      }), e.on("RawSaveContent", (rt) => {
        rt.content = et(rt.content);
      }), e.on("GetContent", (rt) => {
        rt.source_view || rt.format === "raw" || rt.format === "tree" || (rt.content = et(rt.content));
      }), e.on("PostRender", () => {
        e.parser.addNodeFilter("img", (rt) => {
          ke(rt, (dt) => {
            const Ht = dt.attr("src");
            if (!Ht || n.getByUri(Ht))
              return;
            const ln = f.getResultUri(Ht);
            ln && dt.attr("src", ln);
          });
        });
      }), {
        blobCache: n,
        addFilter: xe,
        uploadImages: ce,
        uploadImagesAuto: Oe,
        scanForImages: Pe,
        destroy: Ke
      };
    }, _Y = (e) => {
      const n = e.dom, s = e.schema.type, l = {
        valigntop: [{
          selector: "td,th",
          styles: { verticalAlign: "top" }
        }],
        valignmiddle: [{
          selector: "td,th",
          styles: { verticalAlign: "middle" }
        }],
        valignbottom: [{
          selector: "td,th",
          styles: { verticalAlign: "bottom" }
        }],
        alignleft: [
          {
            selector: "figure.image",
            collapsed: !1,
            classes: "align-left",
            ceFalseOverride: !0,
            preview: "font-family font-size"
          },
          {
            selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
            styles: { textAlign: "left" },
            inherit: !1,
            preview: !1
          },
          {
            selector: "img,audio,video",
            collapsed: !1,
            styles: { float: "left" },
            preview: "font-family font-size"
          },
          {
            selector: "table",
            collapsed: !1,
            styles: {
              marginLeft: "0px",
              marginRight: "auto"
            },
            onformat: (f) => {
              n.setStyle(f, "float", null);
            },
            preview: "font-family font-size"
          },
          {
            selector: ".mce-preview-object,[data-ephox-embed-iri]",
            ceFalseOverride: !0,
            styles: { float: "left" }
          }
        ],
        aligncenter: [
          {
            selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
            styles: { textAlign: "center" },
            inherit: !1,
            preview: "font-family font-size"
          },
          {
            selector: "figure.image",
            collapsed: !1,
            classes: "align-center",
            ceFalseOverride: !0,
            preview: "font-family font-size"
          },
          {
            selector: "img,audio,video",
            collapsed: !1,
            styles: {
              display: "block",
              marginLeft: "auto",
              marginRight: "auto"
            },
            preview: !1
          },
          {
            selector: "table",
            collapsed: !1,
            styles: {
              marginLeft: "auto",
              marginRight: "auto"
            },
            preview: "font-family font-size"
          },
          {
            selector: ".mce-preview-object",
            ceFalseOverride: !0,
            styles: {
              display: "table",
              marginLeft: "auto",
              marginRight: "auto"
            },
            preview: !1
          },
          {
            selector: "[data-ephox-embed-iri]",
            ceFalseOverride: !0,
            styles: {
              marginLeft: "auto",
              marginRight: "auto"
            },
            preview: !1
          }
        ],
        alignright: [
          {
            selector: "figure.image",
            collapsed: !1,
            classes: "align-right",
            ceFalseOverride: !0,
            preview: "font-family font-size"
          },
          {
            selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
            styles: { textAlign: "right" },
            inherit: !1,
            preview: "font-family font-size"
          },
          {
            selector: "img,audio,video",
            collapsed: !1,
            styles: { float: "right" },
            preview: "font-family font-size"
          },
          {
            selector: "table",
            collapsed: !1,
            styles: {
              marginRight: "0px",
              marginLeft: "auto"
            },
            onformat: (f) => {
              n.setStyle(f, "float", null);
            },
            preview: "font-family font-size"
          },
          {
            selector: ".mce-preview-object,[data-ephox-embed-iri]",
            ceFalseOverride: !0,
            styles: { float: "right" },
            preview: !1
          }
        ],
        alignjustify: [{
          selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
          styles: { textAlign: "justify" },
          inherit: !1,
          preview: "font-family font-size"
        }],
        bold: [
          {
            inline: "strong",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          },
          {
            inline: "span",
            styles: { fontWeight: "bold" }
          },
          {
            inline: "b",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          }
        ],
        italic: [
          {
            inline: "em",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          },
          {
            inline: "span",
            styles: { fontStyle: "italic" }
          },
          {
            inline: "i",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          }
        ],
        underline: [
          {
            inline: "span",
            styles: { textDecoration: "underline" },
            exact: !0
          },
          {
            inline: "u",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          }
        ],
        strikethrough: (() => {
          const f = {
            inline: "span",
            styles: { textDecoration: "line-through" },
            exact: !0
          }, b = {
            inline: "strike",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          }, E = {
            inline: "s",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          };
          return s !== "html4" ? [
            E,
            f,
            b
          ] : [
            f,
            E,
            b
          ];
        })(),
        forecolor: {
          inline: "span",
          styles: { color: "%value" },
          links: !0,
          remove_similar: !0,
          clear_child_styles: !0
        },
        hilitecolor: {
          inline: "span",
          styles: { backgroundColor: "%value" },
          links: !0,
          remove_similar: !0,
          clear_child_styles: !0
        },
        fontname: {
          inline: "span",
          toggle: !1,
          styles: { fontFamily: "%value" },
          clear_child_styles: !0
        },
        fontsize: {
          inline: "span",
          toggle: !1,
          styles: { fontSize: "%value" },
          clear_child_styles: !0
        },
        lineheight: {
          selector: "h1,h2,h3,h4,h5,h6,p,li,td,th,div",
          styles: { lineHeight: "%value" }
        },
        fontsize_class: {
          inline: "span",
          attributes: { class: "%value" }
        },
        blockquote: {
          block: "blockquote",
          wrapper: !0,
          remove: "all"
        },
        subscript: { inline: "sub" },
        superscript: { inline: "sup" },
        code: { inline: "code" },
        link: {
          inline: "a",
          selector: "a",
          remove: "all",
          split: !0,
          deep: !0,
          onmatch: (f, b, E) => Un(f) && f.hasAttribute("href"),
          onformat: (f, b, E) => {
            rn.each(E, (N, D) => {
              n.setAttrib(f, D, N);
            });
          }
        },
        lang: {
          inline: "span",
          clear_child_styles: !0,
          remove_similar: !0,
          attributes: {
            lang: "%value",
            "data-mce-lang": (f) => {
              var b;
              return (b = f == null ? void 0 : f.customValue) !== null && b !== void 0 ? b : null;
            }
          }
        },
        removeformat: [
          {
            selector: "b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small",
            remove: "all",
            split: !0,
            expand: !1,
            block_expand: !0,
            deep: !0
          },
          {
            selector: "span",
            attributes: [
              "style",
              "class"
            ],
            remove: "empty",
            split: !0,
            expand: !1,
            deep: !0
          },
          {
            selector: "*",
            attributes: [
              "style",
              "class"
            ],
            split: !1,
            expand: !1,
            deep: !0
          }
        ]
      };
      return rn.each("p h1 h2 h3 h4 h5 h6 div address pre dt dd samp".split(/\s/), (f) => {
        l[f] = {
          block: f,
          remove: "all"
        };
      }), l;
    }, zH = {
      remove_similar: !0,
      inherit: !1
    }, gg = {
      selector: "td,th",
      ...zH
    }, DE = {
      tablecellbackgroundcolor: {
        styles: { backgroundColor: "%value" },
        ...gg
      },
      tablecellverticalalign: {
        styles: { "vertical-align": "%value" },
        ...gg
      },
      tablecellbordercolor: {
        styles: { borderColor: "%value" },
        ...gg
      },
      tablecellclass: {
        classes: ["%value"],
        ...gg
      },
      tableclass: {
        selector: "table",
        classes: ["%value"],
        ...zH
      },
      tablecellborderstyle: {
        styles: { borderStyle: "%value" },
        ...gg
      },
      tablecellborderwidth: {
        styles: { borderWidth: "%value" },
        ...gg
      }
    }, UR = at(DE), WR = (e) => {
      const n = {}, s = (E) => Ie(E) ? n[E] : n, l = (E) => lr(n, E), f = (E, N) => {
        E && (G(E) ? (be(N) || (N = [N]), ke(N, (D) => {
          Le(D.deep) && (D.deep = !Tl(D)), Le(D.split) && (D.split = !Tl(D) || Yi(D)), Le(D.remove) && Tl(D) && !Yi(D) && (D.remove = "none"), Tl(D) && Yi(D) && (D.mixed = !0, D.block_expand = !0), G(D.classes) && (D.classes = D.classes.split(/\s+/));
        }), n[E] = N) : fn(E, (D, U) => {
          f(U, D);
        }));
      }, b = (E) => (E && n[E] && delete n[E], n);
      return f(_Y(e)), f(UR()), f(c_(e)), {
        get: s,
        has: l,
        register: f,
        unregister: b
      };
    }, Jb = rn.each, qu = Is.DOM, CT = (e) => Ie(e) && me(e), HO = (e, n) => {
      const s = n && n.schema || jm({}), l = (D, U) => {
        U.classes.length > 0 && qu.addClass(D, U.classes.join(" ")), qu.setAttribs(D, U.attrs);
      }, f = (D) => {
        const U = G(D) ? {
          name: D,
          classes: [],
          attrs: {}
        } : D, J = qu.create(U.name);
        return l(J, U), J;
      }, b = (D, U) => {
        const J = s.getElementRule(D.nodeName.toLowerCase()), te = J == null ? void 0 : J.parentsRequired;
        return te && te.length ? U && Ge(te, U) ? U : te[0] : !1;
      }, E = (D, U, J) => {
        let te;
        const ce = U[0], Oe = CT(ce) ? ce.name : void 0, Re = b(D, Oe);
        if (Re)
          Oe === Re ? (te = ce, U = U.slice(1)) : te = Re;
        else if (ce)
          te = ce, U = U.slice(1);
        else if (!J)
          return D;
        const xe = te ? f(te) : qu.create("div");
        xe.appendChild(D), J && rn.each(J, (Ke) => {
          const et = f(Ke);
          xe.insertBefore(et, D);
        });
        const Pe = CT(te) ? te.siblings : void 0;
        return E(xe, U, Pe);
      }, N = qu.create("div");
      if (e.length > 0) {
        const D = e[0], U = f(D), J = CT(D) ? D.siblings : void 0;
        N.appendChild(E(U, e.slice(1), J));
      }
      return N;
    }, VH = (e) => {
      e = rn.trim(e);
      let n = "div";
      const s = {
        name: n,
        classes: [],
        attrs: {},
        selector: e
      };
      return e !== "*" && (n = e.replace(/(?:([#\.]|::?)([\w\-]+)|(\[)([^\]]+)\]?)/g, (l, f, b, E, N) => {
        switch (f) {
          case "#":
            s.attrs.id = b;
            break;
          case ".":
            s.classes.push(b);
            break;
          case ":":
            rn.inArray("checked disabled enabled read-only required".split(" "), b) !== -1 && (s.attrs[b] = b);
            break;
        }
        if (E === "[") {
          const D = N.match(/([\w\-]+)(?:\=\"([^\"]+))?/);
          D && (s.attrs[D[1]] = D[2]);
        }
        return "";
      })), s.name = n || "div", s;
    }, e3 = (e) => G(e) ? (e = e.split(/\s*,\s*/)[0], e = e.replace(/\s*(~\+|~|\+|>)\s*/g, "$1"), rn.map(e.split(/(?:>|\s+(?![^\[\]]+\]))/), (n) => {
      const s = rn.map(n.split(/(?:~\+|~|\+)/), VH), l = s.pop();
      return s.length && (l.siblings = s), l;
    }).reverse()) : [], t3 = (e, n) => {
      let s = "", l = vx(e);
      if (l === "")
        return "";
      const f = (ce) => G(ce) ? ce.replace(/%(\w+)/g, "") : "", b = (ce, Oe) => qu.getStyle(Oe ?? e.getBody(), ce, !0);
      if (G(n)) {
        const ce = e.formatter.get(n);
        if (!ce)
          return "";
        n = ce[0];
      }
      if ("preview" in n) {
        const ce = n.preview;
        if (ce === !1)
          return "";
        l = ce || l;
      }
      let E = n.block || n.inline || "span", N;
      const D = e3(n.selector);
      D.length > 0 ? (D[0].name || (D[0].name = E), E = n.selector, N = HO(D, e)) : N = HO([E], e);
      const U = qu.select(E, N)[0] || N.firstChild;
      Jb(n.styles, (ce, Oe) => {
        const Re = f(ce);
        Re && qu.setStyle(U, Oe, Re);
      }), Jb(n.attributes, (ce, Oe) => {
        const Re = f(ce);
        Re && qu.setAttrib(U, Oe, Re);
      }), Jb(n.classes, (ce) => {
        const Oe = f(ce);
        qu.hasClass(U, Oe) || qu.addClass(U, Oe);
      }), e.dispatch("PreviewFormats"), qu.setStyles(N, {
        position: "absolute",
        left: -65535
      }), e.getBody().appendChild(N);
      const J = b("fontSize"), te = /px$/.test(J) ? parseInt(J, 10) : 0;
      return Jb(l.split(" "), (ce) => {
        let Oe = b(ce, U);
        if (!(ce === "background-color" && /transparent|rgba\s*\([^)]+,\s*0\)/.test(Oe) && (Oe = b(ce), Bu(Oe).toLowerCase() === "#ffffff")) && !(ce === "color" && Bu(Oe).toLowerCase() === "#000000")) {
          if (ce === "font-size" && /em|%$/.test(Oe)) {
            if (te === 0)
              return;
            Oe = parseFloat(Oe) / (/%$/.test(Oe) ? 100 : 1) * te + "px";
          }
          ce === "border" && Oe && (s += "padding:0 2px;"), s += ce + ":" + Oe + ";";
        }
      }), e.dispatch("AfterPreviewFormats"), qu.remove(N), s;
    }, UH = (e) => {
      e.addShortcut("meta+b", "", "Bold"), e.addShortcut("meta+i", "", "Italic"), e.addShortcut("meta+u", "", "Underline");
      for (let n = 1; n <= 6; n++)
        e.addShortcut("access+" + n, "", [
          "FormatBlock",
          !1,
          "h" + n
        ]);
      e.addShortcut("access+7", "", [
        "FormatBlock",
        !1,
        "p"
      ]), e.addShortcut("access+8", "", [
        "FormatBlock",
        !1,
        "div"
      ]), e.addShortcut("access+9", "", [
        "FormatBlock",
        !1,
        "address"
      ]);
    }, n3 = (e) => {
      const n = WR(e), s = wa({});
      return UH(e), sZ(e), d1(e) || vZ(s, e), {
        get: n.get,
        has: n.has,
        register: n.register,
        unregister: n.unregister,
        apply: (l, f, b) => {
          TK(e, l, f, b);
        },
        remove: (l, f, b, E) => {
          _K(e, l, f, b, E);
        },
        toggle: (l, f, b) => {
          OK(e, l, f, b);
        },
        match: (l, f, b, E) => gH(e, l, f, b, E),
        closest: (l) => jF(e, l),
        matchAll: (l, f) => vH(e, l, f),
        matchNode: (l, f, b, E) => WF(e, l, f, b, E),
        canApply: (l) => bH(e, l),
        formatChanged: (l, f, b, E) => bh(e, s, l, f, b, E),
        getCssText: Ne(t3, e)
      };
    }, $E = (e) => {
      switch (e.toLowerCase()) {
        case "undo":
        case "redo":
        case "mcefocus":
          return !0;
        default:
          return !1;
      }
    }, WH = (e, n, s) => {
      const l = wa(!1), f = (D) => {
        IR(n, !1, s), n.add({}, D);
      };
      e.on("init", () => {
        n.add();
      }), e.on("BeforeExecCommand", (D) => {
        const U = D.command;
        $E(U) || (uH(n, s), n.beforeChange());
      }), e.on("ExecCommand", (D) => {
        const U = D.command;
        $E(U) || f(D);
      }), e.on("ObjectResizeStart cut", () => {
        n.beforeChange();
      }), e.on("SaveContent ObjectResized blur", f), e.on("dragend", f), e.on("keyup", (D) => {
        const U = D.keyCode;
        if (D.isDefaultPrevented())
          return;
        const J = kn.os.isMacOS() && D.key === "Meta";
        (U >= 33 && U <= 36 || U >= 37 && U <= 40 || U === 45 || D.ctrlKey || J) && (f(), e.nodeChanged()), (U === 46 || U === 8) && e.nodeChanged(), l.get() && n.typing && !HF($R(e), n.data[0]) && (e.isDirty() || e.setDirty(!0), e.dispatch("TypingUndo"), l.set(!1), e.nodeChanged());
      }), e.on("keydown", (D) => {
        const U = D.keyCode;
        if (D.isDefaultPrevented())
          return;
        if (U >= 33 && U <= 36 || U >= 37 && U <= 40 || U === 45) {
          n.typing && f(D);
          return;
        }
        const J = D.ctrlKey && !D.altKey || D.metaKey;
        if ((U < 16 || U > 20) && U !== 224 && U !== 91 && !n.typing && !J) {
          n.beforeChange(), IR(n, !0, s), n.add({}, D), l.set(!0);
          return;
        }
        (kn.os.isMacOS() ? D.metaKey : D.ctrlKey && !D.altKey) && n.beforeChange();
      }), e.on("mousedown", (D) => {
        n.typing && f(D);
      });
      const b = (D) => D.inputType === "insertReplacementText", E = (D) => D.inputType === "insertText" && D.data === null, N = (D) => D.inputType === "insertFromPaste" || D.inputType === "insertFromDrop";
      e.on("input", (D) => {
        D.inputType && (b(D) || E(D) || N(D)) && f(D);
      }), e.on("AddUndo Undo Redo ClearUndos", (D) => {
        D.isDefaultPrevented() || e.nodeChanged();
      });
    }, jH = (e) => {
      e.addShortcut("meta+z", "", "Undo"), e.addShortcut("meta+y,meta+shift+z", "", "Redo");
    }, r3 = (e) => {
      const n = Kh(), s = wa(0), l = wa(0), f = {
        data: [],
        typing: !1,
        beforeChange: () => {
          Ice(e, s, n);
        },
        add: (b, E) => wu(e, f, l, s, n, b, E),
        dispatchChange: () => {
          e.setDirty(!0);
          const b = $R(e);
          b.bookmark = oh(e.selection), e.dispatch("change", {
            level: b,
            lastLevel: Es(f.data, l.get()).getOrUndefined()
          });
        },
        undo: () => mH(e, f, s, l),
        redo: () => pH(e, l, f.data),
        clear: () => {
          hH(e, f, l);
        },
        reset: () => {
          wK(e, f);
        },
        hasUndo: () => EK(e, f, l),
        hasRedo: () => MR(e, f, l),
        transact: (b) => CK(e, f, s, b),
        ignore: (b) => {
          UF(e, s, b);
        },
        extra: (b, E) => {
          xK(e, f, l, b, E);
        }
      };
      return d1(e) || WH(e, f, s), jH(e), f;
    }, jR = [
      9,
      27,
      zn.HOME,
      zn.END,
      19,
      20,
      44,
      144,
      145,
      33,
      34,
      45,
      16,
      17,
      18,
      91,
      92,
      93,
      zn.DOWN,
      zn.UP,
      zn.LEFT,
      zn.RIGHT
    ].concat(kn.browser.isFirefox() ? [224] : []), o3 = "data-mce-placeholder", s3 = (e) => e.type === "keydown" || e.type === "keyup", a3 = (e) => {
      const n = e.keyCode;
      return n === zn.BACKSPACE || n === zn.DELETE;
    }, qH = (e) => {
      if (s3(e)) {
        const n = e.keyCode;
        return !a3(e) && (zn.metaKeyPressed(e) || e.altKey || n >= 112 && n <= 123 || Ge(jR, n));
      } else
        return !1;
    }, m1 = (e) => s3(e) && !(a3(e) || e.type === "keyup" && e.keyCode === 229), aS = (e, n, s) => {
      if (Na(Fe.fromDom(n), !1)) {
        const l = n.firstElementChild;
        return l ? e.getStyle(n.firstElementChild, "padding-left") || e.getStyle(n.firstElementChild, "padding-right") ? !1 : s === l.nodeName.toLowerCase() : !0;
      } else
        return !1;
    }, vg = (e) => {
      var n;
      const s = e.dom, l = al(e), f = (n = Gk(e)) !== null && n !== void 0 ? n : "", b = (E, N) => {
        if (qH(E))
          return;
        const D = e.getBody(), U = m1(E) ? !1 : aS(s, D, l);
        (s.getAttrib(D, o3) !== "" !== U || N) && (s.setAttrib(D, o3, U ? f : null), s.setAttrib(D, "aria-placeholder", U ? f : null), PI(e, U), e.on(U ? "keydown" : "keyup", b), e.off(U ? "keyup" : "keydown", b));
      };
      $o(f) && e.on("init", (E) => {
        b(E, !0), e.on("change SetContent ExecCommand", b), e.on("paste", (N) => sp.setEditorTimeout(e, () => b(N)));
      });
    }, OY = (e, n) => ({
      block: e,
      position: n
    }), AY = (e, n) => ({
      from: e,
      to: n
    }), i3 = (e, n) => {
      const s = Fe.fromDom(e), l = Fe.fromDom(n.container());
      return cT(s, l).map((f) => OY(f, n));
    }, kY = (e) => !Je(e.from.block, e.to.block), GH = (e, n) => Fi(n, (f) => vl(f) || Dc(f.dom), (f) => Je(f, e)).filter(Mi).getOr(e), NY = (e, n) => {
      const s = Fe.fromDom(e);
      return Je(GH(s, n.from.block), GH(s, n.to.block));
    }, RY = (e) => ro(e.from.block.dom) === !1 && ro(e.to.block.dom) === !1, PY = (e) => {
      const n = (s) => lt(s) || U1(s.dom);
      return n(e.from.block) && n(e.to.block);
    }, DY = (e, n, s) => Mo(s.position.getNode()) && !Na(s.block) ? R0(!1, s.block.dom).bind((l) => l.isEqual(s.position) ? il(n, e, l).bind((f) => i3(e, f)) : oe.some(s)).getOr(s) : s, $Y = (e, n, s) => {
      const l = i3(e, yt.fromRangeStart(s)), f = l.bind((b) => il(n, e, b.position).bind((E) => i3(e, E).map((N) => DY(e, n, N))));
      return bs(l, f, AY).filter((b) => kY(b) && NY(e, b) && RY(b) && PY(b));
    }, IY = (e, n, s) => s.collapsed ? $Y(e, n, s) : oe.none(), MY = (e, n) => {
      const s = ga(e);
      return $n(s, (l) => n.isBlock(no(l))).fold(at(s), (l) => s.slice(0, l));
    }, qR = (e, n) => {
      const s = MY(e, n);
      return ke(s, mo), s;
    }, GR = (e, n) => {
      const s = qb(n, e);
      return Bt(s.reverse(), (l) => Na(l)).each(mo);
    }, ZH = (e) => ht(Bg(e), (n) => !Na(n)).length === 0, FY = (e, n, s, l, f) => {
      if (Na(s))
        return vf(s), Wu(s.dom);
      ZH(f) && Na(n) && ba(f, Fe.fromTag("br"));
      const b = gd(s.dom, yt.before(f.dom));
      return ke(qR(n, l), (E) => {
        ba(f, E);
      }), GR(e, n), b;
    }, LY = (e, n) => e.isInline(no(n)), KH = (e, n, s, l) => {
      if (Na(s)) {
        if (Na(n)) {
          const E = bn(((N) => {
            const D = (U, J) => ys(U).fold(() => J, (te) => LY(l, te) ? D(te, J.concat(zu(te))) : J);
            return D(N, []);
          })(s), (N, D) => (zg(N, D), D), bl());
          $u(n), Ys(n, E);
        }
        return mo(s), Wu(n.dom);
      }
      const f = np(s.dom);
      return ke(qR(n, l), (b) => {
        Ys(s, b);
      }), GR(e, n), f;
    }, YH = (e, n) => {
      const s = qb(n, e);
      return oe.from(s[s.length - 1]);
    }, c3 = (e, n) => Wt(n, e) ? YH(n, e) : oe.none(), l3 = (e, n) => {
      R0(e, n.dom).bind((s) => oe.from(s.getNode())).map(Fe.fromDom).filter(ld).each(mo);
    }, u3 = (e, n, s, l) => (l3(!0, n), l3(!1, s), c3(n, s).fold(Ne(KH, e, n, s, l), Ne(FY, e, n, s, l))), ZR = (e, n, s, l, f) => n ? u3(e, l, s, f) : u3(e, s, l, f), d3 = (e, n) => {
      const s = Fe.fromDom(e.getBody());
      return IY(s.dom, n, e.selection.getRng()).map((f) => () => {
        ZR(s, n, f.from.block, f.to.block, e.schema).each((b) => {
          e.selection.setRng(b.toRange());
        });
      });
    }, BY = (e, n, s) => {
      const l = n.getRng();
      return bs(cT(e, Fe.fromDom(l.startContainer)), cT(e, Fe.fromDom(l.endContainer)), (f, b) => Je(f, b) ? oe.none() : oe.some(() => {
        l.deleteContents(), ZR(e, !0, f, b, s).each((E) => {
          n.setRng(E.toRange());
        });
      })).getOr(oe.none());
    }, _v = (e, n) => {
      const s = Fe.fromDom(n), l = Ne(Je, e);
      return Ss(s, vl, l).isSome();
    }, bg = (e, n) => _v(e, n.startContainer) || _v(e, n.endContainer), KR = (e, n) => {
      const s = gd(e.dom, yt.fromRangeStart(n)).isNone(), l = yu(e.dom, yt.fromRangeEnd(n)).isNone();
      return !bg(e, n) && s && l;
    }, QH = (e) => oe.some(() => {
      e.setContent(""), e.selection.setCursorLocation();
    }), YR = (e) => {
      const n = Fe.fromDom(e.getBody()), s = e.selection.getRng();
      return KR(n, s) ? QH(e) : BY(n, e.selection, e.schema);
    }, QR = (e, n) => e.selection.isCollapsed() ? oe.none() : YR(e), ey = (e, n, s, l, f) => oe.from(n._selectionOverrides.showCaret(e, s, l, f)), XH = (e) => {
      const n = e.ownerDocument.createRange();
      return n.selectNode(e), n;
    }, xT = (e, n) => e.dispatch("BeforeObjectSelected", { target: n }).isDefaultPrevented() ? oe.none() : oe.some(XH(n)), JH = (e, n, s) => {
      const l = fs(1, e.getBody(), n), f = yt.fromRangeStart(l), b = f.getNode();
      if (_0(b))
        return ey(1, e, b, !f.isAtEnd(), !1);
      const E = f.getNode(!0);
      if (_0(E))
        return ey(1, e, E, !1, !1);
      const N = Z0(e.dom.getRoot(), f.getNode());
      return _0(N) ? ey(1, e, N, !1, s) : oe.none();
    }, XR = (e, n, s) => n.collapsed ? JH(e, n, s).getOr(n) : n, JR = (e) => r1(e) || nO(e), f3 = (e) => wv(e) || sT(e), HY = (e, n) => {
      Qt(n) && n.data.length === 0 && e.remove(n);
    }, e7 = (e, n, s, l, f, b) => {
      ey(l, e, b.getNode(!f), f, !0).each((E) => {
        if (n.collapsed) {
          const N = n.cloneRange();
          f ? N.setEnd(E.startContainer, E.startOffset) : N.setStart(E.endContainer, E.endOffset), N.deleteContents();
        } else
          n.deleteContents();
        e.selection.setRng(E);
      }), HY(e.dom, s);
    }, zY = (e, n) => {
      const s = e.selection.getRng();
      if (!Qt(s.commonAncestorContainer))
        return oe.none();
      const l = n ? Ms.Forwards : Ms.Backwards, f = ch(e.getBody()), b = Ne(sc, n ? f.next : f.prev), E = n ? JR : f3, N = Lc(l, e.getBody(), s), D = b(N), U = D && mh(n, D);
      if (!U || !Kd(N, U))
        return oe.none();
      if (E(U))
        return oe.some(() => e7(e, s, N.getNode(), l, n, U));
      const J = b(U);
      return J && E(J) && Kd(U, J) ? oe.some(() => e7(e, s, N.getNode(), l, n, J)) : oe.none();
    }, m3 = (e, n) => zY(e, n), eP = (e, n) => {
      const s = e.getBody();
      return n ? Wu(s).filter(r1) : np(s).filter(wv);
    }, p3 = (e) => {
      const n = e.selection.getRng();
      return !n.collapsed && (eP(e, !0).exists((s) => s.isEqual(yt.fromRangeStart(n))) || eP(e, !1).exists((s) => s.isEqual(yt.fromRangeEnd(n))));
    }, VY = (e) => Ie(e) && (vl(Fe.fromDom(e)) || Fu(Fe.fromDom(e))), Hf = hm.generate([
      { remove: ["element"] },
      { moveToElement: ["element"] },
      { moveToPosition: ["position"] }
    ]), UY = (e, n) => {
      const s = n.getNode(!e), l = e ? "after" : "before";
      return Un(s) && s.getAttribute("data-mce-caret") === l;
    }, WY = (e, n, s, l, f) => {
      const b = (E) => f.isInline(E.nodeName.toLowerCase()) && !gn(s, l, e);
      return As(!n, s).fold(() => As(n, l).fold(He, b), b);
    }, t7 = (e, n, s, l) => {
      const f = l.getNode(!n);
      return cT(Fe.fromDom(e), Fe.fromDom(s.getNode())).map((b) => Na(b) ? Hf.remove(b.dom) : Hf.moveToElement(f)).orThunk(() => oe.some(Hf.moveToElement(f)));
    }, n7 = (e, n, s, l) => il(n, e, s).bind((f) => VY(f.getNode()) || WY(e, n, s, f, l) ? oe.none() : n && ro(f.getNode()) || !n && ro(f.getNode(!0)) ? t7(e, n, s, f) : n && wv(s) || !n && r1(s) ? oe.some(Hf.moveToPosition(f)) : oe.none()), jY = (e, n) => je(n) ? oe.none() : e && ro(n.nextSibling) ? oe.some(Hf.moveToElement(n.nextSibling)) : !e && ro(n.previousSibling) ? oe.some(Hf.moveToElement(n.previousSibling)) : oe.none(), qY = (e, n, s) => s.fold((l) => oe.some(Hf.remove(l)), (l) => oe.some(Hf.moveToElement(l)), (l) => gn(n, l, e) ? oe.none() : oe.some(Hf.moveToPosition(l))), GY = (e, n, s, l) => UY(n, s) ? jY(n, s.getNode(!n)).orThunk(() => n7(e, n, s, l)) : n7(e, n, s, l).bind((f) => qY(e, s, f)), tP = (e, n, s, l) => {
      const f = fs(n ? 1 : -1, e, s), b = yt.fromRangeStart(f), E = Fe.fromDom(e);
      return !n && wv(b) ? oe.some(Hf.remove(b.getNode(!0))) : n && r1(b) ? oe.some(Hf.remove(b.getNode())) : !n && r1(b) && oO(E, b, l) ? yG(E, b, l).map((N) => Hf.remove(N.getNode())) : n && wv(b) && rO(E, b, l) ? SG(E, b, l).map((N) => Hf.remove(N.getNode())) : GY(e, n, b, l);
    }, h3 = (e, n) => (s) => (e._selectionOverrides.hideFakeCaret(), s1(e, n, Fe.fromDom(s)), !0), ZY = (e, n) => (s) => {
      const l = n ? yt.before(s) : yt.after(s);
      return e.selection.setRng(l.toRange()), !0;
    }, KY = (e) => (n) => (e.selection.setRng(n.toRange()), !0), r7 = (e, n) => oe.from(Z0(e.getBody(), n)), YY = (e, n) => {
      const s = e.selection.getNode();
      return r7(e, s).filter(ro).fold(() => tP(e.getBody(), n, e.selection.getRng(), e.schema).map((l) => () => l.fold(h3(e, n), ZY(e, n), KY(e))), () => oe.some(Lt));
    }, o7 = (e) => {
      ke(Vi(e, ".mce-offscreen-selection"), mo);
    }, QY = (e, n) => {
      const s = e.selection.getNode();
      return ro(s) && !$p(s) ? r7(e, s.parentNode).filter(ro).fold(() => oe.some(() => {
        o7(Fe.fromDom(e.getBody())), s1(e, n, Fe.fromDom(e.selection.getNode())), hM(e);
      }), () => oe.some(Lt)) : p3(e) ? oe.some(() => {
        UN(e, e.selection.getRng(), Fe.fromDom(e.getBody()));
      }) : oe.none();
    }, s7 = (e) => {
      const n = e.dom, s = e.selection, l = Z0(e.getBody(), s.getNode());
      if (Dc(l) && n.isBlock(l) && n.isEmpty(l)) {
        const f = n.create("br", { "data-mce-bogus": "1" });
        n.setHTML(l, ""), l.appendChild(f), s.setRng(yt.before(f).toRange());
      }
      return !0;
    }, zO = (e, n) => e.selection.isCollapsed() ? YY(e, n) : QY(e, n), XY = (e, n) => {
      const s = yt.fromRangeStart(e.selection.getRng());
      return il(n, e.getBody(), s).filter((l) => n ? mG(l) : pG(l)).bind((l) => Nn(n ? 0 : -1, l)).map((l) => () => e.selection.select(l));
    }, g3 = (e, n) => e.selection.isCollapsed() ? XY(e, n) : oe.none(), TT = Qt, a7 = (e) => TT(e) && e.data[0] === M, i7 = (e) => TT(e) && e.data[e.data.length - 1] === M, c7 = (e) => {
      var n;
      return ((n = e.ownerDocument) !== null && n !== void 0 ? n : document).createTextNode(M);
    }, JY = (e) => {
      var n;
      if (TT(e.previousSibling))
        return i7(e.previousSibling) || e.previousSibling.appendData(M), e.previousSibling;
      if (TT(e))
        return a7(e) || e.insertData(0, M), e;
      {
        const s = c7(e);
        return (n = e.parentNode) === null || n === void 0 || n.insertBefore(s, e), s;
      }
    }, nP = (e) => {
      var n, s;
      if (TT(e.nextSibling))
        return a7(e.nextSibling) || e.nextSibling.insertData(0, M), e.nextSibling;
      if (TT(e))
        return i7(e) || e.appendData(M), e;
      {
        const l = c7(e);
        return e.nextSibling ? (n = e.parentNode) === null || n === void 0 || n.insertBefore(l, e.nextSibling) : (s = e.parentNode) === null || s === void 0 || s.appendChild(l), l;
      }
    }, IE = (e, n) => e ? JY(n) : nP(n), eQ = Ne(IE, !0), tQ = Ne(IE, !1), VO = (e, n) => Qt(e.container()) ? IE(n, e.container()) : IE(n, e.getNode()), l7 = (e, n) => {
      const s = n.get();
      return s && e.container() === s && Sn(s);
    }, v3 = (e, n) => n.fold((s) => {
      Ki(e.get());
      const l = eQ(s);
      return e.set(l), oe.some(yt(l, l.length - 1));
    }, (s) => Wu(s).map((l) => {
      if (l7(l, e)) {
        const f = e.get();
        return yt(f, 1);
      } else {
        Ki(e.get());
        const f = VO(l, !0);
        return e.set(f), yt(f, 1);
      }
    }), (s) => np(s).map((l) => {
      if (l7(l, e)) {
        const f = e.get();
        return yt(f, f.length - 1);
      } else {
        Ki(e.get());
        const f = VO(l, !1);
        return e.set(f), yt(f, f.length - 1);
      }
    }), (s) => {
      Ki(e.get());
      const l = tQ(s);
      return e.set(l), oe.some(yt(l, 1));
    }), u7 = (e, n) => {
      for (let s = 0; s < e.length; s++) {
        const l = e[s].apply(null, n);
        if (l.isSome())
          return l;
      }
      return oe.none();
    }, Xd = hm.generate([
      { before: ["element"] },
      { start: ["element"] },
      { end: ["element"] },
      { after: ["element"] }
    ]), d7 = (e, n) => {
      const s = vn(n, e);
      return s || e;
    }, nQ = (e, n, s) => {
      const l = js(s), f = d7(n, l.container());
      return Ol(e, f, l).fold(() => yu(f, l).bind(Ne(Ol, e, f)).map((b) => Xd.before(b)), oe.none);
    }, rQ = (e, n) => Ky(e, n) === null, f7 = (e, n, s) => Ol(e, n, s).filter(Ne(rQ, n)), oQ = (e, n, s) => {
      const l = c6(s);
      return f7(e, n, l).bind((f) => gd(f, l).isNone() ? oe.some(Xd.start(f)) : oe.none());
    }, sQ = (e, n, s) => {
      const l = js(s);
      return f7(e, n, l).bind((f) => yu(f, l).isNone() ? oe.some(Xd.end(f)) : oe.none());
    }, aQ = (e, n, s) => {
      const l = c6(s), f = d7(n, l.container());
      return Ol(e, f, l).fold(() => gd(f, l).bind(Ne(Ol, e, f)).map((b) => Xd.after(b)), oe.none);
    }, iQ = (e) => !i6(UO(e)), Zl = (e, n, s) => u7([
      nQ,
      oQ,
      sQ,
      aQ
    ], [
      e,
      n,
      s
    ]).filter(iQ), UO = (e) => e.fold(_n, _n, _n, _n), b3 = (e) => e.fold(at("before"), at("start"), at("end"), at("after")), WO = (e) => e.fold(Xd.before, Xd.before, Xd.after, Xd.after), y3 = (e) => e.fold(Xd.start, Xd.start, Xd.end, Xd.end), m7 = (e, n) => b3(e) === b3(n) && UO(e) === UO(n), cQ = (e, n, s, l, f, b) => bs(Ol(n, s, l), Ol(n, s, f), (E, N) => E !== N && iO(s, E, N) ? Xd.after(e ? E : N) : b).getOr(b), p7 = (e, n) => e.fold(ut, (s) => !m7(s, n)), lQ = (e, n, s, l, f) => {
      const b = mh(e, f);
      return il(e, s, b).map(Ne(mh, e)).fold(() => l.map(WO), (D) => Zl(n, s, D).map(Ne(cQ, e, n, s, b, D)).filter(Ne(p7, l))).filter(iQ);
    }, uQ = (e, n) => e ? n.fold(z(oe.some, Xd.start), oe.none, z(oe.some, Xd.after), oe.none) : n.fold(oe.none, z(oe.some, Xd.before), oe.none, z(oe.some, Xd.end)), dQ = (e, n, s, l) => {
      const f = mh(e, l), b = Zl(n, s, f);
      return Zl(n, s, f).bind(Ne(uQ, e)).orThunk(() => lQ(e, n, s, b, l));
    }, _T = (e) => Ce(e.selection.getSel().modify), S3 = (e, n, s) => {
      const l = e ? 1 : -1;
      return n.setRng(yt(s.container(), s.offset() + l).toRange()), n.getSel().modify("move", e ? "forward" : "backward", "word"), !0;
    }, h7 = (e, n) => {
      const s = n.selection.getRng(), l = e ? yt.fromRangeEnd(s) : yt.fromRangeStart(s);
      return _T(n) ? e && Lo(l) ? S3(!0, n.selection, l) : !e && _s(l) ? S3(!1, n.selection, l) : !1 : !1;
    };
    var Ov;
    (function(e) {
      e[e.Br = 0] = "Br", e[e.Block = 1] = "Block", e[e.Wrap = 2] = "Wrap", e[e.Eol = 3] = "Eol";
    })(Ov || (Ov = {}));
    const OT = (e, n) => e === Ms.Backwards ? Xr(n) : n, fQ = (e, n, s) => e === Ms.Forwards ? n.next(s) : n.prev(s), mQ = (e, n, s, l) => Mo(l.getNode(n === Ms.Forwards)) ? Ov.Br : gn(s, l) === !1 ? Ov.Block : Ov.Wrap, g7 = (e, n, s, l) => {
      const f = ch(s);
      let b = l;
      const E = [];
      for (; b; ) {
        const N = fQ(n, f, b);
        if (!N)
          break;
        if (Mo(N.getNode(!1)))
          return n === Ms.Forwards ? {
            positions: OT(n, E).concat([N]),
            breakType: Ov.Br,
            breakAt: oe.some(N)
          } : {
            positions: OT(n, E),
            breakType: Ov.Br,
            breakAt: oe.some(N)
          };
        if (!N.isVisible()) {
          b = N;
          continue;
        }
        if (e(b, N)) {
          const D = mQ(s, n, b, N);
          return {
            positions: OT(n, E),
            breakType: D,
            breakAt: oe.some(N)
          };
        }
        E.push(N), b = N;
      }
      return {
        positions: OT(n, E),
        breakType: Ov.Eol,
        breakAt: oe.none()
      };
    }, pQ = (e, n, s, l) => n(s, l).breakAt.map((f) => {
      const b = n(s, f).positions;
      return e === Ms.Backwards ? b.concat(f) : [f].concat(b);
    }).getOr([]), v7 = (e, n) => Ye(e, (s, l) => s.fold(() => oe.some(l), (f) => bs(br(f.getClientRects()), br(l.getClientRects()), (b, E) => {
      const N = Math.abs(n - b.left);
      return Math.abs(n - E.left) <= N ? l : f;
    }).or(s)), oe.none()), w3 = (e, n) => br(n.getClientRects()).bind((s) => v7(e, s.left)), zf = Ne(g7, yt.isAbove, -1), jO = Ne(g7, yt.isBelow, 1), b7 = Ne(pQ, -1, zf), iS = Ne(pQ, 1, jO), E3 = (e, n) => zf(e, n).breakAt.isNone(), y7 = (e, n) => jO(e, n).breakAt.isNone(), rP = (e) => Wu(e).map((n) => [n].concat(jO(e, n).positions)).getOr([]), hQ = (e) => np(e).map((n) => zf(e, n).positions.concat(n)).getOr([]), gQ = (e, n) => w3(b7(e, n), n), vQ = (e, n) => w3(iS(e, n), n), bQ = ro, S7 = (e, n) => Math.abs(e.left - n), w7 = (e, n) => Math.abs(e.right - n), p1 = (e) => Ei(e, "node"), E7 = (e, n) => vc(e, (s, l) => {
      const f = Math.min(S7(s, n), w7(s, n)), b = Math.min(S7(l, n), w7(l, n));
      return b === f && p1(l) && bQ(l.node) || b < f ? l : s;
    }), yQ = (e) => {
      const n = (s) => St(s, (l) => {
        const f = ov(l);
        return f.node = e, f;
      });
      if (Un(e))
        return n(e.getClientRects());
      if (Qt(e)) {
        const s = e.ownerDocument.createRange();
        return s.setStart(e, 0), s.setEnd(e, e.data.length), n(s.getClientRects());
      } else
        return [];
    }, C7 = (e) => gr(e, yQ);
    var qO;
    (function(e) {
      e[e.Up = -1] = "Up", e[e.Down = 1] = "Down";
    })(qO || (qO = {}));
    const SQ = (e, n, s, l) => {
      let f = l;
      for (; f = it(f, e, fu, n); )
        if (s(f))
          return;
    }, oP = (e, n, s, l, f, b) => {
      let E = 0;
      const N = [], D = (te) => {
        let ce = C7([te]);
        e === -1 && (ce = ce.reverse());
        for (let Oe = 0; Oe < ce.length; Oe++) {
          const Re = ce[Oe];
          if (!s(Re, U)) {
            if (N.length > 0 && n(Re, bc(N)) && E++, Re.line = E, f(Re))
              return !0;
            N.push(Re);
          }
        }
        return !1;
      }, U = bc(b.getClientRects());
      if (!U)
        return N;
      const J = b.getNode();
      return J && (D(J), SQ(e, l, D, J)), N;
    }, C3 = (e, n) => n.line > e, x3 = (e, n) => n.line === e, x7 = Ne(oP, qO.Up, Xh, Jh), T7 = Ne(oP, qO.Down, Jh, Xh), T3 = (e) => bc(e.getClientRects()), wQ = (e, n, s, l) => {
      const f = ch(n);
      let b, E, N, D;
      const U = [];
      let J = 0;
      e === 1 ? (b = f.next, E = Jh, N = Xh, D = yt.after(l)) : (b = f.prev, E = Xh, N = Jh, D = yt.before(l));
      const te = T3(D);
      do {
        if (!D.isVisible())
          continue;
        const ce = T3(D);
        if (N(ce, te))
          continue;
        U.length > 0 && E(ce, bc(U)) && J++;
        const Oe = ov(ce);
        if (Oe.position = D, Oe.line = J, s(Oe))
          return U;
        U.push(Oe);
      } while (D = b(D));
      return U;
    }, AT = (e) => (n) => C3(e, n), kT = (e) => (n) => x3(e, n), ty = (e, n) => {
      e.selection.setRng(n), bE(e, e.selection.getRng());
    }, sP = (e, n, s) => oe.some(XR(e, n, s)), _3 = (e, n, s, l, f, b) => {
      const E = n === Ms.Forwards, N = ch(e.getBody()), D = Ne(sc, E ? N.next : N.prev), U = E ? l : f;
      if (!s.collapsed) {
        const Re = Tb(s);
        if (b(Re))
          return ey(n, e, Re, n === Ms.Backwards, !1);
        if (p3(e)) {
          const xe = s.cloneRange();
          return xe.collapse(n === Ms.Backwards), oe.from(xe);
        }
      }
      const J = Lc(n, e.getBody(), s);
      if (U(J))
        return xT(e, J.getNode(!E));
      let te = D(J);
      const ce = Mp(s);
      if (te)
        te = mh(E, te);
      else
        return ce ? oe.some(s) : oe.none();
      if (U(te))
        return ey(n, e, te.getNode(!E), E, !1);
      const Oe = D(te);
      return Oe && U(Oe) && Kd(te, Oe) ? ey(n, e, Oe.getNode(!E), E, !1) : ce ? sP(e, te.toRange(), !1) : oe.none();
    }, O3 = (e, n, s, l, f, b) => {
      const E = Lc(n, e.getBody(), s), N = bc(E.getClientRects()), D = n === qO.Down, U = e.getBody();
      if (!N)
        return oe.none();
      if (p3(e)) {
        const Pe = D ? yt.fromRangeEnd(s) : yt.fromRangeStart(s);
        return (D ? vQ : gQ)(U, Pe).orThunk(() => oe.from(Pe)).map((et) => et.toRange());
      }
      const te = (D ? T7 : x7)(U, AT(1), E), ce = ht(te, kT(1)), Oe = N.left, Re = E7(ce, Oe);
      if (Re && b(Re.node)) {
        const Pe = Math.abs(Oe - Re.left), Ke = Math.abs(Oe - Re.right);
        return ey(n, e, Re.node, Pe < Ke, !1);
      }
      let xe;
      if (l(E) ? xe = E.getNode() : f(E) ? xe = E.getNode(!0) : xe = Tb(s), xe) {
        const Pe = wQ(n, U, AT(1), xe);
        let Ke = E7(ht(Pe, kT(1)), Oe);
        if (Ke || (Ke = bc(ht(Pe, kT(0))), Ke))
          return sP(e, Ke.position.toRange(), !1);
      }
      return ce.length === 0 ? NT(e, D).filter(D ? f : l).map((Pe) => XR(e, Pe.toRange(), !1)) : oe.none();
    }, NT = (e, n) => {
      const s = e.selection.getRng(), l = n ? yt.fromRangeEnd(s) : yt.fromRangeStart(s), f = At(l.container(), e.getBody());
      if (n) {
        const b = jO(f, l);
        return hs(b.positions);
      } else {
        const b = zf(f, l);
        return br(b.positions);
      }
    }, aP = (e, n, s) => NT(e, n).filter(s).exists((l) => (e.selection.setRng(l.toRange()), !0)), cS = (e, n) => {
      const s = e.dom.createRng();
      s.setStart(n.container(), n.offset()), s.setEnd(n.container(), n.offset()), e.selection.setRng(s);
    }, _7 = (e, n) => {
      e ? n.setAttribute("data-mce-selected", "inline-boundary") : n.removeAttribute("data-mce-selected");
    }, A3 = (e, n, s) => v3(n, s).map((l) => (cS(e, l), s)), EQ = (e, n, s) => {
      const l = yt.fromRangeStart(e);
      if (e.collapsed)
        return l;
      {
        const f = yt.fromRangeEnd(e);
        return s ? gd(n, f).getOr(f) : yu(n, l).getOr(l);
      }
    }, CQ = (e, n, s) => {
      const l = e.getBody(), f = EQ(e.selection.getRng(), l, s), b = Ne(CE, e);
      return dQ(s, b, l, f).bind((N) => A3(e, n, N));
    }, O7 = (e, n, s) => {
      const l = St(Vi(Fe.fromDom(n.getRoot()), '*[data-mce-selected="inline-boundary"]'), (E) => E.dom), f = ht(l, e), b = ht(s, e);
      ke(pc(f, b), Ne(_7, !1)), ke(pc(b, f), Ne(_7, !0));
    }, xQ = (e, n) => {
      const s = n.get();
      if (e.selection.isCollapsed() && !e.composing && s) {
        const l = yt.fromRangeStart(e.selection.getRng());
        yt.isTextPosition(l) && !fh(l) && (cS(e, Nx(s, l)), n.set(null));
      }
    }, A7 = (e, n, s, l) => {
      if (n.selection.isCollapsed()) {
        const f = ht(l, e);
        ke(f, (b) => {
          const E = yt.fromRangeStart(n.selection.getRng());
          Zl(e, n.getBody(), E).bind((N) => A3(n, s, N));
        });
      }
    }, TQ = (e, n, s) => lv(e) ? CQ(e, n, s).isSome() : !1, k7 = (e, n, s) => lv(n) ? h7(e, n) : !1, _Q = (e) => {
      const n = wa(null), s = Ne(CE, e);
      return e.on("NodeChange", (l) => {
        lv(e) && (O7(s, e.dom, l.parents), xQ(e, n), A7(s, e, n, l.parents));
      }), n;
    }, OQ = Ne(k7, !0), AQ = Ne(k7, !1), iP = (e, n, s) => {
      if (lv(e)) {
        const l = NT(e, n).getOrThunk(() => {
          const f = e.selection.getRng();
          return n ? yt.fromRangeEnd(f) : yt.fromRangeStart(f);
        });
        return Zl(Ne(CE, e), e.getBody(), l).exists((f) => {
          const b = WO(f);
          return v3(s, b).exists((E) => (cS(e, E), !0));
        });
      } else
        return !1;
    }, kQ = (e, n) => {
      const s = document.createRange();
      return s.setStart(e.container(), e.offset()), s.setEnd(n.container(), n.offset()), s;
    }, NQ = (e) => bs(Wu(e), np(e), (n, s) => {
      const l = mh(!0, n), f = mh(!1, s);
      return yu(e, l).forall((b) => b.isEqual(f));
    }).getOr(!0), N7 = (e, n) => (s) => v3(n, s).map((l) => () => cS(e, l)), k3 = (e, n, s, l) => {
      const f = e.getBody(), b = Ne(CE, e);
      e.undoManager.ignore(() => {
        e.selection.setRng(kQ(s, l)), VN(e), Zl(b, f, yt.fromRangeStart(e.selection.getRng())).map(y3).bind(N7(e, n)).each(cn);
      }), e.nodeChanged();
    }, RQ = (e, n) => {
      const s = vn(n, e);
      return s || e;
    }, ME = (e, n, s, l) => {
      const f = RQ(e.getBody(), l.container()), b = Ne(CE, e), E = Zl(b, f, l);
      return E.bind((D) => s ? D.fold(at(oe.some(y3(D))), oe.none, at(oe.some(WO(D))), oe.none) : D.fold(oe.none, at(oe.some(WO(D))), oe.none, at(oe.some(y3(D))))).map(N7(e, n)).getOrThunk(() => {
        const D = fv(s, f, l), U = D.bind((J) => Zl(b, f, J));
        return bs(E, U, () => Ol(b, f, l).bind((J) => NQ(J) ? oe.some(() => {
          s1(e, s, Fe.fromDom(J));
        }) : oe.none())).getOrThunk(() => U.bind(() => D.map((J) => () => {
          s ? k3(e, n, l, J) : k3(e, n, J, l);
        })));
      });
    }, cP = (e, n, s) => {
      if (e.selection.isCollapsed() && lv(e)) {
        const l = yt.fromRangeStart(e.selection.getRng());
        return ME(e, n, s, l);
      }
      return oe.none();
    }, N3 = (e) => ec(e) > 1, R3 = (e, n) => {
      const s = Fe.fromDom(e.getBody()), l = Fe.fromDom(e.selection.getStart()), f = qb(l, s);
      return $n(f, n).fold(at(f), (b) => f.slice(0, b));
    }, P3 = (e) => ec(e) === 1, lS = (e) => R3(e, (n) => e.schema.isBlock(no(n)) || N3(n)), R7 = (e) => R3(e, (n) => e.schema.isBlock(no(n))), lp = (e, n) => {
      const s = Ne(n8, e);
      return gr(n, (l) => s(l) ? [l.dom] : []);
    }, uS = (e) => {
      const n = R7(e);
      return lp(e, n);
    }, D3 = (e, n, s, l) => {
      const f = lp(n, l);
      if (f.length === 0)
        s1(n, e, s);
      else {
        const b = cR(s.dom, f);
        n.selection.setRng(b.toRange());
      }
    }, PQ = (e, n) => {
      const s = ht(lS(e), P3);
      return hs(s).bind((l) => {
        const f = yt.fromRangeStart(e.selection.getRng());
        return gM(n, f, l.dom) && !iE(l) ? oe.some(() => D3(n, e, l, s)) : oe.none();
      });
    }, P7 = (e, n) => {
      const s = n.parentElement;
      return Mo(n) && !q(s) && e.dom.isEmpty(s);
    }, DQ = (e) => iE(Fe.fromDom(e)), D7 = (e, n) => {
      const s = e.selection.getStart(), l = P7(e, s) || DQ(s) ? cR(s, n) : t8(e.selection.getRng(), n);
      e.selection.setRng(l.toRange());
    }, $Q = (e, n) => {
      const s = pc(n, uS(e));
      s.length > 0 && D7(e, s);
    }, $7 = (e) => Qt(e.startContainer), IQ = (e) => e.startOffset === 0 && $7(e), I7 = (e, n) => {
      const s = n.startContainer.parentElement;
      return !q(s) && n8(e, Fe.fromDom(s));
    }, MQ = (e) => {
      const n = e.startContainer.parentNode, s = e.endContainer.parentNode;
      return !q(n) && !q(s) && n.isEqualNode(s);
    }, FQ = (e) => {
      const n = e.endContainer;
      return e.endOffset === (Qt(n) ? n.length : n.childNodes.length);
    }, RT = (e) => MQ(e) && FQ(e), $3 = (e) => !e.endContainer.isEqualNode(e.commonAncestorContainer), M7 = (e) => RT(e) || $3(e), F7 = (e) => {
      const n = e.selection.getRng();
      return IQ(n) && I7(e, n) && M7(n);
    }, I3 = (e) => {
      if (F7(e)) {
        const n = uS(e);
        return oe.some(() => {
          VN(e), $Q(e, n);
        });
      } else
        return oe.none();
    }, M3 = (e, n) => e.selection.isCollapsed() ? PQ(e, n) : I3(e), LQ = (e, n) => l6(e, (s) => Rf(s.dom), (s) => n.isBlock(no(s))), BQ = (e) => LQ(Fe.fromDom(e.selection.getStart()), e.schema), HQ = (e) => {
      const n = e.selection.getRng();
      return n.collapsed && ($7(n) || e.dom.isEmpty(n.startContainer)) && !BQ(e);
    }, GO = (e) => (HQ(e) && D7(e, []), !0), F3 = (e, n, s) => Ie(s) ? oe.some(() => {
      e._selectionOverrides.hideFakeCaret(), s1(e, n, Fe.fromDom(s));
    }) : oe.none(), zQ = (e, n) => {
      const s = n ? nO : sT, l = n ? Ms.Forwards : Ms.Backwards, f = Lc(l, e.getBody(), e.selection.getRng());
      return s(f) ? F3(e, n, f.getNode(!n)) : oe.from(mh(n, f)).filter((b) => s(b) && Kd(f, b)).bind((b) => F3(e, n, b.getNode(!n)));
    }, L7 = (e, n) => {
      const s = e.selection.getNode();
      return Ts(s) ? F3(e, n, s) : oe.none();
    }, L3 = (e, n) => e.selection.isCollapsed() ? zQ(e, n) : L7(e, n), VQ = (e) => Fi(e, (n) => Dc(n.dom) || ro(n.dom)).exists((n) => Dc(n.dom)), Vf = (e) => td(e ?? "").getOr(0), B7 = (e, n) => {
      const s = e || nl(n) ? "margin" : "padding", l = va(n, "direction") === "rtl" ? "-right" : "-left";
      return s + l;
    }, B3 = (e, n, s, l, f, b) => {
      const E = B7(s, Fe.fromDom(b)), N = Vf(e.getStyle(b, E));
      if (n === "outdent") {
        const D = Math.max(0, N - l);
        e.setStyle(b, E, D ? D + f : "");
      } else {
        const D = N + l + f;
        e.setStyle(b, E, D);
      }
    }, H7 = (e, n) => Vr(n, (s) => {
      const l = B7(h0(e), s), f = Aa(s, l).map(Vf).getOr(0);
      return e.dom.getContentEditable(s.dom) !== "false" && f > 0;
    }), lP = (e) => {
      const n = V7(e);
      return !e.mode.isReadOnly() && (n.length > 1 || H7(e, n));
    }, z7 = (e) => gl(e) || Fu(e), UQ = (e) => Qo(e).exists(z7), V7 = (e) => ht(sd(e.selection.getSelectedBlocks()), (n) => !z7(n) && !UQ(n) && VQ(n)), U7 = (e, n) => {
      var s, l;
      const { dom: f } = e, b = Fc(e), E = (l = (s = /[a-z%]+$/i.exec(b)) === null || s === void 0 ? void 0 : s[0]) !== null && l !== void 0 ? l : "px", N = Vf(b), D = h0(e);
      ke(V7(e), (U) => {
        B3(f, n, D, N, E, U.dom);
      });
    }, WQ = (e) => U7(e, "indent"), H3 = (e) => U7(e, "outdent"), W7 = (e) => {
      if (e.selection.isCollapsed() && lP(e)) {
        const n = e.dom, s = e.selection.getRng(), l = yt.fromRangeStart(s), f = n.getParent(s.startContainer, n.isBlock);
        if (f !== null && cM(Fe.fromDom(f), l, e.schema))
          return oe.some(() => H3(e));
      }
      return oe.none();
    }, j7 = (e, n, s) => qo([
      W7,
      zO,
      m3,
      (l, f) => cP(l, n, f),
      d3,
      GN,
      g3,
      L3,
      QR,
      M3
    ], (l) => l(e, s)).filter((l) => e.selection.isEditable()), ZO = (e, n) => {
      j7(e, n, !1).fold(() => {
        e.selection.isEditable() && (VN(e), hM(e));
      }, cn);
    }, h1 = (e, n) => {
      j7(e, n, !0).fold(() => {
        e.selection.isEditable() && mM(e);
      }, cn);
    }, FE = (e, n) => {
      e.addCommand("delete", () => {
        ZO(e, n);
      }), e.addCommand("forwardDelete", () => {
        h1(e, n);
      });
    }, KO = 5, z3 = 400, uP = (e) => e.touches === void 0 || e.touches.length !== 1 ? oe.none() : oe.some(e.touches[0]), q7 = (e, n) => {
      const s = Math.abs(e.clientX - n.x), l = Math.abs(e.clientY - n.y);
      return s > KO || l > KO;
    }, jQ = (e) => {
      const n = Kh(), s = wa(!1), l = n0((f) => {
        e.dispatch("longpress", {
          ...f,
          type: "longpress"
        }), s.set(!0);
      }, z3);
      e.on("touchstart", (f) => {
        uP(f).each((b) => {
          l.cancel();
          const E = {
            x: b.clientX,
            y: b.clientY,
            target: f.target
          };
          l.throttle(f), s.set(!1), n.set(E);
        });
      }, !0), e.on("touchmove", (f) => {
        l.cancel(), uP(f).each((b) => {
          n.on((E) => {
            q7(b, E) && (n.clear(), s.set(!1), e.dispatch("longpresscancel"));
          });
        });
      }, !0), e.on("touchend touchcancel", (f) => {
        l.cancel(), f.type !== "touchcancel" && n.get().filter((b) => b.target.isEqualNode(f.target)).each(() => {
          s.get() ? f.preventDefault() : e.dispatch("tap", {
            ...f,
            type: "tap"
          });
        });
      }, !0);
    }, dP = (e, n) => lr(e, n.nodeName), G7 = (e, n) => Qt(n) ? !0 : Un(n) ? !dP(e.getBlockElements(), n) && !Pf(n) && !Jr(e, n) && !z1(n) : !1, qQ = (e, n, s) => qt(aM(Fe.fromDom(s), Fe.fromDom(n)), (l) => dP(e, l.dom)), GQ = (e, n) => {
      if (Qt(n)) {
        if (n.data.length === 0)
          return !0;
        if (/^\s+$/.test(n.data))
          return !n.nextSibling || dP(e, n.nextSibling) || z1(n.nextSibling);
      }
      return !1;
    }, Z7 = (e) => e.dom.create(al(e), ng(e)), ZQ = (e) => {
      const n = e.dom, s = e.selection, l = e.schema, f = l.getBlockElements(), b = s.getStart(), E = e.getBody();
      let N, D, U = !1;
      const J = al(e);
      if (!b || !Un(b))
        return;
      const te = E.nodeName.toLowerCase();
      if (!l.isValidChild(te, J.toLowerCase()) || qQ(f, E, b))
        return;
      const ce = s.getRng(), { startContainer: Oe, startOffset: Re, endContainer: xe, endOffset: Pe } = ce, Ke = W0(e);
      let et = E.firstChild;
      for (; et; )
        if (Un(et) && qp(l, et), G7(l, et)) {
          if (GQ(f, et)) {
            D = et, et = et.nextSibling, n.remove(D);
            continue;
          }
          N || (N = Z7(e), E.insertBefore(N, et), U = !0), D = et, et = et.nextSibling, N.appendChild(D);
        } else
          N = null, et = et.nextSibling;
      U && Ke && (ce.setStart(Oe, Re), ce.setEnd(xe, Pe), s.setRng(ce), e.nodeChanged());
    }, K7 = (e, n, s) => {
      const l = Fe.fromDom(Z7(e)), f = bl();
      Ys(l, f), s(n, l);
      const b = document.createRange();
      return b.setStartBefore(f.dom), b.setEndBefore(f.dom), b;
    }, KQ = (e) => {
      e.on("NodeChange", Ne(ZQ, e));
    }, V3 = (e) => (n) => (" " + n.attr("class") + " ").indexOf(e) !== -1, Y7 = (e, n, s) => function(l) {
      const f = arguments, b = f[f.length - 2], E = b > 0 ? n.charAt(b - 1) : "";
      if (E === '"')
        return l;
      if (E === ">") {
        const N = n.lastIndexOf("<", b);
        if (N !== -1 && n.substring(N, b).indexOf('contenteditable="false"') !== -1)
          return l;
      }
      return '<span class="' + s + '" data-mce-content="' + e.dom.encode(f[0]) + '">' + e.dom.encode(typeof f[1] == "string" ? f[1] : f[0]) + "</span>";
    }, Vce = (e, n, s) => {
      let l = n.length, f = s.content;
      if (s.format !== "raw") {
        for (; l--; )
          f = f.replace(n[l], Y7(e, f, jy(e)));
        s.content = f;
      }
    }, Uce = (e, n) => Vr(e, (s) => {
      const l = n.match(s);
      return l !== null && l[0].length === n.length;
    }), Wce = (e) => {
      const n = "contenteditable", s = " " + rn.trim(_x(e)) + " ", l = " " + rn.trim(jy(e)) + " ", f = V3(s), b = V3(l), E = y_(e);
      E.length > 0 && e.on("BeforeSetContent", (N) => {
        Vce(e, E, N);
      }), e.parser.addAttributeFilter("class", (N) => {
        let D = N.length;
        for (; D--; ) {
          const U = N[D];
          f(U) ? U.attr(n, "true") : b(U) && U.attr(n, "false");
        }
      }), e.serializer.addAttributeFilter(n, (N) => {
        let D = N.length;
        for (; D--; ) {
          const U = N[D];
          if (!f(U) && !b(U))
            continue;
          const J = U.attr("data-mce-content");
          E.length > 0 && J ? Uce(E, J) ? (U.name = "#text", U.type = 3, U.raw = !0, U.value = J) : U.remove() : U.attr(n, null);
        }
      });
    }, YQ = (e) => Li(Fe.fromDom(e.getBody()), "*[data-mce-caret]").map((n) => n.dom).getOrNull(), QQ = (e, n) => {
      n.hasAttribute("data-mce-caret") && (Bd(n), e.selection.setRng(e.selection.getRng()), e.selection.scrollIntoView(n));
    }, jce = (e, n) => {
      const s = YQ(e);
      if (s) {
        if (n.type === "compositionstart") {
          n.preventDefault(), n.stopPropagation(), QQ(e, s);
          return;
        }
        Pr(s) && (QQ(e, s), e.undoManager.add());
      }
    }, XQ = (e) => {
      e.on("keyup compositionstart", Ne(jce, e));
    }, Q7 = ro, qce = (e, n, s) => _3(n, e, s, r1, wv, Q7), JQ = (e, n, s) => O3(n, e, s, (b) => r1(b) || H5(b), (b) => wv(b) || Zr(b), Q7), Cm = (e) => {
      const n = e.dom.create(al(e));
      return n.innerHTML = '<br data-mce-bogus="1">', n;
    }, U3 = (e, n, s) => {
      const l = ch(e.getBody()), f = Ne(sc, n === 1 ? l.next : l.prev);
      if (s.collapsed) {
        const b = e.dom.getParent(s.startContainer, "PRE");
        if (!b)
          return;
        if (!f(yt.fromRangeStart(s))) {
          const N = Fe.fromDom(Cm(e));
          n === 1 ? tl(Fe.fromDom(b), N) : ba(Fe.fromDom(b), N), e.selection.select(N.dom, !0), e.selection.collapse();
        }
      }
    }, YO = (e, n) => {
      const s = n ? Ms.Forwards : Ms.Backwards, l = e.selection.getRng();
      return qce(s, e, l).orThunk(() => (U3(e, s, l), oe.none()));
    }, eX = (e, n) => {
      const s = n ? 1 : -1, l = e.selection.getRng();
      return JQ(s, e, l).orThunk(() => (U3(e, s, l), oe.none()));
    }, X7 = (e, n) => {
      const s = n ? e.getEnd(!0) : e.getStart(!0);
      return i6(s) ? !n : n;
    }, W3 = (e, n) => YO(e, X7(e.selection, n)).exists((s) => (ty(e, s), !0)), fP = (e, n) => eX(e, n).exists((s) => (ty(e, s), !0)), J7 = (e, n) => aP(e, n, n ? wv : r1), mP = (e, n) => eP(e, !n).map((s) => {
      const l = s.toRange(), f = e.selection.getRng();
      return n ? l.setStart(f.startContainer, f.startOffset) : l.setEnd(f.endContainer, f.endOffset), l;
    }).exists((s) => (ty(e, s), !0)), ez = (e) => Ge(["figcaption"], no(e)), tX = (e, n, s) => {
      const l = Ne(Je, n);
      return Fi(Fe.fromDom(e.container()), (f) => s.isBlock(no(f)), l).filter(ez);
    }, nX = (e, n, s) => n ? y7(e.dom, s) : E3(e.dom, s), rX = (e, n) => {
      const s = Fe.fromDom(e.getBody()), l = yt.fromRangeStart(e.selection.getRng());
      return tX(l, s, e.schema).exists(() => {
        if (nX(s, n, l)) {
          const b = K7(e, s, n ? Ys : od);
          return e.selection.setRng(b), !0;
        } else
          return !1;
      });
    }, pP = (e, n) => e.selection.isCollapsed() ? rX(e, n) : !1, oX = (e, n, s) => {
      const l = e.selection.getRng(), f = yt.fromRangeStart(l);
      return e.getBody().firstChild === n && E3(s, f) ? (e.execCommand("InsertNewBlockBefore"), !0) : !1;
    }, sX = (e, n) => {
      const s = e.selection.getRng(), l = yt.fromRangeStart(s);
      return e.getBody().lastChild === n && y7(n, l) ? (e.execCommand("InsertNewBlockAfter"), !0) : !1;
    }, Gce = (e, n) => n ? oe.from(e.dom.getParent(e.selection.getNode(), "details")).map((s) => sX(e, s)).getOr(!1) : oe.from(e.dom.getParent(e.selection.getNode(), "summary")).bind((s) => oe.from(e.dom.getParent(s, "details")).map((l) => oX(e, l, s))).getOr(!1), tz = (e, n) => Gce(e, n), j3 = {
      shiftKey: !1,
      altKey: !1,
      ctrlKey: !1,
      metaKey: !1,
      keyCode: 0
    }, Zce = (e) => St(e, (n) => ({
      ...j3,
      ...n
    })), aX = (e) => St(e, (n) => ({
      ...j3,
      ...n
    })), nz = (e, n) => n.keyCode === e.keyCode && n.shiftKey === e.shiftKey && n.altKey === e.altKey && n.ctrlKey === e.ctrlKey && n.metaKey === e.metaKey, iX = (e, n) => gr(Zce(e), (s) => nz(s, n) ? [s] : []), q3 = (e, n) => gr(aX(e), (s) => nz(s, n) ? [s] : []), Tr = (e, ...n) => () => e.apply(null, n), PT = (e, n) => Bt(iX(e, n), (s) => s.action()), G3 = (e, n) => qo(q3(e, n), (s) => s.action()), rz = (e, n) => {
      const s = n ? Ms.Forwards : Ms.Backwards, l = e.selection.getRng();
      return _3(e, s, l, nO, sT, Ts).exists((f) => (ty(e, f), !0));
    }, oz = (e, n) => {
      const s = n ? 1 : -1, l = e.selection.getRng();
      return O3(e, s, l, nO, sT, Ts).exists((f) => (ty(e, f), !0));
    }, hP = (e, n) => aP(e, n, n ? sT : nO), sz = hm.generate([
      { none: ["current"] },
      { first: ["current"] },
      {
        middle: [
          "current",
          "target"
        ]
      },
      { last: ["current"] }
    ]), QO = {
      ...sz,
      none: (e) => sz.none(e)
    }, cX = (e, n) => Sh(e, n, ut), Sh = (e, n, s) => gr(ga(e), (l) => Bl(l, n) ? s(l) ? [l] : [] : Sh(l, n, s)), az = (e, n, s = He) => {
      if (s(n))
        return oe.none();
      if (Ge(e, no(n)))
        return oe.some(n);
      const l = (f) => Bl(f, "table") || s(f);
      return su(n, e.join(","), l);
    }, iz = (e, n) => az([
      "td",
      "th"
    ], e, n), Yce = (e) => cX(e, "th,td"), lX = (e, n) => au(e, "table", n), cz = (e, n, s, l, f = ut) => {
      const b = l === 1;
      if (!b && s <= 0)
        return QO.first(e[0]);
      if (b && s >= e.length - 1)
        return QO.last(e[e.length - 1]);
      {
        const E = s + l, N = e[E];
        return f(N) ? QO.middle(n, N) : cz(e, n, E, l, f);
      }
    }, uX = (e, n) => lX(e, n).bind((s) => {
      const l = Yce(s);
      return $n(l, (b) => Je(e, b)).map((b) => ({
        index: b,
        all: l
      }));
    }), dX = (e, n, s) => uX(e, s).fold(() => QO.none(e), (f) => cz(f.all, e, f.index, 1, n)), gP = (e, n, s) => uX(e, s).fold(() => QO.none(), (f) => cz(f.all, e, f.index, -1, n)), fX = (e, n) => ({
      left: e.left - n,
      top: e.top - n,
      right: e.right + n * 2,
      bottom: e.bottom + n * 2,
      width: e.width + n,
      height: e.height + n
    }), Z3 = (e, n) => gr(n, (s) => {
      const l = fX(ov(s.getBoundingClientRect()), -1);
      return [
        {
          x: l.left,
          y: e(l),
          cell: s
        },
        {
          x: l.right,
          y: e(l),
          cell: s
        }
      ];
    }), lz = (e, n, s) => Ye(e, (l, f) => l.fold(() => oe.some(f), (b) => {
      const E = Math.sqrt(Math.abs(b.x - n) + Math.abs(b.y - s)), N = Math.sqrt(Math.abs(f.x - n) + Math.abs(f.y - s));
      return oe.some(N < E ? f : b);
    }), oe.none()), K3 = (e, n, s, l, f) => {
      const b = Vi(Fe.fromDom(s), "td,th,caption").map((N) => N.dom), E = ht(Z3(e, b), (N) => n(N, f));
      return lz(E, l, f).map((N) => N.cell);
    }, uz = (e) => e.bottom, mX = (e) => e.top, pX = (e, n) => e.y < n, hX = (e, n) => e.y > n, gX = Ne(K3, uz, pX), vP = Ne(K3, mX, hX), vX = (e, n) => br(n.getClientRects()).bind((s) => gX(e, s.left, s.top)).bind((s) => w3(hQ(s), n)), bX = (e, n) => hs(n.getClientRects()).bind((s) => vP(e, s.left, s.top)).bind((s) => w3(rP(s), n)), yX = (e, n, s) => s.breakAt.exists((l) => e(n, l).breakAt.isSome()), Y3 = (e) => e.breakType === Ov.Wrap && e.positions.length === 0, SX = (e) => e.breakType === Ov.Br && e.positions.length === 1, dz = (e, n, s) => {
      const l = e(n, s);
      return Y3(l) || !Mo(s.getNode()) && SX(l) ? !yX(e, n, l) : l.breakAt.isNone();
    }, fz = Ne(dz, zf), wX = Ne(dz, jO), EX = (e, n, s) => {
      const l = yt.fromRangeStart(n);
      return R0(!e, s).exists((f) => f.isEqual(l));
    }, CX = (e, n, s, l) => {
      const f = e.selection.getRng(), b = n ? 1 : -1;
      return Gy() && EX(n, f, s) ? (ey(b, e, s, !n, !1).each((E) => {
        ty(e, E);
      }), !0) : !1;
    }, xX = (e, n, s) => vX(n, s).orThunk(() => br(s.getClientRects()).bind((l) => v7(b7(e, yt.before(n)), l.left))).getOr(yt.before(n)), TX = (e, n, s) => bX(n, s).orThunk(() => br(s.getClientRects()).bind((l) => v7(iS(e, yt.after(n)), l.left))).getOr(yt.after(n)), mz = (e, n) => {
      const s = n.getNode(e);
      return gf(s) ? oe.some(s) : oe.none();
    }, Q3 = (e, n, s) => {
      n.undoManager.transact(() => {
        const l = e ? tl : ba, f = K7(n, Fe.fromDom(s), l);
        ty(n, f);
      });
    }, pz = (e, n, s) => {
      const l = mz(!!n, s), f = n === !1;
      l.fold(() => ty(e, s.toRange()), (b) => R0(f, e.getBody()).filter((E) => E.isEqual(s)).fold(() => ty(e, s.toRange()), (E) => Q3(n, e, b)));
    }, hz = (e, n, s, l) => {
      const f = e.selection.getRng(), b = yt.fromRangeStart(f), E = e.getBody();
      if (!n && fz(l, b)) {
        const N = xX(E, s, b);
        return pz(e, n, N), !0;
      } else if (n && wX(l, b)) {
        const N = TX(E, s, b);
        return pz(e, n, N), !0;
      } else
        return !1;
    }, gz = (e, n, s) => oe.from(e.dom.getParent(e.selection.getNode(), "td,th")).bind((l) => oe.from(e.dom.getParent(l, "table")).map((f) => s(e, n, f, l))).getOr(!1), vz = (e, n) => gz(e, n, CX), X3 = (e, n) => gz(e, n, hz), _X = (e) => {
      const n = yv.exact(e, 0, e, 0);
      return GI(n);
    }, bz = (e, n, s) => s.fold(oe.none, oe.none, (l, f) => Zq(f).map((b) => _X(b)), (l) => (e.execCommand("mceTableInsertRowAfter"), yz(e, n, l))), yz = (e, n, s) => bz(e, n, dX(s, Rr)), zc = (e, n, s) => bz(e, n, gP(s, Rr)), Sz = (e, n) => {
      const s = [
        "table",
        "li",
        "dl"
      ], l = Fe.fromDom(e.getBody()), f = (N) => {
        const D = no(N);
        return Je(N, l) || Ge(s, D);
      }, b = e.selection.getRng(), E = Fe.fromDom(n ? b.endContainer : b.startContainer);
      return iz(E, f).map((N) => (lX(N, f).each((J) => {
        e.model.table.clearSelectedCells(J.dom);
      }), e.selection.collapse(!n), (n ? yz : zc)(e, f, N).each((J) => {
        e.selection.setRng(J);
      }), !0)).getOr(!1);
    }, OX = (e, n, s) => {
      const l = kn.os.isMacOS() || kn.os.isiOS();
      PT([
        {
          keyCode: zn.RIGHT,
          action: Tr(W3, e, !0)
        },
        {
          keyCode: zn.LEFT,
          action: Tr(W3, e, !1)
        },
        {
          keyCode: zn.UP,
          action: Tr(fP, e, !1)
        },
        {
          keyCode: zn.DOWN,
          action: Tr(fP, e, !0)
        },
        ...l ? [
          {
            keyCode: zn.UP,
            action: Tr(mP, e, !1),
            metaKey: !0,
            shiftKey: !0
          },
          {
            keyCode: zn.DOWN,
            action: Tr(mP, e, !0),
            metaKey: !0,
            shiftKey: !0
          }
        ] : [],
        {
          keyCode: zn.RIGHT,
          action: Tr(vz, e, !0)
        },
        {
          keyCode: zn.LEFT,
          action: Tr(vz, e, !1)
        },
        {
          keyCode: zn.UP,
          action: Tr(X3, e, !1)
        },
        {
          keyCode: zn.DOWN,
          action: Tr(X3, e, !0)
        },
        {
          keyCode: zn.UP,
          action: Tr(X3, e, !1)
        },
        {
          keyCode: zn.UP,
          action: Tr(tz, e, !1)
        },
        {
          keyCode: zn.DOWN,
          action: Tr(tz, e, !0)
        },
        {
          keyCode: zn.RIGHT,
          action: Tr(rz, e, !0)
        },
        {
          keyCode: zn.LEFT,
          action: Tr(rz, e, !1)
        },
        {
          keyCode: zn.UP,
          action: Tr(oz, e, !1)
        },
        {
          keyCode: zn.DOWN,
          action: Tr(oz, e, !0)
        },
        {
          keyCode: zn.RIGHT,
          action: Tr(TQ, e, n, !0)
        },
        {
          keyCode: zn.LEFT,
          action: Tr(TQ, e, n, !1)
        },
        {
          keyCode: zn.RIGHT,
          ctrlKey: !l,
          altKey: l,
          action: Tr(OQ, e, n)
        },
        {
          keyCode: zn.LEFT,
          ctrlKey: !l,
          altKey: l,
          action: Tr(AQ, e, n)
        },
        {
          keyCode: zn.UP,
          action: Tr(pP, e, !1)
        },
        {
          keyCode: zn.DOWN,
          action: Tr(pP, e, !0)
        }
      ], s).each((f) => {
        s.preventDefault();
      });
    }, AX = (e, n) => {
      e.on("keydown", (s) => {
        s.isDefaultPrevented() || OX(e, n, s);
      });
    }, yg = (e, n) => ({
      container: e,
      offset: n
    }), DT = Is.DOM, XO = (e) => (n) => e === n ? -1 : 0, dS = (e) => (n) => e.isBlock(n) || Ge([
      "BR",
      "IMG",
      "HR",
      "INPUT"
    ], n.nodeName) || e.getContentEditable(n) === "false", JO = (e, n, s) => {
      if (Qt(e) && n >= 0)
        return oe.some(yg(e, n));
      {
        const l = Qh(DT);
        return oe.from(l.backwards(e, n, XO(e), s)).map((f) => yg(f.container, f.container.data.length));
      }
    }, wz = (e, n, s) => {
      if (Qt(e) && n >= e.length)
        return oe.some(yg(e, n));
      {
        const l = Qh(DT);
        return oe.from(l.forwards(e, n, XO(e), s)).map((f) => yg(f.container, 0));
      }
    }, eA = (e, n, s) => {
      if (!Qt(e))
        return oe.none();
      const l = e.data;
      if (n >= 0 && n <= l.length)
        return oe.some(yg(e, n));
      {
        const f = Qh(DT);
        return oe.from(f.backwards(e, n, XO(e), s)).bind((b) => {
          const E = b.container.data;
          return eA(b.container, n + E.length, s);
        });
      }
    }, bP = (e, n, s) => {
      if (!Qt(e))
        return oe.none();
      const l = e.data;
      if (n <= l.length)
        return oe.some(yg(e, n));
      {
        const f = Qh(DT);
        return oe.from(f.forwards(e, n, XO(e), s)).bind((b) => bP(b.container, n - l.length, s));
      }
    }, tA = (e, n, s, l, f) => {
      const b = Qh(e, dS(e));
      return oe.from(b.backwards(n, s, l, f));
    }, Ez = (e) => e.collapsed && Qt(e.startContainer), nA = (e) => de(e.toString().replace(/\u00A0/g, " ")), rA = (e) => e !== "" && ` \f
\r	\v`.indexOf(e) !== -1, LE = (e, n) => e.substring(n.length), oA = (e, n, s) => {
      let l;
      const f = s.charAt(0);
      for (l = n - 1; l >= 0; l--) {
        const b = e.charAt(l);
        if (rA(b))
          return oe.none();
        if (f === b && Hs(e, s, l, n))
          break;
      }
      return oe.some(l);
    }, Sg = (e, n, s, l = 0) => {
      if (!Ez(n))
        return oe.none();
      const f = {
        text: "",
        offset: 0
      }, b = (N, D, U) => (f.text = U + f.text, f.offset += D, oA(f.text, f.offset, s).getOr(D)), E = e.getParent(n.startContainer, e.isBlock) || e.getRoot();
      return tA(e, n.startContainer, n.startOffset, b, E).bind((N) => {
        const D = n.cloneRange();
        if (D.setStart(N.container, N.offset), D.setEnd(n.endContainer, n.endOffset), D.collapsed)
          return oe.none();
        const U = nA(D);
        return U.lastIndexOf(s) !== 0 || LE(U, s).length < l ? oe.none() : oe.some({
          text: LE(U, s),
          range: D,
          trigger: s
        });
      });
    }, $T = (e, n, s, l = 0) => Xq(Fe.fromDom(n.startContainer)).fold(() => Sg(e, n, s, l), (f) => {
      const b = e.createRng();
      b.selectNode(f.dom);
      const E = nA(b);
      return oe.some({
        range: b,
        text: LE(E, s),
        trigger: s
      });
    }), Cz = (e) => e.nodeType === Op, xz = (e) => e.nodeType === Ml, Tz = (e) => {
      if (Cz(e))
        return yg(e, e.data.length);
      {
        const n = e.childNodes;
        return n.length > 0 ? Tz(n[n.length - 1]) : yg(e, n.length);
      }
    }, J3 = (e, n) => {
      const s = e.childNodes;
      return s.length > 0 && n < s.length ? J3(s[n], 0) : s.length > 0 && xz(e) && s.length === n ? Tz(s[s.length - 1]) : yg(e, n);
    }, kX = (e, n) => {
      var s;
      const l = (s = e.getParent(n.container, e.isBlock)) !== null && s !== void 0 ? s : e.getRoot();
      return tA(e, n.container, n.offset, (f, b) => b === 0 ? -1 : b, l).filter((f) => {
        const b = f.container.data.charAt(f.offset - 1);
        return !rA(b);
      }).isSome();
    }, NX = (e) => (n) => {
      const s = J3(n.startContainer, n.startOffset);
      return !kX(e, s);
    }, sA = (e, n, s) => qo(s.triggers, (l) => $T(e, n, l)), RX = (e, n) => {
      const s = n(), l = e.selection.getRng();
      return sA(e.dom, l, s).bind((f) => _z(e, n, f));
    }, _z = (e, n, s, l = {}) => {
      var f;
      const b = n(), N = (f = e.selection.getRng().startContainer.nodeValue) !== null && f !== void 0 ? f : "", D = ht(b.lookupByTrigger(s.trigger), (J) => s.text.length >= J.minChars && J.matches.getOrThunk(() => NX(e.dom))(s.range, N, s.text));
      if (D.length === 0)
        return oe.none();
      const U = Promise.all(St(D, (J) => J.fetch(s.text, J.maxResults, l).then((ce) => ({
        matchText: s.text,
        items: ce,
        columns: J.columns,
        onAction: J.onAction,
        highlightOn: J.highlightOn
      }))));
      return oe.some({
        lookupData: U,
        context: s
      });
    };
    var Av;
    (function(e) {
      e[e.Error = 0] = "Error", e[e.Value = 1] = "Value";
    })(Av || (Av = {}));
    const e4 = (e, n, s) => e.stype === Av.Error ? n(e.serror) : s(e.svalue), PX = (e) => {
      const n = [], s = [];
      return ke(e, (l) => {
        e4(l, (f) => s.push(f), (f) => n.push(f));
      }), {
        values: n,
        errors: s
      };
    }, DX = (e, n) => e.stype === Av.Error ? {
      stype: Av.Error,
      serror: n(e.serror)
    } : e, $X = (e, n) => e.stype === Av.Value ? {
      stype: Av.Value,
      svalue: n(e.svalue)
    } : e, IX = (e, n) => e.stype === Av.Value ? n(e.svalue) : e, MX = (e, n) => e.stype === Av.Error ? n(e.serror) : e, Oz = (e) => ({
      stype: Av.Value,
      svalue: e
    }), Az = (e) => ({
      stype: Av.Error,
      serror: e
    }), Eu = {
      fromResult: (e) => e.fold(Az, Oz),
      toResult: (e) => e4(e, gu.error, gu.value),
      svalue: Oz,
      partition: PX,
      serror: Az,
      bind: IX,
      bindError: MX,
      map: $X,
      mapError: DX,
      fold: e4
    }, yP = (e) => me(e) && Co(e).length > 100 ? " removed due to size" : JSON.stringify(e, null, 2), kz = (e) => {
      const n = e.length > 10 ? e.slice(0, 10).concat([{
        path: [],
        getErrorInfo: at("... (only showing first ten failures)")
      }]) : e;
      return St(n, (s) => "Failed path: (" + s.path.join(" > ") + `)
` + s.getErrorInfo());
    }, aA = (e, n) => Eu.serror([{
      path: e,
      getErrorInfo: n
    }]), FX = (e, n, s) => aA(e, () => 'Could not find valid *required* value for "' + n + '" in ' + yP(s)), LX = (e, n) => aA(e, () => 'Choice schema did not contain choice key: "' + n + '"'), BX = (e, n, s) => aA(e, () => 'The chosen schema: "' + s + '" did not exist in branches: ' + yP(n)), HX = (e, n) => aA(e, at(n)), Nz = (e, n, s, l) => gs(s, l).fold(() => BX(e, s, l), (b) => b.extract(e.concat(["branch: " + l]), n)), zX = (e, n) => ({
      extract: (f, b) => gs(b, e).fold(() => LX(f, e), (N) => Nz(f, b, n, N)),
      toString: () => "chooseOn(" + e + "). Possible values: " + Co(n)
    }), Rz = (e, n) => n, VX = (e, n) => we(e) && we(n) ? iA(e, n) : n, t4 = (e) => (...n) => {
      if (n.length === 0)
        throw new Error("Can't merge zero objects");
      const s = {};
      for (let l = 0; l < n.length; l++) {
        const f = n[l];
        for (const b in f)
          lr(f, b) && (s[b] = e(s[b], f[b]));
      }
      return s;
    }, iA = t4(VX), UX = t4(Rz), Pz = () => ({
      tag: "required",
      process: {}
    }), WX = (e) => ({
      tag: "defaultedThunk",
      process: e
    }), n4 = (e) => WX(at(e)), jX = () => ({
      tag: "option",
      process: {}
    }), qX = (e, n) => e.length > 0 ? Eu.svalue(iA(n, UX.apply(void 0, e))) : Eu.svalue(n), r4 = (e) => z(Eu.serror, mr)(e), Dz = {
      consolidateObj: (e, n) => {
        const s = Eu.partition(e);
        return s.errors.length > 0 ? r4(s.errors) : qX(s.values, n);
      },
      consolidateArr: (e) => {
        const n = Eu.partition(e);
        return n.errors.length > 0 ? r4(n.errors) : Eu.svalue(n.values);
      }
    }, GX = (e, n, s, l) => ({
      tag: "field",
      key: e,
      newKey: n,
      presence: s,
      prop: l
    }), ZX = (e, n) => ({
      tag: "custom",
      newKey: e,
      instantiator: n
    }), $z = (e, n, s) => {
      switch (e.tag) {
        case "field":
          return n(e.key, e.newKey, e.presence, e.prop);
        case "custom":
          return s(e.newKey, e.instantiator);
      }
    }, SP = (e) => {
      const n = (l, f) => Eu.bindError(e(f), (b) => HX(l, b)), s = at("val");
      return {
        extract: n,
        toString: s
      };
    }, Iz = SP(Eu.svalue), KX = (e, n, s, l) => gs(n, s).fold(() => FX(e, s, n), l), Mz = (e, n, s, l) => {
      const f = gs(e, n).getOrThunk(() => s(e));
      return l(f);
    }, YX = (e, n, s) => s(gs(e, n)), QX = (e, n, s, l) => {
      const f = gs(e, n).map((b) => b === !0 ? s(e) : b);
      return l(f);
    }, XX = (e, n, s, l, f) => {
      const b = (N) => f.extract(n.concat([l]), N), E = (N) => N.fold(() => Eu.svalue(oe.none()), (D) => {
        const U = f.extract(n.concat([l]), D);
        return Eu.map(U, oe.some);
      });
      switch (e.tag) {
        case "required":
          return KX(n, s, l, b);
        case "defaultedThunk":
          return Mz(s, l, e.process, b);
        case "option":
          return YX(s, l, E);
        case "defaultedOptionThunk":
          return QX(s, l, e.process, E);
        case "mergeWithThunk":
          return Mz(s, l, at({}), (N) => {
            const D = iA(e.process(s), N);
            return b(D);
          });
      }
    }, JX = (e, n, s) => {
      const l = {}, f = [];
      for (const b of s)
        $z(b, (E, N, D, U) => {
          const J = XX(D, e, n, E, U);
          Eu.fold(J, (te) => {
            f.push(...te);
          }, (te) => {
            l[N] = te;
          });
        }, (E, N) => {
          l[E] = N(n);
        });
      return f.length > 0 ? Eu.serror(f) : Eu.svalue(l);
    }, o4 = (e) => ({
      extract: (l, f) => JX(l, f, e),
      toString: () => `obj{
` + St(e, (f) => $z(f, (b, E, N, D) => b + " -> " + D.toString(), (b, E) => "state(" + b + ")")).join(`
`) + "}"
    }), Fz = (e) => ({
      extract: (l, f) => {
        const b = St(f, (E, N) => e.extract(l.concat(["[" + N + "]"]), E));
        return Dz.consolidateArr(b);
      },
      toString: () => "array(" + e.toString() + ")"
    }), tle = (e) => SP((n) => e(n).fold(Eu.serror, Eu.svalue)), eJ = (e, n, s) => {
      const l = n.extract([e], s);
      return Eu.mapError(l, (f) => ({
        input: s,
        errors: f
      }));
    }, wP = (e, n, s) => Eu.toResult(eJ(e, n, s)), Lz = (e) => `Errors: 
` + kz(e.errors).join(`
`) + `

Input object: ` + yP(e.input), s4 = (e, n) => zX(e, Yr(n, o4)), tJ = at(Iz), cA = (e, n) => SP((s) => {
      const l = typeof s;
      return e(s) ? Eu.svalue(s) : Eu.serror(`Expected type: ${n} but got: ${l}`);
    }), Bz = cA(pt, "number"), EP = cA(G, "string"), nJ = cA(Te, "boolean"), a4 = cA(Ce, "function"), IT = GX, Hz = ZX, i4 = (e) => tle((n) => Ge(e, n) ? gu.value(n) : gu.error(`Unsupported value: "${n}", choose one of "${e.join(", ")}".`)), zz = (e, n) => IT(e, e, Pz(), n), Vz = (e) => zz(e, EP), Uz = (e) => zz(e, a4), Wz = (e, n) => IT(e, e, Pz(), Fz(n)), c4 = (e, n) => IT(e, e, jX(), n), CP = (e) => c4(e, EP), rJ = (e) => c4(e, a4), oJ = (e, n) => IT(e, e, n4(n), tJ()), MT = (e, n, s) => IT(e, e, n4(n), s), Vc = (e, n) => MT(e, n, Bz), ny = (e, n) => MT(e, n, EP), jz = (e, n, s) => MT(e, n, i4(s)), qz = (e, n) => MT(e, n, nJ), l4 = (e, n) => MT(e, n, a4), sJ = (e, n, s) => MT(e, n, Fz(s)), aJ = Vz("type"), iJ = Uz("fetch"), xP = Uz("onAction"), FT = l4("onSetup", () => Lt), nle = CP("text"), cJ = CP("icon"), lJ = CP("tooltip"), kv = CP("label"), uJ = qz("active", !1), dJ = qz("enabled", !0), u4 = qz("primary", !1), fJ = (e) => oJ("columns", e), BE = (e) => ny("type", e), Gz = o4([
      aJ,
      Vz("trigger"),
      Vc("minChars", 1),
      fJ(1),
      Vc("maxResults", 10),
      rJ("matches"),
      iJ,
      xP,
      sJ("highlightOn", [], EP)
    ]), mJ = (e) => wP("Autocompleter", Gz, {
      trigger: e.ch,
      ...e
    }), d4 = [
      dJ,
      lJ,
      cJ,
      nle,
      FT
    ], Zz = [uJ].concat(d4), Kz = [
      l4("predicate", He),
      jz("scope", "node", [
        "node",
        "editor"
      ]),
      jz("position", "selection", [
        "node",
        "selection",
        "line"
      ])
    ], Yz = d4.concat([
      BE("contextformbutton"),
      u4,
      xP,
      Hz("original", _n)
    ]), f4 = Zz.concat([
      BE("contextformbutton"),
      u4,
      xP,
      Hz("original", _n)
    ]), m4 = d4.concat([BE("contextformbutton")]), p4 = Zz.concat([BE("contextformtogglebutton")]), pJ = s4("type", {
      contextformbutton: Yz,
      contextformtogglebutton: f4
    });
    o4([
      BE("contextform"),
      l4("initValue", at("")),
      kv,
      Wz("commands", pJ),
      c4("launch", s4("type", {
        contextformbutton: m4,
        contextformtogglebutton: p4
      }))
    ].concat(Kz));
    const hJ = (e) => {
      const n = e.ui.registry.getAll().popups, s = Yr(n, (E) => mJ(E).fold((N) => {
        throw new Error(Lz(N));
      }, _n)), l = Pd(gc(s, (E) => E.trigger)), f = Xl(s);
      return {
        dataset: s,
        triggers: l,
        lookupByTrigger: (E) => ht(f, (N) => N.trigger === E)
      };
    }, gJ = (e, n) => {
      const s = n0(n.load, 50);
      e.on("keypress compositionend", (l) => {
        l.which !== 27 && s.throttle();
      }), e.on("keydown", (l) => {
        const f = l.which;
        f === 8 ? s.throttle() : f === 27 && n.cancelIfNecessary();
      }), e.on("remove", s.cancel);
    }, vJ = (e) => {
      const n = Kh(), s = wa(!1), l = n.isSet, f = () => {
        l() && ($K(e), G_(e), s.set(!1), n.clear());
      }, b = (U) => {
        l() || (DK(e, U.range), n.set({
          trigger: U.trigger,
          matchLength: U.text.length
        }));
      }, E = Qu(() => hJ(e)), N = (U) => n.get().map((J) => $T(e.dom, e.selection.getRng(), J.trigger).bind((te) => _z(e, E, te, U))).getOrThunk(() => RX(e, E)), D = (U) => {
        N(U).fold(f, (J) => {
          b(J.context), J.lookupData.then((te) => {
            n.get().map((ce) => {
              const Oe = J.context;
              ce.trigger === Oe.trigger && (Oe.text.length - ce.matchLength >= 10 ? f() : (n.set({
                ...ce,
                matchLength: Oe.text.length
              }), s.get() ? hN(e, { lookupData: te }) : (s.set(!0), q_(e, { lookupData: te }))));
            });
          });
        });
      };
      e.addCommand("mceAutocompleterReload", (U, J) => {
        const te = me(J) ? J.fetchOptions : {};
        D(te);
      }), e.addCommand("mceAutocompleterClose", f), gJ(e, {
        cancelIfNecessary: f,
        load: D
      });
    }, Xz = Lr().browser.isSafari(), Jz = (e) => vf(Fe.fromDom(e)), h4 = (e, n) => {
      var s;
      return e.startOffset === 0 && e.endOffset === ((s = n.textContent) === null || s === void 0 ? void 0 : s.length);
    }, TP = (e, n) => oe.from(e.getParent(n.container(), "details")), _P = (e, n) => TP(e, n).isSome(), bJ = (e, n) => {
      const s = oe.from(e.getParent(n.startContainer, "details")), l = oe.from(e.getParent(n.endContainer, "details"));
      if (s.isSome() || l.isSome()) {
        const f = s.bind((b) => oe.from(e.select("summary", b)[0]));
        return oe.some({
          startSummary: f,
          startDetails: s,
          endDetails: l
        });
      } else
        return oe.none();
    }, yJ = (e, n) => Wu(n).exists((s) => s.isEqual(e)), SJ = (e, n) => np(n).exists((s) => Mo(s.getNode()) && gd(n, s).exists((l) => l.isEqual(e)) || s.isEqual(e)), wJ = (e, n) => n.startSummary.exists((s) => yJ(e, s)), EJ = (e, n) => n.startSummary.exists((s) => SJ(e, s)), eV = (e, n) => n.startDetails.exists((s) => gd(s, e).forall((l) => n.startSummary.exists((f) => !f.contains(e.container()) && f.contains(l.container())))), g4 = (e, n, s) => s.startDetails.exists((l) => yu(e, n).forall((f) => !l.contains(f.container()))), v4 = (e, n) => {
      const s = n.getNode();
      Le(s) || e.selection.setCursorLocation(s, n.offset());
    }, b4 = (e, n, s) => {
      const l = e.dom.getParent(n.container(), "details");
      if (l && !l.open) {
        const f = e.dom.select("summary", l)[0];
        f && (s ? Wu(f) : np(f)).each((E) => v4(e, E));
      } else
        v4(e, n);
    }, CJ = (e, n) => {
      const s = (D) => D.contains(e.startContainer), l = (D) => D.contains(e.endContainer), f = n.startSummary.exists(s), b = n.startSummary.exists(l), E = n.startDetails.forall((D) => n.endDetails.forall((U) => D !== U));
      return (f || b) && !(f && b) || E;
    }, tV = (e, n, s) => {
      const { dom: l, selection: f } = e, b = e.getBody();
      if (s === "character") {
        const E = yt.fromRangeStart(f.getRng()), N = l.getParent(E.container(), l.isBlock), D = TP(l, E), U = N && l.isEmpty(N), J = q(N == null ? void 0 : N.previousSibling), te = q(N == null ? void 0 : N.nextSibling);
        return U && (n ? te : J) && fv(!n, b, E).exists((Re) => _P(l, Re) && !Dm(D, TP(l, Re))) ? !0 : fv(n, b, E).fold(He, (ce) => {
          const Oe = TP(l, ce);
          if (_P(l, ce) && !Dm(D, Oe)) {
            if (n || b4(e, ce, !1), N && U) {
              if (n && J)
                return !0;
              if (!n && te)
                return !0;
              b4(e, ce, n), e.dom.remove(N);
            }
            return !0;
          } else
            return !1;
        });
      } else
        return !1;
    }, xJ = (e, n, s, l) => {
      const b = e.selection.getRng(), E = yt.fromRangeStart(b), N = e.getBody();
      return l === "selection" ? CJ(b, n) : s ? EJ(E, n) || g4(N, E, n) : wJ(E, n) || eV(E, n);
    }, OP = (e, n, s) => bJ(e.dom, e.selection.getRng()).fold(() => tV(e, n, s), (l) => xJ(e, l, n, s) || tV(e, n, s)), nV = (e, n, s) => {
      const l = e.selection, f = l.getNode(), b = l.getRng(), E = yt.fromRangeStart(b);
      return $c(f) ? (s === "selection" && h4(b, f) || gM(n, E, f) ? Jz(f) : e.undoManager.transact(() => {
        const N = l.getSel();
        let { anchorNode: D, anchorOffset: U, focusNode: J, focusOffset: te } = N ?? {};
        const ce = () => {
          Ie(D) && Ie(U) && Ie(J) && Ie(te) && (N == null || N.setBaseAndExtent(D, U, J, te));
        }, Oe = () => {
          D = N == null ? void 0 : N.anchorNode, U = N == null ? void 0 : N.anchorOffset, J = N == null ? void 0 : N.focusNode, te = N == null ? void 0 : N.focusOffset;
        }, Re = (Pe, Ke) => {
          ke(Pe.childNodes, (et) => {
            tE(et) && Ke.appendChild(et);
          });
        }, xe = e.dom.create("span", { "data-mce-bogus": "1" });
        Re(f, xe), f.appendChild(xe), ce(), (s === "word" || s === "line") && (N == null || N.modify("extend", n ? "right" : "left", s)), !l.isCollapsed() && h4(l.getRng(), xe) ? Jz(f) : (e.execCommand(n ? "ForwardDelete" : "Delete"), Oe(), Re(xe, f), ce()), e.dom.remove(xe);
      }), !0) : !1;
    }, fS = (e, n, s) => OP(e, n, s) || Xz && nV(e, n, s) ? oe.some(Lt) : oe.none(), rV = (e) => (n, s, l = {}) => {
      const f = n.getBody(), b = {
        bubbles: !0,
        composed: !0,
        data: null,
        isComposing: !1,
        detail: 0,
        view: null,
        target: f,
        currentTarget: f,
        eventPhase: Event.AT_TARGET,
        originalTarget: f,
        explicitOriginalTarget: f,
        isTrusted: !1,
        srcElement: f,
        cancelable: !1,
        preventDefault: Lt,
        inputType: s
      }, E = gb(new InputEvent(e));
      return n.dispatch(e, {
        ...E,
        ...b,
        ...l
      });
    }, lA = rV("input"), y4 = rV("beforeinput"), TJ = Lr(), _J = TJ.os, oV = _J.isMacOS() || _J.isiOS(), OJ = TJ.browser.isFirefox(), AJ = (e, n, s) => {
      const l = s.keyCode === zn.BACKSPACE ? "deleteContentBackward" : "deleteContentForward", f = e.selection.isCollapsed(), b = f ? "character" : "selection", E = (N) => f ? N ? "word" : "line" : "selection";
      G3([
        {
          keyCode: zn.BACKSPACE,
          action: Tr(W7, e)
        },
        {
          keyCode: zn.BACKSPACE,
          action: Tr(zO, e, !1)
        },
        {
          keyCode: zn.DELETE,
          action: Tr(zO, e, !0)
        },
        {
          keyCode: zn.BACKSPACE,
          action: Tr(m3, e, !1)
        },
        {
          keyCode: zn.DELETE,
          action: Tr(m3, e, !0)
        },
        {
          keyCode: zn.BACKSPACE,
          action: Tr(cP, e, n, !1)
        },
        {
          keyCode: zn.DELETE,
          action: Tr(cP, e, n, !0)
        },
        {
          keyCode: zn.BACKSPACE,
          action: Tr(GN, e, !1)
        },
        {
          keyCode: zn.DELETE,
          action: Tr(GN, e, !0)
        },
        {
          keyCode: zn.BACKSPACE,
          action: Tr(fS, e, !1, b)
        },
        {
          keyCode: zn.DELETE,
          action: Tr(fS, e, !0, b)
        },
        ...oV ? [
          {
            keyCode: zn.BACKSPACE,
            altKey: !0,
            action: Tr(fS, e, !1, E(!0))
          },
          {
            keyCode: zn.DELETE,
            altKey: !0,
            action: Tr(fS, e, !0, E(!0))
          },
          {
            keyCode: zn.BACKSPACE,
            metaKey: !0,
            action: Tr(fS, e, !1, E(!1))
          }
        ] : [
          {
            keyCode: zn.BACKSPACE,
            ctrlKey: !0,
            action: Tr(fS, e, !1, E(!0))
          },
          {
            keyCode: zn.DELETE,
            ctrlKey: !0,
            action: Tr(fS, e, !0, E(!0))
          }
        ],
        {
          keyCode: zn.BACKSPACE,
          action: Tr(g3, e, !1)
        },
        {
          keyCode: zn.DELETE,
          action: Tr(g3, e, !0)
        },
        {
          keyCode: zn.BACKSPACE,
          action: Tr(L3, e, !1)
        },
        {
          keyCode: zn.DELETE,
          action: Tr(L3, e, !0)
        },
        {
          keyCode: zn.BACKSPACE,
          action: Tr(QR, e, !1)
        },
        {
          keyCode: zn.DELETE,
          action: Tr(QR, e, !0)
        },
        {
          keyCode: zn.BACKSPACE,
          action: Tr(d3, e, !1)
        },
        {
          keyCode: zn.DELETE,
          action: Tr(d3, e, !0)
        },
        {
          keyCode: zn.BACKSPACE,
          action: Tr(M3, e, !1)
        },
        {
          keyCode: zn.DELETE,
          action: Tr(M3, e, !0)
        }
      ], s).filter((N) => e.selection.isEditable()).each((N) => {
        s.preventDefault(), y4(e, l).isDefaultPrevented() || (N(), lA(e, l));
      });
    }, rle = (e, n, s) => PT([
      {
        keyCode: zn.BACKSPACE,
        action: Tr(s7, e)
      },
      {
        keyCode: zn.DELETE,
        action: Tr(s7, e)
      },
      ...oV ? [
        {
          keyCode: zn.BACKSPACE,
          altKey: !0,
          action: Tr(GO, e)
        },
        {
          keyCode: zn.DELETE,
          altKey: !0,
          action: Tr(GO, e)
        },
        ...s ? [{
          keyCode: OJ ? 224 : 91,
          action: Tr(GO, e)
        }] : []
      ] : [
        {
          keyCode: zn.BACKSPACE,
          ctrlKey: !0,
          action: Tr(GO, e)
        },
        {
          keyCode: zn.DELETE,
          ctrlKey: !0,
          action: Tr(GO, e)
        }
      ]
    ], n), kJ = (e, n) => {
      let s = !1;
      e.on("keydown", (l) => {
        s = l.keyCode === zn.BACKSPACE, l.isDefaultPrevented() || AJ(e, n, l);
      }), e.on("keyup", (l) => {
        l.isDefaultPrevented() || rle(e, l, s), s = !1;
      });
    }, Oi = (e) => {
      for (; e; ) {
        if (Un(e) || Qt(e) && e.data && /[\r\n\s]/.test(e.data))
          return e;
        e = e.nextSibling;
      }
      return null;
    }, mS = (e, n) => {
      const s = e.dom, l = e.schema.getMoveCaretBeforeOnEnterElements();
      if (!n)
        return;
      if (/^(LI|DT|DD)$/.test(n.nodeName)) {
        const b = Oi(n.firstChild);
        b && /^(UL|OL|DL)$/.test(b.nodeName) && n.insertBefore(s.doc.createTextNode(xo), n.firstChild);
      }
      const f = s.createRng();
      if (n.normalize(), n.hasChildNodes()) {
        const b = new xs(n, n);
        let E = n, N;
        for (; N = b.current(); ) {
          if (Qt(N)) {
            f.setStart(N, 0), f.setEnd(N, 0);
            break;
          }
          if (l[N.nodeName.toLowerCase()]) {
            f.setStartBefore(N), f.setEndBefore(N);
            break;
          }
          E = N, N = b.next();
        }
        N || (f.setStart(E, 0), f.setEnd(E, 0));
      } else
        Mo(n) ? n.nextSibling && s.isBlock(n.nextSibling) ? (f.setStartBefore(n), f.setEndBefore(n)) : (f.setStartAfter(n), f.setEndAfter(n)) : (f.setStart(n, 0), f.setEnd(n, 0));
      e.selection.setRng(f), bE(e, f);
    }, up = (e, n) => {
      const s = e.getRoot();
      let l, f = n;
      for (; f !== s && f && e.getContentEditable(f) !== "false"; ) {
        if (e.getContentEditable(f) === "true") {
          l = f;
          break;
        }
        f = f.parentNode;
      }
      return f !== s ? l : s;
    }, AP = (e) => oe.from(e.dom.getParent(e.selection.getStart(!0), e.dom.isBlock)), sV = (e) => AP(e).fold(at(""), (n) => n.nodeName.toUpperCase()), NJ = (e) => AP(e).filter((n) => Fu(Fe.fromDom(n))).isSome(), LT = (e) => {
      e.innerHTML = '<br data-mce-bogus="1">';
    }, S4 = (e, n, s) => {
      const l = e.dom;
      oe.from(s.style).map(l.parseStyle).each((D) => {
        const J = {
          ...rd(Fe.fromDom(n)),
          ...D
        };
        l.setStyles(n, J);
      });
      const f = oe.from(s.class).map((D) => D.split(/\s+/)), b = oe.from(n.className).map((D) => ht(D.split(/\s+/), (U) => U !== ""));
      bs(f, b, (D, U) => {
        const J = ht(U, (ce) => !Ge(D, ce)), te = [
          ...D,
          ...J
        ];
        l.setAttrib(n, "class", te.join(" "));
      });
      const E = [
        "style",
        "class"
      ], N = es(s, (D, U) => !Ge(E, U));
      l.setAttribs(n, N);
    }, BT = (e, n) => {
      if (al(e).toLowerCase() === n.tagName.toLowerCase()) {
        const l = ng(e);
        S4(e, n, l);
      }
    }, w4 = (e, n, s, l, f = !0, b, E) => {
      const N = e.dom, D = e.schema, U = al(e), J = s ? s.nodeName.toUpperCase() : "";
      let te = n;
      const ce = D.getTextInlineElements();
      let Oe;
      b || J === "TABLE" || J === "HR" ? Oe = N.create(b || U, E || {}) : Oe = s.cloneNode(!1);
      let Re = Oe;
      if (!f)
        N.setAttrib(Oe, "style", null), N.setAttrib(Oe, "class", null);
      else
        do
          if (ce[te.nodeName]) {
            if (Rf(te) || Pf(te))
              continue;
            const xe = te.cloneNode(!1);
            N.setAttrib(xe, "id", ""), Oe.hasChildNodes() ? (xe.appendChild(Oe.firstChild), Oe.appendChild(xe)) : (Re = xe, Oe.appendChild(xe));
          }
        while ((te = te.parentNode) && te !== l);
      return BT(e, Oe), LT(Re), Oe;
    }, RJ = (e, n) => e.dom.getParent(n, Mt), PJ = (e, n, s) => {
      let l = n;
      for (; l && l !== e && q(l.nextSibling); ) {
        const f = l.parentElement;
        if (!f || !s(f))
          return Mt(f);
        l = f;
      }
      return !1;
    }, DJ = (e, n, s) => !n && s.nodeName.toLowerCase() === al(e) && e.dom.isEmpty(s) && PJ(e.getBody(), s, (l) => lr(e.schema.getTextBlockElements(), l.nodeName.toLowerCase())), $J = (e, n, s) => {
      var l, f, b;
      const E = n(al(e)), N = RJ(e, s);
      N && (e.dom.insertAfter(E, N), mS(e, E), ((b = (f = (l = s.parentElement) === null || l === void 0 ? void 0 : l.childNodes) === null || f === void 0 ? void 0 : f.length) !== null && b !== void 0 ? b : 0) > 1 && e.dom.remove(s));
    }, IJ = (e, n) => e.firstChild && e.firstChild.nodeName === n, aV = (e) => {
      var n;
      return ((n = e.parentNode) === null || n === void 0 ? void 0 : n.firstChild) === e;
    }, iV = (e, n) => {
      const s = e == null ? void 0 : e.parentNode;
      return Ie(s) && s.nodeName === n;
    }, cV = (e) => Ie(e) && /^(OL|UL|LI)$/.test(e.nodeName), E4 = (e) => Ie(e) && /^(LI|DT|DD)$/.test(e.nodeName), MJ = (e) => cV(e) && cV(e.parentNode), kP = (e) => {
      const n = e.parentNode;
      return E4(n) ? n : e;
    }, uA = (e, n, s) => {
      let l = e[s ? "firstChild" : "lastChild"];
      for (; l && !Un(l); )
        l = l[s ? "nextSibling" : "previousSibling"];
      return l === n;
    }, C4 = (e) => Ye(gc(rd(Fe.fromDom(e)), (n, s) => `${s}: ${n};`), (n, s) => n + s, ""), FJ = (e, n, s, l, f) => {
      const b = e.dom, E = e.selection.getRng(), N = s.parentNode;
      if (s === e.getBody() || !N)
        return;
      MJ(s) && (f = "LI");
      const D = E4(l) ? C4(l) : void 0;
      let U = E4(l) && D ? n(f, { style: C4(l) }) : n(f);
      if (uA(s, l, !0) && uA(s, l, !1))
        if (iV(s, "LI")) {
          const J = kP(s);
          b.insertAfter(U, J), aV(s) ? b.remove(J) : b.remove(s);
        } else
          b.replace(U, s);
      else if (uA(s, l, !0))
        iV(s, "LI") ? (b.insertAfter(U, kP(s)), U.appendChild(b.doc.createTextNode(" ")), U.appendChild(s)) : N.insertBefore(U, s), b.remove(l);
      else if (uA(s, l, !1))
        b.insertAfter(U, kP(s)), b.remove(l);
      else {
        s = kP(s);
        const J = E.cloneRange();
        J.setStartAfter(l), J.setEndAfter(s);
        const te = J.extractContents();
        if (f === "LI" && IJ(te, "LI")) {
          const ce = ht(St(U.children, Fe.fromDom), vt(Fl("br")));
          U = te.firstChild, b.insertAfter(te, s), ke(ce, (Oe) => od(Fe.fromDom(U), Oe)), D && U.setAttribute("style", D);
        } else
          b.insertAfter(te, s), b.insertAfter(U, s);
        b.remove(l);
      }
      mS(e, U);
    }, LJ = (e) => {
      ke(Ld(Fe.fromDom(e), hi), (n) => {
        const s = n.dom;
        s.nodeValue = de(s.data);
      });
    }, ole = (e, n) => {
      const s = e.dom.getParent(n, "ol,ul,dl");
      return s !== null && e.dom.getContentEditableParent(s) === "false";
    }, x4 = (e, n) => n && n.nodeName === "A" && e.isEmpty(n), T4 = (e, n) => e.nodeName === n || e.previousSibling && e.previousSibling.nodeName === n, _4 = (e, n) => Ie(n) && e.isBlock(n) && !/^(TD|TH|CAPTION|FORM)$/.test(n.nodeName) && !/^(fixed|absolute)/i.test(n.style.position) && e.isEditable(n.parentNode) && e.getContentEditable(n) !== "false", BJ = (e, n, s) => {
      var l;
      const f = [];
      if (!s)
        return;
      let b = s;
      for (; b = b.firstChild; ) {
        if (e.isBlock(b))
          return;
        Un(b) && !n[b.nodeName.toLowerCase()] && f.push(b);
      }
      let E = f.length;
      for (; E--; )
        b = f[E], (!b.hasChildNodes() || b.firstChild === b.lastChild && ((l = b.firstChild) === null || l === void 0 ? void 0 : l.nodeValue) === "" || x4(e, b)) && e.remove(b);
    }, NP = (e, n, s) => Qt(n) ? e ? s === 1 && n.data.charAt(s - 1) === M ? 0 : s : s === n.data.length - 1 && n.data.charAt(s) === M ? n.data.length : s : s, HJ = (e) => {
      const n = e.cloneRange();
      return n.setStart(e.startContainer, NP(!0, e.startContainer, e.startOffset)), n.setEnd(e.endContainer, NP(!1, e.endContainer, e.endOffset)), n;
    }, lV = (e) => {
      let n = e;
      do
        Qt(n) && (n.data = n.data.replace(/^[\r\n]+/, "")), n = n.firstChild;
      while (n);
    }, zJ = (e, n, s, l, f) => {
      var b, E;
      const N = e.dom, D = (b = up(N, l)) !== null && b !== void 0 ? b : N.getRoot();
      let U = N.getParent(l, N.isBlock);
      if (!U || !_4(N, U)) {
        if (U = U || D, !U.hasChildNodes()) {
          const Oe = N.create(n);
          return BT(e, Oe), U.appendChild(Oe), s.setStart(Oe, 0), s.setEnd(Oe, 0), Oe;
        }
        let J = l;
        for (; J && J.parentNode !== U; )
          J = J.parentNode;
        let te;
        for (; J && !N.isBlock(J); )
          te = J, J = J.previousSibling;
        const ce = (E = te == null ? void 0 : te.parentElement) === null || E === void 0 ? void 0 : E.nodeName;
        if (te && ce && e.schema.isValidChild(ce, n.toLowerCase())) {
          const Oe = te.parentNode, Re = N.create(n);
          for (BT(e, Re), Oe.insertBefore(Re, te), J = te; J && !N.isBlock(J); ) {
            const xe = J.nextSibling;
            Re.appendChild(J), J = xe;
          }
          s.setStart(l, f), s.setEnd(l, f);
        }
      }
      return l;
    }, VJ = (e, n) => {
      n.normalize();
      const s = n.lastChild;
      (!s || Un(s) && /^(left|right)$/gi.test(e.getStyle(s, "float", !0))) && e.add(n, "br");
    }, sle = (e, n) => {
      const s = dx(e);
      return je(n) ? !1 : G(s) ? Ge(rn.explode(s), n.nodeName.toLowerCase()) : s;
    }, uV = {
      insert: (e, n) => {
        let s, l, f, b, E = !1;
        const N = e.dom, D = e.schema, U = D.getNonEmptyElements(), J = e.selection.getRng(), te = al(e), ce = Fe.fromDom(J.startContainer), Oe = Du(ce, J.startOffset), Re = Oe.exists((Kt) => zs(Kt) && !Rr(Kt)), xe = J.collapsed && Re, Pe = (Kt, Mn) => w4(e, s, ln, Ht, n_(e), Kt, Mn), Ke = (Kt) => {
          const Mn = NP(Kt, s, l);
          if (Qt(s) && (Kt ? Mn > 0 : Mn < s.data.length))
            return !1;
          if (s.parentNode === ln && E && !Kt || Kt && Un(s) && s === ln.firstChild)
            return !0;
          if (T4(s, "TABLE") || T4(s, "HR"))
            return E && !Kt || !E && Kt;
          const rr = new xs(s, ln);
          Qt(s) && (Kt && Mn === 0 ? rr.prev() : !Kt && Mn === s.data.length && rr.next());
          let Fr;
          for (; Fr = rr.current(); ) {
            if (Un(Fr)) {
              if (!Fr.getAttribute("data-mce-bogus")) {
                const so = Fr.nodeName.toLowerCase();
                if (U[so] && so !== "br")
                  return !1;
              }
            } else if (Qt(Fr) && !Bp(Fr.data))
              return !1;
            Kt ? rr.prev() : rr.next();
          }
          return !0;
        }, et = () => {
          let Kt;
          return /^(H[1-6]|PRE|FIGURE)$/.test(f) && Dn !== "HGROUP" ? Kt = Pe(te) : Kt = Pe(), sle(e, b) && _4(N, b) && N.isEmpty(ln, void 0, { includeZwsp: !0 }) ? Kt = N.split(b, ln) : N.insertAfter(Kt, ln), mS(e, Kt), Kt;
        };
        V(N, J).each((Kt) => {
          J.setStart(Kt.startContainer, Kt.startOffset), J.setEnd(Kt.endContainer, Kt.endOffset);
        }), s = J.startContainer, l = J.startOffset;
        const rt = !!(n && n.shiftKey), dt = !!(n && n.ctrlKey);
        Un(s) && s.hasChildNodes() && !xe && (E = l > s.childNodes.length - 1, s = s.childNodes[Math.min(l, s.childNodes.length - 1)] || s, E && Qt(s) ? l = s.data.length : l = 0);
        const Ht = up(N, s);
        if (!Ht || ole(e, s))
          return;
        rt || (s = zJ(e, te, J, s, l));
        let ln = N.getParent(s, N.isBlock) || N.getRoot();
        b = Ie(ln == null ? void 0 : ln.parentNode) ? N.getParent(ln.parentNode, N.isBlock) : null, f = ln ? ln.nodeName.toUpperCase() : "";
        const Dn = b ? b.nodeName.toUpperCase() : "";
        if (Dn === "LI" && !dt) {
          const Kt = b;
          ln = Kt, b = Kt.parentNode, f = Dn;
        }
        if (Un(b) && DJ(e, rt, ln))
          return $J(e, Pe, ln);
        if (/^(LI|DT|DD)$/.test(f) && Un(b) && N.isEmpty(ln)) {
          FJ(e, Pe, b, ln, te);
          return;
        }
        if (!xe && (ln === e.getBody() || !_4(N, ln)))
          return;
        const Rt = ln.parentNode;
        let Tt;
        if (xe)
          Tt = Pe(te), Oe.fold(() => {
            Ys(ce, Fe.fromDom(Tt));
          }, (Kt) => {
            ba(Kt, Fe.fromDom(Tt));
          }), e.selection.setCursorLocation(Tt, 0);
        else if (tn(ln))
          Tt = Bd(ln), N.isEmpty(ln) && LT(ln), BT(e, Tt), mS(e, Tt);
        else if (Ke(!1))
          Tt = et();
        else if (Ke(!0) && Rt) {
          Tt = Rt.insertBefore(Pe(), ln);
          const Kt = Bm(Fe.fromDom(J.startContainer)) && J.collapsed;
          mS(e, T4(ln, "HR") || Kt ? Tt : ln);
        } else {
          const Kt = HJ(J).cloneRange();
          Kt.setEndAfter(ln);
          const Mn = Kt.extractContents();
          LJ(Mn), lV(Mn), Tt = Mn.firstChild, N.insertAfter(Mn, ln), BJ(N, U, Tt), VJ(N, ln), N.isEmpty(ln) && LT(ln), Tt.normalize(), N.isEmpty(Tt) ? (N.remove(Tt), et()) : (BT(e, Tt), mS(e, Tt));
        }
        N.setAttrib(Tt, "id", ""), e.dispatch("NewBlock", { newBlock: Tt });
      },
      fakeEventName: "insertParagraph"
    }, UJ = (e, n, s) => {
      const l = new xs(n, s);
      let f;
      const b = e.getNonEmptyElements();
      for (; f = l.next(); )
        if (b[f.nodeName.toLowerCase()] || Qt(f) && f.length > 0)
          return !0;
      return !1;
    }, dV = (e, n, s) => {
      const l = e.dom.createRng();
      s ? (l.setStartBefore(n), l.setEndBefore(n)) : (l.setStartAfter(n), l.setEndAfter(n)), e.selection.setRng(l), bE(e, l);
    }, WJ = (e, n) => {
      const s = e.selection, l = e.dom, f = s.getRng();
      let b, E = !1;
      V(l, f).each((Oe) => {
        f.setStart(Oe.startContainer, Oe.startOffset), f.setEnd(Oe.endContainer, Oe.endOffset);
      });
      let N = f.startOffset, D = f.startContainer;
      if (Un(D) && D.hasChildNodes()) {
        const Oe = N > D.childNodes.length - 1;
        D = D.childNodes[Math.min(N, D.childNodes.length - 1)] || D, Oe && Qt(D) ? N = D.data.length : N = 0;
      }
      let U = l.getParent(D, l.isBlock);
      const J = U && U.parentNode ? l.getParent(U.parentNode, l.isBlock) : null, te = J ? J.nodeName.toUpperCase() : "", ce = !!(n && n.ctrlKey);
      te === "LI" && !ce && (U = J), Qt(D) && N >= D.data.length && (UJ(e.schema, D, U || l.getRoot()) || (b = l.create("br"), f.insertNode(b), f.setStartAfter(b), f.setEndAfter(b), E = !0)), b = l.create("br"), Sw(l, f, b), dV(e, b, E), e.undoManager.add();
    }, jJ = (e, n) => {
      const s = Fe.fromTag("br");
      ba(Fe.fromDom(n), s), e.undoManager.add();
    }, qJ = (e, n) => {
      GJ(e.getBody(), n) || tl(Fe.fromDom(n), Fe.fromTag("br"));
      const s = Fe.fromTag("br");
      tl(Fe.fromDom(n), s), dV(e, s.dom, !1), e.undoManager.add();
    }, RP = (e) => Mo(e.getNode()), GJ = (e, n) => RP(yt.after(n)) ? !0 : yu(e, yt.after(n)).map((s) => Mo(s.getNode())).getOr(!1), fV = (e) => e && e.nodeName === "A" && "href" in e, O4 = (e) => e.fold(He, fV, fV, He), A4 = (e) => {
      const n = Ne(CE, e), s = yt.fromRangeStart(e.selection.getRng());
      return Zl(n, e.getBody(), s).filter(O4);
    }, ZJ = (e, n) => {
      n.fold(Lt, Ne(jJ, e), Ne(qJ, e), Lt);
    }, KJ = {
      insert: (e, n) => {
        const s = A4(e);
        s.isSome() ? s.each(Ne(ZJ, e)) : WJ(e, n);
      },
      fakeEventName: "insertLineBreak"
    }, mV = (e, n) => AP(e).filter((s) => n.length > 0 && Bl(Fe.fromDom(s), n)).isSome(), YJ = (e) => mV(e, t_(e)), ile = (e) => mV(e, Rw(e)), dp = hm.generate([
      { br: [] },
      { block: [] },
      { none: [] }
    ]), Nv = (e, n) => ile(e), pV = (e) => (n, s) => NJ(n) === e, k4 = (e, n) => (s, l) => sV(s) === e.toUpperCase() === n, QJ = (e) => {
      const n = up(e.dom, e.selection.getStart());
      return je(n);
    }, dA = (e) => k4("pre", e), XJ = () => k4("summary", !0), PP = (e) => (n, s) => J2(n) === e, JJ = (e, n) => YJ(e), DP = (e, n) => n, eee = (e) => {
      const n = al(e), s = up(e.dom, e.selection.getStart());
      return Ie(s) && e.schema.isValidChild(s.nodeName, n);
    }, N4 = (e) => {
      const n = e.selection.getRng(), s = Fe.fromDom(n.startContainer), f = Du(s, n.startOffset).map((b) => zs(b) && !Rr(b));
      return n.collapsed && f.getOr(!0);
    }, fp = (e, n) => (s, l) => Ye(e, (b, E) => b && E(s, l), !0) ? oe.some(n) : oe.none(), $P = (e, n) => u7([
      fp([Nv], dp.none()),
      fp([
        dA(!0),
        QJ
      ], dp.none()),
      fp([XJ()], dp.br()),
      fp([
        dA(!0),
        PP(!1),
        DP
      ], dp.br()),
      fp([
        dA(!0),
        PP(!1)
      ], dp.block()),
      fp([
        dA(!0),
        PP(!0),
        DP
      ], dp.block()),
      fp([
        dA(!0),
        PP(!0)
      ], dp.br()),
      fp([
        pV(!0),
        DP
      ], dp.br()),
      fp([pV(!0)], dp.block()),
      fp([JJ], dp.br()),
      fp([DP], dp.br()),
      fp([eee], dp.block()),
      fp([N4], dp.block())
    ], [
      e,
      !!(n && n.shiftKey)
    ]).getOr(dp.none()), IP = (e, n, s) => {
      n.selection.isCollapsed() || cO(n), !(Ie(s) && y4(n, e.fakeEventName).isDefaultPrevented()) && (e.insert(n, s), Ie(s) && lA(n, e.fakeEventName));
    }, hV = (e, n) => {
      const s = () => IP(KJ, e, n), l = () => IP(uV, e, n), f = $P(e, n);
      switch (e_(e)) {
        case "linebreak":
          f.fold(s, s, Lt);
          break;
        case "block":
          f.fold(l, l, Lt);
          break;
        case "invert":
          f.fold(l, s, Lt);
          break;
        default:
          f.fold(s, l, Lt);
          break;
      }
    }, gV = Lr(), tee = gV.os.isiOS() && gV.browser.isSafari(), vV = (e, n) => {
      n.isDefaultPrevented() || (n.preventDefault(), uK(e.undoManager), e.undoManager.transact(() => {
        hV(e, n);
      }));
    }, bV = (e) => {
      if (!e.collapsed)
        return !1;
      const n = e.startContainer;
      if (Qt(n)) {
        const s = /^[\uAC00-\uD7AF\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uD7B0-\uD7FF]$/, l = n.data.charAt(e.startOffset - 1);
        return s.test(l);
      } else
        return !1;
    }, nee = (e) => {
      let n = oe.none();
      const s = (f) => {
        n = oe.some(f.selection.getBookmark()), f.undoManager.add();
      }, l = (f, b) => {
        f.undoManager.undo(), n.fold(Lt, (E) => f.selection.moveToBookmark(E)), vV(f, b), n = oe.none();
      };
      e.on("keydown", (f) => {
        f.keyCode === zn.ENTER && (tee && bV(e.selection.getRng()) ? s(e) : vV(e, f));
      }), e.on("keyup", (f) => {
        f.keyCode === zn.ENTER && n.each(() => l(e, f));
      });
    }, yV = (e, n, s) => {
      const l = kn.os.isMacOS() || kn.os.isiOS();
      PT([
        {
          keyCode: zn.END,
          action: Tr(J7, e, !0)
        },
        {
          keyCode: zn.HOME,
          action: Tr(J7, e, !1)
        },
        ...l ? [] : [
          {
            keyCode: zn.HOME,
            action: Tr(mP, e, !1),
            ctrlKey: !0,
            shiftKey: !0
          },
          {
            keyCode: zn.END,
            action: Tr(mP, e, !0),
            ctrlKey: !0,
            shiftKey: !0
          }
        ],
        {
          keyCode: zn.END,
          action: Tr(hP, e, !0)
        },
        {
          keyCode: zn.HOME,
          action: Tr(hP, e, !1)
        },
        {
          keyCode: zn.END,
          action: Tr(iP, e, !0, n)
        },
        {
          keyCode: zn.HOME,
          action: Tr(iP, e, !1, n)
        }
      ], s).each((f) => {
        s.preventDefault();
      });
    }, SV = (e, n) => {
      e.on("keydown", (s) => {
        s.isDefaultPrevented() || yV(e, n, s);
      });
    }, ree = (e) => {
      e.on("input", (n) => {
        n.isComposing || kG(e);
      });
    }, oee = Lr(), R4 = (e, n, s) => {
      PT([
        {
          keyCode: zn.PAGE_UP,
          action: Tr(iP, e, !1, n)
        },
        {
          keyCode: zn.PAGE_DOWN,
          action: Tr(iP, e, !0, n)
        }
      ], s);
    }, wV = (e) => e.stopImmediatePropagation(), EV = (e) => e.keyCode === zn.PAGE_UP || e.keyCode === zn.PAGE_DOWN, fA = (e, n, s) => {
      s && !e.get() ? n.on("NodeChange", wV, !0) : !s && e.get() && n.off("NodeChange", wV), e.set(s);
    }, see = (e, n) => {
      if (oee.os.isMacOS())
        return;
      const s = wa(!1);
      e.on("keydown", (l) => {
        EV(l) && fA(s, e, !0);
      }), e.on("keyup", (l) => {
        l.isDefaultPrevented() || R4(e, n, l), EV(l) && s.get() && (fA(s, e, !1), e.nodeChanged());
      });
    }, P4 = (e) => {
      e.on("beforeinput", (n) => {
        (!e.selection.isEditable() || qt(n.getTargetRanges(), (s) => !E5(e.dom, s))) && n.preventDefault();
      });
    }, MP = (e, n) => {
      const s = n.container(), l = n.offset();
      return Qt(s) ? (s.insertData(l, e), oe.some(yt(s, l + e.length))) : xl(n).map((f) => {
        const b = Fe.fromText(e);
        return n.isAtEnd() ? tl(f, b) : ba(f, b), yt(b.dom, e.length);
      });
    }, D4 = Ne(MP, xo), CV = Ne(MP, " "), cle = (e, n, s) => J5(e, n, s) ? D4(n) : CV(n), pS = (e) => (n) => n.fold((s) => gd(e.dom, yt.before(s)), (s) => Wu(s), (s) => np(s), (s) => yu(e.dom, yt.after(s))), aee = (e, n, s) => (l) => J5(e, l, s) ? D4(n) : CV(n), xV = (e) => (n) => {
      e.selection.setRng(n.toRange()), e.nodeChanged();
    }, iee = (e, n) => e.isEditable(e.getParent(n, "summary")), FP = (e) => {
      const n = yt.fromRangeStart(e.selection.getRng()), s = Fe.fromDom(e.getBody());
      if (e.selection.isCollapsed()) {
        const l = Ne(CE, e), f = yt.fromRangeStart(e.selection.getRng());
        return Zl(l, e.getBody(), f).bind(pS(s)).map((b) => () => aee(s, n, e.schema)(b).each(xV(e)));
      } else
        return oe.none();
    }, TV = (e) => {
      const n = () => {
        const s = Fe.fromDom(e.getBody());
        e.selection.isCollapsed() || e.getDoc().execCommand("Delete");
        const l = yt.fromRangeStart(e.selection.getRng());
        cle(s, l, e.schema).each(xV(e));
      };
      return Ur(kn.browser.isFirefox() && e.selection.isEditable() && iee(e.dom, e.selection.getRng().startContainer), n);
    }, _V = (e, n) => {
      G3([
        {
          keyCode: zn.SPACEBAR,
          action: Tr(FP, e)
        },
        {
          keyCode: zn.SPACEBAR,
          action: Tr(TV, e)
        }
      ], n).each((s) => {
        n.preventDefault(), y4(e, "insertText", { data: " " }).isDefaultPrevented() || (s(), lA(e, "insertText", { data: " " }));
      });
    }, cee = (e) => {
      e.on("keydown", (n) => {
        n.isDefaultPrevented() || _V(e, n);
      });
    }, OV = (e) => jw(e) ? [
      {
        keyCode: zn.TAB,
        action: Tr(Sz, e, !0)
      },
      {
        keyCode: zn.TAB,
        shiftKey: !0,
        action: Tr(Sz, e, !1)
      }
    ] : [], lee = (e, n) => {
      PT([...OV(e)], n).each((s) => {
        n.preventDefault();
      });
    }, uee = (e) => {
      e.on("keydown", (n) => {
        n.isDefaultPrevented() || lee(e, n);
      });
    }, dee = (e) => {
      if (e.addShortcut("Meta+P", "", "mcePrint"), vJ(e), d1(e))
        return wa(null);
      {
        const n = _Q(e);
        return P4(e), XQ(e), AX(e, n), kJ(e, n), nee(e), cee(e), ree(e), uee(e), SV(e, n), see(e, n), n;
      }
    };
    class AV {
      constructor(n) {
        this.lastPath = [], this.editor = n;
        let s;
        const l = this;
        "onselectionchange" in n.getDoc() || n.on("NodeChange click mouseup keyup focus", (f) => {
          const b = n.selection.getRng(), E = {
            startContainer: b.startContainer,
            startOffset: b.startOffset,
            endContainer: b.endContainer,
            endOffset: b.endOffset
          };
          (f.type === "nodechange" || !Sv(E, s)) && n.dispatch("SelectionChange"), s = E;
        }), n.on("contextmenu", () => {
          n.dispatch("SelectionChange");
        }), n.on("SelectionChange", () => {
          const f = n.selection.getStart(!0);
          f && Vx(n) && !l.isSameElementPath(f) && n.dom.isChildOf(f, n.getBody()) && n.nodeChanged({ selectionChange: !0 });
        }), n.on("mouseup", (f) => {
          !f.isDefaultPrevented() && Vx(n) && (n.selection.getNode().nodeName === "IMG" ? sp.setEditorTimeout(n, () => {
            n.nodeChanged();
          }) : n.nodeChanged());
        });
      }
      nodeChanged(n = {}) {
        const s = this.editor.selection;
        let l;
        if (this.editor.initialized && s && !b0(this.editor) && !this.editor.mode.isReadOnly()) {
          const f = this.editor.getBody();
          l = s.getStart(!0) || f, (l.ownerDocument !== this.editor.getDoc() || !this.editor.dom.isChildOf(l, f)) && (l = f);
          const b = [];
          this.editor.dom.getParent(l, (E) => E === f ? !0 : (b.push(E), !1)), this.editor.dispatch("NodeChange", {
            ...n,
            element: l,
            parents: b
          });
        }
      }
      isSameElementPath(n) {
        let s;
        const l = this.editor, f = Xr(l.dom.getParents(n, ut, l.getBody()));
        if (f.length === this.lastPath.length) {
          for (s = f.length; s >= 0 && f[s] === this.lastPath[s]; s--)
            ;
          if (s === -1)
            return this.lastPath = f, !0;
        }
        return this.lastPath = f, !1;
      }
    }
    const LP = nv("image"), fee = (e) => {
      const n = e;
      return oe.from(n[LP]);
    }, $4 = (e, n) => {
      const s = e;
      s[LP] = n;
    }, BP = nv("event"), HP = (e) => {
      const n = e;
      return oe.from(n[BP]);
    }, mA = (e) => (n) => {
      const s = n;
      s[BP] = e;
    }, kV = (e, n) => mA(n)(e), NV = mA(0), mee = mA(2), zP = mA(1), hee = ((e) => (n) => {
      const s = n;
      return oe.from(s[BP]).exists((l) => l === e);
    })(0), gee = () => Object.freeze({
      length: 0,
      item: (e) => null
    }), VP = nv("mode"), vee = (e) => {
      const n = e;
      return oe.from(n[VP]);
    }, UP = (e) => (n) => {
      const s = n;
      s[VP] = e;
    }, RV = (e, n) => UP(n)(e), PV = UP(0), I4 = UP(2), DV = UP(1), $V = (e) => (n) => {
      const s = n;
      return oe.from(s[VP]).exists((l) => l === e);
    }, HE = $V(0), IV = $V(1), bee = (e, n) => ({
      ...n,
      get length() {
        return n.length;
      },
      add: (s, l) => {
        if (HE(e))
          if (G(s)) {
            if (!Le(l))
              return n.add(s, l);
          } else
            return n.add(s);
        return null;
      },
      remove: (s) => {
        HE(e) && n.remove(s);
      },
      clear: () => {
        HE(e) && n.clear();
      }
    }), yee = [
      "none",
      "copy",
      "link",
      "move"
    ], See = [
      "none",
      "copy",
      "copyLink",
      "copyMove",
      "link",
      "linkMove",
      "move",
      "all",
      "uninitialized"
    ], M4 = () => {
      const e = new window.DataTransfer();
      let n = "move", s = "all";
      const l = {
        get dropEffect() {
          return n;
        },
        set dropEffect(f) {
          Ge(yee, f) && (n = f);
        },
        get effectAllowed() {
          return s;
        },
        set effectAllowed(f) {
          hee(l) && Ge(See, f) && (s = f);
        },
        get items() {
          return bee(l, e.items);
        },
        get files() {
          return IV(l) ? gee() : e.files;
        },
        get types() {
          return e.types;
        },
        setDragImage: (f, b, E) => {
          HE(l) && ($4(l, {
            image: f,
            x: b,
            y: E
          }), e.setDragImage(f, b, E));
        },
        getData: (f) => IV(l) ? "" : e.getData(f),
        setData: (f, b) => {
          HE(l) && e.setData(f, b);
        },
        clearData: (f) => {
          HE(l) && e.clearData(f);
        }
      };
      return PV(l), l;
    }, HT = (e) => {
      const n = M4(), s = vee(e);
      return I4(e), NV(n), n.dropEffect = e.dropEffect, n.effectAllowed = e.effectAllowed, fee(e).each((l) => n.setDragImage(l.image, l.x, l.y)), ke(e.types, (l) => {
        l !== "Files" && n.setData(l, e.getData(l));
      }), ke(e.files, (l) => n.items.add(l)), HP(e).each((l) => {
        kV(n, l);
      }), s.each((l) => {
        RV(e, l), RV(n, l);
      }), n;
    }, wee = (e) => {
      const n = e.getData("text/html");
      return n === "" ? oe.none() : oe.some(n);
    }, MV = (e, n) => e.setData("text/html", n), F4 = "x-tinymce/html", WP = at(F4), L4 = "<!-- " + F4 + " -->", Eee = (e) => L4 + e, FV = (e) => e.replace(L4, ""), LV = (e) => e.indexOf(L4) !== -1, Cee = (e) => !/<(?:\/?(?!(?:div|p|br|span)>)\w+|(?:(?!(?:span style="white-space:\s?pre;?">)|br\s?\/>))\w+\s[^>]+)>/i.test(e), lle = (e, n) => {
      let s = "<" + e;
      const l = gc(n, (f, b) => b + '="' + Yg.encodeAllRaw(f) + '"');
      return l.length && (s += " " + l.join(" ")), s + ">";
    }, jP = (e, n, s) => {
      const l = e.split(/\n\n/), f = lle(n, s), b = "</" + n + ">", E = St(l, (D) => D.split(/\n/).join("<br />")), N = (D) => f + D + b;
      return E.length === 1 ? E[0] : St(E, N).join("");
    }, BV = "%MCEPASTEBIN%", xee = (e, n) => {
      const { dom: s, selection: l } = e, f = e.getBody();
      n.set(l.getRng());
      const b = s.add(e.getBody(), "div", {
        id: "mcepastebin",
        class: "mce-pastebin",
        contentEditable: !0,
        "data-mce-bogus": "all",
        style: "position: fixed; top: 50%; width: 10px; height: 10px; overflow: hidden; opacity: 0"
      }, BV);
      kn.browser.isFirefox() && s.setStyle(b, "left", s.getStyle(f, "direction", !0) === "rtl" ? 65535 : -65535), s.bind(b, "beforedeactivate focusin focusout", (E) => {
        E.stopPropagation();
      }), b.focus(), l.select(b, !0);
    }, Tee = (e, n) => {
      const s = e.dom;
      if (B4(e)) {
        let l;
        const f = n.get();
        for (; l = B4(e); )
          s.remove(l), s.unbind(l);
        f && e.selection.setRng(f);
      }
      n.set(null);
    }, B4 = (e) => e.dom.get("mcepastebin"), _ee = (e) => Ie(e) && e.id === "mcepastebin", Oee = (e) => {
      const n = e.dom, s = (E, N) => {
        E.appendChild(N), n.remove(N, !0);
      }, [l, ...f] = ht(e.getBody().childNodes, _ee);
      ke(f, (E) => {
        s(l, E);
      });
      const b = n.select("div[id=mcepastebin]", l);
      for (let E = b.length - 1; E >= 0; E--) {
        const N = n.create("div");
        l.insertBefore(N, b[E]), s(N, b[E]);
      }
      return l ? l.innerHTML : "";
    }, HV = (e) => e === BV, Aee = (e) => {
      const n = wa(null);
      return {
        create: () => xee(e, n),
        remove: () => Tee(e, n),
        getEl: () => B4(e),
        getHtml: () => Oee(e),
        getLastRng: n.get
      };
    }, zV = (e, n) => (rn.each(n, (s) => {
      ue(s, RegExp) ? e = e.replace(s, "") : e = e.replace(s[0], s[1]);
    }), e), kee = (e) => {
      const n = jm(), s = hg({}, n);
      let l = "";
      const f = n.getVoidElements(), b = rn.makeMap("script noscript style textarea video audio iframe object", " "), E = n.getBlockElements(), N = (D) => {
        const U = D.name, J = D;
        if (U === "br") {
          l += `
`;
          return;
        }
        if (U !== "wbr") {
          if (f[U] && (l += " "), b[U]) {
            l += " ";
            return;
          }
          if (D.type === 3 && (l += D.value), !(D.name in n.getVoidElements())) {
            let te = D.firstChild;
            if (te)
              do
                N(te);
              while (te = te.next);
          }
          E[U] && J.next && (l += `
`, U === "p" && (l += `
`));
        }
      };
      return e = zV(e, [/<!\[[^\]]+\]>/g]), N(s.parse(e)), l;
    }, VV = (e) => (e = zV(e, [
      /^[\s\S]*<body[^>]*>\s*|\s*<\/body[^>]*>[\s\S]*$/ig,
      /<!--StartFragment-->|<!--EndFragment-->/g,
      [
        /( ?)<span class="Apple-converted-space">\u00a0<\/span>( ?)/g,
        (s, l, f) => !l && !f ? " " : xo
      ],
      /<br class="Apple-interchange-newline">/g,
      /<br>$/i
    ]), e), Nee = (e) => {
      let n = 0;
      return () => e + n++;
    }, Ree = (e) => {
      const n = e.toLowerCase(), s = {
        jpg: "jpeg",
        jpe: "jpeg",
        jfi: "jpeg",
        jif: "jpeg",
        jfif: "jpeg",
        pjpeg: "jpeg",
        pjp: "jpeg",
        svg: "svg+xml"
      };
      return rn.hasOwn(s, n) ? "image/" + s[n] : "image/" + n;
    }, Qs = (e, n) => {
      const s = hg({
        sanitize: og(e),
        sandbox_iframes: T0(e)
      }, e.schema);
      s.addNodeFilter("meta", (f) => {
        rn.each(f, (b) => {
          b.remove();
        });
      });
      const l = s.parse(n, {
        forced_root_block: !1,
        isRootContent: !0
      });
      return j0({ validate: !0 }, e.schema).serialize(l);
    }, UV = (e, n) => ({
      content: e,
      cancelled: n
    }), WV = (e, n, s) => {
      const l = e.dom.create("div", { style: "display:none" }, n), f = II(e, l, s);
      return UV(f.node.innerHTML, f.isDefaultPrevented());
    }, Pee = (e, n, s) => {
      const l = $I(e, n, s), f = Qs(e, l.content);
      return e.hasEventListeners("PastePostProcess") && !l.isDefaultPrevented() ? WV(e, f, s) : UV(f, l.isDefaultPrevented());
    }, H4 = (e, n, s) => Pee(e, n, s), qP = (e, n) => (e.insertContent(n, {
      merge: zw(e),
      paste: !0
    }), !0), z4 = (e) => /^https?:\/\/[\w\-\/+=.,!;:&%@^~(){}?#]+$/i.test(e), Dee = (e, n) => z4(n) && qt(Ox(e), (s) => Ac(n.toLowerCase(), `.${s.toLowerCase()}`)), jV = (e, n, s) => (e.undoManager.extra(() => {
      s(e, n);
    }, () => {
      e.insertContent('<img src="' + n + '">');
    }), !0), V4 = (e, n, s) => (e.undoManager.extra(() => {
      s(e, n);
    }, () => {
      e.execCommand("mceInsertLink", !1, n);
    }), !0), $ee = (e, n, s) => !e.selection.isCollapsed() && z4(n) ? V4(e, n, s) : !1, Iee = (e, n, s) => Dee(e, n) ? jV(e, n, s) : !1, Mee = (e, n) => {
      rn.each([
        $ee,
        Iee,
        qP
      ], (s) => !s(e, n, qP));
    }, qV = (e, n, s) => {
      s || !w0(e) ? qP(e, n) : Mee(e, n);
    }, Fee = Nee("mceclip"), Lee = (e) => {
      const n = M4();
      return MV(n, e), I4(n), n;
    }, zE = (e, n, s, l, f) => {
      const b = H4(e, n, s);
      if (!b.cancelled) {
        const E = b.content, N = () => qV(e, E, l);
        f ? y4(e, "insertFromPaste", { dataTransfer: Lee(E) }).isDefaultPrevented() || (N(), lA(e, "insertFromPaste")) : N();
      }
    }, GP = (e, n, s, l) => {
      const f = s || LV(n);
      zE(e, FV(n), f, !1, l);
    }, hS = (e, n, s) => {
      const l = e.dom.encode(n).replace(/\r\n/g, `
`), f = Hp(l, Tx(e)), b = jP(f, al(e), ng(e));
      zE(e, b, !1, !0, s);
    }, zT = (e) => {
      const n = {};
      if (e && e.types)
        for (let s = 0; s < e.types.length; s++) {
          const l = e.types[s];
          try {
            n[l] = e.getData(l);
          } catch {
            n[l] = "";
          }
        }
      return n;
    }, gS = (e, n) => n in e && e[n].length > 0, GV = (e) => gS(e, "text/html") || gS(e, "text/plain"), VT = (e, n) => {
      const s = n.match(/([\s\S]+?)(?:\.[a-z0-9.]+)$/i);
      return Ie(s) ? e.dom.encode(s[1]) : void 0;
    }, Bee = (e, n, s, l) => {
      const f = Fee(), b = Vy(e) && Ie(s.name), E = b ? VT(e, s.name) : f, N = b ? s.name : void 0, D = n.create(f, s, l, E, N);
      return n.add(D), D;
    }, U4 = (e, n) => {
      EO(n.uri).each(({ data: s, type: l, base64Encoded: f }) => {
        const b = f ? s : btoa(s), E = n.file, N = e.editorUpload.blobCache, D = N.getByData(b, l), U = D ?? Bee(e, N, E, b);
        GP(e, `<img src="${U.blobUri()}">`, !1, !0);
      });
    }, Hee = (e) => e.type === "paste", ZV = (e) => Promise.all(St(e, (n) => cF(n).then((s) => ({
      file: n,
      uri: s
    })))), KV = (e) => {
      const n = Ox(e);
      return (s) => Gs(s.type, "image/") && qt(n, (l) => Ree(l) === s.type);
    }, W4 = (e, n) => {
      const s = n.items ? gr(Ps(n.items), (f) => f.kind === "file" ? [f.getAsFile()] : []) : [], l = n.files ? Ps(n.files) : [];
      return ht(s.length > 0 ? s : l, KV(e));
    }, j4 = (e, n, s) => {
      const l = Hee(n) ? n.clipboardData : n.dataTransfer;
      if (S0(e) && l) {
        const f = W4(e, l);
        if (f.length > 0)
          return n.preventDefault(), ZV(f).then((b) => {
            s && e.selection.setRng(s), ke(b, (E) => {
              U4(e, E);
            });
          }), !0;
      }
      return !1;
    }, zee = (e) => {
      var n, s;
      return kn.os.isAndroid() && ((s = (n = e.clipboardData) === null || n === void 0 ? void 0 : n.items) === null || s === void 0 ? void 0 : s.length) === 0;
    }, Vee = (e) => zn.metaKeyPressed(e) && e.keyCode === 86 || e.shiftKey && e.keyCode === 45, ZP = (e, n, s, l, f) => {
      let b = VV(s);
      const E = gS(n, WP()) || LV(s), N = !E && Cee(b), D = z4(b);
      (HV(b) || !b.length || N && !D) && (l = !0), (l || D) && (gS(n, "text/plain") && N ? b = n["text/plain"] : b = kee(b)), !HV(b) && (l ? hS(e, b, f) : GP(e, b, E, f));
    }, Uee = (e, n, s) => {
      let l;
      const f = () => n.getLastRng() || e.selection.getRng();
      e.on("keydown", (b) => {
        Vee(b) && !b.isDefaultPrevented() && (l = b.shiftKey && b.keyCode === 86);
      }), e.on("paste", (b) => {
        if (b.isDefaultPrevented() || zee(b))
          return;
        const E = s.get() === "text" || l;
        l = !1;
        const N = zT(b.clipboardData);
        !GV(N) && j4(e, b, f()) || (gS(N, "text/html") ? (b.preventDefault(), ZP(e, N, N["text/html"], E, !0)) : gS(N, "text/plain") && gS(N, "text/uri-list") ? (b.preventDefault(), ZP(e, N, N["text/plain"], E, !0)) : (n.create(), sp.setEditorTimeout(e, () => {
          const D = n.getHtml();
          n.remove(), ZP(e, N, D, E, !1);
        }, 0)));
      });
    }, YV = (e) => {
      const n = (f) => Gs(f, "webkit-fake-url"), s = (f) => Gs(f, "data:"), l = (f) => {
        var b;
        return ((b = f.data) === null || b === void 0 ? void 0 : b.paste) === !0;
      };
      e.parser.addNodeFilter("img", (f, b, E) => {
        if (!S0(e) && l(E))
          for (const N of f) {
            const D = N.attr("src");
            G(D) && !N.attr("data-mce-object") && D !== kn.transparentSrc && (n(D) || !C0(e) && s(D)) && N.remove();
          }
      });
    }, q4 = (e, n, s) => {
      Uee(e, n, s), YV(e);
    }, QV = (e, n) => {
      n.get() === "text" ? (n.set("html"), gN(e, !1)) : (n.set("text"), gN(e, !0)), e.focus();
    }, Wee = (e, n) => {
      e.addCommand("mceTogglePlainTextPaste", () => {
        QV(e, n);
      }), e.addCommand("mceInsertClipboardContent", (s, l) => {
        l.html && GP(e, l.html, l.internal, !1), l.text && hS(e, l.text, !1);
      });
    }, jee = (e, n, s) => {
      if (e)
        try {
          return e.clearData(), e.setData("text/html", n), e.setData("text/plain", s), e.setData(WP(), n), !0;
        } catch {
          return !1;
        }
      else
        return !1;
    }, XV = (e, n, s, l) => {
      jee(e.clipboardData, n.html, n.text) ? (e.preventDefault(), l()) : s(n.html, l);
    }, G4 = (e) => (n, s) => {
      const { dom: l, selection: f } = e, b = l.create("div", {
        contenteditable: "false",
        "data-mce-bogus": "all"
      }), E = l.create("div", { contenteditable: "true" }, n);
      l.setStyles(b, {
        position: "fixed",
        top: "0",
        left: "-3000px",
        width: "1000px",
        overflow: "hidden"
      }), b.appendChild(E), l.add(e.getBody(), b);
      const N = f.getRng();
      E.focus();
      const D = l.createRng();
      D.selectNodeContents(E), f.setRng(D), sp.setEditorTimeout(e, () => {
        f.setRng(N), l.remove(b), s();
      }, 0);
    }, KP = (e) => ({
      html: Eee(e.selection.getContent({ contextual: !0 })),
      text: e.selection.getContent({ format: "text" })
    }), qee = (e) => !!e.dom.getParent(e.selection.getStart(), "td[data-mce-selected],th[data-mce-selected]", e.getBody()), Z4 = (e) => !e.selection.isCollapsed() || qee(e), JV = (e) => (n) => {
      !n.isDefaultPrevented() && Z4(e) && e.selection.isEditable() && XV(n, KP(e), G4(e), () => {
        if (kn.browser.isChromium() || kn.browser.isFirefox()) {
          const s = e.selection.getRng();
          sp.setEditorTimeout(e, () => {
            e.selection.setRng(s), e.execCommand("Delete");
          }, 0);
        } else
          e.execCommand("Delete");
      });
    }, Gee = (e) => (n) => {
      !n.isDefaultPrevented() && Z4(e) && XV(n, KP(e), G4(e), Lt);
    }, eU = (e) => {
      e.on("cut", JV(e)), e.on("copy", Gee(e));
    }, tU = (e, n) => {
      var s, l;
      return ve.getCaretRangeFromPoint((s = n.clientX) !== null && s !== void 0 ? s : 0, (l = n.clientY) !== null && l !== void 0 ? l : 0, e.getDoc());
    }, Zee = (e) => {
      const n = e["text/plain"];
      return n ? n.indexOf("file://") === 0 : !1;
    }, nU = (e, n) => {
      e.focus(), n && e.selection.setRng(n);
    }, Kee = (e) => qt(e.files, (n) => /^image\//.test(n.type)), Yee = (e, n, s, l) => {
      const f = e.getParent(s, (E) => Jr(n, E));
      if (!q(e.getParent(s, "summary")))
        return !0;
      if (f && lr(l, "text/html")) {
        const E = new DOMParser().parseFromString(l["text/html"], "text/html").body;
        return !q(E.querySelector(f.nodeName.toLowerCase()));
      } else
        return !1;
    }, YP = (e) => {
      e.on("input", (n) => {
        const s = (l) => q(l.querySelector("summary"));
        if (n.inputType === "deleteByDrag") {
          const l = ht(e.dom.select("details"), s);
          ke(l, (f) => {
            Mo(f.firstChild) && f.firstChild.remove();
            const b = e.dom.create("summary");
            b.appendChild(bl().dom), f.prepend(b);
          });
        }
      });
    }, Qee = (e, n) => {
      g_(e) && e.on("dragend dragover draggesture dragdrop drop drag", (s) => {
        s.preventDefault(), s.stopPropagation();
      }), S0(e) || e.on("drop", (s) => {
        const l = s.dataTransfer;
        l && Kee(l) && s.preventDefault();
      }), e.on("drop", (s) => {
        if (s.isDefaultPrevented())
          return;
        const l = tU(e, s);
        if (je(l))
          return;
        const f = zT(s.dataTransfer), b = gS(f, WP());
        if ((!GV(f) || Zee(f)) && j4(e, s, l))
          return;
        const E = f[WP()], N = E || f["text/html"] || f["text/plain"], D = Yee(e.dom, e.schema, l.startContainer, f), U = n.get();
        U && !D || N && (s.preventDefault(), sp.setEditorTimeout(e, () => {
          e.undoManager.transact(() => {
            (E || U && D) && e.execCommand("Delete"), nU(e, l);
            const J = VV(N);
            f["text/html"] ? GP(e, J, b, !0) : hS(e, J, !0);
          });
        }));
      }), e.on("dragstart", (s) => {
        n.set(!0);
      }), e.on("dragover dragend", (s) => {
        S0(e) && !n.get() && (s.preventDefault(), nU(e, tU(e, s))), s.type === "dragend" && n.set(!1);
      }), YP(e);
    }, rU = (e) => {
      const n = (f) => (b) => {
        f(e, b);
      }, s = v_(e);
      Ce(s) && e.on("PastePreProcess", n(s));
      const l = xx(e);
      Ce(l) && e.on("PastePostProcess", n(l));
    }, Xee = (e, n) => {
      e.on("PastePreProcess", (s) => {
        s.content = n(e, s.content, s.internal);
      });
    }, Jee = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi, K4 = (e) => rn.trim(e).replace(Jee, Bu).toLowerCase(), oU = (e, n, s) => {
      const l = Bw(e);
      if (s || l === "all" || !Hw(e))
        return n;
      const f = l ? l.split(/[, ]/) : [];
      if (f && l !== "none") {
        const b = e.dom, E = e.selection.getNode();
        n = n.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, (N, D, U, J) => {
          const te = b.parseStyle(b.decode(U)), ce = {};
          for (let Re = 0; Re < f.length; Re++) {
            const xe = te[f[Re]];
            let Pe = xe, Ke = b.getStyle(E, f[Re], !0);
            /color/.test(f[Re]) && (Pe = K4(Pe), Ke = K4(Ke)), Ke !== Pe && (ce[f[Re]] = xe);
          }
          const Oe = b.serializeStyle(ce, "span");
          return Oe ? D + ' style="' + Oe + '"' + J : D + J;
        });
      } else
        n = n.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, "$1$3");
      return n = n.replace(/(<[^>]+) data-mce-style="([^"]+)"([^>]*>)/gi, (b, E, N, D) => E + ' style="' + N + '"' + D), n;
    }, ete = (e) => {
      (kn.browser.isChromium() || kn.browser.isSafari()) && Xee(e, oU);
    }, tte = (e) => {
      const n = wa(!1), s = wa(E0(e) ? "text" : "html"), l = Aee(e);
      ete(e), Wee(e, s), rU(e), e.on("PreInit", () => {
        eU(e), Qee(e, n), q4(e, l, s);
      });
    }, nte = (e) => {
      e.on("click", (n) => {
        e.dom.getParent(n.target, "details") && n.preventDefault();
      });
    }, rte = (e) => {
      e.parser.addNodeFilter("details", (n) => {
        const s = Tc(e);
        ke(n, (l) => {
          s === "expanded" ? l.attr("open", "open") : s === "collapsed" && l.attr("open", null);
        });
      }), e.serializer.addNodeFilter("details", (n) => {
        const s = Zk(e);
        ke(n, (l) => {
          s === "expanded" ? l.attr("open", "open") : s === "collapsed" && l.attr("open", null);
        });
      });
    }, ote = (e) => {
      nte(e), rte(e);
    }, sU = Mo, aU = Qt, ste = (e) => ro(e.dom), ate = (e) => Dc(e.dom), iU = (e) => (n) => Je(Fe.fromDom(e), n), ite = (e, n, s) => Fi(Fe.fromDom(e), (l) => ate(l) || s.isBlock(no(l)), iU(n)).getOr(Fe.fromDom(n)).dom, cU = (e, n) => Fi(Fe.fromDom(e), ste, iU(n)), lU = (e, n, s) => {
      const l = new xs(e, n), f = s ? l.next.bind(l) : l.prev.bind(l);
      let b = e;
      for (let E = s ? e : f(); E && !sU(E); E = f())
        oo(E) && (b = E);
      return b;
    }, cte = (e, n, s) => {
      const f = yt.fromRangeStart(e).getNode(), b = ite(f, n, s), E = lU(f, b, !1), N = lU(f, b, !0), D = document.createRange();
      return cU(E, b).fold(() => {
        aU(E) ? D.setStart(E, 0) : D.setStartBefore(E);
      }, (U) => D.setStartBefore(U.dom)), cU(N, b).fold(() => {
        aU(N) ? D.setEnd(N, N.data.length) : D.setEndAfter(N);
      }, (U) => D.setEndAfter(U.dom)), D;
    }, uU = (e) => {
      const n = cte(e.selection.getRng(), e.getBody(), e.schema);
      e.selection.setRng(XN(n));
    }, dU = (e) => {
      e.on("mousedown", (n) => {
        n.detail >= 3 && (n.preventDefault(), uU(e));
      });
    };
    var UT;
    (function(e) {
      e.Before = "before", e.After = "after";
    })(UT || (UT = {}));
    const lte = (e, n) => Math.abs(e.left - n), ute = (e, n) => Math.abs(e.right - n), dte = (e, n) => e >= n.top && e <= n.bottom, fte = (e, n) => e.top < n.bottom && e.bottom > n.top, mte = (e, n) => {
      const s = q2(e, n) / Math.min(e.height, n.height);
      return fte(e, n) && s > 0.5;
    }, pte = (e, n) => {
      const s = ht(e, (l) => dte(n, l));
      return j2(s).fold(() => [
        [],
        e
      ], (l) => {
        const {
          pass: f,
          fail: b
        } = an(e, (E) => mte(E, l));
        return [
          f,
          b
        ];
      });
    }, QP = (e, n) => ({
      node: e.node,
      position: lte(e, n) < ute(e, n) ? UT.Before : UT.After
    }), fU = (e, n, s) => n > e.left && n < e.right ? 0 : Math.min(Math.abs(e.left - n), Math.abs(e.right - n)), Y4 = (e, n, s, l) => {
      const f = (te) => oo(te.node) ? oe.some(te) : Un(te.node) ? Y4(Ps(te.node.childNodes), n, s, !1) : oe.none(), b = (te, ce, Oe) => f(ce).filter((Re) => Math.abs(Oe(te, n, s) - Oe(Re, n, s)) < 2 && Qt(Re.node)), E = (te, ce) => {
        const Oe = uo(te, (Re, xe) => ce(Re, n, s) - ce(xe, n, s));
        return qo(Oe, f).map((Re) => l && !Qt(Re.node) && Oe.length > 1 ? b(Re, Oe[1], ce).getOr(Re) : Re);
      }, [N, D] = pte(C7(e), s), {
        pass: U,
        fail: J
      } = an(D, (te) => te.top < s);
      return E(N, fU).orThunk(() => E(J, bw)).orThunk(() => E(U, bw));
    }, mU = (e, n, s, l) => {
      const f = (b, E) => {
        const N = (U) => Un(U) && U.classList.contains("mce-drag-container"), D = ht(b.dom.childNodes, vt(N));
        return E.fold(() => Y4(D, s, l, !0), (U) => {
          const J = ht(D, (te) => te !== U.dom);
          return Y4(J, s, l, !0);
        }).orThunk(() => (Je(b, e) ? oe.none() : Xo(b)).bind((J) => f(J, oe.some(b))));
      };
      return f(n, oe.none());
    }, pU = (e, n, s) => {
      const l = Fe.fromDom(e), f = er(l), E = Fe.fromPoint(f, n, s).filter((N) => Wt(l, N)).getOr(l);
      return mU(l, E, n, s);
    }, XP = (e, n, s) => pU(e, n, s).filter((l) => Lb(l.node)).map((l) => QP(l, n)), hU = (e) => {
      var n, s;
      const l = e.getBoundingClientRect(), f = e.ownerDocument, b = f.documentElement, E = f.defaultView;
      return {
        top: l.top + ((n = E == null ? void 0 : E.scrollY) !== null && n !== void 0 ? n : 0) - b.clientTop,
        left: l.left + ((s = E == null ? void 0 : E.scrollX) !== null && s !== void 0 ? s : 0) - b.clientLeft
      };
    }, gU = (e) => e.inline ? hU(e.getBody()) : {
      left: 0,
      top: 0
    }, hte = (e) => {
      const n = e.getBody();
      return e.inline ? {
        left: n.scrollLeft,
        top: n.scrollTop
      } : {
        left: 0,
        top: 0
      };
    }, vU = (e) => {
      const n = e.getBody(), s = e.getDoc().documentElement, l = {
        left: n.scrollLeft,
        top: n.scrollTop
      }, f = {
        left: n.scrollLeft || s.scrollLeft,
        top: n.scrollTop || s.scrollTop
      };
      return e.inline ? l : f;
    }, gte = (e, n) => {
      if (n.target.ownerDocument !== e.getDoc()) {
        const s = hU(e.getContentAreaContainer()), l = vU(e);
        return {
          left: n.pageX - s.left + l.left,
          top: n.pageY - s.top + l.top
        };
      }
      return {
        left: n.pageX,
        top: n.pageY
      };
    }, bU = (e, n, s) => ({
      pageX: s.left - e.left + n.left,
      pageY: s.top - e.top + n.top
    }), vte = (e, n) => bU(gU(e), hte(e), gte(e, n)), yU = (e) => ({
      target: e,
      srcElement: e
    }), bte = (e, n, s, l) => ({
      ...n,
      dataTransfer: l,
      type: e,
      ...yU(s)
    }), pA = (e, n, s) => {
      const l = Gt("Function not supported on simulated event.");
      return {
        bubbles: !0,
        cancelBubble: !1,
        cancelable: !0,
        composed: !1,
        currentTarget: null,
        defaultPrevented: !1,
        eventPhase: 0,
        isTrusted: !0,
        returnValue: !1,
        timeStamp: 0,
        type: e,
        composedPath: l,
        initEvent: l,
        preventDefault: Lt,
        stopImmediatePropagation: Lt,
        stopPropagation: Lt,
        AT_TARGET: window.Event.AT_TARGET,
        BUBBLING_PHASE: window.Event.BUBBLING_PHASE,
        CAPTURING_PHASE: window.Event.CAPTURING_PHASE,
        NONE: window.Event.NONE,
        altKey: !1,
        button: 0,
        buttons: 0,
        clientX: 0,
        clientY: 0,
        ctrlKey: !1,
        metaKey: !1,
        movementX: 0,
        movementY: 0,
        offsetX: 0,
        offsetY: 0,
        pageX: 0,
        pageY: 0,
        relatedTarget: null,
        screenX: 0,
        screenY: 0,
        shiftKey: !1,
        x: 0,
        y: 0,
        detail: 0,
        view: null,
        which: 0,
        initUIEvent: l,
        initMouseEvent: l,
        getModifierState: l,
        dataTransfer: s,
        ...yU(n)
      };
    }, yte = (e, n) => {
      const s = HT(e);
      return n === "dragstart" ? (NV(s), PV(s)) : n === "drop" ? (mee(s), I4(s)) : (zP(s), DV(s)), s;
    }, Ste = (e, n, s, l) => {
      const f = yte(s, e);
      return Le(l) ? pA(e, n, f) : bte(e, l, n, f);
    }, hA = 32, wte = 100, JP = 8, eD = 16, SU = ro, Ete = G2(SU, Dc), tD = (e, n, s) => SU(s) && s !== n && e.isEditable(s.parentElement), wU = (e, n, s) => je(n) || n === s || e.dom.isChildOf(n, s) ? !1 : e.dom.isEditable(n), EU = (e, n, s, l) => {
      const f = e.dom, b = n.cloneNode(!0);
      f.setStyles(b, {
        width: s,
        height: l
      }), f.setAttrib(b, "data-mce-selected", null);
      const E = f.create("div", {
        class: "mce-drag-container",
        "data-mce-bogus": "all",
        unselectable: "on",
        contenteditable: "false"
      });
      return f.setStyles(E, {
        position: "absolute",
        opacity: 0.5,
        overflow: "hidden",
        border: 0,
        padding: 0,
        margin: 0,
        width: s,
        height: l
      }), f.setStyles(b, {
        margin: 0,
        boxSizing: "border-box"
      }), E.appendChild(b), E;
    }, Cte = (e, n) => {
      e.parentNode !== n && n.appendChild(e);
    }, nD = (e, n) => (s) => () => {
      const l = e === "left" ? s.scrollX : s.scrollY;
      s.scroll({
        [e]: l + n,
        behavior: "smooth"
      });
    }, CU = nD("left", -hA), xte = nD("left", hA), xU = nD("top", -hA), rD = nD("top", hA), Q4 = (e, n, s, l, f, b, E, N, D, U, J, te) => {
      let ce = 0, Oe = 0;
      e.style.left = n.pageX + "px", e.style.top = n.pageY + "px", n.pageX + s > f && (ce = n.pageX + s - f), n.pageY + l > b && (Oe = n.pageY + l - b), e.style.width = s - ce + "px", e.style.height = l - Oe + "px";
      const Re = D.clientHeight, xe = D.clientWidth, Pe = E + D.getBoundingClientRect().top, Ke = N + D.getBoundingClientRect().left;
      J.on((et) => {
        et.intervalId.clear(), et.dragging && te && (E + JP >= Re ? et.intervalId.set(rD(U)) : E - JP <= 0 ? et.intervalId.set(xU(U)) : N + JP >= xe ? et.intervalId.set(xte(U)) : N - JP <= 0 ? et.intervalId.set(CU(U)) : Pe + eD >= window.innerHeight ? et.intervalId.set(rD(window)) : Pe - eD <= 0 ? et.intervalId.set(xU(window)) : Ke + eD >= window.innerWidth ? et.intervalId.set(xte(window)) : Ke - eD <= 0 && et.intervalId.set(CU(window)));
      });
    }, gA = (e) => {
      e && e.parentNode && e.parentNode.removeChild(e);
    }, Tte = (e, n) => {
      const s = e.getParent(n.parentNode, e.isBlock);
      gA(n), s && s !== e.getRoot() && e.isEmpty(s) && vf(Fe.fromDom(s));
    }, _te = (e) => e.button === 0, TU = (e, n) => ({
      pageX: n.pageX - e.relX,
      pageY: n.pageY + 5
    }), Ote = (e, n) => (s) => {
      if (_te(s)) {
        const l = Bt(n.dom.getParents(s.target), Ete).getOr(null);
        if (Ie(l) && tD(n.dom, n.getBody(), l)) {
          const f = n.dom.getPos(l), b = n.getBody(), E = n.getDoc().documentElement;
          e.set({
            element: l,
            dataTransfer: M4(),
            dragging: !1,
            screenX: s.screenX,
            screenY: s.screenY,
            maxX: (n.inline ? b.scrollWidth : E.offsetWidth) - 2,
            maxY: (n.inline ? b.scrollHeight : E.offsetHeight) - 2,
            relX: s.pageX - f.x,
            relY: s.pageY - f.y,
            width: l.offsetWidth,
            height: l.offsetHeight,
            ghost: EU(n, l, l.offsetWidth, l.offsetHeight),
            intervalId: U2(wte)
          });
        }
      }
    }, X4 = (e, n, s) => {
      e._selectionOverrides.hideFakeCaret(), XP(e.getBody(), n, s).fold(() => e.selection.placeCaretAt(n, s), (l) => {
        const f = e._selectionOverrides.showCaret(1, l.node, l.position === UT.Before, !1);
        f ? e.selection.setRng(f) : e.selection.placeCaretAt(n, s);
      });
    }, WT = (e, n, s, l, f) => {
      n === "dragstart" && MV(l, e.dom.getOuterHTML(s));
      const b = Ste(n, s, l, f);
      return e.dispatch(n, b);
    }, Ate = (e, n) => {
      const s = Py((f, b) => X4(n, f, b), 0);
      n.on("remove", s.cancel);
      const l = e;
      return (f) => e.on((b) => {
        const E = Math.max(Math.abs(f.screenX - b.screenX), Math.abs(f.screenY - b.screenY));
        if (!b.dragging && E > 10) {
          const N = WT(n, "dragstart", b.element, b.dataTransfer, f);
          if (Ie(N.dataTransfer) && (b.dataTransfer = N.dataTransfer), N.isDefaultPrevented())
            return;
          b.dragging = !0, n.focus();
        }
        if (b.dragging) {
          const N = f.currentTarget === n.getDoc().documentElement, D = TU(b, vte(n, f));
          Cte(b.ghost, n.getBody()), Q4(b.ghost, D, b.width, b.height, b.maxX, b.maxY, f.clientY, f.clientX, n.getContentAreaContainer(), n.getWin(), l, N), s.throttle(f.clientX, f.clientY);
        }
      });
    }, kte = (e) => {
      const n = e.getSel();
      if (Ie(n)) {
        const l = n.getRangeAt(0).startContainer;
        return Qt(l) ? l.parentNode : l;
      } else
        return null;
    }, _U = (e, n) => (s) => {
      e.on((l) => {
        var f;
        if (l.intervalId.clear(), l.dragging) {
          if (wU(n, kte(n.selection), l.element)) {
            const b = (f = n.getDoc().elementFromPoint(s.clientX, s.clientY)) !== null && f !== void 0 ? f : n.getBody();
            WT(n, "drop", b, l.dataTransfer, s).isDefaultPrevented() || n.undoManager.transact(() => {
              Tte(n.dom, l.element), wee(l.dataTransfer).each((N) => n.insertContent(N)), n._selectionOverrides.hideFakeCaret();
            });
          }
          WT(n, "dragend", n.getBody(), l.dataTransfer, s);
        }
      }), AU(e);
    }, OU = (e, n, s) => {
      e.on((l) => {
        l.intervalId.clear(), l.dragging && s.fold(() => WT(n, "dragend", l.element, l.dataTransfer), (f) => WT(n, "dragend", l.element, l.dataTransfer, f));
      }), AU(e);
    }, ule = (e, n) => (s) => OU(e, n, oe.some(s)), AU = (e) => {
      e.on((n) => {
        n.intervalId.clear(), gA(n.ghost);
      }), e.clear();
    }, Nte = (e) => {
      const n = Kh(), s = Is.DOM, l = document, f = Ote(n, e), b = Ate(n, e), E = _U(n, e), N = ule(n, e);
      e.on("mousedown", f), e.on("mousemove", b), e.on("mouseup", E), s.bind(l, "mousemove", b), s.bind(l, "mouseup", N), e.on("remove", () => {
        s.unbind(l, "mousemove", b), s.unbind(l, "mouseup", N);
      }), e.on("keydown", (D) => {
        D.keyCode === zn.ESC && OU(n, e, oe.none());
      });
    }, Rte = (e) => {
      const n = (f) => {
        if (!f.isDefaultPrevented()) {
          const b = f.dataTransfer;
          b && (Ge(b.types, "Files") || b.files.length > 0) && (f.preventDefault(), f.type === "drop" && HR(e, "Dropped file type is not supported"));
        }
      }, s = (f) => {
        NN(e, f.target) && n(f);
      }, l = () => {
        const f = Is.DOM, b = e.dom, E = document, N = e.inline ? e.getBody() : e.getDoc(), D = [
          "drop",
          "dragover"
        ];
        ke(D, (U) => {
          f.bind(E, U, s), b.bind(N, U, n);
        }), e.on("remove", () => {
          ke(D, (U) => {
            f.unbind(E, U, s), b.unbind(N, U, n);
          });
        });
      };
      e.on("init", () => {
        sp.setEditorTimeout(e, l, 0);
      });
    }, kU = (e) => {
      Nte(e), y0(e) && Rte(e);
    }, Pte = (e) => {
      const n = Py(() => {
        if (!e.removed && e.getBody().contains(document.activeElement)) {
          const s = e.selection.getRng();
          if (s.collapsed) {
            const l = XR(e, s, !1);
            e.selection.setRng(l);
          }
        }
      }, 0);
      e.on("focus", () => {
        n.throttle();
      }), e.on("blur", () => {
        n.cancel();
      });
    }, NU = (e) => {
      e.on("init", () => {
        e.on("focusin", (n) => {
          const s = n.target;
          if (Ts(s)) {
            const l = Z0(e.getBody(), s), f = ro(l) ? l : s;
            e.selection.getNode() !== f && xT(e, f).each((b) => e.selection.setRng(b));
          }
        });
      });
    }, vA = ro, RU = (e, n) => Z0(e.getBody(), n), Dte = (e) => {
      const n = e.selection, s = e.dom, l = e.getBody(), f = Yw(e, l, s.isBlock, () => W0(e)), b = "sel-" + s.uniqueId(), E = "data-mce-selected";
      let N;
      const D = (Dn) => Ie(Dn) && s.hasClass(Dn, "mce-offscreen-selection"), U = (Dn) => Dn !== l && (vA(Dn) || Ts(Dn)) && s.isChildOf(Dn, l) && s.isEditable(Dn.parentNode), J = (Dn) => {
        Dn && n.setRng(Dn);
      }, te = (Dn, Rt, Tt, Kt = !0) => e.dispatch("ShowCaret", {
        target: Rt,
        direction: Dn,
        before: Tt
      }).isDefaultPrevented() ? null : (Kt && n.scrollIntoView(Rt, Dn === -1), f.show(Tt, Rt)), ce = (Dn) => {
        Dn.hasAttribute("data-mce-caret") && (Bd(Dn), n.scrollIntoView(Dn));
      }, Oe = () => {
        e.on("click", (Rt) => {
          s.isEditable(Rt.target) || (Rt.preventDefault(), e.focus());
        }), e.on("blur NewBlock", dt), e.on("ResizeWindow FullscreenStateChanged", f.reposition), e.on("tap", (Rt) => {
          const Tt = Rt.target, Kt = RU(e, Tt);
          vA(Kt) ? (Rt.preventDefault(), xT(e, Kt).each(rt)) : U(Tt) && xT(e, Tt).each(rt);
        }, !0), e.on("mousedown", (Rt) => {
          const Tt = Rt.target;
          if (Tt !== l && Tt.nodeName !== "HTML" && !s.isChildOf(Tt, l) || !aY(e, Rt.clientX, Rt.clientY))
            return;
          dt(), ln();
          const Kt = RU(e, Tt);
          vA(Kt) ? (Rt.preventDefault(), xT(e, Kt).each(rt)) : XP(l, Rt.clientX, Rt.clientY).each((Mn) => {
            Rt.preventDefault();
            const rr = te(1, Mn.node, Mn.position === UT.Before, !1);
            J(rr), Ui(Kt) ? Kt.focus() : e.getBody().focus();
          });
        }), e.on("keypress", (Rt) => {
          zn.modifierPressed(Rt) || vA(n.getNode()) && Rt.preventDefault();
        }), e.on("GetSelectionRange", (Rt) => {
          let Tt = Rt.range;
          if (N) {
            if (!N.parentNode) {
              N = null;
              return;
            }
            Tt = Tt.cloneRange(), Tt.selectNode(N), Rt.range = Tt;
          }
        }), e.on("SetSelectionRange", (Rt) => {
          Rt.range = Pe(Rt.range);
          const Tt = rt(Rt.range, Rt.forward);
          Tt && (Rt.range = Tt);
        });
        const Dn = (Rt) => Un(Rt) && Rt.id === "mcepastebin";
        e.on("AfterSetSelectionRange", (Rt) => {
          const Tt = Rt.range, Kt = Tt.startContainer.parentElement;
          !xe(Tt) && !Dn(Kt) && ln(), D(Kt) || dt();
        }), kU(e), Pte(e), NU(e);
      }, Re = (Dn) => Xn(Dn) || Ic(Dn) || uu(Dn), xe = (Dn) => Re(Dn.startContainer) || Re(Dn.endContainer), Pe = (Dn) => {
        const Rt = e.schema.getVoidElements(), Tt = s.createRng(), Kt = Dn.startContainer, Mn = Dn.startOffset, rr = Dn.endContainer, Fr = Dn.endOffset;
        return lr(Rt, Kt.nodeName.toLowerCase()) ? Mn === 0 ? Tt.setStartBefore(Kt) : Tt.setStartAfter(Kt) : Tt.setStart(Kt, Mn), lr(Rt, rr.nodeName.toLowerCase()) ? Fr === 0 ? Tt.setEndBefore(rr) : Tt.setEndAfter(rr) : Tt.setEnd(rr, Fr), Tt;
      }, Ke = (Dn, Rt) => {
        const Tt = Fe.fromDom(e.getBody()), Kt = e.getDoc(), Mn = Li(Tt, "#" + b).getOrThunk(() => {
          const so = Fe.fromHtml('<div data-mce-bogus="all" class="mce-offscreen-selection"></div>', Kt);
          return is(so, "id", b), Ys(Tt, so), so;
        }), rr = s.createRng();
        $u(Mn), Vo(Mn, [
          Fe.fromText(xo, Kt),
          Fe.fromDom(Rt),
          Fe.fromText(xo, Kt)
        ]), rr.setStart(Mn.dom.firstChild, 1), rr.setEnd(Mn.dom.lastChild, 0), Hi(Mn, { top: s.getPos(Dn, e.getBody()).y + "px" }), CN(Mn);
        const Fr = n.getSel();
        return Fr && (Fr.removeAllRanges(), Fr.addRange(rr)), rr;
      }, et = (Dn) => {
        const Rt = Dn.cloneNode(!0), Tt = e.dispatch("ObjectSelected", {
          target: Dn,
          targetClone: Rt
        });
        if (Tt.isDefaultPrevented())
          return null;
        const Kt = Ke(Dn, Tt.targetClone), Mn = Fe.fromDom(Dn);
        return ke(Vi(Fe.fromDom(e.getBody()), `*[${E}]`), (rr) => {
          Je(Mn, rr) || Vs(rr, E);
        }), s.getAttrib(Dn, E) || Dn.setAttribute(E, "1"), N = Dn, ln(), Kt;
      }, rt = (Dn, Rt) => {
        if (!Dn)
          return null;
        if (Dn.collapsed) {
          if (!xe(Dn)) {
            const rr = Rt ? 1 : -1, Fr = Lc(rr, l, Dn), so = Fr.getNode(!Rt);
            if (Ie(so)) {
              if (Lb(so))
                return te(rr, so, Rt ? !Fr.isAtEnd() : !1, !1);
              if (Sn(so) && ro(so.nextSibling)) {
                const Xs = s.createRng();
                return Xs.setStart(so, 0), Xs.setEnd(so, 0), Xs;
              }
            }
            const Cs = Fr.getNode(Rt);
            if (Ie(Cs)) {
              if (Lb(Cs))
                return te(rr, Cs, Rt ? !1 : !Fr.isAtEnd(), !1);
              if (Sn(Cs) && ro(Cs.previousSibling)) {
                const Xs = s.createRng();
                return Xs.setStart(Cs, 1), Xs.setEnd(Cs, 1), Xs;
              }
            }
          }
          return null;
        }
        let Tt = Dn.startContainer, Kt = Dn.startOffset;
        const Mn = Dn.endOffset;
        if (Qt(Tt) && Kt === 0 && vA(Tt.parentNode) && (Tt = Tt.parentNode, Kt = s.nodeIndex(Tt), Tt = Tt.parentNode), !Un(Tt))
          return null;
        if (Mn === Kt + 1 && Tt === Dn.endContainer) {
          const rr = Tt.childNodes[Kt];
          if (U(rr))
            return et(rr);
        }
        return null;
      }, dt = () => {
        N && N.removeAttribute(E), Li(Fe.fromDom(e.getBody()), "#" + b).each(mo), N = null;
      }, Ht = () => {
        f.destroy(), N = null;
      }, ln = () => {
        f.hide();
      };
      return d1(e) || Oe(), {
        showCaret: te,
        showBlockCaretContainer: ce,
        hideFakeCaret: ln,
        destroy: Ht
      };
    }, $te = (e, n) => {
      let s = n;
      for (let l = e.previousSibling; Qt(l); l = l.previousSibling)
        s += l.data.length;
      return s;
    }, PU = (e, n, s, l, f) => {
      if (Qt(s) && (l < 0 || l > s.data.length))
        return [];
      const b = f && Qt(s) ? [$te(s, l)] : [l];
      let E = s;
      for (; E !== n && E.parentNode; )
        b.push(e.nodeIndex(E, f)), E = E.parentNode;
      return E === n ? b.reverse() : [];
    }, oD = (e, n, s, l, f, b, E = !1) => {
      const N = PU(e, n, s, l, E), D = PU(e, n, f, b, E);
      return {
        start: N,
        end: D
      };
    }, Ite = (e, n) => {
      const s = n.slice(), l = s.pop();
      return pt(l) ? Ye(s, (b, E) => b.bind((N) => oe.from(N.childNodes[E])), oe.some(e)).bind((b) => Qt(b) && (l < 0 || l > b.data.length) ? oe.none() : oe.some({
        node: b,
        offset: l
      })) : oe.none();
    }, DU = (e, n) => Ite(e, n.start).bind(({
      node: s,
      offset: l
    }) => Ite(e, n.end).map(({
      node: f,
      offset: b
    }) => {
      const E = document.createRange();
      return E.setStart(s, l), E.setEnd(f, b), E;
    })), $U = (e, n, s, l = !1) => oD(e, n, s.startContainer, s.startOffset, s.endContainer, s.endOffset, l), jT = (e, n, s) => {
      if (n && e.isEmpty(n) && !s(n)) {
        const l = n.parentNode;
        e.remove(n, Qt(n.firstChild) && Bp(n.firstChild.data)), jT(e, l, s);
      }
    }, qT = (e, n, s, l = !0) => {
      const f = n.startContainer.parentNode, b = n.endContainer.parentNode;
      n.deleteContents(), l && !s(n.startContainer) && (Qt(n.startContainer) && n.startContainer.data.length === 0 && e.remove(n.startContainer), Qt(n.endContainer) && n.endContainer.data.length === 0 && e.remove(n.endContainer), jT(e, f, s), f !== b && jT(e, b, s));
    }, J4 = (e, n) => oe.from(e.dom.getParent(n.startContainer, e.dom.isBlock)), IU = (e, n, s) => {
      const l = e.dynamicPatternsLookup({
        text: s,
        block: n
      });
      return {
        ...e,
        blockPatterns: tg(l).concat(e.blockPatterns),
        inlinePatterns: By(l).concat(e.inlinePatterns)
      };
    }, MU = (e, n, s, l) => {
      const f = e.createRng();
      return f.setStart(n, 0), f.setEnd(s, l), f.toString();
    }, FU = (e) => /^\s[^\s]/.test(e), bA = (e, n, s) => {
      wz(n, 0, n).each((f) => {
        const b = f.container;
        bP(b, s.start.length, n).each((D) => {
          const U = e.createRng();
          U.setStart(b, 0), U.setEnd(D.container, D.offset), qT(e, U, (J) => J === n);
        });
        const E = Fe.fromDom(b), N = lu(E);
        FU(N) && tc(E, N.slice(1));
      });
    }, LU = (e, n) => {
      const s = e.dom, l = n.pattern, f = DU(s.getRoot(), n.range).getOrDie("Unable to resolve path range"), b = (E, N) => {
        const D = N.get(E);
        return be(D) && br(D).exists((U) => lr(U, "block"));
      };
      return J4(e, f).each((E) => {
        l.type === "block-format" ? b(l.format, e.formatter) && e.undoManager.transact(() => {
          bA(e.dom, E, l), e.formatter.apply(l.format);
        }) : l.type === "block-command" && e.undoManager.transact(() => {
          bA(e.dom, E, l), e.execCommand(l.cmd, !1, l.value);
        });
      }), !0;
    }, BU = (e) => uo(e, (n, s) => s.start.length - n.start.length), Mte = (e, n) => {
      const s = BU(e), l = n.replace(xo, " ");
      return Bt(s, (f) => n.indexOf(f.start) === 0 || l.indexOf(f.start) === 0);
    }, Fte = (e, n, s, l) => {
      var f;
      const b = e.dom, E = al(e);
      if (!b.is(n, E))
        return [];
      const N = (f = n.textContent) !== null && f !== void 0 ? f : "";
      return Mte(s.blockPatterns, N).map((D) => rn.trim(N).length === D.start.length ? [] : [{
        pattern: D,
        range: oD(b, b.getRoot(), n, 0, n, 0, l)
      }]).getOr([]);
    }, HU = (e, n) => {
      if (n.length === 0)
        return;
      const s = e.selection.getBookmark();
      ke(n, (l) => LU(e, l)), e.selection.moveToBookmark(s);
    }, zU = (e, n) => e.create("span", {
      "data-mce-type": "bookmark",
      id: n
    }), sD = (e, n) => {
      const s = e.createRng();
      return s.setStartAfter(n.start), s.setEndBefore(n.end), s;
    }, VU = (e, n, s) => {
      const l = DU(e.getRoot(), s).getOrDie("Unable to resolve path range"), f = l.startContainer, b = l.endContainer, E = l.endOffset === 0 ? b : b.splitText(l.endOffset), N = l.startOffset === 0 ? f : f.splitText(l.startOffset), D = N.parentNode, U = E.parentNode;
      return {
        prefix: n,
        end: U.insertBefore(zU(e, n + "-end"), E),
        start: D.insertBefore(zU(e, n + "-start"), N)
      };
    }, aD = (e, n, s) => {
      jT(e, e.get(n.prefix + "-end"), s), jT(e, e.get(n.prefix + "-start"), s);
    }, eL = (e) => e.start.length === 0, Lte = (e) => (n, s) => {
      const f = n.data.substring(0, s), b = f.lastIndexOf(e.charAt(e.length - 1)), E = f.lastIndexOf(e);
      return E !== -1 ? E + e.length : b !== -1 ? b + 1 : -1;
    }, UU = (e, n, s, l) => {
      const f = n.start;
      return tA(e, l.container, l.offset, Lte(f), s).bind((E) => {
        var N, D;
        const U = (D = (N = s.textContent) === null || N === void 0 ? void 0 : N.indexOf(f)) !== null && D !== void 0 ? D : -1;
        if (U !== -1 && E.offset >= U + f.length) {
          const te = e.createRng();
          return te.setStart(E.container, E.offset - f.length), te.setEnd(E.container, E.offset), oe.some(te);
        } else {
          const te = E.offset - f.length;
          return eA(E.container, te, s).map((ce) => {
            const Oe = e.createRng();
            return Oe.setStart(ce.container, ce.offset), Oe.setEnd(E.container, E.offset), Oe;
          }).filter((ce) => ce.toString() === f).orThunk(() => UU(e, n, s, yg(E.container, 0)));
        }
      });
    }, Bte = (e, n, s, l, f, b = !1) => {
      if (n.start.length === 0 && !b) {
        const E = e.createRng();
        return E.setStart(s, l), E.setEnd(s, l), oe.some(E);
      }
      return JO(s, l, f).bind((E) => UU(e, n, f, E).bind((D) => {
        var U;
        if (b) {
          if (D.endContainer === E.container && D.endOffset === E.offset)
            return oe.none();
          if (E.offset === 0 && ((U = D.endContainer.textContent) === null || U === void 0 ? void 0 : U.length) === D.endOffset)
            return oe.none();
        }
        return oe.some(D);
      }));
    }, Hte = (e, n, s, l) => {
      const f = e.dom, b = f.getRoot(), E = s.pattern, N = s.position.container, D = s.position.offset;
      return eA(N, D - s.pattern.end.length, n).bind((U) => {
        const J = oD(f, b, U.container, U.offset, N, D, l);
        if (eL(E))
          return oe.some({
            matches: [{
              pattern: E,
              startRng: J,
              endRng: J
            }],
            position: U
          });
        {
          const te = iD(e, s.remainingPatterns, U.container, U.offset, n, l), ce = te.getOr({
            matches: [],
            position: U
          }), Oe = ce.position;
          return Bte(f, E, Oe.container, Oe.offset, n, te.isNone()).map((xe) => {
            const Pe = $U(f, b, xe, l);
            return {
              matches: ce.matches.concat([{
                pattern: E,
                startRng: Pe,
                endRng: J
              }]),
              position: yg(xe.startContainer, xe.startOffset)
            };
          });
        }
      });
    }, iD = (e, n, s, l, f, b) => {
      const E = e.dom;
      return JO(s, l, E.getRoot()).bind((N) => {
        const D = MU(E, f, s, l);
        for (let U = 0; U < n.length; U++) {
          const J = n[U];
          if (!Ac(D, J.end))
            continue;
          const te = n.slice();
          te.splice(U, 1);
          const ce = Hte(e, f, {
            pattern: J,
            remainingPatterns: te,
            position: N
          }, b);
          if (ce.isNone() && l > 0)
            return iD(e, n, s, l - 1, f, b);
          if (ce.isSome())
            return ce;
        }
        return oe.none();
      });
    }, tL = (e, n, s) => {
      e.selection.setRng(s), n.type === "inline-format" ? ke(n.format, (l) => {
        e.formatter.apply(l);
      }) : e.execCommand(n.cmd, !1, n.value);
    }, WU = (e, n, s, l) => {
      const f = sD(e.dom, s);
      qT(e.dom, f, l), tL(e, n, f);
    }, nL = (e, n, s, l, f) => {
      const b = e.dom, E = sD(b, l), N = sD(b, s);
      qT(b, N, f), qT(b, E, f);
      const D = {
        prefix: s.prefix,
        start: s.end,
        end: l.start
      }, U = sD(b, D);
      tL(e, n, U);
    }, rL = (e, n) => {
      const s = nv("mce_textpattern"), l = bn(n, (f, b) => {
        const E = VU(e, s + `_end${f.length}`, b.endRng);
        return f.concat([{
          ...b,
          endMarker: E
        }]);
      }, []);
      return bn(l, (f, b) => {
        const E = l.length - f.length - 1, N = eL(b.pattern) ? b.endMarker : VU(e, s + `_start${E}`, b.startRng);
        return f.concat([{
          ...b,
          startMarker: N
        }]);
      }, []);
    }, zte = (e) => uo(e, (n, s) => s.end.length - n.end.length), oL = (e, n) => {
      const s = Vr(e, (l) => qt(n, (f) => l.pattern.start === f.pattern.start && l.pattern.end === f.pattern.end));
      return e.length === n.length ? s ? e : n : e.length > n.length ? e : n;
    }, jU = (e, n, s, l, f, b) => {
      const E = iD(e, f.inlinePatterns, s, l, n, b).fold(() => [], (D) => D.matches), N = iD(e, zte(f.inlinePatterns), s, l, n, b).fold(() => [], (D) => D.matches);
      return oL(E, N);
    }, qU = (e, n) => {
      if (n.length === 0)
        return;
      const s = e.dom, l = e.selection.getBookmark(), f = rL(s, n);
      ke(f, (b) => {
        const E = s.getParent(b.startMarker.start, s.isBlock), N = (D) => D === E;
        eL(b.pattern) ? WU(e, b.pattern, b.endMarker, N) : nL(e, b.pattern, b.startMarker, b.endMarker, N), aD(s, b.endMarker, N), aD(s, b.startMarker, N);
      }), e.selection.moveToBookmark(l);
    }, GU = (e, n) => {
      const s = e.selection.getRng();
      return J4(e, s).map((l) => {
        var f;
        const b = Math.max(0, s.startOffset), E = IU(n, l, (f = l.textContent) !== null && f !== void 0 ? f : ""), N = jU(e, l, s.startContainer, b, E, !0), D = Fte(e, l, E, !0);
        return D.length > 0 || N.length > 0 ? (e.undoManager.add(), e.undoManager.extra(() => {
          e.execCommand("mceInsertNewLine");
        }, () => {
          Ee(e), qU(e, N), HU(e, D);
          const U = e.selection.getRng(), J = JO(U.startContainer, U.startOffset, e.dom.getRoot());
          e.execCommand("mceInsertNewLine"), J.each((te) => {
            const ce = te.container;
            ce.data.charAt(te.offset - 1) === jg && (ce.deleteData(te.offset - 1, 1), jT(e.dom, ce.parentNode, (Oe) => Oe === e.dom.getRoot()));
          });
        }), !0) : !1;
      }).getOr(!1);
    }, Vte = (e, n) => {
      const s = e.selection.getRng();
      J4(e, s).map((l) => {
        const f = Math.max(0, s.startOffset - 1), b = MU(e.dom, l, s.startContainer, f), E = IU(n, l, b), N = jU(e, l, s.startContainer, f, E, !1);
        N.length > 0 && e.undoManager.transact(() => {
          qU(e, N);
        });
      });
    }, ZU = (e, n, s) => {
      for (let l = 0; l < e.length; l++)
        if (s(e[l], n))
          return !0;
      return !1;
    }, Ute = (e, n) => ZU(e, n, (s, l) => s === l.keyCode && !zn.modifierPressed(l)), Wte = (e, n) => ZU(e, n, (s, l) => s.charCodeAt(0) === l.charCode), jte = (e) => {
      const n = [
        ",",
        ".",
        ";",
        ":",
        "!",
        "?"
      ], s = [32], l = () => vu(x0(e), b_(e)), f = () => Uw(e);
      e.on("keydown", (E) => {
        if (E.keyCode === 13 && !zn.modifierPressed(E) && e.selection.isCollapsed()) {
          const N = l();
          (N.inlinePatterns.length > 0 || N.blockPatterns.length > 0 || f()) && GU(e, N) && E.preventDefault();
        }
      }, !0);
      const b = () => {
        if (e.selection.isCollapsed()) {
          const E = l();
          (E.inlinePatterns.length > 0 || f()) && Vte(e, E);
        }
      };
      e.on("keyup", (E) => {
        Ute(s, E) && b();
      }), e.on("keypress", (E) => {
        Wte(n, E) && sp.setEditorTimeout(e, b);
      });
    }, qte = (e) => {
      jte(e);
    }, Gte = (e) => {
      const n = rn.each, s = zn.BACKSPACE, l = zn.DELETE, f = e.dom, b = e.selection, E = e.parser, N = kn.browser, D = N.isFirefox(), U = N.isChromium() || N.isSafari(), J = kn.deviceType.isiPhone() || kn.deviceType.isiPad(), te = kn.os.isMacOS() || kn.os.isiOS(), ce = (Qn, Jn) => {
        try {
          e.getDoc().execCommand(Qn, !1, String(Jn));
        } catch {
        }
      }, Oe = (Qn) => Qn.isDefaultPrevented(), Re = () => {
        const Qn = (pn) => {
          const kr = f.create("body"), To = pn.cloneContents();
          return kr.appendChild(To), b.serializer.serialize(kr, { format: "html" });
        }, Jn = (pn) => {
          const kr = Qn(pn), To = f.createRng();
          To.selectNode(e.getBody());
          const Ns = Qn(To);
          return kr === Ns;
        };
        e.on("keydown", (pn) => {
          const kr = pn.keyCode;
          if (!Oe(pn) && (kr === l || kr === s) && e.selection.isEditable()) {
            const To = e.selection.isCollapsed(), Ns = e.getBody();
            if (To && !Na(Fe.fromDom(Ns)) || !To && !Jn(e.selection.getRng()))
              return;
            pn.preventDefault(), e.setContent(""), Ns.firstChild && f.isBlock(Ns.firstChild) ? e.selection.setCursorLocation(Ns.firstChild, 0) : e.selection.setCursorLocation(Ns, 0), e.nodeChanged();
          }
        });
      }, xe = () => {
        e.shortcuts.add("meta+a", null, "SelectAll");
      }, Pe = () => {
        e.inline || f.bind(e.getDoc(), "mousedown mouseup", (Qn) => {
          let Jn;
          if (Qn.target === e.getDoc().documentElement)
            if (Jn = b.getRng(), e.getBody().focus(), Qn.type === "mousedown") {
              if (Xn(Jn.startContainer))
                return;
              b.placeCaretAt(Qn.clientX, Qn.clientY);
            } else
              b.setRng(Jn);
        });
      }, Ke = () => {
        e.on("keydown", (Qn) => {
          if (!Oe(Qn) && Qn.keyCode === s) {
            if (!e.getBody().getElementsByTagName("hr").length)
              return;
            if (b.isCollapsed() && b.getRng().startOffset === 0) {
              const Jn = b.getNode(), pn = Jn.previousSibling;
              if (Jn.nodeName === "HR") {
                f.remove(Jn), Qn.preventDefault();
                return;
              }
              pn && pn.nodeName && pn.nodeName.toLowerCase() === "hr" && (f.remove(pn), Qn.preventDefault());
            }
          }
        });
      }, et = () => {
        Range.prototype.getClientRects || e.on("mousedown", (Qn) => {
          if (!Oe(Qn) && Qn.target.nodeName === "HTML") {
            const Jn = e.getBody();
            Jn.blur(), sp.setEditorTimeout(e, () => {
              Jn.focus();
            });
          }
        });
      }, rt = () => {
        const Qn = wx(e);
        e.on("click", (Jn) => {
          const pn = Jn.target;
          /^(IMG|HR)$/.test(pn.nodeName) && f.isEditable(pn) && (Jn.preventDefault(), e.selection.select(pn), e.nodeChanged()), pn.nodeName === "A" && f.hasClass(pn, Qn) && pn.childNodes.length === 0 && f.isEditable(pn.parentNode) && (Jn.preventDefault(), b.select(pn));
        });
      }, dt = () => {
        const Qn = () => {
          const pn = f.getAttribs(b.getStart().cloneNode(!1));
          return () => {
            const kr = b.getStart();
            kr !== e.getBody() && (f.setAttrib(kr, "style", null), n(pn, (To) => {
              kr.setAttributeNode(To.cloneNode(!0));
            }));
          };
        }, Jn = () => !b.isCollapsed() && f.getParent(b.getStart(), f.isBlock) !== f.getParent(b.getEnd(), f.isBlock);
        e.on("keypress", (pn) => {
          let kr;
          return !Oe(pn) && (pn.keyCode === 8 || pn.keyCode === 46) && Jn() ? (kr = Qn(), e.getDoc().execCommand("delete", !1), kr(), pn.preventDefault(), !1) : !0;
        }), f.bind(e.getDoc(), "cut", (pn) => {
          if (!Oe(pn) && Jn()) {
            const kr = Qn();
            sp.setEditorTimeout(e, () => {
              kr();
            });
          }
        });
      }, Ht = () => {
        e.on("keydown", (Qn) => {
          if (!Oe(Qn) && Qn.keyCode === s && b.isCollapsed() && b.getRng().startOffset === 0) {
            const Jn = b.getNode().previousSibling;
            if (Jn && Jn.nodeName && Jn.nodeName.toLowerCase() === "table")
              return Qn.preventDefault(), !1;
          }
          return !0;
        });
      }, ln = () => {
        e.on("keydown", (Qn) => {
          if (Oe(Qn) || Qn.keyCode !== zn.BACKSPACE)
            return;
          let Jn = b.getRng();
          const pn = Jn.startContainer, kr = Jn.startOffset, To = f.getRoot();
          let Ns = pn;
          if (!(!Jn.collapsed || kr !== 0)) {
            for (; Ns.parentNode && Ns.parentNode.firstChild === Ns && Ns.parentNode !== To; )
              Ns = Ns.parentNode;
            Ns.nodeName === "BLOCKQUOTE" && (e.formatter.toggle("blockquote", void 0, Ns), Jn = f.createRng(), Jn.setStart(pn, 0), Jn.setEnd(pn, 0), b.setRng(Jn));
          }
        });
      }, Dn = () => {
        const Qn = () => {
          ce("StyleWithCSS", !1), ce("enableInlineTableEditing", !1), Nb(e) || ce("enableObjectResizing", !1);
        };
        Uy(e) || e.on("BeforeExecCommand mousedown", Qn);
      }, Rt = () => {
        const Qn = () => {
          n(f.select("a:not([data-mce-block])"), (Jn) => {
            var pn;
            let kr = Jn.parentNode;
            const To = f.getRoot();
            if ((kr == null ? void 0 : kr.lastChild) === Jn) {
              for (; kr && !f.isBlock(kr); ) {
                if (((pn = kr.parentNode) === null || pn === void 0 ? void 0 : pn.lastChild) !== kr || kr === To)
                  return;
                kr = kr.parentNode;
              }
              f.add(kr, "br", { "data-mce-bogus": 1 });
            }
          });
        };
        e.on("SetContent ExecCommand", (Jn) => {
          (Jn.type === "setcontent" || Jn.command === "mceInsertLink") && Qn();
        });
      }, Tt = () => {
        e.on("init", () => {
          ce("DefaultParagraphSeparator", al(e));
        });
      }, Kt = (Qn) => {
        const Jn = Qn.getBody(), pn = Qn.selection.getRng();
        return pn.startContainer === pn.endContainer && pn.startContainer === Jn && pn.startOffset === 0 && pn.endOffset === Jn.childNodes.length;
      }, Mn = () => {
        e.on("keyup focusin mouseup", (Qn) => {
          !zn.modifierPressed(Qn) && !Kt(e) && b.normalize();
        }, !0);
      }, rr = () => {
        e.contentStyles.push("img:-moz-broken {-moz-force-broken-image-icon:1;min-width:24px;min-height:24px}");
      }, Fr = () => {
        e.inline || e.on("keydown", () => {
          document.activeElement === document.body && e.getWin().focus();
        });
      }, so = () => {
        e.inline || (e.contentStyles.push("body {min-height: 150px}"), e.on("click", (Qn) => {
          let Jn;
          Qn.target.nodeName === "HTML" && (Jn = e.selection.getRng(), e.getBody().focus(), e.selection.setRng(Jn), e.selection.normalize(), e.nodeChanged());
        }));
      }, Cs = () => {
        te && e.on("keydown", (Qn) => {
          zn.metaKeyPressed(Qn) && !Qn.shiftKey && (Qn.keyCode === 37 || Qn.keyCode === 39) && (Qn.preventDefault(), e.selection.getSel().modify("move", Qn.keyCode === 37 ? "backward" : "forward", "lineboundary"));
        });
      }, Xs = () => {
        e.on("click", (Qn) => {
          let Jn = Qn.target;
          do
            if (Jn.tagName === "A") {
              Qn.preventDefault();
              return;
            }
          while (Jn = Jn.parentNode);
        }), e.contentStyles.push(".mce-content-body {-webkit-touch-callout: none}");
      }, Si = () => {
        e.on("init", () => {
          e.dom.bind(e.getBody(), "submit", (Qn) => {
            Qn.preventDefault();
          });
        });
      }, Kl = () => {
        E.addNodeFilter("br", (Qn) => {
          let Jn = Qn.length;
          for (; Jn--; )
            Qn[Jn].attr("class") === "Apple-interchange-newline" && Qn[Jn].remove();
        });
      }, ll = Lt, wn = () => {
        if (!D || e.removed)
          return !1;
        const Qn = e.selection.getSel();
        return !Qn || !Qn.rangeCount || Qn.rangeCount === 0;
      }, Ln = () => {
        U && (Pe(), rt(), Si(), xe(), J && (Fr(), so(), Xs())), D && (et(), Dn(), rr(), Cs());
      }, Ho = () => {
        e.on("drop", (Qn) => {
          var Jn;
          const pn = (Jn = Qn.dataTransfer) === null || Jn === void 0 ? void 0 : Jn.getData("text/html");
          G(pn) && /^<img[^>]*>$/.test(pn) && e.dispatch("dragend", new window.DragEvent("dragend", Qn));
        });
      }, Ao = () => {
        ln(), Re(), kn.windowsPhone || Mn(), U && (Pe(), rt(), Tt(), Si(), Ht(), Kl(), J ? (Fr(), so(), Xs()) : xe()), D && (Ke(), et(), dt(), Dn(), Rt(), rr(), Cs(), Ht(), Ho());
      };
      return d1(e) ? Ln() : Ao(), {
        refreshContentEditable: ll,
        isHidden: wn
      };
    }, cD = Is.DOM, Zte = (e, n) => {
      const s = Fe.fromDom(e.getBody()), l = Dp(Cc(s)), f = Fe.fromTag("style");
      is(f, "type", "text/css"), Ys(f, Fe.fromText(n)), Ys(l, f), e.on("remove", () => {
        mo(f);
      });
    }, sL = (e) => e.inline ? e.getElement().nodeName.toLowerCase() : void 0, aL = (e) => es(e, (n) => Le(n) === !1), KU = (e) => {
      const n = e.options.get, s = e.editorUpload.blobCache;
      return aL({
        allow_conditional_comments: n("allow_conditional_comments"),
        allow_html_data_urls: n("allow_html_data_urls"),
        allow_svg_data_urls: n("allow_svg_data_urls"),
        allow_html_in_named_anchor: n("allow_html_in_named_anchor"),
        allow_script_urls: n("allow_script_urls"),
        allow_unsafe_link_target: n("allow_unsafe_link_target"),
        convert_unsafe_embeds: n("convert_unsafe_embeds"),
        convert_fonts_to_spans: n("convert_fonts_to_spans"),
        fix_list_elements: n("fix_list_elements"),
        font_size_legacy_values: n("font_size_legacy_values"),
        forced_root_block: n("forced_root_block"),
        forced_root_block_attrs: n("forced_root_block_attrs"),
        preserve_cdata: n("preserve_cdata"),
        inline_styles: n("inline_styles"),
        root_name: sL(e),
        sandbox_iframes: n("sandbox_iframes"),
        sanitize: n("xss_sanitization"),
        validate: !0,
        blob_cache: s,
        document: e.getDoc()
      });
    }, YU = (e) => {
      const n = e.options.get;
      return aL({
        custom_elements: n("custom_elements"),
        extended_valid_elements: n("extended_valid_elements"),
        invalid_elements: n("invalid_elements"),
        invalid_styles: n("invalid_styles"),
        schema: n("schema"),
        valid_children: n("valid_children"),
        valid_classes: n("valid_classes"),
        valid_elements: n("valid_elements"),
        valid_styles: n("valid_styles"),
        verify_html: n("verify_html"),
        padd_empty_block_inline_children: n("format_empty_lines")
      });
    }, Kte = (e) => {
      const n = e.options.get;
      return {
        ...KU(e),
        ...YU(e),
        ...aL({
          remove_trailing_brs: n("remove_trailing_brs"),
          pad_empty_with_br: n("pad_empty_with_br"),
          url_converter: n("url_converter"),
          url_converter_scope: n("url_converter_scope"),
          element_format: n("element_format"),
          entities: n("entities"),
          entity_encoding: n("entity_encoding"),
          indent: n("indent"),
          indent_after: n("indent_after"),
          indent_before: n("indent_before")
        })
      };
    }, Yte = (e) => {
      const n = hg(KU(e), e.schema);
      return n.addAttributeFilter("src,href,style,tabindex", (s, l) => {
        const f = e.dom, b = "data-mce-" + l;
        let E = s.length;
        for (; E--; ) {
          const N = s[E];
          let D = N.attr(l);
          if (D && !N.attr(b)) {
            if (D.indexOf("data:") === 0 || D.indexOf("blob:") === 0)
              continue;
            l === "style" ? (D = f.serializeStyle(f.parseStyle(D), N.name), D.length || (D = null), N.attr(b, D), N.attr(l, D)) : l === "tabindex" ? (N.attr(b, D), N.attr(l, null)) : N.attr(b, e.convertURL(D, l, N.name));
          }
        }
      }), n.addNodeFilter("script", (s) => {
        let l = s.length;
        for (; l--; ) {
          const f = s[l], b = f.attr("type") || "no/type";
          b.indexOf("mce-") !== 0 && f.attr("type", "mce-" + b);
        }
      }), Vw(e) && n.addNodeFilter("#cdata", (s) => {
        var l;
        let f = s.length;
        for (; f--; ) {
          const b = s[f];
          b.type = 8, b.name = "#comment", b.value = "[CDATA[" + e.dom.encode((l = b.value) !== null && l !== void 0 ? l : "") + "]]";
        }
      }), n.addNodeFilter("p,h1,h2,h3,h4,h5,h6,div", (s) => {
        let l = s.length;
        const f = e.schema.getNonEmptyElements();
        for (; l--; ) {
          const b = s[l];
          b.isEmpty(f) && b.getAll("br").length === 0 && b.append(new yd("br", 1));
        }
      }), n;
    }, Qte = (e) => {
      const n = Ex(e);
      n && sp.setEditorTimeout(e, () => {
        let s;
        n === !0 ? s = e : s = e.editorManager.get(n), s && !s.destroyed && (s.focus(), s.selection.scrollIntoView());
      }, 100);
    }, lD = (e) => {
      const n = e.dom.getRoot();
      !e.inline && (!Vx(e) || e.selection.getStart(!0) === n) && Wu(n).each((s) => {
        const l = s.getNode(), f = gf(l) ? Wu(l).getOr(s) : s;
        e.selection.setRng(f.toRange());
      });
    }, Xte = (e) => {
      e.bindPendingEventDelegates(), e.initialized = !0, fE(e), e.focus(!0), lD(e), e.nodeChanged({ initial: !0 });
      const n = m_(e);
      Ce(n) && n.call(e, e), Qte(e);
    }, iL = (e) => e.inline ? e.ui.styleSheetLoader : e.dom.styleSheetLoader, Jte = (e, n, s) => {
      const {
        pass: l,
        fail: f
      } = an(n, (N) => tinymce.Resource.has(XF(N))), E = [
        ...l.map((N) => {
          const D = tinymce.Resource.get(XF(N));
          return G(D) ? Promise.resolve(iL(e).loadRawCss(N, D)) : Promise.resolve();
        }),
        iL(e).loadAll(f)
      ];
      return e.inline ? E : E.concat([e.ui.styleSheetLoader.loadAll(s)]);
    }, QU = (e) => {
      const n = iL(e), s = px(e), l = e.contentCSS, f = () => {
        n.unloadAll(l), e.inline || e.ui.styleSheetLoader.unloadAll(s);
      }, b = () => {
        e.removed ? f() : e.on("remove", f);
      };
      if (e.contentStyles.length > 0) {
        let D = "";
        rn.each(e.contentStyles, (U) => {
          D += U + `\r
`;
        }), e.dom.addStyle(D);
      }
      const E = Promise.all(Jte(e, l, s)).then(b).catch(b), N = g0(e);
      return N && Zte(e, N), E;
    }, ene = (e) => {
      const n = e.getDoc(), s = e.getBody();
      Ub(e), h_(e) || (n.body.spellcheck = !1, cD.setAttrib(s, "spellcheck", "false")), e.quirks = Gte(e), RI(e);
      const l = s_(e);
      l !== void 0 && (s.dir = l);
      const f = Cx(e);
      f && e.on("BeforeSetContent", (b) => {
        rn.each(f, (E) => {
          b.content = b.content.replace(E, (N) => "<!--mce:protected " + escape(N) + "-->");
        });
      }), e.on("SetContent", () => {
        e.addVisual(e.getBody());
      }), e.on("compositionstart compositionend", (b) => {
        e.composing = b.type === "compositionstart";
      });
    }, tne = (e) => {
      d1(e) || e.load({
        initial: !0,
        format: "html"
      }), e.startContent = e.getContent({ format: "raw" });
    }, cL = (e) => {
      e.removed !== !0 && (tne(e), Xte(e));
    }, nne = (e) => {
      let n = !1;
      const s = setTimeout(() => {
        n || e.setProgressState(!0);
      }, 500);
      return () => {
        clearTimeout(s), n = !0, e.setProgressState(!1);
      };
    }, XU = (e) => {
      const n = e.getElement();
      let s = e.getDoc();
      e.inline && (cD.addClass(n, "mce-content-body"), e.contentDocument = s = document, e.contentWindow = window, e.bodyElement = n, e.contentAreaContainer = n);
      const l = e.getBody();
      l.disabled = !0, e.readonly = Uy(e), e._editableRoot = Gd(e), !e.readonly && e.hasEditableRoot() && (e.inline && cD.getStyle(l, "position", !0) === "static" && (l.style.position = "relative"), l.contentEditable = "true"), l.disabled = !1, e.editorUpload = TY(e), e.schema = jm(YU(e)), e.dom = Is(s, {
        keep_values: !0,
        url_converter: e.convertURL,
        url_converter_scope: e,
        update_styles: !0,
        root_element: e.inline ? e.getBody() : null,
        collect: e.inline,
        schema: e.schema,
        contentCssCors: sh(e),
        referrerPolicy: Gr(e),
        onSetAttrib: (E) => {
          e.dispatch("SetAttrib", E);
        },
        force_hex_color: Mb(e)
      }), e.parser = Yte(e), e.serializer = _H(Kte(e), e), e.selection = rS(e.dom, e.getWin(), e.serializer, e), e.annotator = z_(e), e.formatter = n3(e), e.undoManager = r3(e), e._nodeChangeDispatcher = new AV(e), e._selectionOverrides = Dte(e), jQ(e), ote(e), Wce(e), d1(e) || (dU(e), qte(e));
      const f = dee(e);
      FE(e, f), KQ(e), vg(e), tte(e);
      const b = SK(e);
      ene(e), b.fold(() => {
        const E = nne(e);
        QU(e).then(() => {
          cL(e), E();
        });
      }, (E) => {
        e.setProgressState(!0), QU(e).then(() => {
          E().then((N) => {
            e.setProgressState(!1), cL(e), qF(e);
          }, (N) => {
            e.notificationManager.open({
              type: "error",
              text: String(N)
            }), cL(e), qF(e);
          });
        });
      });
    }, JU = ut, rne = (e, n, s) => Vg(e, n, JU, s), uD = Is.DOM, one = (e, n, s, l) => {
      const f = Fe.fromTag("iframe");
      return l.each((b) => is(f, "tabindex", b)), ru(f, s), ru(f, {
        id: e + "_ifr",
        frameBorder: "0",
        allowTransparency: "true",
        title: n
      }), nd(f, "tox-edit-area__iframe"), f;
    }, sne = (e) => {
      let n = Nw(e) + "<html><head>";
      pd(e) !== e.documentBaseUrl && (n += '<base href="' + e.documentBaseURI.getURI() + '" />'), n += '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />';
      const s = p0(e), l = X2(e), f = e.translate(f_(e));
      return aa(e) && (n += '<meta http-equiv="Content-Security-Policy" content="' + aa(e) + '" />'), n += `</head><body id="${s}" class="mce-content-body ${l}" data-id="${e.id}" aria-label="${f}"><br></body></html>`, n;
    }, e9 = (e, n) => {
      const s = e.translate("Rich Text Area"), l = ri(Fe.fromDom(e.getElement()), "tabindex").bind(td), f = one(e.id, s, Uo(e), l).dom;
      f.onload = () => {
        f.onload = null, e.dispatch("load");
      }, e.contentAreaContainer = n.iframeContainer, e.iframeElement = f, e.iframeHTML = sne(e), uD.add(n.iframeContainer, f);
    }, yA = (e) => {
      const n = e.iframeElement, s = () => {
        e.contentDocument = n.contentDocument, XU(e);
      };
      if (S_(e) || kn.browser.isFirefox()) {
        const l = e.getDoc();
        l.open(), l.write(e.iframeHTML), l.close(), s();
      } else {
        const l = rne(Fe.fromDom(n), "load", () => {
          l.unbind(), s();
        });
        n.srcdoc = e.iframeHTML;
      }
    }, ane = (e, n) => {
      e9(e, n), n.editorContainer && (n.editorContainer.style.display = e.orgDisplay, e.hidden = uD.isHidden(n.editorContainer)), e.getElement().style.display = "none", uD.setAttrib(e.id, "aria-hidden", "true"), e.getElement().style.visibility = e.orgVisibility, yA(e);
    }, lL = Is.DOM, ine = (e, n, s) => {
      const l = PE.get(s), f = PE.urls[s] || e.documentBaseUrl.replace(/\/$/, "");
      if (s = rn.trim(s), l && rn.inArray(n, s) === -1) {
        if (e.plugins[s])
          return;
        try {
          const b = l(e, f) || {};
          e.plugins[s] = b, Ce(b.init) && (b.init(e, f), n.push(s));
        } catch (b) {
          LH(e, s, b);
        }
      }
    }, cne = (e) => e.replace(/^\-/, ""), lne = (e) => {
      const n = [];
      ke(Wy(e), (s) => {
        ine(e, n, cne(s));
      });
    }, une = (e) => {
      const n = rn.trim(Pw(e)), s = e.ui.registry.getAll().icons, l = {
        ...MO.get("default").icons,
        ...MO.get(n).icons
      };
      fn(l, (f, b) => {
        lr(s, b) || e.ui.registry.addIcon(b, f);
      });
    }, t9 = (e) => {
      const n = Rb(e);
      if (G(n)) {
        const s = f1.get(n);
        e.theme = s(e, f1.urls[n]) || {}, Ce(e.theme.init) && e.theme.init(e, f1.urls[n] || e.documentBaseUrl.replace(/\/$/, ""));
      } else
        e.theme = {};
    }, dne = (e) => {
      const n = v0(e), s = yh.get(n);
      e.model = s(e, yh.urls[n]);
    }, n9 = (e) => {
      const n = e.theme.renderUI;
      return n ? n() : o9(e);
    }, fne = (e) => {
      const n = e.getElement(), l = Rb(e)(e, n);
      return l.editorContainer.nodeType && (l.editorContainer.id = l.editorContainer.id || e.id + "_parent"), l.iframeContainer && l.iframeContainer.nodeType && (l.iframeContainer.id = l.iframeContainer.id || e.id + "_iframecontainer"), l.height = l.iframeHeight ? l.iframeHeight : n.offsetHeight, l;
    }, r9 = (e, n) => ({
      editorContainer: e,
      iframeContainer: n,
      api: {}
    }), mne = (e) => {
      const n = lL.create("div");
      return lL.insertAfter(n, e), r9(n, n);
    }, o9 = (e) => {
      const n = e.getElement();
      return e.inline ? r9(null) : mne(n);
    }, pne = (e) => {
      const n = e.getElement();
      return e.orgDisplay = n.style.display, G(Rb(e)) ? n9(e) : Ce(Rb(e)) ? fne(e) : o9(e);
    }, hne = (e, n) => {
      const s = {
        show: oe.from(n.show).getOr(Lt),
        hide: oe.from(n.hide).getOr(Lt),
        isEnabled: oe.from(n.isEnabled).getOr(ut),
        setEnabled: (l) => {
          e.mode.isReadOnly() || oe.from(n.setEnabled).each((f) => f(l));
        }
      };
      e.ui = {
        ...e.ui,
        ...s
      };
    }, gne = async (e) => {
      e.dispatch("ScriptsLoaded"), une(e), t9(e), dne(e), lne(e);
      const n = await pne(e);
      hne(e, oe.from(n.api).getOr({})), e.editorContainer = n.editorContainer, hY(e), e.inline ? XU(e) : ane(e, {
        editorContainer: n.editorContainer,
        iframeContainer: n.iframeContainer
      });
    }, VE = Is.DOM, s9 = (e) => e.charAt(0) === "-", a9 = (e, n) => {
      const s = Iw(n), l = Cl(n);
      if (!Af.hasCode(s) && s !== "en") {
        const f = $o(l) ? l : `${n.editorManager.baseURL}/langs/${s}.js`;
        e.add(f).catch(() => {
          LO(n, f, s);
        });
      }
    }, uL = (e, n) => {
      const s = Rb(e);
      if (G(s) && !s9(s) && !lr(f1.urls, s)) {
        const l = i_(e), f = l ? e.documentBaseURI.toAbsolute(l) : `themes/${s}/theme${n}.js`;
        f1.load(s, f).catch(() => {
          dY(e, f, s);
        });
      }
    }, i9 = (e, n) => {
      const s = v0(e);
      if (s !== "plugin" && !lr(yh.urls, s)) {
        const l = Mw(e), f = G(l) ? e.documentBaseURI.toAbsolute(l) : `models/${s}/model${n}.js`;
        yh.load(s, f).catch(() => {
          FH(e, f, s);
        });
      }
    }, c9 = (e) => oe.from(cv(e)).filter($o).map((n) => ({
      url: n,
      name: oe.none()
    })), l9 = (e, n, s) => oe.from(n).filter((l) => $o(l) && !MO.has(l)).map((l) => ({
      url: `${e.editorManager.baseURL}/icons/${l}/icons${s}.js`,
      name: oe.some(l)
    })), vne = (e, n, s) => {
      const l = l9(n, "default", s), f = c9(n).orThunk(() => l9(n, Pw(n), ""));
      ke(Ta([
        l,
        f
      ]), (b) => {
        e.add(b.url).catch(() => {
          uY(n, b.url, b.name.getOrUndefined());
        });
      });
    }, bne = (e, n) => {
      const s = (l, f) => {
        PE.load(l, f).catch(() => {
          zce(e, f, l);
        });
      };
      fn(rg(e), (l, f) => {
        s(f, l), e.options.set("plugins", Wy(e).concat(f));
      }), ke(Wy(e), (l) => {
        l = rn.trim(l), l && !PE.urls[l] && !s9(l) && s(l, `plugins/${l}/plugin${n}.js`);
      });
    }, u9 = (e) => {
      const n = Rb(e);
      return !G(n) || Ie(f1.get(n));
    }, d9 = (e) => {
      const n = v0(e);
      return Ie(yh.get(n));
    }, yne = (e, n) => {
      const s = Ti.ScriptLoader, l = () => {
        !e.removed && u9(e) && d9(e) && gne(e);
      };
      uL(e, n), i9(e, n), a9(s, e), vne(s, e, n), bne(e, n), s.loadQueue().then(l, l);
    }, Sne = (e, n) => sw.forElement(e, {
      contentCssCors: $b(n),
      referrerPolicy: Gr(n)
    }), dL = (e) => {
      const n = e.id;
      Af.setCode(Iw(e));
      const s = () => {
        VE.unbind(window, "ready", s), e.render();
      };
      if (!hu.Event.domLoaded) {
        VE.bind(window, "ready", s);
        return;
      }
      if (!e.getElement())
        return;
      const l = Fe.fromDom(e.getElement()), f = cf(l);
      e.on("remove", () => {
        Ct(l.dom.attributes, (E) => Vs(l, E.name)), ru(l, f);
      }), e.ui.styleSheetLoader = Sne(l, e), Fw(e) ? e.inline = !0 : (e.orgVisibility = e.getElement().style.visibility, e.getElement().style.visibility = "hidden");
      const b = e.getElement().form || VE.getParent(n, "form");
      b && (e.formElement = b, l_(e) && !sm(e.getElement()) && (VE.insertAfter(VE.create("input", {
        type: "hidden",
        name: n
      }), n), e.hasHiddenInput = !0), e.formEventDelegate = (E) => {
        e.dispatch(E.type, E);
      }, VE.bind(b, "submit reset", e.formEventDelegate), e.on("reset", () => {
        e.resetContent();
      }), Sx(e) && !b.submit.nodeType && !b.submit.length && !b._mceOldSubmit && (b._mceOldSubmit = b.submit, b.submit = () => (e.editorManager.triggerSave(), e.setDirty(!1), b._mceOldSubmit(b)))), e.windowManager = MH(e), e.notificationManager = QF(e), Ww(e) && e.on("GetContent", (E) => {
        E.save && (E.content = VE.encode(E.content));
      }), ep(e) && e.on("submit", () => {
        e.initialized && e.save();
      }), Pb(e) && (e._beforeUnload = () => {
        e.initialized && !e.destroyed && !e.isHidden() && e.save({
          format: "raw",
          no_events: !0,
          set_dirty: !1
        });
      }, e.editorManager.on("BeforeUnload", e._beforeUnload)), e.editorManager.add(e), yne(e, e.suffix);
    }, dD = (e, n) => {
      e._editableRoot !== n && (e._editableRoot = n, e.readonly || (e.getBody().contentEditable = String(e.hasEditableRoot()), e.nodeChanged()), MI(e, n));
    }, fD = (e) => e._editableRoot, g1 = (e, n) => ({
      sections: at(e),
      options: at(n)
    }), SA = Lr().deviceType, UE = SA.isPhone(), f9 = SA.isTablet(), wA = (e) => {
      if (je(e))
        return [];
      {
        const n = be(e) ? e : e.split(/[ ,]/), s = St(n, Xu);
        return ht(s, $o);
      }
    }, wne = (e, n) => {
      const s = wi(n, (l, f) => Ge(e, f));
      return g1(s.t, s.f);
    }, m9 = (e, n, s = {}) => {
      const l = e.sections(), f = gs(l, n).getOr({});
      return rn.extend({}, s, f);
    }, fL = (e, n) => lr(e.sections(), n), mL = (e, n) => fL(e, n) ? e.sections()[n] : {}, mD = (e, n) => ({
      ...{
        table_grid: !1,
        object_resizing: !1,
        resize: !1,
        toolbar_mode: gs(e, "toolbar_mode").getOr("scrolling"),
        toolbar_sticky: !1
      },
      ...n ? { menubar: !1 } : {}
    }), vS = (e, n) => {
      var s;
      const l = (s = n.external_plugins) !== null && s !== void 0 ? s : {};
      return e && e.external_plugins ? rn.extend({}, e.external_plugins, l) : l;
    }, WE = (e, n) => [
      ...wA(e),
      ...wA(n)
    ], p9 = (e, n, s, l) => e && fL(n, "mobile") ? l : s, Ene = (e, n, s, l) => {
      const f = wA(s.forced_plugins), b = wA(l.plugins), E = mL(n, "mobile"), N = E.plugins ? wA(E.plugins) : b, D = p9(e, n, b, N), U = WE(f, D);
      return rn.extend(l, {
        forced_plugins: f,
        plugins: U
      });
    }, Cne = (e, n) => e && fL(n, "mobile"), xne = (e, n, s, l, f) => {
      var b;
      const E = e ? { mobile: mD((b = f.mobile) !== null && b !== void 0 ? b : {}, n) } : {}, N = wne(["mobile"], iA(E, f)), D = rn.extend(s, l, N.options(), Cne(e, N) ? m9(N, "mobile") : {}, { external_plugins: vS(l, N.options()) });
      return Ene(e, N, l, D);
    }, Tne = (e, n) => xne(UE || f9, UE, n, e, n), _ne = (e, n) => PK(e, n), One = (e) => {
      const n = (l, f) => {
        e.formatter.toggle(l, f), e.nodeChanged();
      }, s = (l) => () => {
        ke("left,center,right,justify".split(","), (f) => {
          l !== f && e.formatter.remove("align" + f);
        }), l !== "none" && n("align" + l);
      };
      e.editorCommands.addCommands({
        JustifyLeft: s("left"),
        JustifyCenter: s("center"),
        JustifyRight: s("right"),
        JustifyFull: s("justify"),
        JustifyNone: s("none")
      });
    }, h9 = (e) => {
      const n = (s) => () => {
        const l = e.selection, f = l.isCollapsed() ? [e.dom.getParent(l.getNode(), e.dom.isBlock)] : l.getSelectedBlocks();
        return qt(f, (b) => Ie(e.formatter.matchNode(b, s)));
      };
      e.editorCommands.addCommands({
        JustifyLeft: n("alignleft"),
        JustifyCenter: n("aligncenter"),
        JustifyRight: n("alignright"),
        JustifyFull: n("alignjustify")
      }, "state");
    }, Ane = (e) => {
      One(e), h9(e);
    }, kne = (e) => {
      e.editorCommands.addCommands({
        "Cut,Copy,Paste": (n) => {
          const s = e.getDoc();
          let l;
          try {
            s.execCommand(n);
          } catch {
            l = !0;
          }
          if (n === "paste" && !s.queryCommandEnabled(n) && (l = !0), l || !s.queryCommandSupported(n)) {
            let f = e.translate("Your browser doesn't support direct access to the clipboard. Please use the Ctrl+X/C/V keyboard shortcuts instead.");
            (kn.os.isMacOS() || kn.os.isiOS()) && (f = f.replace(/Ctrl\+/g, "+")), e.notificationManager.open({
              text: f,
              type: "error"
            });
          }
        }
      });
    }, Nne = (e, n, s, l) => {
      const f = Fe.fromDom(e.getRoot());
      return aT(f, yt.fromRangeStart(n), l) ? s = s.replace(/^ /, "&nbsp;") : s = s.replace(/^&nbsp;/, " "), iT(f, yt.fromRangeEnd(n), l) ? s = s.replace(/(&nbsp;| )(<br( \/)>)?$/, "&nbsp;") : s = s.replace(/&nbsp;(<br( \/)?>)?$/, " "), s;
    }, dle = (e) => {
      if (typeof e != "string") {
        const n = rn.extend({
          paste: e.paste,
          data: { paste: e.paste }
        }, e);
        return {
          content: e.content,
          details: n
        };
      }
      return {
        content: e,
        details: {}
      };
    }, Rne = (e, n) => {
      const s = e.selection, l = e.dom;
      return /^ | $/.test(n) ? Nne(l, s.getRng(), n, e.schema) : n;
    }, GT = (e, n) => {
      if (e.selection.isEditable()) {
        const { content: s, details: l } = dle(n);
        xF(e, {
          ...l,
          content: Rne(e, s),
          format: "html",
          set: !1,
          selection: !0
        }).each((f) => {
          const b = NK(e, f.content, l);
          OR(e, b, f), e.addVisual();
        });
      }
    }, Pne = (e) => {
      e.editorCommands.addCommands({
        mceCleanup: () => {
          const n = e.selection.getBookmark();
          e.setContent(e.getContent()), e.selection.moveToBookmark(n);
        },
        insertImage: (n, s, l) => {
          GT(e, e.dom.createHTML("img", { src: l }));
        },
        insertHorizontalRule: () => {
          e.execCommand("mceInsertContent", !1, "<hr>");
        },
        insertText: (n, s, l) => {
          GT(e, e.dom.encode(l));
        },
        insertHTML: (n, s, l) => {
          GT(e, l);
        },
        mceInsertContent: (n, s, l) => {
          GT(e, l);
        },
        mceSetContent: (n, s, l) => {
          e.setContent(l);
        },
        mceReplaceContent: (n, s, l) => {
          e.execCommand("mceInsertContent", !1, l.replace(/\{\$selection\}/g, e.selection.getContent({ format: "text" })));
        },
        mceNewDocument: () => {
          e.setContent(Ib(e));
        }
      });
    }, Dne = {
      "font-size": "size",
      "font-family": "face"
    }, g9 = Fl("font"), $ne = (e, n, s) => {
      const l = (b) => Aa(b, e).orThunk(() => g9(b) ? gs(Dne, e).bind((E) => ri(b, E)) : oe.none()), f = (b) => Je(Fe.fromDom(n), b);
      return GM(Fe.fromDom(s), (b) => l(b), f);
    }, v9 = (e) => e.replace(/[\'\"\\]/g, "").replace(/,\s+/g, ","), Ine = (e, n) => oe.from(Is.DOM.getStyle(n, e, !0)), pD = (e) => (n, s) => oe.from(s).map(Fe.fromDom).filter(Mi).bind((l) => $ne(e, n, l.dom).or(Ine(e, l.dom))).getOr(""), Mne = pD("font-size"), Fne = z(v9, pD("font-family")), Lne = (e) => Wu(e.getBody()).bind((n) => {
      const s = n.container();
      return oe.from(Qt(s) ? s.parentNode : s);
    }), Bne = (e) => oe.from(e.selection.getRng()).bind((n) => {
      const s = e.getBody();
      return n.startContainer === s && n.startOffset === 0 ? oe.none() : oe.from(e.selection.getStart(!0));
    }), b9 = (e, n) => Bne(e).orThunk(Ne(Lne, e)).map(Fe.fromDom).filter(Mi).bind(n), EA = (e, n) => b9(e, bt(oe.some, n)), pL = (e, n) => {
      if (/^[0-9.]+$/.test(n)) {
        const s = parseInt(n, 10);
        if (s >= 1 && s <= 7) {
          const l = w_(e), f = E_(e);
          return f.length > 0 ? f[s - 1] || n : l[s - 1] || n;
        } else
          return n;
      } else
        return n;
    }, hL = (e) => {
      const n = e.split(/\s*,\s*/);
      return St(n, (s) => s.indexOf(" ") !== -1 && !(Gs(s, '"') || Gs(s, "'")) ? `'${s}'` : s).join(",");
    }, Hne = (e, n) => {
      const s = pL(e, n);
      e.formatter.toggle("fontname", { value: hL(s) }), e.nodeChanged();
    }, fle = (e) => EA(e, (n) => Fne(e.getBody(), n.dom)).getOr(""), mle = (e, n) => {
      e.formatter.toggle("fontsize", { value: pL(e, n) }), e.nodeChanged();
    }, zne = (e) => EA(e, (n) => Mne(e.getBody(), n.dom)).getOr(""), y9 = (e) => EA(e, (n) => {
      const s = Fe.fromDom(e.getBody()), l = GM(n, (b) => Aa(b, "line-height"), Ne(Je, s)), f = () => {
        const b = parseFloat(va(n, "line-height")), E = parseFloat(va(n, "font-size"));
        return String(b / E);
      };
      return l.getOrThunk(f);
    }).getOr(""), Vne = (e, n) => {
      e.formatter.toggle("lineheight", { value: String(n) }), e.nodeChanged();
    }, Une = (e) => {
      const n = (s, l) => {
        e.formatter.toggle(s, l), e.nodeChanged();
      };
      e.editorCommands.addCommands({
        "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": (s) => {
          n(s);
        },
        "ForeColor,HiliteColor": (s, l, f) => {
          n(s, { value: f });
        },
        BackColor: (s, l, f) => {
          n("hilitecolor", { value: f });
        },
        FontName: (s, l, f) => {
          Hne(e, f);
        },
        FontSize: (s, l, f) => {
          mle(e, f);
        },
        LineHeight: (s, l, f) => {
          Vne(e, f);
        },
        Lang: (s, l, f) => {
          var b;
          n(s, {
            value: f.code,
            customValue: (b = f.customCode) !== null && b !== void 0 ? b : null
          });
        },
        RemoveFormat: (s) => {
          e.formatter.remove(s);
        },
        mceBlockQuote: () => {
          n("blockquote");
        },
        FormatBlock: (s, l, f) => {
          n(G(f) ? f : "p");
        },
        mceToggleFormat: (s, l, f) => {
          n(f);
        }
      });
    }, Wne = (e) => {
      const n = (s) => e.formatter.match(s);
      e.editorCommands.addCommands({
        "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": (s) => n(s),
        mceBlockQuote: () => n("blockquote")
      }, "state"), e.editorCommands.addQueryValueHandler("FontName", () => fle(e)), e.editorCommands.addQueryValueHandler("FontSize", () => zne(e)), e.editorCommands.addQueryValueHandler("LineHeight", () => y9(e));
    }, ple = (e) => {
      Une(e), Wne(e);
    }, hle = (e) => {
      e.editorCommands.addCommands({
        mceAddUndoLevel: () => {
          e.undoManager.add();
        },
        mceEndUndoLevel: () => {
          e.undoManager.add();
        },
        Undo: () => {
          e.undoManager.undo();
        },
        Redo: () => {
          e.undoManager.redo();
        }
      });
    }, S9 = (e) => {
      e.editorCommands.addCommands({
        Indent: () => {
          WQ(e);
        },
        Outdent: () => {
          H3(e);
        }
      }), e.editorCommands.addCommands({ Outdent: () => lP(e) }, "state");
    }, w9 = (e) => {
      const n = (s, l, f) => {
        const b = G(f) ? { href: f } : f, E = e.dom.getParent(e.selection.getNode(), "a");
        me(b) && G(b.href) && (b.href = b.href.replace(/ /g, "%20"), (!E || !b.href) && e.formatter.remove("link"), b.href && e.formatter.apply("link", b, E));
      };
      e.editorCommands.addCommands({
        unlink: () => {
          if (e.selection.isEditable()) {
            if (e.selection.isCollapsed()) {
              const s = e.dom.getParent(e.selection.getStart(), "a");
              s && e.dom.remove(s, !0);
              return;
            }
            e.formatter.remove("link");
          }
        },
        mceInsertLink: n,
        createLink: n
      });
    }, jne = (e) => {
      e.editorCommands.addCommands({
        "InsertUnorderedList,InsertOrderedList": (n) => {
          e.getDoc().execCommand(n);
          const s = e.dom.getParent(e.selection.getNode(), "ol,ul");
          if (s) {
            const l = s.parentNode;
            if (l && /^(H[1-6]|P|ADDRESS|PRE)$/.test(l.nodeName)) {
              const f = e.selection.getBookmark();
              e.dom.split(l, s), e.selection.moveToBookmark(f);
            }
          }
        }
      });
    }, qne = (e) => {
      e.editorCommands.addCommands({
        "InsertUnorderedList,InsertOrderedList": (n) => {
          const s = e.dom.getParent(e.selection.getNode(), "ul,ol");
          return s && (n === "insertunorderedlist" && s.tagName === "UL" || n === "insertorderedlist" && s.tagName === "OL");
        }
      }, "state");
    }, Gne = (e) => {
      jne(e), qne(e);
    }, gle = (e, n, s, l) => {
      const f = e.dom, b = (N) => f.isBlock(N) && N.parentElement === s, E = b(n) ? n : f.getParent(l, b, s);
      return oe.from(E).map(Fe.fromDom);
    }, Zne = (e, n) => {
      const s = e.dom, l = e.selection.getRng(), f = n ? e.selection.getStart() : e.selection.getEnd(), b = n ? l.startContainer : l.endContainer, E = up(s, b);
      if (!E || !E.isContentEditable)
        return;
      const N = n ? ba : tl, D = al(e);
      gle(e, f, E, b).each((U) => {
        const J = w4(e, b, U.dom, E, !1, D);
        N(U, Fe.fromDom(J)), e.selection.setCursorLocation(J, 0), e.dispatch("NewBlock", { newBlock: J }), lA(e, "insertParagraph");
      });
    }, vle = (e) => Zne(e, !0), Kne = (e) => Zne(e, !1), ble = (e) => {
      e.editorCommands.addCommands({
        InsertNewBlockBefore: () => {
          vle(e);
        },
        InsertNewBlockAfter: () => {
          Kne(e);
        }
      });
    }, Yne = (e) => {
      e.editorCommands.addCommands({
        insertParagraph: () => {
          IP(uV, e);
        },
        mceInsertNewLine: (n, s, l) => {
          hV(e, l);
        },
        InsertLineBreak: (n, s, l) => {
          IP(KJ, e);
        }
      });
    }, jE = (e) => {
      e.editorCommands.addCommands({
        mceSelectNodeDepth: (n, s, l) => {
          let f = 0;
          e.dom.getParent(e.selection.getNode(), (b) => Un(b) && f++ === l ? (e.selection.select(b), !1) : !0, e.getBody());
        },
        mceSelectNode: (n, s, l) => {
          e.selection.select(l);
        },
        selectAll: () => {
          const n = e.dom.getParent(e.selection.getStart(), Dc);
          if (n) {
            const s = e.dom.createRng();
            s.selectNodeContents(n), e.selection.setRng(s);
          }
        }
      });
    }, gL = (e) => {
      e.editorCommands.addCommands({
        mceRemoveNode: (n, s, l) => {
          const f = l ?? e.selection.getNode();
          if (f !== e.getBody()) {
            const b = e.selection.getBookmark();
            e.dom.remove(f, !0), e.selection.moveToBookmark(b);
          }
        },
        mcePrint: () => {
          e.getWin().print();
        },
        mceFocus: (n, s, l) => {
          zq(e, l === !0);
        },
        mceToggleVisualAid: () => {
          e.hasVisual = !e.hasVisual, e.addVisual();
        }
      });
    }, hD = (e) => {
      Ane(e), kne(e), hle(e), jE(e), Pne(e), w9(e), S9(e), ble(e), Yne(e), Gne(e), ple(e), gL(e);
    }, E9 = ["toggleview"], vL = (e) => Ge(E9, e.toLowerCase());
    class bL {
      constructor(n) {
        this.commands = {
          state: {},
          exec: {},
          value: {}
        }, this.editor = n;
      }
      execCommand(n, s = !1, l, f) {
        const b = this.editor, E = n.toLowerCase(), N = f == null ? void 0 : f.skip_focus;
        if (b.removed || (E !== "mcefocus" && (!/^(mceAddUndoLevel|mceEndUndoLevel)$/i.test(E) && !N ? b.focus() : Oq(b)), b.dispatch("BeforeExecCommand", {
          command: n,
          ui: s,
          value: l
        }).isDefaultPrevented()))
          return !1;
        const U = this.commands.exec[E];
        return Ce(U) ? (U(E, s, l), b.dispatch("ExecCommand", {
          command: n,
          ui: s,
          value: l
        }), !0) : !1;
      }
      queryCommandState(n) {
        if (!vL(n) && this.editor.quirks.isHidden() || this.editor.removed)
          return !1;
        const s = n.toLowerCase(), l = this.commands.state[s];
        return Ce(l) ? l(s) : !1;
      }
      queryCommandValue(n) {
        if (!vL(n) && this.editor.quirks.isHidden() || this.editor.removed)
          return "";
        const s = n.toLowerCase(), l = this.commands.value[s];
        return Ce(l) ? l(s) : "";
      }
      addCommands(n, s = "exec") {
        const l = this.commands;
        fn(n, (f, b) => {
          ke(b.toLowerCase().split(","), (E) => {
            l[s][E] = f;
          });
        });
      }
      addCommand(n, s, l) {
        const f = n.toLowerCase();
        this.commands.exec[f] = (b, E, N) => s.call(l ?? this.editor, E, N);
      }
      queryCommandSupported(n) {
        const s = n.toLowerCase();
        return !!this.commands.exec[s];
      }
      addQueryStateHandler(n, s, l) {
        this.commands.state[n.toLowerCase()] = () => s.call(l ?? this.editor);
      }
      addQueryValueHandler(n, s, l) {
        this.commands.value[n.toLowerCase()] = () => s.call(l ?? this.editor);
      }
    }
    const qE = "data-mce-contenteditable", Qne = (e, n, s) => {
      Id(e, n) && !s ? wc(e, n) : s && nd(e, n);
    }, yL = (e, n, s) => {
      try {
        e.getDoc().execCommand(n, !1, String(s));
      } catch {
      }
    }, gD = (e, n) => {
      e.dom.contentEditable = n ? "true" : "false";
    }, bS = (e) => {
      ke(Vi(e, '*[contenteditable="true"]'), (n) => {
        is(n, qE, "true"), gD(n, !1);
      });
    }, Xne = (e) => {
      ke(Vi(e, `*[${qE}="true"]`), (n) => {
        Vs(n, qE), gD(n, !0);
      });
    }, C9 = (e) => {
      oe.from(e.selection.getNode()).each((n) => {
        n.removeAttribute("data-mce-selected");
      });
    }, Jne = (e) => {
      e.selection.setRng(e.selection.getRng());
    }, vD = (e, n) => {
      const s = Fe.fromDom(e.getBody());
      Qne(s, "mce-content-readonly", n), n ? (e.selection.controlSelection.hideResizeRect(), e._selectionOverrides.hideFakeCaret(), C9(e), e.readonly = !0, gD(s, !1), bS(s)) : (e.readonly = !1, e.hasEditableRoot() && gD(s, !0), Xne(s), yL(e, "StyleWithCSS", !1), yL(e, "enableInlineTableEditing", !1), yL(e, "enableObjectResizing", !1), w5(e) && e.focus(), Jne(e), e.nodeChanged());
    }, GE = (e) => e.readonly, x9 = (e) => {
      e.parser.addAttributeFilter("contenteditable", (n) => {
        GE(e) && ke(n, (s) => {
          s.attr(qE, s.attr("contenteditable")), s.attr("contenteditable", "false");
        });
      }), e.serializer.addAttributeFilter(qE, (n) => {
        GE(e) && ke(n, (s) => {
          s.attr("contenteditable", s.attr(qE));
        });
      }), e.serializer.addTempAttr(qE);
    }, ere = (e) => {
      e.serializer ? x9(e) : e.on("PreInit", () => {
        x9(e);
      });
    }, T9 = (e) => e.type === "click", tre = ["copy"], nre = (e) => Ge(tre, e.type), rre = (e, n) => au(n, "a", (l) => Je(l, Fe.fromDom(e.getBody()))).bind((l) => ri(l, "href")), SL = (e, n) => {
      if (T9(n) && !zn.metaKeyPressed(n)) {
        const s = Fe.fromDom(n.target);
        rre(e, s).each((l) => {
          if (n.preventDefault(), /^#/.test(l)) {
            const f = e.dom.select(`${l},[name="${em(l, "#")}"]`);
            f.length && e.selection.scrollIntoView(f[0], !0);
          } else
            window.open(l, "_blank", "rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes");
        });
      } else
        nre(n) && e.dispatch(n.type, n);
    }, ore = (e) => {
      e.on("ShowCaret", (n) => {
        GE(e) && n.preventDefault();
      }), e.on("ObjectSelected", (n) => {
        GE(e) && n.preventDefault();
      });
    }, sre = rn.makeMap("focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover draggesture dragdrop drop drag submit compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel", " ");
    class ic {
      static isNative(n) {
        return !!sre[n.toLowerCase()];
      }
      constructor(n) {
        this.bindings = {}, this.settings = n || {}, this.scope = this.settings.scope || this, this.toggleEvent = this.settings.toggleEvent || He;
      }
      fire(n, s) {
        return this.dispatch(n, s);
      }
      dispatch(n, s) {
        const l = n.toLowerCase(), f = vb(l, s ?? {}, this.scope);
        this.settings.beforeFire && this.settings.beforeFire(f);
        const b = this.bindings[l];
        if (b)
          for (let E = 0, N = b.length; E < N; E++) {
            const D = b[E];
            if (!D.removed) {
              if (D.once && this.off(l, D.func), f.isImmediatePropagationStopped())
                return f;
              if (D.func.call(this.scope, f) === !1)
                return f.preventDefault(), f;
            }
          }
        return f;
      }
      on(n, s, l, f) {
        if (s === !1 && (s = He), s) {
          const b = {
            func: s,
            removed: !1
          };
          f && rn.extend(b, f);
          const E = n.toLowerCase().split(" ");
          let N = E.length;
          for (; N--; ) {
            const D = E[N];
            let U = this.bindings[D];
            U || (U = [], this.toggleEvent(D, !0)), l ? U = [
              b,
              ...U
            ] : U = [
              ...U,
              b
            ], this.bindings[D] = U;
          }
        }
        return this;
      }
      off(n, s) {
        if (n) {
          const l = n.toLowerCase().split(" ");
          let f = l.length;
          for (; f--; ) {
            const b = l[f];
            let E = this.bindings[b];
            if (!b)
              return fn(this.bindings, (N, D) => {
                this.toggleEvent(D, !1), delete this.bindings[D];
              }), this;
            if (E) {
              if (!s)
                E.length = 0;
              else {
                const N = an(E, (D) => D.func === s);
                E = N.fail, this.bindings[b] = E, ke(N.pass, (D) => {
                  D.removed = !0;
                });
              }
              E.length || (this.toggleEvent(n, !1), delete this.bindings[b]);
            }
          }
        } else
          fn(this.bindings, (l, f) => {
            this.toggleEvent(f, !1);
          }), this.bindings = {};
        return this;
      }
      once(n, s, l) {
        return this.on(n, s, l, { once: !0 });
      }
      has(n) {
        n = n.toLowerCase();
        const s = this.bindings[n];
        return !(!s || s.length === 0);
      }
    }
    const CA = (e) => (e._eventDispatcher || (e._eventDispatcher = new ic({
      scope: e,
      toggleEvent: (n, s) => {
        ic.isNative(n) && e.toggleNativeEvent && e.toggleNativeEvent(n, s);
      }
    })), e._eventDispatcher), wL = {
      fire(e, n, s) {
        return this.dispatch(e, n, s);
      },
      dispatch(e, n, s) {
        const l = this;
        if (l.removed && e !== "remove" && e !== "detach")
          return vb(e.toLowerCase(), n ?? {}, l);
        const f = CA(l).dispatch(e, n);
        if (s !== !1 && l.parent) {
          let b = l.parent();
          for (; b && !f.isPropagationStopped(); )
            b.dispatch(e, f, !1), b = b.parent ? b.parent() : void 0;
        }
        return f;
      },
      on(e, n, s) {
        return CA(this).on(e, n, s);
      },
      off(e, n) {
        return CA(this).off(e, n);
      },
      once(e, n) {
        return CA(this).once(e, n);
      },
      hasEventListeners(e) {
        return CA(this).has(e);
      }
    }, ZT = Is.DOM;
    let yS;
    const KT = (e, n) => {
      if (n === "selectionchange")
        return e.getDoc();
      if (!e.inline && /^(?:mouse|touch|click|contextmenu|drop|dragover|dragend)/.test(n))
        return e.getDoc().documentElement;
      const s = ah(e);
      return s ? (e.eventRoot || (e.eventRoot = ZT.select(s)[0]), e.eventRoot) : e.getBody();
    }, are = (e) => !e.hidden && !GE(e), _9 = (e, n, s) => {
      are(e) ? e.dispatch(n, s) : GE(e) && SL(e, s);
    }, O9 = (e, n) => {
      if (e.delegates || (e.delegates = {}), e.delegates[n] || e.removed)
        return;
      const s = KT(e, n);
      if (ah(e)) {
        if (yS || (yS = {}, e.editorManager.on("removeEditor", () => {
          e.editorManager.activeEditor || yS && (fn(yS, (f, b) => {
            e.dom.unbind(KT(e, b));
          }), yS = null);
        })), yS[n])
          return;
        const l = (f) => {
          const b = f.target, E = e.editorManager.get();
          let N = E.length;
          for (; N--; ) {
            const D = E[N].getBody();
            (D === b || ZT.isChildOf(b, D)) && _9(E[N], n, f);
          }
        };
        yS[n] = l, ZT.bind(s, n, l);
      } else {
        const l = (f) => {
          _9(e, n, f);
        };
        ZT.bind(s, n, l), e.delegates[n] = l;
      }
    }, A9 = {
      ...wL,
      bindPendingEventDelegates() {
        const e = this;
        rn.each(e._pendingNativeEvents, (n) => {
          O9(e, n);
        });
      },
      toggleNativeEvent(e, n) {
        const s = this;
        e === "focus" || e === "blur" || s.removed || (n ? s.initialized ? O9(s, e) : s._pendingNativeEvents ? s._pendingNativeEvents.push(e) : s._pendingNativeEvents = [e] : s.initialized && s.delegates && (s.dom.unbind(KT(s, e), e, s.delegates[e]), delete s.delegates[e]));
      },
      unbindAllNativeEvents() {
        const e = this, n = e.getBody(), s = e.dom;
        e.delegates && (fn(e.delegates, (l, f) => {
          e.dom.unbind(KT(e, f), f, l);
        }), delete e.delegates), !e.inline && n && s && (n.onload = null, s.unbind(e.getWin()), s.unbind(e.getDoc())), s && (s.unbind(n), s.unbind(e.getContainer()));
      }
    }, ire = (e) => G(e) ? {
      value: e.split(/[ ,]/),
      valid: !0
    } : sn(e, G) ? {
      value: e,
      valid: !0
    } : {
      valid: !1,
      message: "The value must be a string[] or a comma/space separated string."
    }, cre = (e) => {
      const n = (() => {
        switch (e) {
          case "array":
            return be;
          case "boolean":
            return Te;
          case "function":
            return Ce;
          case "number":
            return pt;
          case "object":
            return me;
          case "string":
            return G;
          case "string[]":
            return ire;
          case "object[]":
            return (s) => sn(s, me);
          case "regexp":
            return (s) => ue(s, RegExp);
          default:
            return ut;
        }
      })();
      return (s) => wh(s, n, `The value must be a ${e}.`);
    }, lre = (e) => G(e.processor), k9 = (e, n) => {
      const s = ei(n.message) ? "" : `. ${n.message}`;
      return e + s;
    }, ZE = (e) => e.valid, wh = (e, n, s = "") => {
      const l = n(e);
      return Te(l) ? l ? {
        value: e,
        valid: !0
      } : {
        valid: !1,
        message: s
      } : l;
    }, ure = (e, n, s) => {
      if (!Le(n)) {
        const l = wh(n, s);
        if (ZE(l))
          return l.value;
        console.error(k9(`Invalid default value passed for the "${e}" option`, l));
      }
    }, dre = (e, n) => {
      const s = {}, l = {}, f = (te, ce, Oe) => {
        const Re = wh(ce, Oe);
        return ZE(Re) ? (l[te] = Re.value, !0) : (console.warn(k9(`Invalid value passed for the ${te} option`, Re)), !1);
      }, b = (te, ce) => {
        const Oe = lre(ce) ? cre(ce.processor) : ce.processor, Re = ure(te, ce.default, Oe);
        s[te] = {
          ...ce,
          default: Re,
          processor: Oe
        }, gs(l, te).orThunk(() => gs(n, te)).each((Pe) => f(te, Pe, Oe));
      }, E = (te) => lr(s, te);
      return {
        register: b,
        isRegistered: E,
        get: (te) => gs(l, te).orThunk(() => gs(s, te).map((ce) => ce.default)).getOrUndefined(),
        set: (te, ce) => {
          if (E(te)) {
            const Oe = s[te];
            return Oe.immutable ? (console.error(`"${te}" is an immutable option and cannot be updated`), !1) : f(te, ce, Oe.processor);
          } else
            return console.warn(`"${te}" is not a registered option. Ensure the option has been registered before setting a value.`), !1;
        },
        unset: (te) => {
          const ce = E(te);
          return ce && delete l[te], ce;
        },
        isSet: (te) => lr(l, te)
      };
    }, fre = [
      "design",
      "readonly"
    ], N9 = (e, n, s, l) => {
      const f = s[n.get()], b = s[l];
      try {
        b.activate();
      } catch (E) {
        console.error(`problem while activating editor mode ${l}:`, E);
        return;
      }
      f.deactivate(), f.editorReadOnly !== b.editorReadOnly && vD(e, b.editorReadOnly), n.set(l), W_(e, l);
    }, mre = (e, n, s, l) => {
      if (l !== s.get()) {
        if (!lr(n, l))
          throw new Error(`Editor mode '${l}' is invalid`);
        e.initialized ? N9(e, s, n, l) : e.on("init", () => N9(e, s, n, l));
      }
    }, pre = (e, n, s) => {
      if (Ge(fre, n))
        throw new Error(`Cannot override default mode ${n}`);
      return {
        ...e,
        [n]: {
          ...s,
          deactivate: () => {
            try {
              s.deactivate();
            } catch (l) {
              console.error(`problem while deactivating editor mode ${n}:`, l);
            }
          }
        }
      };
    }, hre = (e) => {
      const n = wa("design"), s = wa({
        design: {
          activate: Lt,
          deactivate: Lt,
          editorReadOnly: !1
        },
        readonly: {
          activate: Lt,
          deactivate: Lt,
          editorReadOnly: !0
        }
      });
      return ere(e), ore(e), {
        isReadOnly: () => GE(e),
        set: (l) => mre(e, s.get(), n, l),
        get: () => n.get(),
        register: (l, f) => {
          s.set(pre(s.get(), l, f));
        }
      };
    }, EL = rn.each, CL = rn.explode, yle = {
      f1: 112,
      f2: 113,
      f3: 114,
      f4: 115,
      f5: 116,
      f6: 117,
      f7: 118,
      f8: 119,
      f9: 120,
      f10: 121,
      f11: 122,
      f12: 123
    }, R9 = rn.makeMap("alt,ctrl,shift,meta,access"), gre = (e) => e in R9, vre = (e) => {
      const n = {}, s = kn.os.isMacOS() || kn.os.isiOS();
      EL(CL(e.toLowerCase(), "+"), (b) => {
        gre(b) ? n[b] = !0 : /^[0-9]{2,}$/.test(b) ? n.keyCode = parseInt(b, 10) : (n.charCode = b.charCodeAt(0), n.keyCode = yle[b] || b.toUpperCase().charCodeAt(0));
      });
      const l = [n.keyCode];
      let f;
      for (f in R9)
        n[f] ? l.push(f) : n[f] = !1;
      return n.id = l.join(","), n.access && (n.alt = !0, s ? n.ctrl = !0 : n.shift = !0), n.meta && (s ? n.meta = !0 : (n.ctrl = !0, n.meta = !1)), n;
    };
    class P9 {
      constructor(n) {
        this.shortcuts = {}, this.pendingPatterns = [], this.editor = n;
        const s = this;
        n.on("keyup keypress keydown", (l) => {
          (s.hasModifier(l) || s.isFunctionKey(l)) && !l.isDefaultPrevented() && (EL(s.shortcuts, (f) => {
            s.matchShortcut(l, f) && (s.pendingPatterns = f.subpatterns.slice(0), l.type === "keydown" && s.executeShortcutAction(f));
          }), s.matchShortcut(l, s.pendingPatterns[0]) && (s.pendingPatterns.length === 1 && l.type === "keydown" && s.executeShortcutAction(s.pendingPatterns[0]), s.pendingPatterns.shift()));
        });
      }
      add(n, s, l, f) {
        const b = this, E = b.normalizeCommandFunc(l);
        return EL(CL(rn.trim(n)), (N) => {
          const D = b.createShortcut(N, s, E, f);
          b.shortcuts[D.id] = D;
        }), !0;
      }
      remove(n) {
        const s = this.createShortcut(n);
        return this.shortcuts[s.id] ? (delete this.shortcuts[s.id], !0) : !1;
      }
      normalizeCommandFunc(n) {
        const s = this, l = n;
        return typeof l == "string" ? () => {
          s.editor.execCommand(l, !1, null);
        } : rn.isArray(l) ? () => {
          s.editor.execCommand(l[0], l[1], l[2]);
        } : l;
      }
      createShortcut(n, s, l, f) {
        const b = rn.map(CL(n, ">"), vre);
        return b[b.length - 1] = rn.extend(b[b.length - 1], {
          func: l,
          scope: f || this.editor
        }), rn.extend(b[0], {
          desc: this.editor.translate(s),
          subpatterns: b.slice(1)
        });
      }
      hasModifier(n) {
        return n.altKey || n.ctrlKey || n.metaKey;
      }
      isFunctionKey(n) {
        return n.type === "keydown" && n.keyCode >= 112 && n.keyCode <= 123;
      }
      matchShortcut(n, s) {
        return !s || s.ctrl !== n.ctrlKey || s.meta !== n.metaKey || s.alt !== n.altKey || s.shift !== n.shiftKey ? !1 : n.keyCode === s.keyCode || n.charCode && n.charCode === s.charCode ? (n.preventDefault(), !0) : !1;
      }
      executeShortcutAction(n) {
        return n.func ? n.func.call(n.scope) : null;
      }
    }
    const bre = () => {
      const e = {}, n = {}, s = {}, l = {}, f = {}, b = {}, E = {}, N = {}, D = (J, te) => (ce, Oe) => {
        J[ce.toLowerCase()] = {
          ...Oe,
          type: te
        };
      }, U = (J, te) => l[J.toLowerCase()] = te;
      return {
        addButton: D(e, "button"),
        addGroupToolbarButton: D(e, "grouptoolbarbutton"),
        addToggleButton: D(e, "togglebutton"),
        addMenuButton: D(e, "menubutton"),
        addSplitButton: D(e, "splitbutton"),
        addMenuItem: D(n, "menuitem"),
        addNestedMenuItem: D(n, "nestedmenuitem"),
        addToggleMenuItem: D(n, "togglemenuitem"),
        addAutocompleter: D(s, "autocompleter"),
        addContextMenu: D(f, "contextmenu"),
        addContextToolbar: D(b, "contexttoolbar"),
        addContextForm: D(b, "contextform"),
        addSidebar: D(E, "sidebar"),
        addView: D(N, "views"),
        addIcon: U,
        getAll: () => ({
          buttons: e,
          menuItems: n,
          icons: l,
          popups: s,
          contextMenus: f,
          contextToolbars: b,
          sidebars: E,
          views: N
        })
      };
    }, yre = () => {
      const e = bre();
      return {
        addAutocompleter: e.addAutocompleter,
        addButton: e.addButton,
        addContextForm: e.addContextForm,
        addContextMenu: e.addContextMenu,
        addContextToolbar: e.addContextToolbar,
        addIcon: e.addIcon,
        addMenuButton: e.addMenuButton,
        addMenuItem: e.addMenuItem,
        addNestedMenuItem: e.addNestedMenuItem,
        addSidebar: e.addSidebar,
        addSplitButton: e.addSplitButton,
        addToggleButton: e.addToggleButton,
        addGroupToolbarButton: e.addGroupToolbarButton,
        addToggleMenuItem: e.addToggleMenuItem,
        addView: e.addView,
        getAll: e.getAll
      };
    }, YT = Is.DOM, D9 = rn.extend, Sre = rn.each;
    class bD {
      constructor(n, s, l) {
        this.plugins = {}, this.contentCSS = [], this.contentStyles = [], this.loadedCSS = {}, this.isNotDirty = !1, this.composing = !1, this.destroyed = !1, this.hasHiddenInput = !1, this.iframeElement = null, this.initialized = !1, this.readonly = !1, this.removed = !1, this.startContent = "", this._pendingNativeEvents = [], this._skinLoaded = !1, this._editableRoot = !0, this.editorManager = l, this.documentBaseUrl = l.documentBaseURL, D9(this, A9);
        const f = this;
        this.id = n, this.hidden = !1;
        const b = Tne(l.defaultOptions, s);
        this.options = dre(f, b), Jm(f);
        const E = this.options.get;
        E("deprecation_warnings") && Lce(s, b);
        const N = E("suffix");
        N && (l.suffix = N), this.suffix = l.suffix;
        const D = E("base_url");
        D && l._setBaseUrl(D), this.baseUri = l.baseURI;
        const U = Gr(f);
        U && (Ti.ScriptLoader._setReferrerPolicy(U), Is.DOM.styleSheetLoader._setReferrerPolicy(U));
        const J = $b(f);
        Ie(J) && Is.DOM.styleSheetLoader._setContentCssCors(J), wl.languageLoad = E("language_load"), wl.baseURL = l.baseURL, this.setDirty(!1), this.documentBaseURI = new vh(pd(f), { base_uri: this.baseUri }), this.baseURI = this.baseUri, this.inline = Fw(f), this.hasVisual = u_(f), this.shortcuts = new P9(this), this.editorCommands = new bL(this), hD(this);
        const te = E("cache_suffix");
        te && (kn.cacheSuffix = te.replace(/^[\?\&]+/, "")), this.ui = {
          registry: yre(),
          styleSheetLoader: void 0,
          show: Lt,
          hide: Lt,
          setEnabled: Lt,
          isEnabled: ut
        }, this.mode = hre(f), l.dispatch("SetupEditor", { editor: this });
        const ce = Lw(f);
        Ce(ce) && ce.call(f, f);
      }
      render() {
        dL(this);
      }
      focus(n) {
        this.execCommand("mceFocus", !1, n);
      }
      hasFocus() {
        return W0(this);
      }
      translate(n) {
        return Af.translate(n);
      }
      getParam(n, s, l) {
        const f = this.options;
        return f.isRegistered(n) || (Ie(l) ? f.register(n, {
          processor: l,
          default: s
        }) : f.register(n, {
          processor: ut,
          default: s
        })), !f.isSet(n) && !Le(s) ? s : f.get(n);
      }
      hasPlugin(n, s) {
        return Ge(Wy(this), n) ? s ? PE.get(n) !== void 0 : !0 : !1;
      }
      nodeChanged(n) {
        this._nodeChangeDispatcher.nodeChanged(n);
      }
      addCommand(n, s, l) {
        this.editorCommands.addCommand(n, s, l);
      }
      addQueryStateHandler(n, s, l) {
        this.editorCommands.addQueryStateHandler(n, s, l);
      }
      addQueryValueHandler(n, s, l) {
        this.editorCommands.addQueryValueHandler(n, s, l);
      }
      addShortcut(n, s, l, f) {
        this.shortcuts.add(n, s, l, f);
      }
      execCommand(n, s, l, f) {
        return this.editorCommands.execCommand(n, s, l, f);
      }
      queryCommandState(n) {
        return this.editorCommands.queryCommandState(n);
      }
      queryCommandValue(n) {
        return this.editorCommands.queryCommandValue(n);
      }
      queryCommandSupported(n) {
        return this.editorCommands.queryCommandSupported(n);
      }
      show() {
        const n = this;
        n.hidden && (n.hidden = !1, n.inline ? n.getBody().contentEditable = "true" : (YT.show(n.getContainer()), YT.hide(n.id)), n.load(), n.dispatch("show"));
      }
      hide() {
        const n = this;
        n.hidden || (n.save(), n.inline ? (n.getBody().contentEditable = "false", n === n.editorManager.focusedEditor && (n.editorManager.focusedEditor = null)) : (YT.hide(n.getContainer()), YT.setStyle(n.id, "display", n.orgDisplay)), n.hidden = !0, n.dispatch("hide"));
      }
      isHidden() {
        return this.hidden;
      }
      setProgressState(n, s) {
        this.dispatch("ProgressState", {
          state: n,
          time: s
        });
      }
      load(n = {}) {
        const s = this, l = s.getElement();
        if (s.removed)
          return "";
        if (l) {
          const f = {
            ...n,
            load: !0
          }, b = sm(l) ? l.value : l.innerHTML, E = s.setContent(b, f);
          return f.no_events || s.dispatch("LoadContent", {
            ...f,
            element: l
          }), E;
        } else
          return "";
      }
      save(n = {}) {
        const s = this;
        let l = s.getElement();
        if (!l || !s.initialized || s.removed)
          return "";
        const f = {
          ...n,
          save: !0,
          element: l
        };
        let b = s.getContent(f);
        const E = {
          ...f,
          content: b
        };
        if (E.no_events || s.dispatch("SaveContent", E), E.format === "raw" && s.dispatch("RawSaveContent", E), b = E.content, sm(l))
          l.value = b;
        else {
          (n.is_removing || !s.inline) && (l.innerHTML = b);
          const N = YT.getParent(s.id, "form");
          N && Sre(N.elements, (D) => D.name === s.id ? (D.value = b, !1) : !0);
        }
        return E.element = f.element = l = null, E.set_dirty !== !1 && s.setDirty(!1), b;
      }
      setContent(n, s) {
        return ZF(this, n, s);
      }
      getContent(n) {
        return AH(this, n);
      }
      insertContent(n, s) {
        s && (n = D9({ content: n }, s)), this.execCommand("mceInsertContent", !1, n);
      }
      resetContent(n) {
        n === void 0 ? ZF(this, this.startContent, { format: "raw" }) : ZF(this, n), this.undoManager.reset(), this.setDirty(!1), this.nodeChanged();
      }
      isDirty() {
        return !this.isNotDirty;
      }
      setDirty(n) {
        const s = !this.isNotDirty;
        this.isNotDirty = !n, n && n !== s && this.dispatch("dirty");
      }
      getContainer() {
        const n = this;
        return n.container || (n.container = n.editorContainer || YT.get(n.id + "_parent")), n.container;
      }
      getContentAreaContainer() {
        return this.contentAreaContainer;
      }
      getElement() {
        return this.targetElm || (this.targetElm = YT.get(this.id)), this.targetElm;
      }
      getWin() {
        const n = this;
        if (!n.contentWindow) {
          const s = n.iframeElement;
          s && (n.contentWindow = s.contentWindow);
        }
        return n.contentWindow;
      }
      getDoc() {
        const n = this;
        if (!n.contentDocument) {
          const s = n.getWin();
          s && (n.contentDocument = s.document);
        }
        return n.contentDocument;
      }
      getBody() {
        var n, s;
        const l = this.getDoc();
        return (s = (n = this.bodyElement) !== null && n !== void 0 ? n : l == null ? void 0 : l.body) !== null && s !== void 0 ? s : null;
      }
      convertURL(n, s, l) {
        const f = this, b = f.options.get, E = p_(f);
        if (Ce(E))
          return E.call(f, n, l, !0, s);
        if (!b("convert_urls") || l === "link" || me(l) && l.nodeName === "LINK" || n.indexOf("file:") === 0 || n.length === 0)
          return n;
        const N = new vh(n);
        return N.protocol !== "http" && N.protocol !== "https" && N.protocol !== "" ? n : b("relative_urls") ? f.documentBaseURI.toRelative(n) : (n = f.documentBaseURI.toAbsolute(n, b("remove_script_host")), n);
      }
      addVisual(n) {
        _ne(this, n);
      }
      setEditableRoot(n) {
        dD(this, n);
      }
      hasEditableRoot() {
        return fD(this);
      }
      remove() {
        oY(this);
      }
      destroy(n) {
        sY(this, n);
      }
      uploadImages() {
        return this.editorUpload.uploadImages();
      }
      _scanForImages() {
        return this.editorUpload.scanForImages();
      }
    }
    const QT = Is.DOM, yD = rn.each;
    let $9 = !1, SD, Uf = [];
    const wD = (e) => {
      const n = e.type;
      yD(SS.get(), (s) => {
        switch (n) {
          case "scroll":
            s.dispatch("ScrollWindow", e);
            break;
          case "resize":
            s.dispatch("ResizeWindow", e);
            break;
        }
      });
    }, I9 = (e) => {
      if (e !== $9) {
        const n = Is.DOM;
        e ? (n.bind(window, "resize", wD), n.bind(window, "scroll", wD)) : (n.unbind(window, "resize", wD), n.unbind(window, "scroll", wD)), $9 = e;
      }
    }, M9 = (e) => {
      const n = Uf;
      return Uf = ht(Uf, (s) => e !== s), SS.activeEditor === e && (SS.activeEditor = Uf.length > 0 ? Uf[0] : null), SS.focusedEditor === e && (SS.focusedEditor = null), n.length !== Uf.length;
    }, wre = (e) => {
      e && e.initialized && !(e.getContainer() || e.getBody()).parentNode && (M9(e), e.unbindAllNativeEvents(), e.destroy(!0), e.removed = !0);
    }, Ere = document.compatMode !== "CSS1Compat", SS = {
      ...wL,
      baseURI: null,
      baseURL: null,
      defaultOptions: {},
      documentBaseURL: null,
      suffix: null,
      majorVersion: "6",
      minorVersion: "8.6",
      releaseDate: "TBD",
      i18n: Af,
      activeEditor: null,
      focusedEditor: null,
      setup() {
        const e = this;
        let n = "", s = "", l = vh.getDocumentBaseUrl(document.location);
        /^[^:]+:\/\/\/?[^\/]+\//.test(l) && (l = l.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, ""), /[\/\\]$/.test(l) || (l += "/"));
        const f = window.tinymce || window.tinyMCEPreInit;
        if (f)
          n = f.base || f.baseURL, s = f.suffix;
        else {
          const b = document.getElementsByTagName("script");
          for (let E = 0; E < b.length; E++) {
            const N = b[E].src || "";
            if (N === "")
              continue;
            const D = N.substring(N.lastIndexOf("/"));
            if (/tinymce(\.full|\.jquery|)(\.min|\.dev|)\.js/.test(N)) {
              D.indexOf(".min") !== -1 && (s = ".min"), n = N.substring(0, N.lastIndexOf("/"));
              break;
            }
          }
          if (!n && document.currentScript) {
            const E = document.currentScript.src;
            E.indexOf(".min") !== -1 && (s = ".min"), n = E.substring(0, E.lastIndexOf("/"));
          }
        }
        e.baseURL = new vh(l).toAbsolute(n), e.documentBaseURL = l, e.baseURI = new vh(e.baseURL), e.suffix = s, $q(e);
      },
      overrideDefaults(e) {
        const n = e.base_url;
        n && this._setBaseUrl(n);
        const s = e.suffix;
        s && (this.suffix = s), this.defaultOptions = e;
        const l = e.plugin_base_urls;
        l !== void 0 && fn(l, (f, b) => {
          wl.PluginManager.urls[b] = f;
        });
      },
      init(e) {
        const n = this;
        let s;
        const l = rn.makeMap("area base basefont br col frame hr img input isindex link meta param embed source wbr track colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu", " "), f = (J, te) => J.inline && te.tagName.toLowerCase() in l, b = (J) => {
          let te = J.id;
          return te || (te = gs(J, "name").filter((ce) => !QT.get(ce)).getOrThunk(QT.uniqueId), J.setAttribute("id", te)), te;
        }, E = (J) => {
          const te = e[J];
          if (te)
            return te.apply(n, []);
        }, N = (J) => kn.browser.isIE() || kn.browser.isEdge() ? (BO("TinyMCE does not support the browser you are using. For a list of supported browsers please see: https://www.tiny.cloud/docs/tinymce/6/support/#supportedwebbrowsers"), []) : Ere ? (BO("Failed to initialize the editor as the document is not in standards mode. TinyMCE requires standards mode."), []) : G(J.selector) ? QT.select(J.selector) : Ie(J.target) ? [J.target] : [];
        let D = (J) => {
          s = J;
        };
        const U = () => {
          let J = 0;
          const te = [];
          let ce;
          const Oe = (Re, xe, Pe) => {
            const Ke = new bD(Re, xe, n);
            te.push(Ke), Ke.on("init", () => {
              ++J === ce.length && D(te);
            }), Ke.targetElm = Ke.targetElm || Pe, Ke.render();
          };
          QT.unbind(window, "ready", U), E("onpageload"), ce = hc(N(e)), rn.each(ce, (Re) => {
            wre(n.get(Re.id));
          }), ce = rn.grep(ce, (Re) => !n.get(Re.id)), ce.length === 0 ? D([]) : yD(ce, (Re) => {
            f(e, Re) ? BO("Could not initialize inline editor on invalid inline target element", Re) : Oe(b(Re), e, Re);
          });
        };
        return QT.bind(window, "ready", U), new Promise((J) => {
          s ? J(s) : D = (te) => {
            J(te);
          };
        });
      },
      get(e) {
        return arguments.length === 0 ? Uf.slice(0) : G(e) ? Bt(Uf, (n) => n.id === e).getOr(null) : pt(e) && Uf[e] ? Uf[e] : null;
      },
      add(e) {
        const n = this, s = n.get(e.id);
        return s === e || (s === null && Uf.push(e), I9(!0), n.activeEditor = e, n.dispatch("AddEditor", { editor: e }), SD || (SD = (l) => {
          const f = n.dispatch("BeforeUnload");
          if (f.returnValue)
            return l.preventDefault(), l.returnValue = f.returnValue, f.returnValue;
        }, window.addEventListener("beforeunload", SD))), e;
      },
      createEditor(e, n) {
        return this.add(new bD(e, n, this));
      },
      remove(e) {
        const n = this;
        let s;
        if (!e) {
          for (let l = Uf.length - 1; l >= 0; l--)
            n.remove(Uf[l]);
          return;
        }
        if (G(e)) {
          yD(QT.select(e), (l) => {
            s = n.get(l.id), s && n.remove(s);
          });
          return;
        }
        return s = e, q(n.get(s.id)) ? null : (M9(s) && n.dispatch("RemoveEditor", { editor: s }), Uf.length === 0 && window.removeEventListener("beforeunload", SD), s.remove(), I9(Uf.length > 0), s);
      },
      execCommand(e, n, s) {
        var l;
        const f = this, b = me(s) ? (l = s.id) !== null && l !== void 0 ? l : s.index : s;
        switch (e) {
          case "mceAddEditor": {
            if (!f.get(b)) {
              const E = s.options;
              new bD(b, E, f).render();
            }
            return !0;
          }
          case "mceRemoveEditor": {
            const E = f.get(b);
            return E && E.remove(), !0;
          }
          case "mceToggleEditor": {
            const E = f.get(b);
            return E ? (E.isHidden() ? E.show() : E.hide(), !0) : (f.execCommand("mceAddEditor", !1, s), !0);
          }
        }
        return f.activeEditor ? f.activeEditor.execCommand(e, n, s) : !1;
      },
      triggerSave: () => {
        yD(Uf, (e) => {
          e.save();
        });
      },
      addI18n: (e, n) => {
        Af.add(e, n);
      },
      translate: (e) => Af.translate(e),
      setActive(e) {
        const n = this.activeEditor;
        this.activeEditor !== e && (n && n.dispatch("deactivate", { relatedTarget: e }), e.dispatch("activate", { relatedTarget: n })), this.activeEditor = e;
      },
      _setBaseUrl(e) {
        this.baseURL = new vh(this.documentBaseURL).toAbsolute(e.replace(/\/+$/, "")), this.baseURI = new vh(this.baseURL);
      }
    };
    SS.setup();
    const Cre = (() => {
      const e = Kh(), n = (b) => ({
        items: b,
        types: Co(b),
        getType: (E) => gs(b, E).getOrUndefined()
      }), s = (b) => {
        e.set(b);
      }, l = () => e.get().getOrUndefined(), f = e.clear;
      return {
        FakeClipboardItem: n,
        write: s,
        read: l,
        clear: f
      };
    })(), xL = Math.min, XT = Math.max, ED = Math.round, F9 = (e, n, s) => {
      let l = n.x, f = n.y;
      const b = e.w, E = e.h, N = n.w, D = n.h, U = (s || "").split("");
      return U[0] === "b" && (f += D), U[1] === "r" && (l += N), U[0] === "c" && (f += ED(D / 2)), U[1] === "c" && (l += ED(N / 2)), U[3] === "b" && (f -= E), U[4] === "r" && (l -= b), U[3] === "c" && (f -= ED(E / 2)), U[4] === "c" && (l -= ED(b / 2)), JT(l, f, b, E);
    }, xre = (e, n, s, l) => {
      for (let f = 0; f < l.length; f++) {
        const b = F9(e, n, l[f]);
        if (b.x >= s.x && b.x + b.w <= s.w + s.x && b.y >= s.y && b.y + b.h <= s.h + s.y)
          return l[f];
      }
      return null;
    }, Tre = (e, n, s) => JT(e.x - n, e.y - s, e.w + n * 2, e.h + s * 2), _re = (e, n) => {
      const s = XT(e.x, n.x), l = XT(e.y, n.y), f = xL(e.x + e.w, n.x + n.w), b = xL(e.y + e.h, n.y + n.h);
      return f - s < 0 || b - l < 0 ? null : JT(s, l, f - s, b - l);
    }, Ore = (e, n, s) => {
      let l = e.x, f = e.y, b = e.x + e.w, E = e.y + e.h;
      const N = n.x + n.w, D = n.y + n.h, U = XT(0, n.x - l), J = XT(0, n.y - f), te = XT(0, b - N), ce = XT(0, E - D);
      return l += U, f += J, s && (b += U, E += J, l -= te, f -= ce), b -= te, E -= ce, JT(l, f, b - l, E - f);
    }, JT = (e, n, s, l) => ({
      x: e,
      y: n,
      w: s,
      h: l
    }), kre = {
      inflate: Tre,
      relativePosition: F9,
      findBestRelativePosition: xre,
      intersect: _re,
      clamp: Ore,
      create: JT,
      fromClientRect: (e) => JT(e.left, e.top, e.width, e.height)
    }, Nre = (e, n, s = 1e3) => {
      let l = !1, f = null;
      const b = (U) => (...J) => {
        l || (l = !0, f !== null && (clearTimeout(f), f = null), U.apply(null, J));
      }, E = b(e), N = b(n);
      return {
        start: (...U) => {
          !l && f === null && (f = setTimeout(() => N.apply(null, U), s));
        },
        resolve: E,
        reject: N
      };
    }, Rre = (() => {
      const e = {}, n = {}, s = {};
      return {
        load: (D, U) => {
          const J = `Script at URL "${U}" failed to load`, te = `Script at URL "${U}" did not call \`tinymce.Resource.add('${D}', data)\` within 1 second`;
          if (e[D] !== void 0)
            return e[D];
          {
            const ce = new Promise((Oe, Re) => {
              const xe = Nre(Oe, Re);
              n[D] = xe.resolve, Ti.ScriptLoader.loadScript(U).then(() => xe.start(te), () => xe.reject(J));
            });
            return e[D] = ce, ce;
          }
        },
        add: (D, U) => {
          n[D] !== void 0 && (n[D](U), delete n[D]), e[D] = Promise.resolve(U), s[D] = U;
        },
        has: (D) => D in s,
        get: (D) => s[D],
        unload: (D) => {
          delete e[D];
        }
      };
    })(), Pre = () => (() => {
      let e = {}, n = [];
      const s = {
        getItem: (l) => {
          const f = e[l];
          return f || null;
        },
        setItem: (l, f) => {
          n.push(l), e[l] = String(f);
        },
        key: (l) => n[l],
        removeItem: (l) => {
          n = n.filter((f) => f === l), delete e[l];
        },
        clear: () => {
          n = [], e = {};
        },
        length: 0
      };
      return Object.defineProperty(s, "length", {
        get: () => n.length,
        configurable: !1,
        enumerable: !1
      }), s;
    })();
    let xA;
    try {
      const e = "__storage_test__";
      xA = window.localStorage, xA.setItem(e, e), xA.removeItem(e);
    } catch {
      xA = Pre();
    }
    var Dre = xA;
    const $re = {
      geom: { Rect: kre },
      util: {
        Delay: sp,
        Tools: rn,
        VK: zn,
        URI: vh,
        EventDispatcher: ic,
        Observable: wL,
        I18n: Af,
        LocalStorage: Dre,
        ImageUploader: CY
      },
      dom: {
        EventUtils: hu,
        TreeWalker: xs,
        TextSeeker: Qh,
        DOMUtils: Is,
        ScriptLoader: Ti,
        RangeUtils: ve,
        Serializer: _H,
        StyleSheetLoader: j1,
        ControlSelection: u5,
        BookmarkManager: Xy,
        Selection: rS,
        Event: hu.Event
      },
      html: {
        Styles: qm,
        Entities: Yg,
        Node: yd,
        Schema: jm,
        DomParser: hg,
        Writer: I5,
        Serializer: j0
      },
      Env: kn,
      AddOnManager: wl,
      Annotator: z_,
      Formatter: n3,
      UndoManager: r3,
      EditorCommands: bL,
      WindowManager: MH,
      NotificationManager: QF,
      EditorObservable: A9,
      Shortcuts: P9,
      Editor: bD,
      FocusManager: h5,
      EditorManager: SS,
      DOM: Is.DOM,
      ScriptLoader: Ti.ScriptLoader,
      PluginManager: PE,
      ThemeManager: f1,
      ModelManager: yh,
      IconManager: MO,
      Resource: Rre,
      FakeClipboard: Cre,
      trim: rn.trim,
      isArray: rn.isArray,
      is: rn.is,
      toArray: rn.toArray,
      makeMap: rn.makeMap,
      each: rn.each,
      map: rn.map,
      grep: rn.grep,
      inArray: rn.inArray,
      extend: rn.extend,
      walk: rn.walk,
      resolve: rn.resolve,
      explode: rn.explode,
      _addCacheSuffix: rn._addCacheSuffix
    }, TL = rn.extend(SS, $re), Ele = (e) => {
      try {
        r.exports = e;
      } catch {
      }
    };
    ((e) => {
      window.tinymce = e, window.tinyMCE = e;
    })(TL), Ele(TL);
  })();
})(QZe);
(function() {
  var r = tinymce.util.Tools.resolve("tinymce.ModelManager");
  const o = (h, w, A) => {
    var P;
    return A(h, w.prototype) ? !0 : ((P = h.constructor) === null || P === void 0 ? void 0 : P.name) === w.name;
  }, c = (h) => {
    const w = typeof h;
    return h === null ? "null" : w === "object" && Array.isArray(h) ? "array" : w === "object" && o(h, String, (A, P) => P.isPrototypeOf(A)) ? "string" : w;
  }, i = (h) => (w) => c(w) === h, d = (h) => (w) => typeof w === h, m = (h) => (w) => h === w, v = i("string"), g = i("object"), C = i("array"), O = m(null), R = d("boolean"), I = m(void 0), L = (h) => h == null, Z = (h) => !L(h), ne = d("function"), se = d("number"), Q = () => {
  }, he = (h, w) => (...A) => h(w.apply(null, A)), ue = (h, w) => (A) => h(w(A)), G = (h) => () => h, me = (h) => h, we = (h, w) => h === w;
  function be(h, ...w) {
    return (...A) => {
      const P = w.concat(A);
      return h.apply(null, P);
    };
  }
  const q = (h) => (w) => !h(w), Te = (h) => () => {
    throw new Error(h);
  }, Le = (h) => h(), je = G(!1), Ie = G(!0);
  class Ce {
    constructor(w, A) {
      this.tag = w, this.value = A;
    }
    static some(w) {
      return new Ce(!0, w);
    }
    static none() {
      return Ce.singletonNone;
    }
    fold(w, A) {
      return this.tag ? A(this.value) : w();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(w) {
      return this.tag ? Ce.some(w(this.value)) : Ce.none();
    }
    bind(w) {
      return this.tag ? w(this.value) : Ce.none();
    }
    exists(w) {
      return this.tag && w(this.value);
    }
    forall(w) {
      return !this.tag || w(this.value);
    }
    filter(w) {
      return !this.tag || w(this.value) ? this : Ce.none();
    }
    getOr(w) {
      return this.tag ? this.value : w;
    }
    or(w) {
      return this.tag ? this : w;
    }
    getOrThunk(w) {
      return this.tag ? this.value : w();
    }
    orThunk(w) {
      return this.tag ? this : w();
    }
    getOrDie(w) {
      if (this.tag)
        return this.value;
      throw new Error(w ?? "Called getOrDie on None");
    }
    static from(w) {
      return Z(w) ? Ce.some(w) : Ce.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(w) {
      this.tag && w(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  Ce.singletonNone = new Ce(!1);
  const pt = Array.prototype.slice, sn = Array.prototype.indexOf, Lt = Array.prototype.push, z = (h, w) => sn.call(h, w), bt = (h, w) => z(h, w) > -1, at = (h, w) => {
    for (let A = 0, P = h.length; A < P; A++) {
      const V = h[A];
      if (w(V, A))
        return !0;
    }
    return !1;
  }, _n = (h, w) => {
    const A = [];
    for (let P = 0; P < h; P++)
      A.push(w(P));
    return A;
  }, st = (h, w) => {
    const A = h.length, P = new Array(A);
    for (let V = 0; V < A; V++) {
      const K = h[V];
      P[V] = w(K, V);
    }
    return P;
  }, Ne = (h, w) => {
    for (let A = 0, P = h.length; A < P; A++) {
      const V = h[A];
      w(V, A);
    }
  }, vt = (h, w) => {
    for (let A = h.length - 1; A >= 0; A--) {
      const P = h[A];
      w(P, A);
    }
  }, Gt = (h, w) => {
    const A = [], P = [];
    for (let V = 0, K = h.length; V < K; V++) {
      const ie = h[V];
      (w(ie, V) ? A : P).push(ie);
    }
    return {
      pass: A,
      fail: P
    };
  }, xt = (h, w) => {
    const A = [];
    for (let P = 0, V = h.length; P < V; P++) {
      const K = h[P];
      w(K, P) && A.push(K);
    }
    return A;
  }, cn = (h, w, A) => (vt(h, (P, V) => {
    A = w(A, P, V);
  }), A), He = (h, w, A) => (Ne(h, (P, V) => {
    A = w(A, P, V);
  }), A), ut = (h, w, A) => {
    for (let P = 0, V = h.length; P < V; P++) {
      const K = h[P];
      if (w(K, P))
        return Ce.some(K);
      if (A(K, P))
        break;
    }
    return Ce.none();
  }, oe = (h, w) => ut(h, w, je), qn = (h, w) => {
    for (let A = 0, P = h.length; A < P; A++) {
      const V = h[A];
      if (w(V, A))
        return Ce.some(A);
    }
    return Ce.none();
  }, Rn = (h) => {
    const w = [];
    for (let A = 0, P = h.length; A < P; ++A) {
      if (!C(h[A]))
        throw new Error("Arr.flatten item " + A + " was not an array, input: " + h);
      Lt.apply(w, h[A]);
    }
    return w;
  }, Zt = (h, w) => Rn(st(h, w)), Jt = (h, w) => {
    for (let A = 0, P = h.length; A < P; ++A) {
      const V = h[A];
      if (w(V, A) !== !0)
        return !1;
    }
    return !0;
  }, wo = (h) => {
    const w = pt.call(h, 0);
    return w.reverse(), w;
  }, Ge = (h, w) => {
    const A = {};
    for (let P = 0, V = h.length; P < V; P++) {
      const K = h[P];
      A[String(K)] = w(K, P);
    }
    return A;
  }, qt = (h, w) => {
    const A = pt.call(h, 0);
    return A.sort(w), A;
  }, St = (h, w) => w >= 0 && w < h.length ? Ce.some(h[w]) : Ce.none(), ke = (h) => St(h, 0), Ct = (h) => St(h, h.length - 1), an = (h, w) => {
    for (let A = 0; A < h.length; A++) {
      const P = w(h[A], A);
      if (P.isSome())
        return P;
    }
    return Ce.none();
  }, ht = Object.keys, bn = Object.hasOwnProperty, Ye = (h, w) => {
    const A = ht(h);
    for (let P = 0, V = A.length; P < V; P++) {
      const K = A[P], ie = h[K];
      w(ie, K);
    }
  }, nn = (h, w) => Bt(h, (A, P) => ({
    k: P,
    v: w(A, P)
  })), Bt = (h, w) => {
    const A = {};
    return Ye(h, (P, V) => {
      const K = w(P, V);
      A[K.k] = K.v;
    }), A;
  }, $n = (h) => (w, A) => {
    h[A] = w;
  }, mr = (h, w, A, P) => {
    Ye(h, (V, K) => {
      (w(V, K) ? A : P)(V, K);
    });
  }, gr = (h, w) => {
    const A = {};
    return mr(h, w, $n(A), Q), A;
  }, Vr = (h, w) => {
    const A = [];
    return Ye(h, (P, V) => {
      A.push(w(P, V));
    }), A;
  }, Xr = (h) => Vr(h, me), pc = (h, w) => Eo(h, w) ? Ce.from(h[w]) : Ce.none(), Eo = (h, w) => bn.call(h, w), uo = (h, w) => Eo(h, w) && h[w] !== void 0 && h[w] !== null, Es = (h) => {
    for (const w in h)
      if (bn.call(h, w))
        return !1;
    return !0;
  }, br = typeof window < "u" ? window : Function("return this;")(), hs = (h, w) => {
    let A = w ?? br;
    for (let P = 0; P < h.length && A !== void 0 && A !== null; ++P)
      A = A[h[P]];
    return A;
  }, Ps = (h, w) => {
    const A = h.split(".");
    return hs(A, w);
  }, qo = (h, w) => Ps(h, w), hc = (h, w) => {
    const A = qo(h, w);
    if (A == null)
      throw new Error(h + " not available on this browser");
    return A;
  }, Co = Object.getPrototypeOf, fl = (h) => hc("HTMLElement", h), fn = (h) => {
    const w = Ps("ownerDocument.defaultView", h);
    return g(h) && (fl(w).prototype.isPrototypeOf(h) || /^HTML\w*Element$/.test(Co(h).constructor.name));
  }, Yr = 8, xa = 9, $i = 11, Kc = 1, wi = 3, es = (h) => h.dom.nodeName.toLowerCase(), gc = (h) => h.dom.nodeType, Xl = (h) => (w) => gc(w) === h, gs = (h) => gc(h) === Yr || es(h) === "#comment", lr = (h) => Ei(h) && fn(h.dom), Ei = Xl(Kc), Jl = Xl(wi), Pd = Xl(xa), Xf = Xl($i), Qa = (h) => (w) => Ei(w) && es(w) === h, Xa = (h, w, A) => {
    if (v(A) || R(A) || se(A))
      h.setAttribute(w, A + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", w, ":: Value ", A, ":: Element ", h), new Error("Attribute value was not simple");
  }, ia = (h, w, A) => {
    Xa(h.dom, w, A);
  }, Nl = (h, w) => {
    const A = h.dom;
    Ye(w, (P, V) => {
      Xa(A, V, P);
    });
  }, Sp = (h, w) => {
    Ye(w, (A, P) => {
      A.fold(() => {
        ea(h, P);
      }, (V) => {
        Xa(h.dom, P, V);
      });
    });
  }, Yu = (h, w) => {
    const A = h.dom.getAttribute(w);
    return A === null ? void 0 : A;
  }, vc = (h, w) => Ce.from(Yu(h, w)), ea = (h, w) => {
    h.dom.removeAttribute(w);
  }, bc = (h) => He(h.dom.attributes, (w, A) => (w[A.name] = A.value, w), {}), Qu = (h, w) => {
    const P = (w || document).createElement("div");
    if (P.innerHTML = h, !P.hasChildNodes() || P.childNodes.length > 1) {
      const V = "HTML does not have a single root node";
      throw console.error(V, h), new Error(V);
    }
    return Ou(P.childNodes[0]);
  }, wp = (h, w) => {
    const P = (w || document).createElement(h);
    return Ou(P);
  }, of = (h, w) => {
    const P = (w || document).createTextNode(h);
    return Ou(P);
  }, Ou = (h) => {
    if (h == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: h };
  }, nt = {
    fromHtml: Qu,
    fromTag: wp,
    fromText: of,
    fromDom: Ou,
    fromPoint: (h, w, A) => Ce.from(h.dom.elementFromPoint(w, A)).map(Ou)
  }, Ja = (h, w) => {
    const A = h.dom;
    if (A.nodeType !== Kc)
      return !1;
    {
      const P = A;
      if (P.matches !== void 0)
        return P.matches(w);
      if (P.msMatchesSelector !== void 0)
        return P.msMatchesSelector(w);
      if (P.webkitMatchesSelector !== void 0)
        return P.webkitMatchesSelector(w);
      if (P.mozMatchesSelector !== void 0)
        return P.mozMatchesSelector(w);
      throw new Error("Browser lacks native selectors");
    }
  }, eu = (h) => h.nodeType !== Kc && h.nodeType !== xa && h.nodeType !== $i || h.childElementCount === 0, Ep = (h, w) => {
    const A = w === void 0 ? document : w.dom;
    return eu(A) ? [] : st(A.querySelectorAll(h), nt.fromDom);
  }, Jf = (h, w) => {
    const A = w === void 0 ? document : w.dom;
    return eu(A) ? Ce.none() : Ce.from(A.querySelector(h)).map(nt.fromDom);
  }, os = (h, w) => h.dom === w.dom, Cp = (h, w) => {
    const A = h.dom, P = w.dom;
    return A === P ? !1 : A.contains(P);
  }, Am = Ja, tu = (h) => nt.fromDom(h.dom.ownerDocument), em = (h) => Pd(h) ? h : tu(h), Hs = (h) => nt.fromDom(em(h).dom.documentElement), Gs = (h) => nt.fromDom(em(h).dom.defaultView), Ac = (h) => Ce.from(h.dom.parentNode).map(nt.fromDom), kc = (h) => Ce.from(h.dom.parentElement).map(nt.fromDom), Xu = (h, w) => {
    const A = ne(w) ? w : je;
    let P = h.dom;
    const V = [];
    for (; P.parentNode !== null && P.parentNode !== void 0; ) {
      const K = P.parentNode, ie = nt.fromDom(K);
      if (V.push(ie), A(ie) === !0)
        break;
      P = K;
    }
    return V;
  }, Ju = (h) => Ce.from(h.dom.previousSibling).map(nt.fromDom), ed = (h) => Ce.from(h.dom.nextSibling).map(nt.fromDom), $o = (h) => st(h.dom.childNodes, nt.fromDom), ei = (h, w) => {
    const A = h.dom.childNodes;
    return Ce.from(A[w]).map(nt.fromDom);
  }, Rl = (h) => ei(h, 0), td = (h, w) => {
    Ac(h).each((P) => {
      P.dom.insertBefore(w.dom, h.dom);
    });
  }, Xi = (h, w) => {
    ed(h).fold(() => {
      Ac(h).each((V) => {
        ss(V, w);
      });
    }, (P) => {
      td(P, w);
    });
  }, Zs = (h, w) => {
    Rl(h).fold(() => {
      ss(h, w);
    }, (P) => {
      h.dom.insertBefore(w.dom, P.dom);
    });
  }, ss = (h, w) => {
    h.dom.appendChild(w.dom);
  }, yc = (h, w, A) => {
    ei(h, A).fold(() => {
      ss(h, w);
    }, (P) => {
      td(P, w);
    });
  }, tm = (h, w) => {
    td(h, w), ss(w, h);
  }, Io = (h, w) => {
    Ne(w, (A, P) => {
      const V = P === 0 ? h : w[P - 1];
      Xi(V, A);
    });
  }, za = (h, w) => {
    Ne(w, (A) => {
      ss(h, A);
    });
  }, ti = (h) => {
    h.dom.textContent = "", Ne($o(h), (w) => {
      Ra(w);
    });
  }, Ra = (h) => {
    const w = h.dom;
    w.parentNode !== null && w.parentNode.removeChild(w);
  }, Pl = (h) => {
    const w = $o(h);
    w.length > 0 && Io(h, w), Ra(h);
  }, nu = (h, w) => nt.fromDom(h.dom.cloneNode(w)), Ii = (h) => nu(h, !1), Dl = (h) => nu(h, !0), $l = (h, w) => {
    const A = nt.fromTag(w), P = bc(h);
    return Nl(A, P), A;
  }, km = (h, w) => {
    const A = $l(h, w), P = $o(Dl(h));
    return za(A, P), A;
  }, Il = (h, w) => {
    const A = $l(h, w);
    Xi(h, A);
    const P = $o(h);
    return za(A, P), Ra(h), A;
  }, xp = [
    "tfoot",
    "thead",
    "tbody",
    "colgroup"
  ], Nc = (h) => bt(xp, h), ku = (h, w) => ({
    rows: h,
    columns: w
  }), sf = (h, w) => ({
    row: h,
    column: w
  }), Nm = (h, w, A) => ({
    element: h,
    rowspan: w,
    colspan: A
  }), Tp = (h, w, A, P) => ({
    element: h,
    rowspan: w,
    colspan: A,
    isNew: P
  }), Se = (h, w, A, P, V, K) => ({
    element: h,
    rowspan: w,
    colspan: A,
    row: P,
    column: V,
    isLocked: K
  }), Ve = (h, w, A) => ({
    element: h,
    cells: w,
    section: A
  }), tt = (h, w, A, P) => ({
    element: h,
    cells: w,
    section: A,
    isNew: P
  }), wt = (h, w, A) => ({
    element: h,
    isNew: w,
    isLocked: A
  }), en = (h, w, A, P) => ({
    element: h,
    cells: w,
    section: A,
    isNew: P
  }), ur = (h, w, A, P) => ({
    startRow: h,
    startCol: w,
    finishRow: A,
    finishCol: P
  }), Yo = (h, w, A) => ({
    element: h,
    colspan: w,
    column: A
  }), Lr = (h, w) => ({
    element: h,
    columns: w
  }), Nr = (h) => Xf(h) && Z(h.dom.host), Ks = ne(Element.prototype.attachShadow) && ne(Node.prototype.getRootNode), fo = G(Ks), ta = Ks ? (h) => nt.fromDom(h.dom.getRootNode()) : em, Yc = (h) => {
    const w = ta(h);
    return Nr(w) ? Ce.some(w) : Ce.none();
  }, Rm = (h) => nt.fromDom(h.dom.host), kn = (h) => {
    if (fo() && Z(h.target)) {
      const w = nt.fromDom(h.target);
      if (Ei(w) && Pm(w) && h.composed && h.composedPath) {
        const A = h.composedPath();
        if (A)
          return ke(A);
      }
    }
    return Ce.from(h.target);
  }, Pm = (h) => Z(h.dom.shadowRoot), ca = (h) => {
    const w = Jl(h) ? h.dom.parentNode : h.dom;
    if (w == null || w.ownerDocument === null)
      return !1;
    const A = w.ownerDocument;
    return Yc(nt.fromDom(w)).fold(() => A.body.contains(w), ue(ca, Rm));
  }, as = () => _p(nt.fromDom(document)), _p = (h) => {
    const w = h.dom.body;
    if (w == null)
      throw new Error("Body is not available yet");
    return nt.fromDom(w);
  }, vs = (h, w, A) => xt(Xu(h, A), w), Wv = (h, w) => xt($o(h), w), Va = (h, w) => {
    let A = [];
    return Ne($o(h), (P) => {
      w(P) && (A = A.concat([P])), A = A.concat(Va(P, w));
    }), A;
  }, Sc = (h, w, A) => vs(h, (P) => Ja(P, w), A), Sr = (h, w) => Wv(h, (A) => Ja(A, w)), Rc = (h, w) => Ep(w, h);
  var rn = (h, w, A, P, V) => h(A, P) ? Ce.some(A) : ne(V) && V(A) ? Ce.none() : w(A, P, V);
  const na = (h, w, A) => {
    let P = h.dom;
    const V = ne(A) ? A : je;
    for (; P.parentNode; ) {
      P = P.parentNode;
      const K = nt.fromDom(P);
      if (w(K))
        return Ce.some(K);
      if (V(K))
        break;
    }
    return Ce.none();
  }, Dm = (h, w, A) => rn((V, K) => K(V), na, h, w, A), Ta = (h, w) => {
    const A = (V) => w(nt.fromDom(V));
    return oe(h.dom.childNodes, A).map(nt.fromDom);
  }, bs = (h, w) => {
    const A = (P) => {
      for (let V = 0; V < P.childNodes.length; V++) {
        const K = nt.fromDom(P.childNodes[V]);
        if (w(K))
          return Ce.some(K);
        const ie = A(P.childNodes[V]);
        if (ie.isSome())
          return ie;
      }
      return Ce.none();
    };
    return A(h.dom);
  }, Dd = (h, w, A) => na(h, (P) => Ja(P, w), A), Ur = (h, w) => Ta(h, (A) => Ja(A, w)), Qc = (h, w) => Jf(w, h), ni = (h, w, A) => rn((V, K) => Ja(V, K), Dd, h, w, A), Xc = (h, w, A = we) => h.exists((P) => A(P, w)), Ds = (h) => {
    const w = [], A = (P) => {
      w.push(P);
    };
    for (let P = 0; P < h.length; P++)
      h[P].each(A);
    return w;
  }, af = (h, w) => h != null ? w(h) : Ce.none(), _a = (h, w) => h ? Ce.some(w) : Ce.none(), $d = (h, w, A) => w === "" || h.length >= w.length && h.substr(A, A + w.length) === w, Oo = (h, w, A = 0, P) => {
    const V = h.indexOf(w, A);
    return V !== -1 ? I(P) ? !0 : V + w.length <= P : !1;
  }, Nu = (h, w) => $d(h, w, 0), Ru = (h, w) => $d(h, w, h.length - w.length), Ml = ((h) => (w) => w.replace(h, ""))(/^\s+|\s+$/g), Op = (h) => h.length > 0, no = (h) => {
    const w = parseFloat(h);
    return isNaN(w) ? Ce.none() : Ce.some(w);
  }, Oa = (h) => h.style !== void 0 && ne(h.style.getPropertyValue), Pa = (h, w, A) => {
    if (!v(A))
      throw console.error("Invalid call to CSS.set. Property ", w, ":: Value ", A, ":: Element ", h), new Error("CSS value must be a string: " + A);
    Oa(h) && h.style.setProperty(w, A);
  }, jv = (h, w) => {
    Oa(h) && h.style.removeProperty(w);
  }, zs = (h, w, A) => {
    const P = h.dom;
    Pa(P, w, A);
  }, Mi = (h, w) => {
    const A = h.dom;
    Ye(w, (P, V) => {
      Pa(A, V, P);
    });
  }, hi = (h, w) => {
    const A = h.dom, V = window.getComputedStyle(A).getPropertyValue(w);
    return V === "" && !ca(h) ? Fh(A, w) : V;
  }, Fh = (h, w) => Oa(h) ? h.style.getPropertyValue(w) : "", Lh = (h, w) => {
    const A = h.dom, P = Fh(A, w);
    return Ce.from(P).filter((V) => V.length > 0);
  }, Fl = (h, w) => {
    const A = h.dom;
    jv(A, w), Xc(vc(h, "style").map(Ml), "") && ea(h, "style");
  }, $m = (h, w) => {
    const A = h.dom, P = w.dom;
    Oa(A) && Oa(P) && (P.style.cssText = A.style.cssText);
  }, is = (h, w, A = 0) => vc(h, w).map((P) => parseInt(P, 10)).getOr(A), ru = (h, w) => is(h, w, 1), Ji = (h) => Qa("col")(h) ? is(h, "span", 1) > 1 : ru(h, "colspan") > 1, ri = (h) => ru(h, "rowspan") > 1, Da = (h, w) => parseInt(hi(h, w), 10), Vs = G(10), Ll = G(10), cf = (h, w) => nm(h, w, Ie), nm = (h, w, A) => Zt($o(h), (P) => Ja(P, w) ? A(P) ? [P] : [] : nm(P, w, A)), Bh = (h, w, A = je) => {
    if (A(w))
      return Ce.none();
    if (bt(h, es(w)))
      return Ce.some(w);
    const P = (V) => Ja(V, "table") || A(V);
    return Dd(w, h.join(","), P);
  }, Ap = (h, w) => Bh([
    "td",
    "th"
  ], h, w), Pc = (h) => cf(h, "th,td"), kp = (h) => Ja(h, "colgroup") ? Sr(h, "col") : Zt(Np(h), (w) => Sr(w, "col")), gi = (h, w) => ni(h, "table", w), Pu = (h) => cf(h, "tr"), Np = (h) => gi(h).fold(G([]), (w) => Sr(w, "colgroup")), nd = (h, w) => st(h, (A) => {
    if (es(A) === "colgroup") {
      const P = st(kp(A), (V) => {
        const K = is(V, "span", 1);
        return Nm(V, 1, K);
      });
      return Ve(A, P, "colgroup");
    } else {
      const P = st(Pc(A), (V) => {
        const K = is(V, "rowspan", 1), ie = is(V, "colspan", 1);
        return Nm(V, K, ie);
      });
      return Ve(A, P, w(A));
    }
  }), Im = (h) => Ac(h).map((w) => {
    const A = es(w);
    return Nc(A) ? A : "tbody";
  }).getOr("tbody"), wc = (h) => {
    const w = Pu(h), P = [
      ...Np(h),
      ...w
    ];
    return nd(P, Im);
  }, Mm = (h, w) => nd(h, () => w), Id = (h) => {
    let w = !1, A;
    return (...P) => (w || (w = !0, A = h.apply(null, P)), A);
  }, Ig = (h, w, A, P) => {
    const V = h.isiOS() && /ipad/i.test(A) === !0, K = h.isiOS() && !V, ie = h.isiOS() || h.isAndroid(), ve = ie || P("(pointer:coarse)"), Ae = V || !K && ie && P("(min-device-width:768px)"), Ue = K || ie && !Ae, ct = w.isSafari() && h.isiOS() && /safari/i.test(A) === !1, Yt = !Ue && !Ae && !ct;
    return {
      isiPad: G(V),
      isiPhone: G(K),
      isTablet: G(Ae),
      isPhone: G(Ue),
      isTouch: G(ve),
      isAndroid: h.isAndroid,
      isiOS: h.isiOS,
      isWebView: G(ct),
      isDesktop: G(Yt)
    };
  }, Mg = (h, w) => {
    for (let A = 0; A < h.length; A++) {
      const P = h[A];
      if (P.test(w))
        return P;
    }
  }, lf = (h, w) => {
    const A = Mg(h, w);
    if (!A)
      return {
        major: 0,
        minor: 0
      };
    const P = (V) => Number(w.replace(A, "$" + V));
    return Fe(P(1), P(2));
  }, Ec = (h, w) => {
    const A = String(w).toLowerCase();
    return h.length === 0 ? Fg() : lf(h, A);
  }, Fg = () => Fe(0, 0), Fe = (h, w) => ({
    major: h,
    minor: w
  }), uf = {
    nu: Fe,
    detect: Ec,
    unknown: Fg
  }, Bl = (h, w) => an(w.brands, (A) => {
    const P = A.brand.toLowerCase();
    return oe(h, (V) => {
      var K;
      return P === ((K = V.brand) === null || K === void 0 ? void 0 : K.toLowerCase());
    }).map((V) => ({
      current: V.name,
      version: uf.nu(parseInt(A.version, 10), 0)
    }));
  }), Fm = (h, w) => {
    const A = String(w).toLowerCase();
    return oe(h, (P) => P.search(A));
  }, Lg = (h, w) => Fm(h, w).map((A) => {
    const P = uf.detect(A.versionRegexes, w);
    return {
      current: A.name,
      version: P
    };
  }), Lm = (h, w) => Fm(h, w).map((A) => {
    const P = uf.detect(A.versionRegexes, w);
    return {
      current: A.name,
      version: P
    };
  }), Je = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/, Wt = (h) => (w) => Oo(w, h), Ft = [
    {
      name: "Edge",
      versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
      search: (h) => Oo(h, "edge/") && Oo(h, "chrome") && Oo(h, "safari") && Oo(h, "applewebkit")
    },
    {
      name: "Chromium",
      brand: "Chromium",
      versionRegexes: [
        /.*?chrome\/([0-9]+)\.([0-9]+).*/,
        Je
      ],
      search: (h) => Oo(h, "chrome") && !Oo(h, "chromeframe")
    },
    {
      name: "IE",
      versionRegexes: [
        /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
        /.*?rv:([0-9]+)\.([0-9]+).*/
      ],
      search: (h) => Oo(h, "msie") || Oo(h, "trident")
    },
    {
      name: "Opera",
      versionRegexes: [
        Je,
        /.*?opera\/([0-9]+)\.([0-9]+).*/
      ],
      search: Wt("opera")
    },
    {
      name: "Firefox",
      versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
      search: Wt("firefox")
    },
    {
      name: "Safari",
      versionRegexes: [
        Je,
        /.*?cpu os ([0-9]+)_([0-9]+).*/
      ],
      search: (h) => (Oo(h, "safari") || Oo(h, "mobile/")) && Oo(h, "applewebkit")
    }
  ], er = [
    {
      name: "Windows",
      search: Wt("win"),
      versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
    },
    {
      name: "iOS",
      search: (h) => Oo(h, "iphone") || Oo(h, "ipad"),
      versionRegexes: [
        /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
        /.*cpu os ([0-9]+)_([0-9]+).*/,
        /.*cpu iphone os ([0-9]+)_([0-9]+).*/
      ]
    },
    {
      name: "Android",
      search: Wt("android"),
      versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
    },
    {
      name: "macOS",
      search: Wt("mac os x"),
      versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
    },
    {
      name: "Linux",
      search: Wt("linux"),
      versionRegexes: []
    },
    {
      name: "Solaris",
      search: Wt("sunos"),
      versionRegexes: []
    },
    {
      name: "FreeBSD",
      search: Wt("freebsd"),
      versionRegexes: []
    },
    {
      name: "ChromeOS",
      search: Wt("cros"),
      versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
    }
  ], Qr = {
    browsers: G(Ft),
    oses: G(er)
  }, No = "Edge", Qo = "Chromium", Xo = "IE", Rp = "Opera", qv = "Firefox", $a = "Safari", Hl = () => Bg({
    current: void 0,
    version: uf.unknown()
  }), Bg = (h) => {
    const w = h.current, A = h.version, P = (V) => () => w === V;
    return {
      current: w,
      version: A,
      isEdge: P(No),
      isChromium: P(Qo),
      isIE: P(Xo),
      isOpera: P(Rp),
      isFirefox: P(qv),
      isSafari: P($a)
    };
  }, oi = {
    unknown: Hl,
    nu: Bg,
    edge: G(No),
    chromium: G(Qo),
    ie: G(Xo),
    opera: G(Rp),
    firefox: G(qv),
    safari: G($a)
  }, ga = "Windows", Du = "iOS", ys = "Android", ou = "Linux", ec = "macOS", Bm = "Solaris", Gv = "FreeBSD", Pp = "ChromeOS", Hh = () => Md({
    current: void 0,
    version: uf.unknown()
  }), Md = (h) => {
    const w = h.current, A = h.version, P = (V) => () => w === V;
    return {
      current: w,
      version: A,
      isWindows: P(ga),
      isiOS: P(Du),
      isAndroid: P(ys),
      isMacOS: P(ec),
      isLinux: P(ou),
      isSolaris: P(Bm),
      isFreeBSD: P(Gv),
      isChromeOS: P(Pp)
    };
  }, Cc = {
    unknown: Hh,
    nu: Md,
    windows: G(ga),
    ios: G(Du),
    android: G(ys),
    linux: G(ou),
    macos: G(ec),
    solaris: G(Bm),
    freebsd: G(Gv),
    chromeos: G(Pp)
  }, wy = { detect: (h, w, A) => {
    const P = Qr.browsers(), V = Qr.oses(), K = w.bind((Ae) => Bl(P, Ae)).orThunk(() => Lg(P, h)).fold(oi.unknown, oi.nu), ie = Lm(V, h).fold(Cc.unknown, Cc.nu), ve = Ig(ie, K, h, A);
    return {
      browser: K,
      os: ie,
      deviceType: ve
    };
  } }, Hm = (h) => window.matchMedia(h).matches;
  let zh = Id(() => wy.detect(navigator.userAgent, Ce.from(navigator.userAgentData), Hm));
  const df = () => zh(), ff = (h, w) => {
    const A = (ve, Ae) => {
      if (!se(Ae) && !Ae.match(/^[0-9]+$/))
        throw new Error(h + ".set accepts only positive integer values. Value was " + Ae);
      const Ue = ve.dom;
      Oa(Ue) && (Ue.style[h] = Ae + "px");
    }, P = (ve) => {
      const Ae = w(ve);
      if (Ae <= 0 || Ae === null) {
        const Ue = hi(ve, h);
        return parseFloat(Ue) || 0;
      }
      return Ae;
    }, V = P, K = (ve, Ae) => He(Ae, (Ue, ct) => {
      const Yt = hi(ve, ct), On = Yt === void 0 ? 0 : parseInt(Yt, 10);
      return isNaN(On) ? Ue : Ue + On;
    }, 0);
    return {
      set: A,
      get: P,
      getOuter: V,
      aggregate: K,
      max: (ve, Ae, Ue) => {
        const ct = K(ve, Ue);
        return Ae > ct ? Ae - ct : 0;
      }
    };
  }, rm = (h, w) => no(h).getOr(w), cs = (h, w, A) => rm(hi(h, w), A), Ss = (h, w, A, P) => {
    const V = cs(h, `padding-${A}`, 0), K = cs(h, `padding-${P}`, 0), ie = cs(h, `border-${A}-width`, 0), ve = cs(h, `border-${P}-width`, 0);
    return w - V - K - ie - ve;
  }, Fi = (h, w) => {
    const A = h.dom, P = A.getBoundingClientRect().width || A.offsetWidth;
    return w === "border-box" ? P : Ss(h, P, "left", "right");
  }, Hg = (h) => cs(h, "height", h.dom.offsetHeight), Zv = (h) => cs(h, "width", h.dom.offsetWidth), Ci = (h) => Fi(h, "content-box"), su = ff("width", (h) => h.dom.offsetWidth), Li = (h) => su.get(h), au = (h) => su.getOuter(h), Vh = Ci, Rr = Zv, el = (h, w, A) => {
    const P = h.cells, V = P.slice(0, w), K = P.slice(w), ie = V.concat(A).concat(K);
    return Bi(h, ie);
  }, mf = (h, w, A) => el(h, w, [A]), Ia = (h, w, A) => {
    const P = h.cells;
    P[w] = A;
  }, Bi = (h, w) => en(h.element, w, h.section, h.isNew), Kv = (h, w) => {
    const A = h.cells, P = st(A, w);
    return en(h.element, P, h.section, h.isNew);
  }, Hi = (h, w) => h.cells[w], va = (h, w) => Hi(h, w).element, ml = (h) => h.cells.length, Aa = (h) => {
    const w = Gt(h, (A) => A.section === "colgroup");
    return {
      rows: w.fail,
      cols: w.pass
    };
  }, rd = (h, w, A) => {
    const P = st(h.cells, A);
    return en(w(h.element), P, h.section, !0);
  }, Fd = "data-snooker-locked-cols", $s = (h) => vc(h, Fd).bind((w) => Ce.from(w.match(/\d+/g))).map((w) => Ge(w, Ie)), ba = (h) => {
    const w = He(Aa(h).rows, (P, V) => (Ne(V.cells, (K, ie) => {
      K.isLocked && (P[ie] = !0);
    }), P), {}), A = Vr(w, (P, V) => parseInt(V, 10));
    return qt(A);
  }, tl = (h, w) => h + "," + w, od = (h, w, A) => Ce.from(h.access[tl(w, A)]), Ys = (h, w, A) => {
    const P = zg(h, (V) => A(w, V.element));
    return P.length > 0 ? Ce.some(P[0]) : Ce.none();
  }, zg = (h, w) => {
    const A = Zt(h.all, (P) => P.cells);
    return xt(A, w);
  }, Yv = (h) => {
    const w = {};
    let A = 0;
    return Ne(h.cells, (P) => {
      const V = P.colspan;
      _n(V, (K) => {
        const ie = A + K;
        w[ie] = Yo(P.element, V, ie);
      }), A += V;
    }), w;
  }, Vo = (h) => {
    const w = {}, A = [], V = ke(h).map((Tn) => Tn.element).bind(gi).bind($s).getOr({});
    let K = 0, ie = 0, ve = 0;
    const {
      pass: Ae,
      fail: Ue
    } = Gt(h, (Tn) => Tn.section === "colgroup");
    Ne(Ue, (Tn) => {
      const It = [];
      Ne(Tn.cells, (An) => {
        let $t = 0;
        for (; w[tl(ve, $t)] !== void 0; )
          $t++;
        const Gn = uo(V, $t.toString()), Or = Se(An.element, An.rowspan, An.colspan, ve, $t, Gn);
        for (let jr = 0; jr < An.colspan; jr++)
          for (let da = 0; da < An.rowspan; da++) {
            const _c = ve + da, ui = $t + jr, bd = tl(_c, ui);
            w[bd] = Or, ie = Math.max(ie, ui + 1);
          }
        It.push(Or);
      }), K++, A.push(Ve(Tn.element, It, Tn.section)), ve++;
    });
    const { columns: ct, colgroups: Yt } = Ct(Ae).map((Tn) => {
      const It = Yv(Tn);
      return {
        colgroups: [Lr(Tn.element, Xr(It))],
        columns: It
      };
    }).getOrThunk(() => ({
      colgroups: [],
      columns: {}
    }));
    return {
      grid: ku(K, ie),
      access: w,
      all: A,
      columns: ct,
      colgroups: Yt
    };
  }, ye = {
    fromTable: (h) => {
      const w = wc(h);
      return Vo(w);
    },
    generate: Vo,
    getAt: od,
    findItem: Ys,
    filterItems: zg,
    justCells: (h) => Zt(h.all, (w) => w.cells),
    justColumns: (h) => Xr(h.columns),
    hasColumns: (h) => ht(h.columns).length > 0,
    getColumnAt: (h, w) => Ce.from(h.columns[w])
  }, cu = (h, w = Ie) => {
    const A = h.grid, P = _n(A.columns, me), V = _n(A.rows, me);
    return st(P, (K) => zm(() => Zt(V, (Ue) => ye.getAt(h, Ue, K).filter((ct) => ct.column === K).toArray()), (Ue) => Ue.colspan === 1 && w(Ue.element), () => ye.getAt(h, 0, K)));
  }, zm = (h, w, A) => {
    const P = h();
    return oe(P, w).orThunk(() => Ce.from(P[0]).orThunk(A)).map((ie) => ie.element);
  }, pl = (h) => {
    const w = h.grid, A = _n(w.rows, me), P = _n(w.columns, me);
    return st(A, (V) => zm(() => Zt(P, (Ae) => ye.getAt(h, V, Ae).filter((Ue) => Ue.row === V).fold(G([]), (Ue) => [Ue])), (Ae) => Ae.rowspan === 1, () => ye.getAt(h, V, 0)));
  }, ts = (h, w) => {
    if (w < 0 || w >= h.length - 1)
      return Ce.none();
    const A = h[w].fold(() => {
      const V = wo(h.slice(0, w));
      return an(V, (K, ie) => K.map((ve) => ({
        value: ve,
        delta: ie + 1
      })));
    }, (V) => Ce.some({
      value: V,
      delta: 0
    })), P = h[w + 1].fold(() => {
      const V = h.slice(w + 1);
      return an(V, (K, ie) => K.map((ve) => ({
        value: ve,
        delta: ie + 1
      })));
    }, (V) => Ce.some({
      value: V,
      delta: 1
    }));
    return A.bind((V) => P.map((K) => {
      const ie = K.delta + V.delta;
      return Math.abs(K.value - V.value) / ie;
    }));
  }, Qv = (h, w) => (A) => Uh(A) === "rtl" ? w : h, Uh = (h) => hi(h, "direction") === "rtl" ? "rtl" : "ltr", Vg = ff("height", (h) => {
    const w = h.dom;
    return ca(h) ? w.getBoundingClientRect().height : w.offsetHeight;
  }), Iu = (h) => Vg.get(h), H = (h) => Vg.getOuter(h), X = Hg, fe = (h, w) => ({
    left: h,
    top: w,
    translate: (P, V) => fe(h + P, w + V)
  }), Me = fe, We = (h) => {
    const w = h.getBoundingClientRect();
    return Me(w.left, w.top);
  }, Ut = (h, w) => h !== void 0 ? h : w !== void 0 ? w : 0, Wn = (h) => {
    const w = h.dom.ownerDocument, A = w.body, P = w.defaultView, V = w.documentElement;
    if (A === h.dom)
      return Me(A.offsetLeft, A.offsetTop);
    const K = Ut(P == null ? void 0 : P.pageYOffset, V.scrollTop), ie = Ut(P == null ? void 0 : P.pageXOffset, V.scrollLeft), ve = Ut(V.clientTop, A.clientTop), Ae = Ut(V.clientLeft, A.clientLeft);
    return xr(h).translate(ie - Ae, K - ve);
  }, xr = (h) => {
    const w = h.dom, P = w.ownerDocument.body;
    return P === w ? Me(P.offsetLeft, P.offsetTop) : ca(h) ? We(w) : Me(0, 0);
  }, wr = (h, w) => ({
    row: h,
    y: w
  }), pr = (h, w) => ({
    col: h,
    x: w
  }), Us = (h) => Wn(h).left + au(h), ra = (h) => Wn(h).left, hl = (h, w) => pr(h, ra(w)), Ld = (h, w) => pr(h, Us(w)), Vi = (h) => Wn(h).top, rw = (h, w) => wr(h, Vi(w)), xs = (h, w) => wr(h, Vi(w) + H(w)), jn = (h, w, A) => {
    if (A.length === 0)
      return [];
    const P = st(A.slice(1), (K, ie) => K.map((ve) => h(ie, ve))), V = A[A.length - 1].map((K) => w(A.length - 1, K));
    return P.concat([V]);
  }, pf = (h) => -h, Un = {
    delta: me,
    positions: (h) => jn(rw, xs, h),
    edge: Vi
  }, hf = Qv({
    delta: me,
    edge: ra,
    positions: (h) => jn(hl, Ld, h)
  }, {
    delta: pf,
    edge: Us,
    positions: (h) => jn(Ld, hl, h)
  }), Ua = {
    delta: (h, w) => hf(w).delta(h, w),
    positions: (h, w) => hf(w).positions(h, w),
    edge: (h) => hf(h).edge(h)
  }, om = {
    unsupportedLength: [
      "em",
      "ex",
      "cap",
      "ch",
      "ic",
      "rem",
      "lh",
      "rlh",
      "vw",
      "vh",
      "vi",
      "vb",
      "vmin",
      "vmax",
      "cm",
      "mm",
      "Q",
      "in",
      "pc",
      "pt",
      "px"
    ],
    fixed: [
      "px",
      "pt"
    ],
    relative: ["%"],
    empty: [""]
  }, Ug = (() => {
    const h = "[0-9]+", A = "[eE]" + ("[+-]?" + h), P = "\\.", V = (ve) => `(?:${ve})?`, ie = `[+-]?(?:${[
      "Infinity",
      h + P + V(h) + V(A),
      P + h + V(A),
      h + V(A)
    ].join("|")})`;
    return new RegExp(`^(${ie})(.*)$`);
  })(), xi = (h, w) => at(w, (A) => at(om[A], (P) => h === P)), ad = (h, w) => Ce.from(Ug.exec(h)).bind((P) => {
    const V = Number(P[1]), K = P[2];
    return xi(K, w) ? Ce.some({
      value: V,
      unit: K
    }) : Ce.none();
  }), Xv = /(\d+(\.\d+)?)%/, gf = /(\d+(\.\d+)?)px|em/, Jv = Qa("col"), sm = (h, w, A) => {
    const P = kc(h).getOrThunk(() => _p(tu(h)));
    return w(h) / A(P) * 100;
  }, Qt = (h, w) => {
    zs(h, "width", w + "px");
  }, H1 = (h, w) => {
    zs(h, "width", w + "%");
  }, am = (h, w) => {
    zs(h, "height", w + "px");
  }, im = (h) => X(h) + "px", Mu = (h, w, A, P) => {
    const V = gi(h).map((K) => {
      const ie = A(K);
      return Math.floor(w / 100 * ie);
    }).getOr(w);
    return P(h, V), V;
  }, Ws = (h, w, A, P) => {
    const V = parseFloat(h);
    return Ru(h, "%") && es(w) !== "table" ? Mu(w, V, A, P) : V;
  }, Mo = (h) => {
    const w = im(h);
    return w ? Ws(w, h, Iu, am) : Iu(h);
  }, ya = (h, w, A) => {
    const P = A(h), V = ru(h, w);
    return P / V;
  }, Dc = (h, w) => Lh(h, w).orThunk(() => vc(h, w).map((A) => A + "px")), ro = (h) => Dc(h, "width"), $p = (h) => Dc(h, "height"), si = (h) => sm(h, Li, Vh), Ts = (h) => Jv(h) ? Li(h) : Rr(h), Wg = (h) => ya(h, "rowspan", Mo), Mt = (h) => ro(h).bind((A) => ad(A, [
    "fixed",
    "relative",
    "empty"
  ])), $c = (h, w, A) => {
    zs(h, "width", w + A);
  }, jg = (h) => Li(h) + "px", xo = (h) => sm(h, Li, Vh) + "%", ka = (h) => ro(h).exists((w) => Xv.test(w)), eb = (h) => ro(h).exists((w) => gf.test(w)), id = (h) => ro(h).isNone(), cd = G(Xv), lu = Qa("col"), Wh = (h) => ro(h).getOrThunk(() => Ts(h) + "px"), tc = (h) => $p(h).getOrThunk(() => Wg(h) + "px"), Fo = (h) => st(ye.justColumns(h), (w) => Ce.from(w.element)), ai = (h) => {
    const w = df().browser, A = w.isChromium() || w.isFirefox();
    return lu(h) ? A : !0;
  }, cm = (h, w, A, P, V, K) => h.filter(P).fold(() => K(ts(A, w)), (ie) => V(ie)), nc = (h, w, A, P) => {
    const V = cu(h), K = ye.hasColumns(h) ? Fo(h) : V, ie = [Ce.some(Ua.edge(w))].concat(st(Ua.positions(V, w), (Ae) => Ae.map((Ue) => Ue.x))), ve = q(Ji);
    return st(K, (Ae, Ue) => cm(Ae, Ue, ie, ve, (ct) => {
      if (ai(ct))
        return A(ct);
      {
        const Yt = af(V[Ue], me);
        return cm(Yt, Ue, ie, ve, (On) => P(Ce.some(Li(On))), P);
      }
    }, P));
  }, Ey = (h) => h.map((w) => w + "px").getOr(""), Ip = (h, w) => nc(h, w, Wh, Ey), lm = (h, w, A) => nc(h, w, si, (P) => P.fold(() => A.minCellWidth(), (V) => V / A.pixelWidth() * 100)), nl = (h, w, A) => nc(h, w, Ts, (P) => P.getOrThunk(A.minCellWidth)), ld = (h, w, A, P, V) => {
    const K = pl(h), ie = [Ce.some(A.edge(w))].concat(st(A.positions(K, w), (ve) => ve.map((Ae) => Ae.y)));
    return st(K, (ve, Ae) => cm(ve, Ae, ie, q(ri), P, V));
  }, lt = (h, w, A) => ld(h, w, A, Wg, (P) => P.getOrThunk(Ll)), gl = (h, w, A) => ld(h, w, A, tc, Ey), Fu = (h, w) => () => ca(h) ? w(h) : parseFloat(Lh(h, "width").getOr("0")), rl = (h) => {
    const w = Fu(h, Li), A = G(0);
    return {
      width: w,
      pixelWidth: w,
      getWidths: (V, K) => nl(V, h, K),
      getCellDelta: A,
      singleColumnWidth: G([0]),
      minCellWidth: A,
      setElementWidth: Q,
      adjustTableWidth: Q,
      isRelative: !0,
      label: "none"
    };
  }, vl = (h) => {
    const w = Fu(h, (Ae) => parseFloat(xo(Ae))), A = Fu(h, Li);
    return {
      width: w,
      pixelWidth: A,
      getWidths: (Ae, Ue) => lm(Ae, h, Ue),
      getCellDelta: (Ae) => Ae / A() * 100,
      singleColumnWidth: (Ae, Ue) => [100 - Ae],
      minCellWidth: () => Vs() / A() * 100,
      setElementWidth: H1,
      adjustTableWidth: (Ae) => {
        const Ue = w(), ct = Ae / 100 * Ue, Yt = Ue + ct;
        H1(h, Yt);
      },
      isRelative: !0,
      label: "percent"
    };
  }, vi = (h) => {
    const w = Fu(h, Li);
    return {
      width: w,
      pixelWidth: w,
      getWidths: (ie, ve) => nl(ie, h, ve),
      getCellDelta: me,
      singleColumnWidth: (ie, ve) => [Math.max(Vs(), ie + ve) - ie],
      minCellWidth: Vs,
      setElementWidth: Qt,
      adjustTableWidth: (ie) => {
        const ve = w() + ie;
        Qt(h, ve);
      },
      isRelative: !1,
      label: "pixel"
    };
  }, ii = (h, w) => cd().exec(w) !== null ? vl(h) : vi(h), bl = {
    getTableSize: (h) => ro(h).fold(() => rl(h), (A) => ii(h, A)),
    pixelSize: vi,
    percentageSize: vl,
    noneSize: rl
  }, vf = (h, w, A, P, V, K) => ({
    minRow: h,
    minCol: w,
    maxRow: A,
    maxCol: P,
    allCells: V,
    selectedCells: K
  }), sr = (h, w) => {
    const A = h.grid.columns;
    let V = h.grid.rows, K = A, ie = 0, ve = 0;
    const Ae = [], Ue = [];
    return Ye(h.access, (ct) => {
      if (Ae.push(ct), w(ct)) {
        Ue.push(ct);
        const Yt = ct.row, On = Yt + ct.rowspan - 1, Tn = ct.column, It = Tn + ct.colspan - 1;
        Yt < V ? V = Yt : On > ie && (ie = On), Tn < K ? K = Tn : It > ve && (ve = It);
      }
    }), vf(V, K, ie, ve, Ae, Ue);
  }, M = (h, w, A) => {
    const P = h[A].element, V = nt.fromTag("td");
    ss(V, nt.fromTag("br")), (w ? ss : Zs)(P, V);
  }, W = (h, w, A, P) => {
    const V = xt(h, (ve) => ve.section !== "colgroup"), K = w.grid.columns, ie = w.grid.rows;
    for (let ve = 0; ve < ie; ve++) {
      let Ae = !1;
      for (let Ue = 0; Ue < K; Ue++)
        ve < A.minRow || ve > A.maxRow || Ue < A.minCol || Ue > A.maxCol || (ye.getAt(w, ve, Ue).filter(P).isNone() ? M(V, Ae, ve) : Ae = !0);
    }
  }, de = (h, w, A, P) => {
    Ye(A.columns, (ie) => {
      (ie.column < w.minCol || ie.column > w.maxCol) && Ra(ie.element);
    });
    const V = xt(cf(h, "tr"), (ie) => ie.dom.childElementCount === 0);
    Ne(V, Ra), (w.minCol === w.maxCol || w.minRow === w.maxRow) && Ne(cf(h, "th,td"), (ie) => {
      ea(ie, "rowspan"), ea(ie, "colspan");
    }), ea(h, Fd), ea(h, "data-snooker-col-series"), bl.getTableSize(h).adjustTableWidth(P);
  }, Ee = (h, w, A, P) => {
    if (P.minCol === 0 && w.grid.columns === P.maxCol + 1)
      return 0;
    const V = nl(w, h, A), K = He(V, (Ue, ct) => Ue + ct, 0), Ae = He(V.slice(P.minCol, P.maxCol + 1), (Ue, ct) => Ue + ct, 0) / K * A.pixelWidth() - A.pixelWidth();
    return A.getCellDelta(Ae);
  }, qe = (h, w) => {
    const A = (On) => Ja(On.element, w), P = Dl(h), V = wc(P), K = bl.getTableSize(h), ie = ye.generate(V), ve = sr(ie, A), Ae = "th:not(" + w + "),td:not(" + w + ")", Ue = nm(P, "th,td", (On) => Ja(On, Ae));
    Ne(Ue, Ra), W(V, ie, ve, A);
    const ct = ye.fromTable(h), Yt = Ee(h, ct, K, ve);
    return de(P, ve, ie, Yt), P;
  }, kt = "", Sn = ((h, w) => {
    const A = (K) => {
      if (!h(K))
        throw new Error("Can only get " + w + " value of a " + w + " node");
      return P(K).getOr("");
    }, P = (K) => h(K) ? Ce.from(K.dom.nodeValue) : Ce.none();
    return {
      get: A,
      getOption: P,
      set: (K, ie) => {
        if (!h(K))
          throw new Error("Can only set raw " + w + " value of a " + w + " node");
        K.dom.nodeValue = ie;
      }
    };
  })(Jl, "text"), Xn = (h) => Sn.get(h), Pr = (h) => Sn.getOption(h), la = (h, w) => Sn.set(h, w), Lo = (h) => es(h) === "img" ? 1 : Pr(h).fold(() => $o(h).length, (w) => w.length), _s = (h) => Pr(h).filter((w) => w.trim().length !== 0 || w.indexOf(kt) > -1).isSome(), zl = (h) => lr(h) && Yu(h, "contenteditable") === "false", Ic = [
    "img",
    "br"
  ], uu = (h) => _s(h) || bt(Ic, es(h)) || zl(h), bf = (h) => bs(h, uu), Bd = (h) => Mp(h, uu), Mp = (h, w) => {
    const A = (P) => {
      const V = $o(P);
      for (let K = V.length - 1; K >= 0; K--) {
        const ie = V[K];
        if (w(ie))
          return Ce.some(ie);
        const ve = A(ie);
        if (ve.isSome())
          return ve;
      }
      return Ce.none();
    };
    return A(h);
  }, Ro = {
    scope: [
      "row",
      "col"
    ]
  }, Fp = (h) => () => {
    const w = nt.fromTag("td", h.dom);
    return ss(w, nt.fromTag("br", h.dom)), w;
  }, qg = (h) => () => nt.fromTag("col", h.dom), Sa = (h) => () => nt.fromTag("colgroup", h.dom), du = (h) => () => nt.fromTag("tr", h.dom), jh = (h, w, A) => {
    const P = km(h, w);
    return Ye(A, (V, K) => {
      V === null ? ea(P, K) : ia(P, K, V);
    }), P;
  }, Lp = (h) => h, qr = (h, w, A) => bf(h).map((V) => {
    const K = A.join(","), ie = Sc(V, K, (ve) => os(ve, h));
    return cn(ie, (ve, Ae) => {
      const Ue = Ii(Ae);
      return ss(ve, Ue), Ue;
    }, w);
  }).getOr(w), oo = (h, w) => {
    Ye(Ro, (A, P) => vc(h, P).filter((V) => bt(A, V)).each((V) => ia(w, P, V)));
  }, ci = (h, w, A) => {
    const P = (ie, ve) => {
      $m(ie.element, ve), Fl(ve, "height"), ie.colspan !== 1 && Fl(ve, "width");
    }, V = (ie) => {
      const ve = nt.fromTag(es(ie.element), w.dom), Ae = A.getOr([
        "strong",
        "em",
        "b",
        "i",
        "span",
        "font",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "p",
        "div"
      ]), Ue = Ae.length > 0 ? qr(ie.element, ve, Ae) : ve;
      return ss(Ue, nt.fromTag("br")), P(ie, ve), oo(ie.element, ve), h(ie.element, ve), ve;
    };
    return {
      col: (ie) => {
        const ve = nt.fromTag(es(ie.element), w.dom);
        return P(ie, ve), h(ie.element, ve), ve;
      },
      colgroup: Sa(w),
      row: du(w),
      cell: V,
      replace: jh,
      colGap: qg(w),
      gap: Fp(w)
    };
  }, rc = (h) => ({
    col: qg(h),
    colgroup: Sa(h),
    row: du(h),
    cell: Fp(h),
    replace: Lp,
    colGap: qg(h),
    gap: Fp(h)
  }), tb = (h, w) => {
    const P = (w || document).createElement("div");
    return P.innerHTML = h, $o(nt.fromDom(P));
  }, yf = (h) => st(h, nt.fromDom), oa = (h) => (w) => w.options.get(h), fu = "100%", ud = (h) => {
    var w;
    const A = h.dom, P = (w = A.getParent(h.selection.getStart(), A.isBlock)) !== null && w !== void 0 ? w : h.getBody();
    return Vh(nt.fromDom(P)) + "px";
  }, Bp = (h, w) => Up(h) || !Lu(h) ? w : Vp(h) ? {
    ...w,
    width: ud(h)
  } : {
    ...w,
    width: fu
  }, Vm = (h, w) => Up(h) || Lu(h) ? w : Vp(h) ? {
    ...w,
    width: ud(h)
  } : {
    ...w,
    width: fu
  }, Gg = (h) => {
    const w = h.options.register;
    w("table_clone_elements", { processor: "string[]" }), w("table_use_colgroups", {
      processor: "boolean",
      default: !0
    }), w("table_header_type", {
      processor: (A) => {
        const P = bt([
          "section",
          "cells",
          "sectionCells",
          "auto"
        ], A);
        return P ? {
          value: A,
          valid: P
        } : {
          valid: !1,
          message: "Must be one of: section, cells, sectionCells or auto."
        };
      },
      default: "section"
    }), w("table_sizing_mode", {
      processor: "string",
      default: "auto"
    }), w("table_default_attributes", {
      processor: "object",
      default: { border: "1" }
    }), w("table_default_styles", {
      processor: "object",
      default: { "border-collapse": "collapse" }
    }), w("table_column_resizing", {
      processor: (A) => {
        const P = bt([
          "preservetable",
          "resizetable"
        ], A);
        return P ? {
          value: A,
          valid: P
        } : {
          valid: !1,
          message: "Must be preservetable, or resizetable."
        };
      },
      default: "preservetable"
    }), w("table_resize_bars", {
      processor: "boolean",
      default: !0
    }), w("table_style_by_css", {
      processor: "boolean",
      default: !0
    }), w("table_merge_content_on_paste", {
      processor: "boolean",
      default: !0
    });
  }, um = (h) => Ce.from(h.options.get("table_clone_elements")), WC = (h) => {
    const w = h.options.get("object_resizing");
    return bt(w.split(","), "table");
  }, Hp = oa("table_header_type"), xy = oa("table_column_resizing"), zp = (h) => xy(h) === "preservetable", Wa = (h) => xy(h) === "resizetable", Hd = oa("table_sizing_mode"), Sf = (h) => Hd(h) === "relative", Vp = (h) => Hd(h) === "fixed", Up = (h) => Hd(h) === "responsive", Zg = oa("table_resize_bars"), Lu = oa("table_style_by_css"), Na = oa("table_merge_content_on_paste"), wf = (h) => {
    const w = h.options, A = w.get("table_default_attributes");
    return w.isSet("table_default_attributes") ? A : Vm(h, A);
  }, z1 = (h) => {
    const w = h.options, A = w.get("table_default_styles");
    return w.isSet("table_default_styles") ? A : Bp(h, A);
  }, Ty = oa("table_use_colgroups"), _y = (h) => ni(h, "[contenteditable]"), Wp = (h, w = !1) => ca(h) ? h.dom.isContentEditable : _y(h).fold(G(w), (A) => yl(A) === "true"), yl = (h) => h.dom.contentEditable, zd = (h) => nt.fromDom(h.getBody()), Um = (h) => (w) => os(w, zd(h)), dm = (h) => {
    ea(h, "data-mce-style");
    const w = (A) => ea(A, "data-mce-style");
    Ne(Pc(h), w), Ne(kp(h), w), Ne(Pu(h), w);
  }, Vl = (h) => nt.fromDom(h.selection.getStart()), Vd = (h) => h.getBoundingClientRect().width, jp = (h) => h.getBoundingClientRect().height, ow = (h, w) => {
    const A = h.dom.getStyle(w, "width") || h.dom.getAttrib(w, "width");
    return Ce.from(A).filter(Op);
  }, V1 = (h) => /^(\d+(\.\d+)?)%$/.test(h), nb = (h) => /^(\d+(\.\d+)?)px$/.test(h), qp = (h) => Dm(h, Qa("table")).exists(Wp), rb = (h, w) => {
    const A = w.column, P = w.column + w.colspan - 1, V = w.row, K = w.row + w.rowspan - 1;
    return A <= h.finishCol && P >= h.startCol && V <= h.finishRow && K >= h.startRow;
  }, U1 = (h, w) => w.column >= h.startCol && w.column + w.colspan - 1 <= h.finishCol && w.row >= h.startRow && w.row + w.rowspan - 1 <= h.finishRow, ob = (h, w) => {
    let A = !0;
    const P = be(U1, w);
    for (let V = w.startRow; V <= w.finishRow; V++)
      for (let K = w.startCol; K <= w.finishCol; K++)
        A = A && ye.getAt(h, V, K).exists(P);
    return A ? Ce.some(w) : Ce.none();
  }, sb = (h, w) => ur(Math.min(h.row, w.row), Math.min(h.column, w.column), Math.max(h.row + h.rowspan - 1, w.row + w.rowspan - 1), Math.max(h.column + h.colspan - 1, w.column + w.colspan - 1)), Jr = (h, w, A) => {
    const P = ye.findItem(h, w, os), V = ye.findItem(h, A, os);
    return P.bind((K) => V.map((ie) => sb(K, ie)));
  }, nr = (h, w, A) => Jr(h, w, A).bind((P) => ob(h, P)), Ef = (h, w, A, P) => ye.findItem(h, w, os).bind((V) => {
    const K = A > 0 ? V.row + V.rowspan - 1 : V.row, ie = P > 0 ? V.column + V.colspan - 1 : V.column;
    return ye.getAt(h, K + A, ie + P).map((Ae) => Ae.element);
  }), ab = (h, w, A) => Jr(h, w, A).map((P) => {
    const V = ye.filterItems(h, be(rb, P));
    return st(V, (K) => K.element);
  }), qh = (h, w) => {
    const A = (P, V) => Cp(V, P);
    return ye.findItem(h, w, A).map((P) => P.element);
  }, M2 = (h, w, A) => gi(h).bind((P) => {
    const V = Oy(P);
    return Ef(V, h, w, A);
  }), W1 = (h, w, A) => {
    const P = Oy(h);
    return ab(P, w, A);
  }, ls = (h, w, A, P, V) => {
    const K = Oy(h), ie = os(h, A) ? Ce.some(w) : qh(K, w), ve = os(h, V) ? Ce.some(P) : qh(K, P);
    return ie.bind((Ae) => ve.bind((Ue) => ab(K, Ae, Ue)));
  }, j1 = (h, w, A) => {
    const P = Oy(h);
    return nr(P, w, A);
  }, Oy = ye.fromTable;
  var sw = [
    "body",
    "p",
    "div",
    "article",
    "aside",
    "figcaption",
    "figure",
    "footer",
    "header",
    "nav",
    "section",
    "ol",
    "ul",
    "li",
    "table",
    "thead",
    "tbody",
    "tfoot",
    "caption",
    "tr",
    "td",
    "th",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "blockquote",
    "pre",
    "address"
  ], Pt = () => {
    const h = (Ue) => nt.fromDom(Ue.dom.cloneNode(!1)), w = (Ue) => em(Ue).dom, A = (Ue) => Ei(Ue) ? es(Ue) === "body" ? !0 : bt(sw, es(Ue)) : !1, P = (Ue) => Ei(Ue) ? bt([
      "br",
      "img",
      "hr",
      "input"
    ], es(Ue)) : !1, V = (Ue) => Ei(Ue) && Yu(Ue, "contenteditable") === "false", K = (Ue, ct) => Ue.dom.compareDocumentPosition(ct.dom), ie = (Ue, ct) => {
      const Yt = bc(Ue);
      Nl(ct, Yt);
    }, ve = (Ue) => {
      const ct = es(Ue);
      return bt([
        "script",
        "noscript",
        "iframe",
        "noframes",
        "noembed",
        "title",
        "style",
        "textarea",
        "xmp"
      ], ct);
    }, Ae = (Ue) => Ei(Ue) ? vc(Ue, "lang") : Ce.none();
    return {
      up: G({
        selector: Dd,
        closest: ni,
        predicate: na,
        all: Xu
      }),
      down: G({
        selector: Rc,
        predicate: Va
      }),
      styles: G({
        get: hi,
        getRaw: Lh,
        set: zs,
        remove: Fl
      }),
      attrs: G({
        get: Yu,
        set: ia,
        remove: ea,
        copyTo: ie
      }),
      insert: G({
        before: td,
        after: Xi,
        afterAll: Io,
        append: ss,
        appendAll: za,
        prepend: Zs,
        wrap: tm
      }),
      remove: G({
        unwrap: Pl,
        remove: Ra
      }),
      create: G({
        nu: nt.fromTag,
        clone: h,
        text: nt.fromText
      }),
      query: G({
        comparePosition: K,
        prevSibling: Ju,
        nextSibling: ed
      }),
      property: G({
        children: $o,
        name: es,
        parent: Ac,
        document: w,
        isText: Jl,
        isComment: gs,
        isElement: Ei,
        isSpecial: ve,
        getLanguage: Ae,
        getText: Xn,
        setText: la,
        isBoundary: A,
        isEmptyTag: P,
        isNonEditable: V
      }),
      eq: os,
      is: Am
    };
  };
  const Cf = (h, w, A, P) => {
    const V = A[0], K = A.slice(1);
    return P(h, w, V, K);
  }, jC = (h, w, A) => A.length > 0 ? Cf(h, w, A, ib) : Ce.none(), ib = (h, w, A, P) => {
    const V = w(h, A);
    return cn(P, (K, ie) => {
      const ve = w(h, ie);
      return F2(h, K, ve);
    }, V);
  }, F2 = (h, w, A) => w.bind((P) => A.filter(be(h.eq, P))), Kg = (h, w) => be(h.eq, w), aw = (h, w, A, P = je) => {
    const V = [w].concat(h.up().all(w)), K = [A].concat(h.up().all(A)), ie = (ct) => qn(ct, P).fold(() => ct, (On) => ct.slice(0, On + 1)), ve = ie(V), Ae = ie(K), Ue = oe(ve, (ct) => at(Ae, Kg(h, ct)));
    return {
      firstpath: ve,
      secondpath: Ae,
      shared: Ue
    };
  }, Gp = jC, Zp = aw, xf = Pt(), us = (h, w) => Gp(xf, (A, P) => h(P), w), Tf = (h, w, A) => Zp(xf, h, w, A), cb = (h) => Dd(h, "table"), Ul = (h, w, A) => {
    const P = (V) => (K) => A !== void 0 && A(K) || os(K, V);
    return os(h, w) ? Ce.some({
      boxes: Ce.some([h]),
      start: h,
      finish: w
    }) : cb(h).bind((V) => cb(w).bind((K) => {
      if (os(V, K))
        return Ce.some({
          boxes: W1(V, h, w),
          start: h,
          finish: w
        });
      if (Cp(V, K)) {
        const ie = Sc(w, "td,th", P(V)), ve = ie.length > 0 ? ie[ie.length - 1] : w;
        return Ce.some({
          boxes: ls(V, h, V, w, K),
          start: h,
          finish: ve
        });
      } else if (Cp(K, V)) {
        const ie = Sc(h, "td,th", P(K)), ve = ie.length > 0 ? ie[ie.length - 1] : h;
        return Ce.some({
          boxes: ls(K, h, V, w, K),
          start: h,
          finish: ve
        });
      } else
        return Tf(h, w).shared.bind((ie) => ni(ie, "table", A).bind((ve) => {
          const Ae = Sc(w, "td,th", P(ve)), Ue = Ae.length > 0 ? Ae[Ae.length - 1] : w, ct = Sc(h, "td,th", P(ve)), Yt = ct.length > 0 ? ct[ct.length - 1] : h;
          return Ce.some({
            boxes: ls(ve, h, V, w, K),
            start: Yt,
            finish: Ue
          });
        }));
    }));
  }, Wr = (h, w) => {
    const A = Rc(h, w);
    return A.length > 0 ? Ce.some(A) : Ce.none();
  }, lb = (h, w) => oe(h, (A) => Ja(A, w)), Kp = (h, w, A) => Qc(h, w).bind((P) => Qc(h, A).bind((V) => us(cb, [
    P,
    V
  ]).map((K) => ({
    first: P,
    last: V,
    table: K
  })))), Gh = (h, w) => Dd(h, "table").bind((A) => Qc(A, w).bind((P) => Ul(P, h).bind((V) => V.boxes.map((K) => ({
    boxes: K,
    start: V.start,
    finish: V.finish
  }))))), q1 = (h, w, A, P, V) => lb(h, V).bind((K) => M2(K, w, A).bind((ie) => Gh(ie, P))), Ay = (h, w) => Wr(h, w), qC = (h, w, A) => Kp(h, w, A).bind((P) => {
    const V = (Ae) => os(h, Ae), K = "thead,tfoot,tbody,table", ie = Dd(P.first, K, V), ve = Dd(P.last, K, V);
    return ie.bind((Ae) => ve.bind((Ue) => os(Ae, Ue) ? j1(P.table, P.first, P.last) : Ce.none()));
  }), Sl = me, Wm = (h) => {
    const w = (P, V) => vc(P, V).exists((K) => parseInt(K, 10) > 1), A = (P) => w(P, "rowspan") || w(P, "colspan");
    return h.length > 0 && Jt(h, A) ? Ce.some(h) : Ce.none();
  }, Vk = (h, w, A) => w.length <= 1 ? Ce.none() : qC(h, A.firstSelectedSelector, A.lastSelectedSelector).map((P) => ({
    bounds: P,
    cells: w
  })), G1 = "data-mce-selected", Yg = "td[" + G1 + "],th[" + G1 + "]", xc = "[" + G1 + "]", Hn = "data-mce-first-selected", L2 = "td[" + Hn + "],th[" + Hn + "]", iw = "data-mce-last-selected", Yp = "td[" + iw + "],th[" + iw + "]", mu = xc, Qp = {
    selected: G1,
    selectedSelector: Yg,
    firstSelected: Hn,
    firstSelectedSelector: L2,
    lastSelected: iw,
    lastSelectedSelector: Yp
  }, ub = (h, w, A) => ({
    element: A,
    mergable: Vk(w, h, Qp),
    unmergable: Wm(h),
    selection: Sl(h)
  }), Qg = (h, w, A) => ({
    element: h,
    clipboard: w,
    generators: A
  }), db = (h, w, A, P) => ({
    selection: Sl(h),
    clipboard: A,
    generators: P
  }), Z1 = (h) => gi(h).bind((w) => Ay(w, Qp.firstSelectedSelector)).fold(G(h), (w) => w[0]), Ud = (h) => (w, A) => {
    const P = es(w), V = P === "col" || P === "colgroup" ? Z1(w) : w;
    return ni(V, h, A);
  }, _f = Ud("th,td,caption"), fb = Ud("th,td"), Wd = (h) => yf(h.model.table.getSelectedCells()), K1 = (h) => xt(Wd(h), (w) => Ja(w, Qp.selectedSelector)), GC = (h) => gi(h[0]).map((w) => {
    const A = qe(w, mu);
    return dm(A), [A];
  }), mb = (h, w) => st(w, (A) => h.selection.serializer.serialize(A.dom, {})).join(""), jm = (h) => st(h, (w) => w.dom.innerText).join(""), ZC = (h, w) => {
    h.on("BeforeGetContent", (A) => {
      const P = (V) => {
        A.preventDefault(), GC(V).each((K) => {
          A.content = A.format === "text" ? jm(K) : mb(h, K);
        });
      };
      if (A.selection === !0) {
        const V = K1(h);
        V.length >= 1 && P(V);
      }
    }), h.on("BeforeSetContent", (A) => {
      if (A.selection === !0 && A.paste === !0) {
        const P = Wd(h);
        ke(P).each((V) => {
          gi(V).each((K) => {
            const ie = xt(tb(A.content), (Ae) => es(Ae) !== "meta"), ve = Qa("table");
            if (Na(h) && ie.length === 1 && ve(ie[0])) {
              A.preventDefault();
              const Ae = nt.fromDom(h.getDoc()), Ue = rc(Ae), ct = Qg(V, ie[0], Ue);
              w.pasteCells(K, ct).each(() => {
                h.focus();
              });
            }
          });
        });
      }
    });
  }, pb = (h, w) => ({
    element: h,
    offset: w
  }), Xp = (h, w, A) => h.property().isText(w) && h.property().getText(w).trim().length === 0 || h.property().isComment(w) ? A(w).bind((P) => Xp(h, P, A).orThunk(() => Ce.some(P))) : Ce.none(), jd = (h, w) => h.property().isText(w) ? h.property().getText(w).length : h.property().children(w).length, ol = (h, w) => {
    const A = Xp(h, w, h.query().prevSibling).getOr(w);
    if (h.property().isText(A))
      return pb(A, jd(h, A));
    const P = h.property().children(A);
    return P.length > 0 ? ol(h, P[P.length - 1]) : pb(A, jd(h, A));
  }, cw = ol, lw = Pt(), uw = (h) => cw(lw, h), hb = (h, w) => {
    Ji(h) || Mt(h).each((P) => {
      const V = P.value / 2;
      $c(h, V, P.unit), $c(w, V, P.unit);
    });
  }, pu = (h) => st(h, G(0)), Bu = (h, w, A, P, V) => V(h.slice(0, w)).concat(P).concat(V(h.slice(A))), qm = (h) => (w, A, P, V) => {
    if (h(P)) {
      const K = Math.max(V, w[A] - Math.abs(P)), ie = Math.abs(K - w[A]);
      return P >= 0 ? ie : -ie;
    } else
      return P;
  }, Y1 = qm((h) => h < 0), KC = qm(Ie), YC = () => {
    const h = (ve, Ae, Ue, ct, Yt) => {
      const On = Y1(ve, Ae, ct, Yt);
      return Bu(ve, Ae, Ue + 1, [
        On,
        0
      ], pu);
    }, w = (ve, Ae, Ue, ct) => {
      const Yt = (100 + Ue) / 100, On = Math.max(ct, (ve[Ae] + Ue) / Yt);
      return st(ve, (Tn, It) => (It === Ae ? On : Tn / Yt) - Tn);
    }, A = (ve, Ae, Ue, ct, Yt, On) => On ? w(ve, Ae, ct, Yt) : h(ve, Ae, Ue, ct, Yt);
    return {
      resizeTable: (ve, Ae) => ve(Ae),
      clampTableDelta: Y1,
      calcLeftEdgeDeltas: A,
      calcMiddleDeltas: (ve, Ae, Ue, ct, Yt, On, Tn) => A(ve, Ue, ct, Yt, On, Tn),
      calcRightEdgeDeltas: (ve, Ae, Ue, ct, Yt, On) => {
        if (On)
          return w(ve, Ue, ct, Yt);
        {
          const Tn = Y1(ve, Ue, ct, Yt);
          return pu(ve.slice(0, Ue)).concat([Tn]);
        }
      },
      calcRedestributedWidths: (ve, Ae, Ue, ct) => {
        if (ct) {
          const On = (Ae + Ue) / Ae, Tn = st(ve, (It) => It / On);
          return {
            delta: On * 100 - 100,
            newSizes: Tn
          };
        } else
          return {
            delta: Ue,
            newSizes: ve
          };
      }
    };
  }, dw = () => {
    const h = (ie, ve, Ae, Ue, ct) => {
      const Yt = Ue >= 0 ? Ae : ve, On = KC(ie, Yt, Ue, ct);
      return Bu(ie, ve, Ae + 1, [
        On,
        -On
      ], pu);
    };
    return {
      resizeTable: (ie, ve, Ae) => {
        Ae && ie(ve);
      },
      clampTableDelta: (ie, ve, Ae, Ue, ct) => {
        if (ct) {
          if (Ae >= 0)
            return Ae;
          {
            const Yt = He(ie, (On, Tn) => On + Tn - Ue, 0);
            return Math.max(-Yt, Ae);
          }
        } else
          return Y1(ie, ve, Ae, Ue);
      },
      calcLeftEdgeDeltas: h,
      calcMiddleDeltas: (ie, ve, Ae, Ue, ct, Yt) => h(ie, Ae, Ue, ct, Yt),
      calcRightEdgeDeltas: (ie, ve, Ae, Ue, ct, Yt) => {
        if (Yt)
          return pu(ie);
        {
          const On = Ue / ie.length;
          return st(ie, G(On));
        }
      },
      calcRedestributedWidths: (ie, ve, Ae, Ue) => ({
        delta: 0,
        newSizes: ie
      })
    };
  }, gb = (h) => ye.fromTable(h).grid, vb = Qa("th"), Q1 = (h) => Jt(h, (w) => vb(w.element)), B2 = (h, w) => h && w ? "sectionCells" : h ? "section" : "cells", X1 = (h) => {
    const w = h.section === "thead", A = Xc(bb(h.cells), "th");
    return h.section === "tfoot" ? { type: "footer" } : w || A ? {
      type: "header",
      subType: B2(w, A)
    } : { type: "body" };
  }, bb = (h) => {
    const w = xt(h, (A) => vb(A.element));
    return w.length === 0 ? Ce.some("td") : w.length === h.length ? Ce.some("th") : Ce.none();
  }, H2 = (h) => {
    const w = st(h, (V) => X1(V).type), A = bt(w, "header"), P = bt(w, "footer");
    if (!A && !P)
      return Ce.some("body");
    {
      const V = bt(w, "body");
      return A && !V && !P ? Ce.some("header") : !A && !V && P ? Ce.some("footer") : Ce.none();
    }
  }, ky = (h) => an(h.all, (w) => {
    const A = X1(w);
    return A.type === "header" ? Ce.from(A.subType) : Ce.none();
  }), fw = (h, w, A) => wt(A(h.element, w), !0, h.isLocked), hu = (h, w) => h.section !== w ? en(h.element, h.cells, w, h.isNew) : h, Ny = () => ({
    transformRow: hu,
    transformCell: (h, w, A) => {
      const P = A(h.element, w), V = es(P) !== "td" ? Il(P, "td") : P;
      return wt(V, h.isNew, h.isLocked);
    }
  }), mw = () => ({
    transformRow: hu,
    transformCell: fw
  }), J1 = () => ({
    transformRow: (h, w) => hu(h, w === "thead" ? "tbody" : w),
    transformCell: fw
  }), Jp = {
    getTableSectionType: (h, w) => {
      const A = ye.fromTable(h);
      switch (ky(A).getOr(w)) {
        case "section":
          return Ny();
        case "sectionCells":
          return mw();
        case "cells":
          return J1();
      }
    },
    section: Ny,
    sectionCells: mw,
    cells: J1,
    fallback: () => ({
      transformRow: me,
      transformCell: fw
    })
  }, Gm = (h, w, A, P) => {
    A === P ? ea(h, w) : ia(h, w, A);
  }, pw = (h, w, A) => {
    Ct(Sr(h, w)).fold(() => Zs(h, A), (P) => Xi(P, A));
  }, yb = (h, w) => {
    const A = Ur(h, w).getOrThunk(() => {
      const P = nt.fromTag(w, tu(h).dom);
      return w === "thead" ? pw(h, "caption,colgroup", P) : w === "colgroup" ? pw(h, "caption", P) : ss(h, P), P;
    });
    return ti(A), A;
  }, t0 = (h, w) => {
    const A = [], P = [], V = (Tn) => st(Tn, (It) => {
      It.isNew && A.push(It.element);
      const An = It.element;
      return ti(An), Ne(It.cells, ($t) => {
        $t.isNew && P.push($t.element), Gm($t.element, "colspan", $t.colspan, 1), Gm($t.element, "rowspan", $t.rowspan, 1), ss(An, $t.element);
      }), An;
    }), K = (Tn) => Zt(Tn, (It) => st(It.cells, (An) => (Gm(An.element, "span", An.colspan, 1), An.element))), ie = (Tn, It) => {
      const An = yb(h, It), Gn = (It === "colgroup" ? K : V)(Tn);
      za(An, Gn);
    }, ve = (Tn) => {
      Ur(h, Tn).each(Ra);
    }, Ae = (Tn, It) => {
      Tn.length > 0 ? ie(Tn, It) : ve(It);
    }, Ue = [], ct = [], Yt = [], On = [];
    return Ne(w, (Tn) => {
      switch (Tn.section) {
        case "thead":
          Ue.push(Tn);
          break;
        case "tbody":
          ct.push(Tn);
          break;
        case "tfoot":
          Yt.push(Tn);
          break;
        case "colgroup":
          On.push(Tn);
          break;
      }
    }), Ae(On, "colgroup"), Ae(Ue, "thead"), Ae(ct, "tbody"), Ae(Yt, "tfoot"), {
      newRows: A,
      newCells: P
    };
  }, QC = (h) => st(h, (w) => {
    const A = Ii(w.element);
    return Ne(w.cells, (P) => {
      const V = Dl(P.element);
      Gm(V, "colspan", P.colspan, 1), Gm(V, "rowspan", P.rowspan, 1), ss(A, V);
    }), A;
  }), Is = (h, w) => st(h, (A) => Hi(A, w)), Of = (h, w) => h[w], ja = (h, w) => {
    if (h.length === 0)
      return 0;
    const A = h[0];
    return qn(h, (V) => !w(A.element, V.element)).getOr(h.length);
  }, XC = (h, w, A, P) => {
    const V = Of(h, w), K = V.section === "colgroup", ie = ja(V.cells.slice(A), P), ve = K ? 1 : ja(Is(h.slice(w), A), P);
    return {
      colspan: ie,
      rowspan: ve
    };
  }, ua = (h, w) => {
    const A = st(h, (V) => st(V.cells, je)), P = (V, K, ie, ve) => {
      for (let Ae = V; Ae < V + ie; Ae++)
        for (let Ue = K; Ue < K + ve; Ue++)
          A[Ae][Ue] = !0;
    };
    return st(h, (V, K) => {
      const ie = Zt(V.cells, (ve, Ae) => {
        if (A[K][Ae] === !1) {
          const Ue = XC(h, K, Ae, w);
          return P(K, Ae, Ue.rowspan, Ue.colspan), [Tp(ve.element, Ue.rowspan, Ue.colspan, ve.isNew)];
        } else
          return [];
      });
      return tt(V.element, ie, V.section, V.isNew);
    });
  }, Xg = (h, w, A) => {
    const P = [];
    Ne(h.colgroups, (V) => {
      const K = [];
      for (let ie = 0; ie < h.grid.columns; ie++) {
        const ve = ye.getColumnAt(h, ie).map((Ae) => wt(Ae.element, A, !1)).getOrThunk(() => wt(w.colGap(), !0, !1));
        K.push(ve);
      }
      P.push(en(V.element, K, "colgroup", A));
    });
    for (let V = 0; V < h.grid.rows; V++) {
      const K = [];
      for (let Ae = 0; Ae < h.grid.columns; Ae++) {
        const Ue = ye.getAt(h, V, Ae).map((ct) => wt(ct.element, A, ct.isLocked)).getOrThunk(() => wt(w.gap(), !0, !1));
        K.push(Ue);
      }
      const ie = h.all[V], ve = en(ie.element, K, ie.section, A);
      P.push(ve);
    }
    return P;
  }, Ti = (h, w) => Xg(h, w, !1), wa = (h) => ua(h, os), dd = (h, w) => an(h.all, (A) => oe(A.cells, (P) => os(w, P.element))), hw = (h, w, A) => {
    const P = st(w.selection, (K) => Ap(K).bind((ie) => dd(h, ie)).filter(A)), V = Ds(P);
    return _a(V.length > 0, V);
  }, oc = (h, w, A, P, V) => (K, ie, ve, Ae) => {
    const Ue = ye.fromTable(K), ct = Ce.from(Ae == null ? void 0 : Ae.section).getOrThunk(Jp.fallback);
    return w(Ue, ie).map((On) => {
      const Tn = Ti(Ue, ve), It = h(Tn, On, os, V(ve), ct), An = ba(It.grid), $t = wa(It.grid);
      return {
        info: On,
        grid: $t,
        cursor: It.cursor,
        lockedColumns: An
      };
    }).bind((On) => {
      const Tn = t0(K, On.grid), It = Ce.from(Ae == null ? void 0 : Ae.sizing).getOrThunk(() => bl.getTableSize(K)), An = Ce.from(Ae == null ? void 0 : Ae.resize).getOrThunk(dw);
      return A(K, On.grid, On.info, {
        sizing: It,
        resize: An,
        section: ct
      }), P(K), ea(K, Fd), On.lockedColumns.length > 0 && ia(K, Fd, On.lockedColumns.join(",")), Ce.some({
        cursor: On.cursor,
        newRows: Tn.newRows,
        newCells: Tn.newCells
      });
    });
  }, Ry = (h, w) => Ap(w.element).bind((A) => dd(h, A).map((P) => ({
    ...P,
    generators: w.generators,
    clipboard: w.clipboard
  }))), Sb = (h, w) => hw(h, w, Ie).map((A) => ({
    cells: A,
    generators: w.generators,
    clipboard: w.clipboard
  })), Zm = (h, w) => w.mergable, wb = (h, w) => w.unmergable, Zh = (h, w) => hw(h, w, Ie), eh = (h, w) => hw(h, w, (A) => !A.isLocked), z2 = (h, w) => dd(h, w).exists((A) => !A.isLocked), JC = (h, w) => Jt(w, (A) => z2(h, A)), Wk = (h, w) => Zm(h, w).filter((A) => JC(h, A.cells)), jk = (h, w) => wb(h, w).filter((A) => JC(h, A)), Af = (h, w, A, P) => {
    const V = Aa(h).rows;
    if (V.length === 0)
      return h;
    for (let K = w.startRow; K <= w.finishRow; K++)
      for (let ie = w.startCol; ie <= w.finishCol; ie++) {
        const ve = V[K], Ae = Hi(ve, ie).isLocked;
        Ia(ve, ie, wt(P(), !1, Ae));
      }
    return h;
  }, wl = (h, w, A, P) => {
    const V = Aa(h).rows;
    let K = !0;
    for (let ie = 0; ie < V.length; ie++)
      for (let ve = 0; ve < ml(V[0]); ve++) {
        const Ae = V[ie], Ue = Hi(Ae, ve), ct = Ue.element, Yt = A(ct, w);
        Yt && !K ? Ia(Ae, ve, wt(P(), !0, Ue.isLocked)) : Yt && (K = !1);
      }
    return h;
  }, V2 = (h, w) => He(h, (A, P) => at(A, (V) => w(V.element, P.element)) ? A : A.concat([P]), []), U2 = (h, w, A, P) => (w > 0 && w < h[0].cells.length && Ne(h, (V) => {
    const K = V.cells[w - 1];
    let ie = 0;
    const ve = P();
    for (; V.cells.length > w + ie && A(K.element, V.cells[w + ie].element); )
      Ia(V, w + ie, wt(ve, !0, V.cells[w + ie].isLocked)), ie++;
  }), h), Kh = (h, w, A, P) => {
    const V = Aa(h).rows;
    if (w > 0 && w < V.length) {
      const K = V[w - 1].cells, ie = V2(K, A);
      Ne(ie, (ve) => {
        let Ae = Ce.none();
        for (let Ue = w; Ue < V.length; Ue++)
          for (let ct = 0; ct < ml(V[0]); ct++) {
            const Yt = V[Ue], On = Hi(Yt, ct);
            A(On.element, ve.element) && (Ae.isNone() && (Ae = Ce.some(P())), Ae.each((It) => {
              Ia(Yt, ct, wt(It, !0, On.isLocked));
            }));
          }
      });
    }
    return h;
  }, Py = (h) => {
    const w = (K) => K(h), A = G(h), P = () => V, V = {
      tag: !0,
      inner: h,
      fold: (K, ie) => ie(h),
      isValue: Ie,
      isError: je,
      map: (K) => Km.value(K(h)),
      mapError: P,
      bind: w,
      exists: w,
      forall: w,
      getOr: A,
      or: P,
      getOrThunk: A,
      orThunk: P,
      getOrDie: A,
      each: (K) => {
        K(h);
      },
      toOptional: () => Ce.some(h)
    };
    return V;
  }, n0 = (h) => {
    const w = () => A, A = {
      tag: !1,
      inner: h,
      fold: (P, V) => P(h),
      isValue: je,
      isError: Ie,
      map: w,
      mapError: (P) => Km.error(P(h)),
      bind: w,
      exists: je,
      forall: Ie,
      getOr: me,
      or: me,
      getOrThunk: Le,
      orThunk: Le,
      getOrDie: Te(String(h)),
      each: Q,
      toOptional: Ce.none
    };
    return A;
  }, Km = {
    value: Py,
    error: n0,
    fromOption: (h, w) => h.fold(() => n0(w), Py)
  }, Eb = (h, w, A) => {
    if (h.row >= w.length || h.column > ml(w[0]))
      return Km.error("invalid start address out of table bounds, row: " + h.row + ", column: " + h.column);
    const P = w.slice(h.row), V = P[0].cells.slice(h.column), K = ml(A[0]), ie = A.length;
    return Km.value({
      rowDelta: P.length - ie,
      colDelta: V.length - K
    });
  }, Yh = (h, w) => {
    const A = ml(h[0]), P = ml(w[0]);
    return {
      rowDelta: 0,
      colDelta: A - P
    };
  }, Jg = (h, w) => {
    const A = h.length, P = w.length;
    return {
      rowDelta: A - P,
      colDelta: 0
    };
  }, ev = (h, w, A, P) => {
    const V = w.section === "colgroup" ? A.col : A.cell;
    return _n(h, (K) => wt(V(), !0, P(K)));
  }, ex = (h, w, A, P) => {
    const V = h[h.length - 1];
    return h.concat(_n(w, () => {
      const K = V.section === "colgroup" ? A.colgroup : A.row, ie = rd(V, K, me), ve = ev(ie.cells.length, ie, A, (Ae) => Eo(P, Ae.toString()));
      return Bi(ie, ve);
    }));
  }, Ma = (h, w, A, P) => st(h, (V) => {
    const K = ev(w, V, A, je);
    return el(V, P, K);
  }), tx = (h, w, A) => st(h, (P) => He(A, (V, K) => {
    const ie = ev(1, P, w, Ie)[0];
    return mf(V, K, ie);
  }, P)), Cb = (h, w, A) => {
    const P = w.colDelta < 0 ? Ma : me, V = w.rowDelta < 0 ? ex : me, K = ba(h), ie = ml(h[0]), ve = at(K, (ct) => ct === ie - 1), Ae = P(h, Math.abs(w.colDelta), A, ve ? ie - 1 : ie), Ue = ba(Ae);
    return V(Ae, Math.abs(w.rowDelta), A, Ge(Ue, Ie));
  }, nx = (h, w, A, P) => {
    const V = Hi(h[w], A), K = be(P, V.element), ie = h[w];
    return h.length > 1 && ml(ie) > 1 && (A > 0 && K(va(ie, A - 1)) || A < ie.cells.length - 1 && K(va(ie, A + 1)) || w > 0 && K(va(h[w - 1], A)) || w < h.length - 1 && K(va(h[w + 1], A)));
  }, o0 = (h, w, A, P, V, K) => {
    const ie = h.row, ve = h.column, Ae = A.length, Ue = ml(A[0]), ct = ie + Ae, Yt = ve + Ue + K.length, On = Ge(K, Ie);
    for (let Tn = ie; Tn < ct; Tn++) {
      let It = 0;
      for (let An = ve; An < Yt; An++) {
        if (On[An]) {
          It++;
          continue;
        }
        nx(w, Tn, An, V) && wl(w, va(w[Tn], An), V, P.cell);
        const $t = An - ve - It, Gn = Hi(A[Tn - ie], $t), Or = Gn.element, jr = P.replace(Or);
        Ia(w[Tn], An, wt(jr, !0, Gn.isLocked));
      }
    }
    return w;
  }, sl = (h, w, A) => {
    const P = ml(w[0]), V = Aa(w).cols.length + h.row, K = _n(P - h.column, (ve) => ve + h.column), ie = oe(K, (ve) => Jt(A, (Ae) => Ae !== ve)).getOr(P - 1);
    return {
      row: V,
      column: ie
    };
  }, Hu = (h, w, A) => xt(A, (P) => P >= h.column && P <= ml(w[0]) + h.column), rx = (h, w, A, P, V) => {
    const K = ba(w), ie = sl(h, w, K), ve = Aa(A).rows, Ae = Hu(ie, ve, K);
    return Eb(ie, w, ve).map((ct) => {
      const Yt = {
        ...ct,
        colDelta: ct.colDelta - Ae.length
      }, On = Cb(w, Yt, P), Tn = ba(On), It = Hu(ie, ve, Tn);
      return o0(ie, On, ve, P, V, It);
    });
  }, tv = (h, w, A, P, V) => {
    U2(w, h, V, P.cell);
    const K = Jg(A, w), ie = Cb(A, K, P), ve = Jg(w, ie), Ae = Cb(w, ve, P);
    return st(Ae, (Ue, ct) => el(Ue, h, ie[ct].cells));
  }, nv = (h, w, A, P, V) => {
    Kh(w, h, V, P.cell);
    const K = ba(w), ie = Yh(w, A), ve = {
      ...ie,
      colDelta: ie.colDelta - K.length
    }, Ae = Cb(w, ve, P), {
      cols: Ue,
      rows: ct
    } = Aa(Ae), Yt = ba(Ae), On = Yh(A, w), Tn = {
      ...On,
      colDelta: On.colDelta + Yt.length
    }, It = tx(A, P, Yt), An = Cb(It, Tn, P);
    return [
      ...Ue,
      ...ct.slice(0, h),
      ...An,
      ...ct.slice(h, ct.length)
    ];
  }, W2 = (h, w, A, P) => rd(h, (V) => P(V, A), w), ox = (h, w, A, P, V) => {
    const { rows: K, cols: ie } = Aa(h), ve = K.slice(0, w), Ae = K.slice(w), Ue = W2(K[A], (ct, Yt) => w > 0 && w < K.length && P(va(K[w - 1], Yt), va(K[w], Yt)) ? Hi(K[w], Yt) : wt(V(ct.element, P), !0, ct.isLocked), P, V);
    return [
      ...ie,
      ...ve,
      Ue,
      ...Ae
    ];
  }, gw = (h, w, A, P, V, K, ie) => {
    if (A === "colgroup" || !P) {
      const ve = Hi(h, V);
      return wt(ie(ve.element, K), !0, !1);
    } else
      return Hi(h, w);
  }, zu = (h, w, A, P, V) => st(h, (K) => {
    const ie = w > 0 && w < ml(K) && P(va(K, w - 1), va(K, w)), ve = gw(K, w, K.section, ie, A, P, V);
    return mf(K, w, ve);
  }), s0 = (h, w) => Zt(h, (A) => {
    const P = A.cells, V = cn(w, (K, ie) => ie >= 0 && ie < K.length ? K.slice(0, ie).concat(K.slice(ie + 1)) : K, P);
    return V.length > 0 ? [en(A.element, V, A.section, A.isNew)] : [];
  }), qa = (h, w, A) => {
    const { rows: P, cols: V } = Aa(h);
    return [
      ...V,
      ...P.slice(0, w),
      ...P.slice(A + 1)
    ];
  }, fm = (h, w, A, P) => va(h[w], A) !== void 0 && w > 0 && P(va(h[w - 1], A), va(h[w], A)), xb = (h, w, A) => w > 0 && A(va(h, w - 1), va(h, w)), Qh = (h, w, A, P) => fm(h, w, A, P) || xb(h[w], A, P), rv = (h, w) => Jt(w, me) && Q1(h.cells) ? Ie : (P, V, K) => !(es(P.element) === "th" && w[K]), ov = (h, w) => Jt(w, me) && Q1(h) ? Ie : (P, V, K) => !(es(P.element) === "th" && w[V]), th = (h, w, A, P) => {
    const V = (ie) => ie === "row" ? ri(w) : Ji(w), K = (ie) => V(ie) ? `${ie}group` : ie;
    return h ? vb(w) ? K(A) : null : P && vb(w) ? K(A === "row" ? "col" : "row") : null;
  }, sx = (h, w) => (A, P, V) => Ce.some(th(h, A.element, "col", w[V])), sv = (h, w) => (A, P) => Ce.some(th(h, A.element, "row", w[P])), Xh = (h, w, A) => wt(A(h.element, w), !0, h.isLocked), Jh = (h, w, A, P, V, K, ie) => {
    const ve = (Ae) => at(w, (Ue) => A(Ae.element, Ue.element));
    return st(h, (Ae, Ue) => Kv(Ae, (ct, Yt) => {
      if (ve(ct)) {
        const On = ie(ct, Ue, Yt) ? V(ct, A, P) : ct;
        return K(On, Ue, Yt).each((Tn) => {
          Sp(On.element, { scope: Ce.from(Tn) });
        }), On;
      } else
        return ct;
    }));
  }, vw = (h, w, A) => Zt(h, (P, V) => Qh(h, V, w, A) ? [] : [Hi(P, w)]), j2 = (h, w, A) => {
    const P = h[w];
    return Zt(P.cells, (V, K) => Qh(h, w, K, A) ? [] : [V]);
  }, bw = (h, w, A, P, V) => {
    const K = Aa(h).rows, ie = Zt(w, (ct) => vw(K, ct, P)), ve = st(K, (ct) => Q1(ct.cells)), Ae = ov(ie, ve), Ue = sv(A, ve);
    return Jh(h, ie, P, V, Xh, Ue, Ae);
  }, q2 = (h, w, A, P, V, K, ie) => {
    const { cols: ve, rows: Ae } = Aa(h), Ue = Ae[w[0]], ct = Zt(w, ($t) => j2(Ae, $t, V)), Yt = st(Ue.cells, ($t, Gn) => Q1(vw(Ae, Gn, V))), On = [...Ae];
    Ne(w, ($t) => {
      On[$t] = ie.transformRow(Ae[$t], A);
    });
    const Tn = [
      ...ve,
      ...On
    ], It = rv(Ue, Yt), An = sx(P, Yt);
    return Jh(Tn, ct, V, K, ie.transformCell, An, It);
  }, a0 = (h, w, A, P) => {
    const V = Aa(h).rows, K = st(w, (ie) => Hi(V[ie.row], ie.column));
    return Jh(h, K, A, P, Xh, Ce.none, Ie);
  }, Vu = { generate: (h) => {
    if (!C(h))
      throw new Error("cases must be an array");
    if (h.length === 0)
      throw new Error("there must be at least one case");
    const w = [], A = {};
    return Ne(h, (P, V) => {
      const K = ht(P);
      if (K.length !== 1)
        throw new Error("one and only one name per case");
      const ie = K[0], ve = P[ie];
      if (A[ie] !== void 0)
        throw new Error("duplicate key detected:" + ie);
      if (ie === "cata")
        throw new Error("cannot have a case named cata (sorry)");
      if (!C(ve))
        throw new Error("case arguments must be an array");
      w.push(ie), A[ie] = (...Ae) => {
        const Ue = Ae.length;
        if (Ue !== ve.length)
          throw new Error("Wrong number of arguments to case " + ie + ". Expected " + ve.length + " (" + ve + "), got " + Ue);
        return {
          fold: (...Yt) => {
            if (Yt.length !== h.length)
              throw new Error("Wrong number of arguments to fold. Expected " + h.length + ", got " + Yt.length);
            return Yt[V].apply(null, Ae);
          },
          match: (Yt) => {
            const On = ht(Yt);
            if (w.length !== On.length)
              throw new Error("Wrong number of arguments to match. Expected: " + w.join(",") + `
Actual: ` + On.join(","));
            if (!Jt(w, (It) => bt(On, It)))
              throw new Error("Not all branches were specified when using match. Specified: " + On.join(", ") + `
Required: ` + w.join(", "));
            return Yt[ie].apply(null, Ae);
          },
          log: (Yt) => {
            console.log(Yt, {
              constructors: w,
              constructor: ie,
              params: Ae
            });
          }
        };
      };
    }), A;
  } }, _b = { ...Vu.generate([
    { none: [] },
    { only: ["index"] },
    {
      left: [
        "index",
        "next"
      ]
    },
    {
      middle: [
        "prev",
        "index",
        "next"
      ]
    },
    {
      right: [
        "prev",
        "index"
      ]
    }
  ]) }, ix = (h, w) => h.length === 0 ? _b.none() : h.length === 1 ? _b.only(0) : w === 0 ? _b.left(0, 1) : w === h.length - 1 ? _b.right(w - 1, w) : w > 0 && w < h.length - 1 ? _b.middle(w - 1, w, w + 1) : _b.none(), G2 = (h, w, A, P, V) => {
    const K = h.slice(0), ie = ix(h, w), ve = G(st(K, G(0))), Ae = (On) => P.singleColumnWidth(K[On], A), Ue = (On, Tn) => V.calcLeftEdgeDeltas(K, On, Tn, A, P.minCellWidth(), P.isRelative), ct = (On, Tn, It) => V.calcMiddleDeltas(K, On, Tn, It, A, P.minCellWidth(), P.isRelative), Yt = (On, Tn) => V.calcRightEdgeDeltas(K, On, Tn, A, P.minCellWidth(), P.isRelative);
    return ie.fold(ve, Ae, Ue, ct, Yt);
  }, Dy = (h, w, A) => {
    let P = 0;
    for (let V = h; V < w; V++)
      P += A[V] !== void 0 ? A[V] : 0;
    return P;
  }, eg = (h, w) => {
    const A = ye.justCells(h);
    return st(A, (P) => {
      const V = Dy(P.column, P.column + P.colspan, w);
      return {
        element: P.element,
        width: V,
        colspan: P.colspan
      };
    });
  }, i0 = (h, w) => {
    const A = ye.justColumns(h);
    return st(A, (P, V) => ({
      element: P.element,
      width: w[V],
      colspan: P.colspan
    }));
  }, po = (h, w) => {
    const A = ye.justCells(h);
    return st(A, (P) => {
      const V = Dy(P.row, P.row + P.rowspan, w);
      return {
        element: P.element,
        height: V,
        rowspan: P.rowspan
      };
    });
  }, Uu = (h, w) => st(h.all, (A, P) => ({
    element: A.element,
    height: w[P]
  })), mm = (h) => cn(h, (w, A) => w + A, 0), Ob = (h, w) => ye.hasColumns(h) ? i0(h, w) : eg(h, w), ds = (h, w, A) => {
    const P = Ob(h, w);
    Ne(P, (V) => {
      A.setElementWidth(V.element, V.width);
    });
  }, Ab = (h, w, A, P, V) => {
    const K = ye.fromTable(h), ie = V.getCellDelta(w), ve = V.getWidths(K, V), Ae = A === K.grid.columns - 1, Ue = P.clampTableDelta(ve, A, ie, V.minCellWidth(), Ae), ct = G2(ve, A, Ue, V, P), Yt = st(ct, (On, Tn) => On + ve[Tn]);
    ds(K, Yt, V), P.resizeTable(V.adjustTableWidth, Ue, Ae);
  }, c0 = (h, w, A, P) => {
    const V = ye.fromTable(h), K = lt(V, h, P), ie = st(K, (ct, Yt) => A === Yt ? Math.max(w + ct, Ll()) : ct), ve = po(V, ie), Ae = Uu(V, ie);
    Ne(Ae, (ct) => {
      am(ct.element, ct.height);
    }), Ne(ve, (ct) => {
      am(ct.element, ct.height);
    });
    const Ue = mm(ie);
    am(h, Ue);
  }, bi = (h, w, A, P, V) => {
    const K = ye.generate(w), ie = P.getWidths(K, P), ve = P.pixelWidth(), { newSizes: Ae, delta: Ue } = V.calcRedestributedWidths(ie, ve, A.pixelDelta, P.isRelative);
    ds(K, Ae, P), P.adjustTableWidth(Ue);
  }, pm = (h, w, A, P) => {
    const V = ye.generate(w), K = P.getWidths(V, P);
    ds(V, K, P);
  }, nh = (h) => He(h, (A, P) => at(A, (K) => K.column === P.column) ? A : A.concat([P]), []).sort((A, P) => A.column - P.column), l0 = Qa("col"), $y = Qa("colgroup"), Iy = (h) => es(h) === "tr" || $y(h), yw = (h) => {
    const w = is(h, "colspan", 1), A = is(h, "rowspan", 1);
    return {
      element: h,
      colspan: w,
      rowspan: A
    };
  }, u0 = (h, w = yw) => {
    const A = (ve) => l0(ve.element) ? h.col(ve) : h.cell(ve), P = (ve) => $y(ve.element) ? h.colgroup(ve) : h.row(ve), V = (ve) => {
      if (Iy(ve))
        return P({ element: ve });
      {
        const Ae = ve, Ue = A(w(Ae));
        return K = Ce.some({
          item: Ae,
          replacement: Ue
        }), Ue;
      }
    };
    let K = Ce.none();
    return { getOrInit: (ve, Ae) => K.fold(() => V(ve), (Ue) => Ae(ve, Ue.item) ? Ue.replacement : V(ve)) };
  }, qd = (h) => (w) => {
    const A = [], P = (ie, ve) => oe(A, (Ae) => ve(Ae.item, ie)), V = (ie) => {
      const ve = h === "td" ? { scope: null } : {}, Ae = w.replace(ie, h, ve);
      return A.push({
        item: ie,
        sub: Ae
      }), Ae;
    };
    return { replaceOrInit: (ie, ve) => {
      if (Iy(ie) || l0(ie))
        return ie;
      {
        const Ae = ie;
        return P(Ae, ve).fold(() => V(Ae), (Ue) => ve(ie, Ue.item) ? Ue.sub : V(Ae));
      }
    } };
  }, kf = (h) => vc(h, "scope").map((w) => w.substr(0, 3)), yt = {
    modification: u0,
    transform: qd,
    merging: (h) => ({
      unmerge: (P) => {
        const V = kf(P);
        return V.each((K) => ia(P, "scope", K)), () => {
          const K = h.cell({
            element: P,
            colspan: 1,
            rowspan: 1
          });
          return Fl(K, "width"), Fl(P, "width"), V.each((ie) => ia(K, "scope", ie)), K;
        };
      },
      merge: (P) => {
        const V = () => {
          const K = Ds(st(P, kf));
          if (K.length === 0)
            return Ce.none();
          {
            const ie = K[0], ve = [
              "row",
              "col"
            ];
            return at(K, (Ue) => Ue !== ie && bt(ve, Ue)) ? Ce.none() : Ce.from(ie);
          }
        };
        return Fl(P[0], "width"), V().fold(() => ea(P[0], "scope"), (K) => ia(P[0], "scope", K + "group")), G(P[0]);
      }
    })
  }, av = [
    "body",
    "p",
    "div",
    "article",
    "aside",
    "figcaption",
    "figure",
    "footer",
    "header",
    "nav",
    "section",
    "ol",
    "ul",
    "table",
    "thead",
    "tfoot",
    "tbody",
    "caption",
    "tr",
    "td",
    "th",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "blockquote",
    "pre",
    "address"
  ], iv = (h, w) => {
    const A = h.property().name(w);
    return bt([
      "ol",
      "ul"
    ], A);
  }, fd = (h, w) => {
    const A = h.property().name(w);
    return bt(av, A);
  }, Sw = (h, w) => bt([
    "br",
    "img",
    "hr",
    "input"
  ], h.property().name(w)), sa = Pt(), d0 = (h) => fd(sa, h), rh = (h) => iv(sa, h), ww = (h) => Sw(sa, h), f0 = (h) => {
    const w = Qa("br"), A = (Ae) => Jt(Ae, (Ue) => w(Ue) || Jl(Ue) && Xn(Ue).trim().length === 0), P = (Ae) => es(Ae) === "li" || na(Ae, rh).isSome(), V = (Ae) => ed(Ae).map((Ue) => d0(Ue) ? !0 : ww(Ue) ? es(Ue) !== "img" : !1).getOr(!1), K = (Ae) => Bd(Ae).bind((Ue) => {
      const ct = V(Ue);
      return Ac(Ue).map((Yt) => ct === !0 || P(Yt) || w(Ue) || d0(Yt) && !os(Ae, Yt) ? [] : [nt.fromTag("br")]);
    }).getOr([]), ve = (() => {
      const Ae = Zt(h, (Ue) => {
        const ct = $o(Ue);
        return A(ct) ? [] : ct.concat(K(Ue));
      });
      return Ae.length === 0 ? [nt.fromTag("br")] : Ae;
    })();
    ti(h[0]), za(h[0], ve);
  }, Ew = (h) => Wp(h, !0), My = (h) => {
    Pc(h).length === 0 && Ra(h);
  }, kb = (h, w) => ({
    grid: h,
    cursor: w
  }), Cw = (h) => an(h, (w) => an(w.cells, (A) => {
    const P = A.element;
    return _a(Ew(P), P);
  })), K2 = (h, w, A) => {
    var P, V;
    const K = Aa(h).rows;
    return Ce.from((V = (P = K[w]) === null || P === void 0 ? void 0 : P.cells[A]) === null || V === void 0 ? void 0 : V.element).filter(Ew).orThunk(() => Cw(K));
  }, Ga = (h, w, A) => {
    const P = K2(h, w, A);
    return kb(h, P);
  }, Wi = (h) => He(h, (A, P) => at(A, (K) => K.row === P.row) ? A : A.concat([P]), []).sort((A, P) => A.row - P.row), Mc = (h, w, A, P) => {
    const V = w[0].row, K = Wi(w), ie = cn(K, (ve, Ae) => ({
      grid: ox(ve.grid, V, Ae.row + ve.delta, A, P.getOrInit),
      delta: ve.delta + 1
    }), {
      grid: h,
      delta: 0
    }).grid;
    return Ga(ie, V, w[0].column);
  }, ji = (h, w, A, P) => {
    const V = Wi(w), K = V[V.length - 1], ie = K.row + K.rowspan, ve = cn(V, (Ae, Ue) => ox(Ae, ie, Ue.row, A, P.getOrInit), h);
    return Ga(ve, ie, w[0].column);
  }, Br = (h, w, A, P) => {
    const V = w.details, K = nh(V), ie = K[0].column, ve = cn(K, (Ae, Ue) => ({
      grid: zu(Ae.grid, ie, Ue.column + Ae.delta, A, P.getOrInit),
      delta: Ae.delta + 1
    }), {
      grid: h,
      delta: 0
    }).grid;
    return Ga(ve, V[0].row, ie);
  }, El = (h, w, A, P) => {
    const V = w.details, K = V[V.length - 1], ie = K.column + K.colspan, ve = nh(V), Ae = cn(ve, (Ue, ct) => zu(Ue, ie, ct.column, A, P.getOrInit), h);
    return Ga(Ae, V[0].row, ie);
  }, Os = (h, w, A, P) => {
    const V = nh(w), K = st(V, (ve) => ve.column), ie = bw(h, K, !0, A, P.replaceOrInit);
    return Ga(ie, w[0].row, w[0].column);
  }, qi = (h, w, A, P) => {
    const V = a0(h, w, A, P.replaceOrInit);
    return Ga(V, w[0].row, w[0].column);
  }, Fy = (h, w, A, P) => {
    const V = nh(w), K = st(V, (ve) => ve.column), ie = bw(h, K, !1, A, P.replaceOrInit);
    return Ga(ie, w[0].row, w[0].column);
  }, Ym = (h, w, A, P) => {
    const V = a0(h, w, A, P.replaceOrInit);
    return Ga(V, w[0].row, w[0].column);
  }, Ly = (h, w) => (A, P, V, K, ie) => {
    const ve = Wi(P), Ae = st(ve, (ct) => ct.row), Ue = q2(A, Ae, h, w, V, K.replaceOrInit, ie);
    return Ga(Ue, P[0].row, P[0].column);
  }, xw = Ly("thead", !0), cx = Ly("tbody", !1), m0 = Ly("tfoot", !1), Tw = (h, w, A, P) => {
    const V = nh(w.details), K = s0(h, st(V, (ve) => ve.column)), ie = K.length > 0 ? K[0].cells.length - 1 : 0;
    return Ga(K, V[0].row, Math.min(V[0].column, ie));
  }, _w = (h, w, A, P) => {
    const V = Wi(w), K = qa(h, V[0].row, V[V.length - 1].row), ie = K.length > 0 ? K.length - 1 : 0;
    return Ga(K, Math.min(w[0].row, ie), w[0].column);
  }, Y2 = (h, w, A, P) => {
    const V = w.cells;
    f0(V);
    const K = Af(h, w.bounds, A, P.merge(V));
    return kb(K, Ce.from(V[0]));
  }, Qm = (h, w, A, P) => {
    const K = cn(w, (ie, ve) => wl(ie, ve, A, P.unmerge(ve)), h);
    return kb(K, Ce.from(w[0]));
  }, lx = (h, w, A, P) => {
    const K = ((Ae, Ue) => {
      const ct = ye.fromTable(Ae);
      return Xg(ct, Ue, !0);
    })(w.clipboard, w.generators), ie = sf(w.row, w.column);
    return rx(ie, h, K, w.generators, A).fold(() => kb(h, Ce.some(w.element)), (Ae) => Ga(Ae, w.row, w.column));
  }, oh = (h, w, A) => {
    const P = Mm(h, A.section), V = ye.generate(P);
    return Xg(V, w, !0);
  }, li = (h, w, A, P) => {
    const V = Aa(h).rows, K = w.cells[0].column, ie = V[w.cells[0].row], ve = oh(w.clipboard, w.generators, ie), Ae = tv(K, h, ve, w.generators, A);
    return Ga(Ae, w.cells[0].row, w.cells[0].column);
  }, Gi = (h, w, A, P) => {
    const V = Aa(h).rows, K = w.cells[w.cells.length - 1].column + w.cells[w.cells.length - 1].colspan, ie = V[w.cells[0].row], ve = oh(w.clipboard, w.generators, ie), Ae = tv(K, h, ve, w.generators, A);
    return Ga(Ae, w.cells[0].row, w.cells[0].column);
  }, Q2 = (h, w, A, P) => {
    const V = Aa(h).rows, K = w.cells[0].row, ie = V[K], ve = oh(w.clipboard, w.generators, ie), Ae = nv(K, h, ve, w.generators, A);
    return Ga(Ae, w.cells[0].row, w.cells[0].column);
  }, gu = (h, w, A, P) => {
    const V = Aa(h).rows, K = w.cells[w.cells.length - 1].row + w.cells[w.cells.length - 1].rowspan, ie = V[w.cells[0].row], ve = oh(w.clipboard, w.generators, ie), Ae = nv(K, h, ve, w.generators, A);
    return Ga(Ae, w.cells[0].row, w.cells[0].column);
  }, qk = (h, w) => {
    const A = ye.fromTable(h);
    return Zh(A, w).bind((V) => {
      const K = V[V.length - 1], ie = V[0].column, ve = K.column + K.colspan, Ae = Rn(st(A.all, (Ue) => xt(Ue.cells, (ct) => ct.column >= ie && ct.column < ve)));
      return bb(Ae);
    }).getOr("");
  }, hm = (h, w) => {
    const A = ye.fromTable(h);
    return Zh(A, w).bind(bb).getOr("");
  }, mn = (h, w) => {
    const A = ye.fromTable(h);
    return Zh(A, w).bind((V) => {
      const K = V[V.length - 1], ie = V[0].row, ve = K.row + K.rowspan, Ae = A.all.slice(ie, ve);
      return H2(Ae);
    }).getOr("");
  }, Ow = (h, w, A, P) => pm(h, w, A, P.sizing), Zi = (h, w, A, P) => bi(h, w, A, P.sizing, P.resize), Aw = (h, w) => at(w, (A) => A.column === 0 && A.isLocked), tg = (h, w) => at(w, (A) => A.column + A.colspan >= h.grid.columns && A.isLocked), By = (h, w) => {
    const A = cu(h), P = nh(w);
    return He(P, (V, K) => {
      const ve = A[K.column].map(au).getOr(0);
      return V + ve;
    }, 0);
  }, vu = (h) => (w, A) => Zh(w, A).filter((P) => !(h ? Aw : tg)(w, P)).map((P) => ({
    details: P,
    pixelDelta: By(w, P)
  })), ux = (h, w) => eh(h, w).map((A) => ({
    details: A,
    pixelDelta: -By(h, A)
  })), Hy = (h) => (w, A) => Sb(w, A).filter((P) => !(h ? Aw : tg)(w, P.cells)), Fa = yt.transform("th"), gm = yt.transform("td"), zy = oc(Mc, Zh, Q, Q, yt.modification), Xm = oc(ji, Zh, Q, Q, yt.modification), Nf = oc(Br, vu(!0), Zi, Q, yt.modification), Fn = oc(El, vu(!1), Zi, Q, yt.modification), md = oc(Tw, ux, Zi, My, yt.modification), kw = oc(_w, Zh, Q, My, yt.modification), Jm = oc(Os, eh, Q, Q, Fa), Uo = oc(Fy, eh, Q, Q, gm), Nw = oc(xw, eh, Q, Q, Fa), pd = oc(cx, eh, Q, Q, gm), p0 = oc(m0, eh, Q, Q, gm), X2 = oc(qi, eh, Q, Q, Fa), aa = oc(Ym, eh, Q, Q, gm), J2 = oc(Y2, Wk, Ow, Q, yt.merging), al = oc(Qm, jk, Ow, Q, yt.merging), ng = oc(lx, Ry, Ow, Q, yt.modification), e_ = oc(li, Hy(!0), Q, Q, yt.modification), t_ = oc(Gi, Hy(!1), Q, Q, yt.modification), Rw = oc(Q2, Sb, Q, Q, yt.modification), n_ = oc(gu, Sb, Q, Q, yt.modification), dx = qk, fx = hm, Vy = mn, mx = (h, w) => h.dispatch("NewRow", { node: w }), Pw = (h, w) => h.dispatch("NewCell", { node: w }), cv = (h, w, A) => {
    h.dispatch("TableModified", {
      ...A,
      table: w
    });
  }, r_ = (h, w, A, P, V) => {
    h.dispatch("TableSelectionChange", {
      cells: w,
      start: A,
      finish: P,
      otherCells: V
    });
  }, o_ = (h) => {
    h.dispatch("TableSelectionClear");
  }, Dw = (h, w, A, P, V) => {
    h.dispatch("ObjectResizeStart", {
      target: w,
      width: A,
      height: P,
      origin: V
    });
  }, $w = (h, w, A, P, V) => {
    h.dispatch("ObjectResized", {
      target: w,
      width: A,
      height: P,
      origin: V
    });
  }, sh = {
    structure: !1,
    style: !0
  }, Gr = {
    structure: !0,
    style: !1
  }, Iw = {
    structure: !0,
    style: !0
  }, Cl = (h, w) => Sf(h) ? bl.percentageSize(w) : Vp(h) ? bl.pixelSize(w) : bl.getTableSize(w), h0 = (h, w, A) => {
    const P = (ju) => es(zd(ju)) === "table", V = (ju) => !P(h) || gb(ju).rows > 1, K = (ju) => !P(h) || gb(ju).columns > 1, ie = um(h), ve = Wa(h) ? Q : hb, Ae = (ju) => {
      switch (Hp(h)) {
        case "section":
          return Jp.section();
        case "sectionCells":
          return Jp.sectionCells();
        case "cells":
          return Jp.cells();
        default:
          return Jp.getTableSectionType(ju, "section");
      }
    }, Ue = (ju, eO) => eO.cursor.fold(() => {
      const vE = Pc(ju);
      return ke(vE).filter(ca).map((dg) => {
        A.clearSelectedCells(ju.dom);
        const Gl = h.dom.createRng();
        return Gl.selectNode(dg.dom), h.selection.setRng(Gl), ia(dg, "data-mce-selected", "1"), Gl;
      });
    }, (vE) => {
      const dg = uw(vE), Gl = h.dom.createRng();
      return Gl.setStart(dg.element.dom, dg.offset), Gl.setEnd(dg.element.dom, dg.offset), h.selection.setRng(Gl), A.clearSelectedCells(ju.dom), Ce.some(Gl);
    }), ct = (ju, eO, vE, dg) => (Gl, bE, CN = !1) => {
      dm(Gl);
      const xN = nt.fromDom(h.getDoc()), U0 = ci(vE, xN, ie), TN = {
        sizing: Cl(h, Gl),
        resize: Wa(h) ? YC() : dw(),
        section: Ae(Gl)
      };
      return eO(Gl) ? ju(Gl, bE, U0, TN).bind((rT) => {
        w.refresh(Gl.dom), Ne(rT.newRows, (n1) => {
          mx(h, n1.dom);
        }), Ne(rT.newCells, (n1) => {
          Pw(h, n1.dom);
        });
        const _N = Ue(Gl, rT);
        return ca(Gl) && (dm(Gl), CN || cv(h, Gl.dom, dg)), _N.map((n1) => ({
          rng: n1,
          effect: dg
        }));
      }) : Ce.none();
    }, Yt = ct(kw, V, Q, Gr), On = ct(md, K, Q, Gr), Tn = ct(zy, Ie, Q, Gr), It = ct(Xm, Ie, Q, Gr), An = ct(Nf, Ie, ve, Gr), $t = ct(Fn, Ie, ve, Gr), Gn = ct(J2, Ie, Q, Gr), Or = ct(al, Ie, Q, Gr), jr = ct(e_, Ie, Q, Gr), da = ct(t_, Ie, Q, Gr), _c = ct(Rw, Ie, Q, Gr), ui = ct(n_, Ie, Q, Gr), bd = ct(ng, Ie, Q, Iw), e1 = ct(X2, Ie, Q, Gr), t1 = ct(aa, Ie, Q, Gr), J_ = ct(Jm, Ie, Q, Gr), nT = ct(Uo, Ie, Q, Gr), ks = ct(Nw, Ie, Q, Gr), Su = ct(pd, Ie, Q, Gr), _l = ct(p0, Ie, Q, Gr);
    return {
      deleteRow: Yt,
      deleteColumn: On,
      insertRowsBefore: Tn,
      insertRowsAfter: It,
      insertColumnsBefore: An,
      insertColumnsAfter: $t,
      mergeCells: Gn,
      unmergeCells: Or,
      pasteColsBefore: jr,
      pasteColsAfter: da,
      pasteRowsBefore: _c,
      pasteRowsAfter: ui,
      pasteCells: bd,
      makeCellsHeader: e1,
      unmakeCellsHeader: t1,
      makeColumnsHeader: J_,
      unmakeColumnsHeader: nT,
      makeRowsHeader: ks,
      makeRowsBody: Su,
      makeRowsFooter: _l,
      getTableRowType: Vy,
      getTableCellType: fx,
      getTableColType: dx
    };
  }, Fc = (h, w, A) => {
    const P = is(h, w, 1);
    A === 1 || P <= 1 ? ea(h, w) : ia(h, w, Math.min(A, P));
  }, bu = (h, w) => (A) => {
    const P = A.column + A.colspan - 1, V = A.column;
    return P >= h && V < w;
  }, g0 = (h, w, A) => {
    if (ye.hasColumns(h)) {
      const P = xt(ye.justColumns(h), bu(w, A)), V = st(P, (ie) => {
        const ve = Dl(ie.element);
        return Fc(ve, "span", A - w), ve;
      }), K = nt.fromTag("colgroup");
      return za(K, V), [K];
    } else
      return [];
  }, px = (h, w, A) => st(h.all, (P) => {
    const V = xt(P.cells, bu(w, A)), K = st(V, (ve) => {
      const Ae = Dl(ve.element);
      return Fc(Ae, "colspan", A - w), Ae;
    }), ie = nt.fromTag("tr");
    return za(ie, K), ie;
  }), s_ = (h, w) => {
    const A = ye.fromTable(h);
    return eh(A, w).map((V) => {
      const K = V[V.length - 1], ie = V[0].column, ve = K.column + K.colspan, Ae = g0(A, ie, ve), Ue = px(A, ie, ve);
      return [
        ...Ae,
        ...Ue
      ];
    });
  }, hx = (h, w, A) => {
    const P = ye.fromTable(h);
    return Zh(P, w).bind((K) => {
      const ie = Xg(P, A, !1), Ae = Aa(ie).rows.slice(K[0].row, K[K.length - 1].row + K[K.length - 1].rowspan), Ue = Zt(Ae, (Yt) => {
        const On = xt(Yt.cells, (Tn) => !Tn.isLocked);
        return On.length > 0 ? [{
          ...Yt,
          cells: On
        }] : [];
      }), ct = wa(Ue);
      return _a(ct.length > 0, ct);
    }).map((K) => QC(K));
  }, Nb = Vu.generate([
    { invalid: ["raw"] },
    { pixels: ["value"] },
    { percent: ["value"] }
  ]), gx = (h, w, A) => {
    const P = A.substring(0, A.length - h.length), V = parseFloat(P);
    return P === V.toString() ? w(V) : Nb.invalid(A);
  }, ah = {
    ...Nb,
    from: (h) => Ru(h, "%") ? gx("%", Nb.percent, h) : Ru(h, "px") ? gx("px", Nb.pixels, h) : Nb.invalid(h)
  }, a_ = (h, w) => st(h, (A) => ah.from(A).fold(() => A, (V) => V / w * 100 + "%", (V) => V + "%")), Rb = (h, w, A) => {
    const P = A / w;
    return st(h, (V) => ah.from(V).fold(() => V, (ie) => ie * P + "px", (ie) => ie / 100 * A + "px"));
  }, i_ = (h, w) => {
    const A = h.fold(() => G(""), (P) => {
      const V = P / w;
      return G(V + "px");
    }, () => {
      const P = 100 / w;
      return G(P + "%");
    });
    return _n(w, A);
  }, v0 = (h, w, A) => h.fold(() => w, (P) => Rb(w, A, P), (P) => a_(w, A)), Mw = (h, w, A) => {
    const P = ah.from(A), V = Jt(h, (K) => K === "0px") ? i_(P, h.length) : v0(P, h, w);
    return bx(V);
  }, lv = (h, w) => h.length === 0 ? w : cn(h, (A, P) => ah.from(P).fold(G(0), me, me) + A, 0), c_ = (h, w) => {
    const A = Math.floor(h);
    return {
      value: A + w,
      remainder: h - A
    };
  }, vx = (h, w) => ah.from(h).fold(G(h), (A) => A + w + "px", (A) => A + w + "%"), bx = (h) => {
    if (h.length === 0)
      return h;
    const w = cn(h, (P, V) => {
      const K = ah.from(V).fold(() => ({
        value: V,
        remainder: 0
      }), (ie) => c_(ie, "px"), (ie) => ({
        value: ie + "%",
        remainder: 0
      }));
      return {
        output: [K.value].concat(P.output),
        remainder: P.remainder + K.remainder
      };
    }, {
      output: [],
      remainder: 0
    }), A = w.output;
    return A.slice(0, A.length - 1).concat([vx(A[A.length - 1], Math.round(w.remainder))]);
  }, vm = ah.from, yx = (h, w, A) => {
    Ne(w, (P) => {
      const V = h.slice(P.column, P.colspan + P.column), K = lv(V, Vs());
      zs(P.element, "width", K + A);
    });
  }, Fw = (h, w, A) => {
    Ne(w, (P, V) => {
      const K = lv([h[V]], Vs());
      zs(P.element, "width", K + A);
    });
  }, l_ = (h, w, A, P) => {
    Ne(A, (V) => {
      const K = h.slice(V.row, V.rowspan + V.row), ie = lv(K, Ll());
      zs(V.element, "height", ie + P);
    }), Ne(w, (V, K) => {
      zs(V.element, "height", h[K]);
    });
  }, Sx = (h) => vm(h).fold(G("px"), G("px"), G("%")), ep = (h, w, A) => {
    const P = ye.fromTable(h), V = P.all, K = ye.justCells(P), ie = ye.justColumns(P);
    w.each((ve) => {
      const Ae = Sx(ve), Ue = Li(h), ct = Ip(P, h), Yt = Mw(ct, Ue, ve);
      ye.hasColumns(P) ? Fw(Yt, ie, Ae) : yx(Yt, K, Ae), zs(h, "width", ve);
    }), A.each((ve) => {
      const Ae = Sx(ve), Ue = Iu(h), ct = gl(P, h, Un), Yt = Mw(ct, Ue, ve);
      l_(Yt, V, K, Ae), zs(h, "height", ve);
    });
  }, Pb = ka, Db = eb, b0 = id, Uy = (h) => {
    ea(h, "width");
  }, Gd = (h) => {
    const w = xo(h);
    ep(h, Ce.some(w), Ce.none()), Uy(h);
  }, $b = (h) => {
    const w = jg(h);
    ep(h, Ce.some(w), Ce.none()), Uy(h);
  }, Wy = (h) => {
    Fl(h, "width");
    const w = kp(h), A = w.length > 0 ? w : Pc(h);
    Ne(A, (P) => {
      Fl(P, "width"), Uy(P);
    }), Uy(h);
  }, rg = {
    styles: {
      "border-collapse": "collapse",
      width: "100%"
    },
    attributes: { border: "1" },
    colGroups: !1
  }, y0 = () => nt.fromTag("th"), u_ = () => nt.fromTag("td"), d_ = () => nt.fromTag("col"), wx = (h, w, A, P) => {
    const V = nt.fromTag("tr");
    for (let K = 0; K < h; K++) {
      const ie = P < w || K < A ? y0() : u_();
      K < A && ia(ie, "scope", "row"), P < w && ia(ie, "scope", "col"), ss(ie, nt.fromTag("br")), ss(V, ie);
    }
    return V;
  }, f_ = (h) => {
    const w = nt.fromTag("colgroup");
    return _n(h, () => ss(w, d_())), w;
  }, Lw = (h, w, A, P) => _n(h, (V) => wx(w, A, P, V)), m_ = (h, w, A, P, V, K = rg) => {
    const ie = nt.fromTag("table"), ve = V !== "cells";
    Mi(ie, K.styles), Nl(ie, K.attributes), K.colGroups && ss(ie, f_(w));
    const Ae = Math.min(h, A);
    if (ve && A > 0) {
      const Tn = nt.fromTag("thead");
      ss(ie, Tn);
      const An = Lw(A, w, V === "sectionCells" ? Ae : 0, P);
      za(Tn, An);
    }
    const Ue = nt.fromTag("tbody");
    ss(ie, Ue);
    const ct = ve ? h - Ae : h, On = Lw(ct, w, ve ? 0 : A, P);
    return za(Ue, On), ie;
  }, p_ = (h) => h.dom.innerHTML, Ex = (h) => {
    const w = nt.fromTag("div"), A = nt.fromDom(h.dom.cloneNode(!0));
    return ss(w, A), p_(w);
  }, h_ = (h, w) => {
    h.selection.select(w.dom, !0), h.selection.collapse(!0);
  }, Cx = (h, w) => {
    Qc(w, "td,th").each(be(h_, h));
  }, g_ = (h, w) => {
    Ne(Rc(w, "tr"), (A) => {
      mx(h, A.dom), Ne(Rc(A, "th,td"), (P) => {
        Pw(h, P.dom);
      });
    });
  }, S0 = (h) => v(h) && h.indexOf("%") !== -1, v_ = (h, w, A, P, V) => {
    const K = z1(h), ie = {
      styles: K,
      attributes: wf(h),
      colGroups: Ty(h)
    };
    return h.undoManager.ignore(() => {
      const ve = m_(A, w, V, P, Hp(h), ie);
      ia(ve, "data-mce-id", "__mce");
      const Ae = Ex(ve);
      h.insertContent(Ae), h.addVisual();
    }), Qc(zd(h), 'table[data-mce-id="__mce"]').map((ve) => (Vp(h) ? $b(ve) : Up(h) ? Wy(ve) : (Sf(h) || S0(K.width)) && Gd(ve), dm(ve), ea(ve, "data-mce-id"), g_(h, ve), Cx(h, ve), ve.dom)).getOrNull();
  }, xx = (h, w, A, P = {}) => {
    const V = (K) => se(K) && K > 0;
    if (V(w) && V(A)) {
      const K = P.headerRows || 0, ie = P.headerColumns || 0;
      return v_(h, A, w, ie, K);
    } else
      return console.error("Invalid values for mceInsertTable - rows and columns values are required to insert a table."), null;
  };
  var Ib = tinymce.util.Tools.resolve("tinymce.FakeClipboard");
  const Bw = "x-tinymce/dom-table-", Hw = Bw + "rows", zw = Bw + "columns", w0 = (h) => {
    const w = Ib.FakeClipboardItem(h);
    Ib.write([w]);
  }, E0 = (h) => {
    var w;
    const A = (w = Ib.read()) !== null && w !== void 0 ? w : [];
    return an(A, (P) => Ce.from(P.getType(h)));
  }, Tx = (h) => {
    E0(h).isSome() && Ib.clear();
  }, C0 = (h) => {
    h.fold(b_, (w) => w0({ [Hw]: w }));
  }, x0 = () => E0(Hw), b_ = () => Tx(Hw), jy = (h) => {
    h.fold(y_, (w) => w0({ [zw]: w }));
  }, _x = () => E0(zw), y_ = () => Tx(zw), Vw = (h) => _f(Vl(h), Um(h)).filter(qp), hd = (h) => fb(Vl(h), Um(h)).filter(qp), og = (h, w) => {
    const A = Um(h), P = () => Vw(h).each(($t) => {
      gi($t, A).filter(q(A)).each((Gn) => {
        const Or = nt.fromText("");
        if (Xi(Gn, Or), Ra(Gn), h.dom.isEmpty(h.getBody()))
          h.setContent(""), h.selection.setCursorLocation();
        else {
          const jr = h.dom.createRng();
          jr.setStart(Or.dom, 0), jr.setEnd(Or.dom, 0), h.selection.setRng(jr), h.nodeChanged();
        }
      });
    }), V = ($t) => Vw(h).each((Gn) => {
      Up(h) || Vp(h) || Sf(h) || gi(Gn, A).each((jr) => {
        $t === "relative" && !Pb(jr) ? Gd(jr) : $t === "fixed" && !Db(jr) ? $b(jr) : $t === "responsive" && !b0(jr) && Wy(jr), dm(jr), cv(h, jr.dom, Gr);
      });
    }), K = ($t) => gi($t, A), ie = ($t) => hd(h).bind((Gn) => K(Gn).map((Or) => $t(Or, Gn))), ve = ($t, Gn) => {
      ie((Or) => {
        h.formatter.toggle("tableclass", { value: Gn }, Or.dom), cv(h, Or.dom, sh);
      });
    }, Ae = ($t, Gn) => {
      ie((Or) => {
        const jr = Wd(h), _c = Jt(jr, (ui) => h.formatter.match("tablecellclass", { value: Gn }, ui.dom)) ? h.formatter.remove : h.formatter.apply;
        Ne(jr, (ui) => _c("tablecellclass", { value: Gn }, ui.dom)), cv(h, Or.dom, sh);
      });
    }, Ue = () => {
      Vw(h).each(($t) => {
        gi($t, A).each((Gn) => {
          Ur(Gn, "caption").fold(() => {
            const Or = nt.fromTag("caption");
            ss(Or, nt.fromText("Caption")), yc(Gn, Or, 0), h.selection.setCursorLocation(Or.dom, 0);
          }, (Or) => {
            Qa("caption")($t) && Jf("td", Gn).each((jr) => h.selection.setCursorLocation(jr.dom, 0)), Ra(Or);
          }), cv(h, Gn.dom, Gr);
        });
      });
    }, ct = ($t) => {
      h.focus();
    }, Yt = ($t, Gn = !1) => ie((Or, jr) => {
      const da = ub(Wd(h), Or, jr);
      $t(Or, da, Gn).each(ct);
    }), On = () => ie(($t, Gn) => {
      const Or = ub(Wd(h), $t, Gn), jr = ci(Q, nt.fromDom(h.getDoc()), Ce.none());
      return hx($t, Or, jr);
    }), Tn = () => ie(($t, Gn) => {
      const Or = ub(Wd(h), $t, Gn);
      return s_($t, Or);
    }), It = ($t, Gn) => Gn().each((Or) => {
      const jr = st(Or, (da) => Dl(da));
      ie((da, _c) => {
        const ui = rc(nt.fromDom(h.getDoc())), bd = db(Wd(h), _c, jr, ui);
        $t(da, bd).each(ct);
      });
    }), An = ($t) => (Gn, Or) => pc(Or, "type").each((jr) => {
      Yt($t(jr), Or.no_events);
    });
    Ye({
      mceTableSplitCells: () => Yt(w.unmergeCells),
      mceTableMergeCells: () => Yt(w.mergeCells),
      mceTableInsertRowBefore: () => Yt(w.insertRowsBefore),
      mceTableInsertRowAfter: () => Yt(w.insertRowsAfter),
      mceTableInsertColBefore: () => Yt(w.insertColumnsBefore),
      mceTableInsertColAfter: () => Yt(w.insertColumnsAfter),
      mceTableDeleteCol: () => Yt(w.deleteColumn),
      mceTableDeleteRow: () => Yt(w.deleteRow),
      mceTableCutCol: () => Tn().each(($t) => {
        jy($t), Yt(w.deleteColumn);
      }),
      mceTableCutRow: () => On().each(($t) => {
        C0($t), Yt(w.deleteRow);
      }),
      mceTableCopyCol: () => Tn().each(($t) => jy($t)),
      mceTableCopyRow: () => On().each(($t) => C0($t)),
      mceTablePasteColBefore: () => It(w.pasteColsBefore, _x),
      mceTablePasteColAfter: () => It(w.pasteColsAfter, _x),
      mceTablePasteRowBefore: () => It(w.pasteRowsBefore, x0),
      mceTablePasteRowAfter: () => It(w.pasteRowsAfter, x0),
      mceTableDelete: P,
      mceTableCellToggleClass: Ae,
      mceTableToggleClass: ve,
      mceTableToggleCaption: Ue,
      mceTableSizingMode: ($t, Gn) => V(Gn),
      mceTableCellType: An(($t) => $t === "th" ? w.makeCellsHeader : w.unmakeCellsHeader),
      mceTableColType: An(($t) => $t === "th" ? w.makeColumnsHeader : w.unmakeColumnsHeader),
      mceTableRowType: An(($t) => {
        switch ($t) {
          case "header":
            return w.makeRowsHeader;
          case "footer":
            return w.makeRowsFooter;
          default:
            return w.makeRowsBody;
        }
      })
    }, ($t, Gn) => h.addCommand(Gn, $t)), h.addCommand("mceInsertTable", ($t, Gn) => {
      xx(h, Gn.rows, Gn.columns, Gn.options);
    }), h.addCommand("mceTableApplyCellStyle", ($t, Gn) => {
      const Or = (_c) => "tablecell" + _c.toLowerCase().replace("-", "");
      if (!g(Gn))
        return;
      const jr = xt(Wd(h), qp);
      if (jr.length === 0)
        return;
      const da = gr(Gn, (_c, ui) => h.formatter.has(Or(ui)) && v(_c));
      Es(da) || (Ye(da, (_c, ui) => {
        const bd = Or(ui);
        Ne(jr, (e1) => {
          _c === "" ? h.formatter.remove(bd, { value: null }, e1.dom, !0) : h.formatter.apply(bd, { value: _c }, e1.dom);
        });
      }), K(jr[0]).each((_c) => cv(h, _c.dom, sh)));
    });
  }, S_ = (h, w) => {
    const A = Um(h), P = (V) => fb(Vl(h)).bind((K) => gi(K, A).map((ie) => {
      const ve = ub(Wd(h), ie, K);
      return V(ie, ve);
    })).getOr("");
    Ye({
      mceTableRowType: () => P(w.getTableRowType),
      mceTableCellType: () => P(w.getTableCellType),
      mceTableColType: () => P(w.getTableColType)
    }, (V, K) => h.addQueryValueHandler(K, V));
  }, Uw = Vu.generate([
    { before: ["element"] },
    {
      on: [
        "element",
        "offset"
      ]
    },
    { after: ["element"] }
  ]), w_ = (h, w, A, P) => h.fold(w, A, P), E_ = (h) => h.fold(me, me, me), Ww = Uw.before, Ox = Uw.on, jw = Uw.after, Tc = {
    before: Ww,
    on: Ox,
    after: jw,
    cata: w_,
    getStart: E_
  }, Mb = { create: (h, w) => ({
    selection: h,
    kill: w
  }) }, T0 = (h, w) => {
    const A = h.document.createRange();
    return A.selectNode(w.dom), A;
  }, qw = (h, w) => {
    const A = h.document.createRange();
    return Gw(A, w), A;
  }, Gw = (h, w) => h.selectNodeContents(w.dom), Ax = (h, w) => {
    w.fold((A) => {
      h.setStartBefore(A.dom);
    }, (A, P) => {
      h.setStart(A.dom, P);
    }, (A) => {
      h.setStartAfter(A.dom);
    });
  }, kx = (h, w) => {
    w.fold((A) => {
      h.setEndBefore(A.dom);
    }, (A, P) => {
      h.setEnd(A.dom, P);
    }, (A) => {
      h.setEndAfter(A.dom);
    });
  }, ih = (h, w, A) => {
    const P = h.document.createRange();
    return Ax(P, w), kx(P, A), P;
  }, uv = (h, w, A, P, V) => {
    const K = h.document.createRange();
    return K.setStart(w.dom, A), K.setEnd(P.dom, V), K;
  }, C_ = (h) => ({
    left: h.left,
    top: h.top,
    right: h.right,
    bottom: h.bottom,
    width: h.width,
    height: h.height
  }), x_ = (h) => {
    const w = h.getClientRects(), A = w.length > 0 ? w[0] : h.getBoundingClientRect();
    return A.width > 0 || A.height > 0 ? Ce.some(A).map(C_) : Ce.none();
  }, qy = Vu.generate([
    {
      ltr: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    },
    {
      rtl: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    }
  ]), Zw = (h, w, A) => w(nt.fromDom(A.startContainer), A.startOffset, nt.fromDom(A.endContainer), A.endOffset), Nx = (h, w) => w.match({
    domRange: (A) => ({
      ltr: G(A),
      rtl: Ce.none
    }),
    relative: (A, P) => ({
      ltr: Id(() => ih(h, A, P)),
      rtl: Id(() => Ce.some(ih(h, P, A)))
    }),
    exact: (A, P, V, K) => ({
      ltr: Id(() => uv(h, A, P, V, K)),
      rtl: Id(() => Ce.some(uv(h, V, K, A, P)))
    })
  }), Ki = (h, w) => {
    const A = w.ltr();
    return A.collapsed ? w.rtl().filter((V) => V.collapsed === !1).map((V) => qy.rtl(nt.fromDom(V.endContainer), V.endOffset, nt.fromDom(V.startContainer), V.startOffset)).getOrThunk(() => Zw(h, qy.ltr, A)) : Zw(h, qy.ltr, A);
  }, Rx = (h, w) => {
    const A = Nx(h, w);
    return Ki(h, A);
  }, Kw = (h, w) => Rx(h, w).match({
    ltr: (P, V, K, ie) => {
      const ve = h.document.createRange();
      return ve.setStart(P.dom, V), ve.setEnd(K.dom, ie), ve;
    },
    rtl: (P, V, K, ie) => {
      const ve = h.document.createRange();
      return ve.setStart(K.dom, ie), ve.setEnd(P.dom, V), ve;
    }
  });
  qy.ltr, qy.rtl;
  const Fb = { create: (h, w, A, P) => ({
    start: h,
    soffset: w,
    finish: A,
    foffset: P
  }) }, Px = { create: (h, w, A, P) => ({
    start: Tc.on(h, w),
    finish: Tc.on(A, P)
  }) }, Yw = (h, w) => {
    const A = Kw(h, w);
    return Fb.create(nt.fromDom(A.startContainer), A.startOffset, nt.fromDom(A.endContainer), A.endOffset);
  }, Gy = Px.create, _0 = (h, w, A, P, V, K, ie) => os(A, V) && P === K ? Ce.none() : ni(A, "td,th", w).bind((ve) => ni(V, "td,th", w).bind((Ae) => Lb(h, w, ve, Ae, ie))), Lb = (h, w, A, P, V) => os(A, P) ? Ce.none() : Ul(A, P, w).bind((K) => {
    const ie = K.boxes.getOr([]);
    return ie.length > 1 ? (V(h, ie, K.start, K.finish), Ce.some(Mb.create(Ce.some(Gy(A, 0, A, Lo(A))), !0))) : Ce.none();
  }), __ = (h, w, A, P, V) => {
    const K = (ie) => (V.clearBeforeUpdate(A), V.selectRange(A, ie.boxes, ie.start, ie.finish), ie.boxes);
    return q1(P, h, w, V.firstSelectedSelector, V.lastSelectedSelector).map(K);
  }, sg = (h, w) => ({
    item: h,
    mode: w
  }), Dx = (h, w, A, P = ag) => h.property().parent(w).map((V) => sg(V, P)), ag = (h, w, A, P = ig) => A.sibling(h, w).map((V) => sg(V, P)), ig = (h, w, A, P = ig) => {
    const V = h.property().children(w);
    return A.first(V).map((ie) => sg(ie, P));
  }, S = [
    {
      current: Dx,
      next: ag,
      fallback: Ce.none()
    },
    {
      current: ag,
      next: ig,
      fallback: Ce.some(Dx)
    },
    {
      current: ig,
      next: ig,
      fallback: Ce.some(ag)
    }
  ], T = (h, w, A, P, V = S) => oe(V, (ie) => ie.current === A).bind((ie) => ie.current(h, w, P, ie.next).orThunk(() => ie.fallback.bind((ve) => T(h, w, ve, P)))), ge = {
    left: () => ({
      sibling: (A, P) => A.query().prevSibling(P),
      first: (A) => A.length > 0 ? Ce.some(A[A.length - 1]) : Ce.none()
    }),
    right: () => ({
      sibling: (A, P) => A.query().nextSibling(P),
      first: (A) => A.length > 0 ? Ce.some(A[0]) : Ce.none()
    })
  }, De = (h, w, A, P, V, K) => T(h, w, P, V).bind((ve) => K(ve.item) ? Ce.none() : A(ve.item) ? Ce.some(ve.item) : De(h, ve.item, A, ve.mode, V, K)), Qe = (h, w, A, P) => De(h, w, A, ag, ge.left(), P), it = (h, w, A, P) => De(h, w, A, ag, ge.right(), P), At = (h) => (w) => h.property().children(w).length === 0, vn = (h, w, A) => Nn(h, w, At(h), A), gn = (h, w, A) => ir(h, w, At(h), A), Nn = Qe, ir = it, Dr = Pt(), io = (h, w) => vn(Dr, h, w), Bo = (h, w) => gn(Dr, h, w), eo = (h, w, A) => Nn(Dr, h, w, A), fs = (h, w, A) => ir(Dr, h, w, A), As = (h, w, A) => na(h, w, A).isSome(), Lc = Vu.generate([
    { none: ["message"] },
    { success: [] },
    { failedUp: ["cell"] },
    { failedDown: ["cell"] }
  ]), xl = (h, w, A) => {
    const P = h.getRect(w), V = h.getRect(A);
    return V.right > P.left && V.left < P.right;
  }, Zd = (h) => ni(h, "tr"), Ms = {
    ...Lc,
    verify: (h, w, A, P, V, K, ie) => ni(P, "td,th", ie).bind((ve) => ni(w, "td,th", ie).map((Ae) => os(ve, Ae) ? os(P, ve) && Lo(ve) === V ? K(Ae) : Lc.none("in same cell") : us(Zd, [
      ve,
      Ae
    ]).fold(() => xl(h, Ae, ve) ? Lc.success() : K(Ae), (Ue) => K(Ae)))).getOr(Lc.none("default")),
    cata: (h, w, A, P, V) => h.fold(w, A, P, V)
  }, O_ = (h, w, A, P) => ({
    parent: h,
    children: w,
    element: A,
    index: P
  }), dv = (h) => Ac(h).bind((w) => {
    const A = $o(w);
    return Yk(A, h).map((P) => O_(w, A, h, P));
  }), Yk = (h, w) => qn(h, be(os, w)), $x = Qa("br"), Bb = (h, w, A) => w(h, A).bind((P) => Jl(P) && Xn(P).trim().length === 0 ? Bb(P, w, A) : Ce.some(P)), Wl = (h, w, A) => A.traverse(w).orThunk(() => Bb(w, A.gather, h)).map(A.relative), O0 = (h, w) => ei(h, w).filter($x).orThunk(() => ei(h, w - 1).filter($x)), Qw = (h, w, A, P) => O0(w, A).bind((V) => P.traverse(V).fold(() => Bb(V, P.gather, h).map(P.relative), (K) => dv(K).map((ie) => Tc.on(ie.parent, ie.index)))), A0 = (h, w, A, P) => ($x(w) ? Wl(h, w, P) : Qw(h, w, A, P)).map((K) => ({
    start: K,
    finish: K
  })), A_ = (h) => Ms.cata(h, (w) => Ce.none(), () => Ce.none(), (w) => Ce.some(pb(w, 0)), (w) => Ce.some(pb(w, Lo(w)))), k0 = (h, w) => ({
    left: h.left,
    top: h.top + w,
    right: h.right,
    bottom: h.bottom + w
  }), Zy = (h, w) => ({
    left: h.left,
    top: h.top - w,
    right: h.right,
    bottom: h.bottom - w
  }), ch = (h, w, A) => ({
    left: h.left + w,
    top: h.top + A,
    right: h.right + w,
    bottom: h.bottom + A
  }), gI = (h) => h.top, vI = (h) => h.bottom, Hb = (h, w, A) => A >= 0 && A < Lo(w) ? h.getRangedRect(w, A, w, A + 1) : A > 0 ? h.getRangedRect(w, A - 1, w, A) : Ce.none(), N0 = (h) => ({
    left: h.left,
    top: h.top,
    right: h.right,
    bottom: h.bottom
  }), Ix = (h, w) => Ce.some(h.getRect(w)), cg = (h, w, A) => Ei(w) ? Ix(h, w).map(N0) : Jl(w) ? Hb(h, w, A).map(N0) : Ce.none(), k_ = (h, w) => Ei(w) ? Ix(h, w).map(N0) : Jl(w) ? h.getRangedRect(w, 0, w, Lo(w)).map(N0) : Ce.none(), il = 5, fv = 100, tp = Vu.generate([
    { none: [] },
    { retry: ["caret"] }
  ]), R0 = (h, w) => h.left < w.left || Math.abs(w.right - h.left) < 1 || h.left > w.right, yu = (h, w, A) => Dm(w, d0).fold(je, (P) => k_(h, P).exists((V) => R0(A, V))), gd = (h, w, A, P, V) => {
    const K = k0(V, il);
    return Math.abs(A.bottom - P.bottom) < 1 || A.top > V.bottom ? tp.retry(K) : A.top === V.bottom ? tp.retry(k0(V, 1)) : yu(h, w, V) ? tp.retry(ch(K, il, 0)) : tp.none();
  }, np = {
    point: gI,
    adjuster: (h, w, A, P, V) => {
      const K = Zy(V, il);
      return Math.abs(A.top - P.top) < 1 || A.bottom < V.top ? tp.retry(K) : A.bottom === V.top ? tp.retry(Zy(V, 1)) : yu(h, w, V) ? tp.retry(ch(K, il, 0)) : tp.none();
    },
    move: Zy,
    gather: io
  }, Mx = {
    point: vI,
    adjuster: gd,
    move: k0,
    gather: Bo
  }, Rf = (h, w, A) => h.elementFromPoint(w, A).filter((P) => es(P) === "table").isSome(), Ky = (h, w, A, P, V) => N_(h, w, A, w.move(P, il), V), N_ = (h, w, A, P, V) => V === 0 ? Ce.some(P) : Rf(h, P.left, w.point(P)) ? Ky(h, w, A, P, V - 1) : h.situsFromPoint(P.left, w.point(P)).bind((K) => K.start.fold(Ce.none, (ie) => k_(h, ie).bind((ve) => w.adjuster(h, ie, ve, A, P).fold(Ce.none, (Ae) => N_(h, w, A, Ae, V - 1))).orThunk(() => Ce.some(P)), Ce.none)), bI = (h, w, A) => h.point(w) > A.getInnerHeight() ? Ce.some(h.point(w) - A.getInnerHeight()) : h.point(w) < 0 ? Ce.some(-h.point(w)) : Ce.none(), Qk = (h, w, A) => {
    const P = h.move(A, il), V = N_(w, h, A, P, fv).getOr(P);
    return bI(h, V, w).fold(() => w.situsFromPoint(V.left, h.point(V)), (K) => (w.scrollBy(0, K), w.situsFromPoint(V.left, h.point(V) - K)));
  }, Xw = {
    tryUp: be(Qk, np),
    tryDown: be(Qk, Mx),
    getJumpSize: G(il)
  }, Xk = 20, Jw = (h, w, A) => h.getSelection().bind((P) => A0(w, P.finish, P.foffset, A).fold(() => Ce.some(pb(P.finish, P.foffset)), (V) => {
    const K = h.fromSitus(V), ie = Ms.verify(h, P.finish, P.foffset, K.finish, K.foffset, A.failure, w);
    return A_(ie);
  })), Fx = (h, w, A, P, V, K) => K === 0 ? Ce.none() : SI(h, w, A, P, V).bind((ie) => {
    const ve = h.fromSitus(ie), Ae = Ms.verify(h, A, P, ve.finish, ve.foffset, V.failure, w);
    return Ms.cata(Ae, () => Ce.none(), () => Ce.some(ie), (Ue) => os(A, Ue) && P === 0 ? yI(h, A, P, Zy, V) : Fx(h, w, Ue, 0, V, K - 1), (Ue) => os(A, Ue) && P === Lo(Ue) ? yI(h, A, P, k0, V) : Fx(h, w, Ue, Lo(Ue), V, K - 1));
  }), yI = (h, w, A, P, V) => cg(h, w, A).bind((K) => Jk(h, V, P(K, Xw.getJumpSize()))), Jk = (h, w, A) => {
    const P = df().browser;
    return P.isChromium() || P.isSafari() || P.isFirefox() ? w.retry(h, A) : Ce.none();
  }, SI = (h, w, A, P, V) => cg(h, A, P).bind((K) => Jk(h, V, K)), i5 = (h, w, A) => Jw(h, w, A).bind((P) => Fx(h, w, P.element, P.offset, A, Xk).map(h.fromSitus)), eN = (h, w) => As(h, (A) => Ac(A).exists((P) => os(P, w))), bo = (h, w, A, P, V) => ni(P, "td,th", w).bind((K) => ni(K, "table", w).bind((ie) => eN(V, ie) ? i5(h, w, A).bind((ve) => ni(ve.finish, "td,th", w).map((Ae) => ({
    start: K,
    finish: Ae,
    range: ve
  }))) : Ce.none())), lh = (h, w, A, P, V, K) => K(P, w).orThunk(() => bo(h, w, A, P, V).map((ie) => {
    const ve = ie.range;
    return Mb.create(Ce.some(Gy(ve.start, ve.soffset, ve.finish, ve.foffset)), !0);
  })), Yy = (h, w) => ni(h, "tr", w).bind((A) => ni(A, "table", w).bind((P) => {
    const V = Rc(P, "tr");
    return os(A, V[0]) ? eo(P, (K) => Bd(K).isSome(), w).map((K) => {
      const ie = Lo(K);
      return Mb.create(Ce.some(Gy(K, ie, K, ie)), !0);
    }) : Ce.none();
  })), R_ = (h, w) => ni(h, "tr", w).bind((A) => ni(A, "table", w).bind((P) => {
    const V = Rc(P, "tr");
    return os(A, V[V.length - 1]) ? fs(P, (K) => bf(K).isSome(), w).map((K) => Mb.create(Ce.some(Gy(K, 0, K, 0)), !0)) : Ce.none();
  })), tN = (h, w, A, P, V, K, ie) => bo(h, A, P, V, K).bind((ve) => Lb(w, A, ve.start, ve.finish, ie)), eE = (h) => {
    let w = h;
    return {
      get: () => w,
      set: (V) => {
        w = V;
      }
    };
  }, wI = (h) => {
    const w = eE(Ce.none()), A = () => w.get().each(h);
    return {
      clear: () => {
        A(), w.set(Ce.none());
      },
      isSet: () => w.get().isSome(),
      get: () => w.get(),
      set: (ve) => {
        A(), w.set(Ce.some(ve));
      }
    };
  }, P0 = () => {
    const h = wI(Q);
    return {
      ...h,
      on: (A) => h.get().each(A)
    };
  }, Lx = (h, w) => ni(h, "td,th", w), Pf = (h) => kc(h).exists(Wp), wq = (h, w, A, P) => {
    const V = P0(), K = V.clear, ie = (ct) => {
      V.on((Yt) => {
        P.clearBeforeUpdate(w), Lx(ct.target, A).each((On) => {
          Ul(Yt, On, A).each((Tn) => {
            const It = Tn.boxes.getOr([]);
            if (It.length === 1) {
              const An = It[0], $t = yl(An) === "false", Gn = Xc(_y(ct.target), An, os);
              $t && Gn && (P.selectRange(w, It, An, An), h.selectContents(An));
            } else
              It.length > 1 && (P.selectRange(w, It, Tn.start, Tn.finish), h.selectContents(On));
          });
        });
      });
    };
    return {
      clearstate: K,
      mousedown: (ct) => {
        P.clear(w), Lx(ct.target, A).filter(Pf).each(V.set);
      },
      mouseover: (ct) => {
        ie(ct);
      },
      mouseup: (ct) => {
        ie(ct), K();
      }
    };
  }, Bx = {
    traverse: ed,
    gather: Bo,
    relative: Tc.before,
    retry: Xw.tryDown,
    failure: Ms.failedDown
  }, D0 = {
    traverse: Ju,
    gather: io,
    relative: Tc.before,
    retry: Xw.tryUp,
    failure: Ms.failedUp
  }, zb = (h) => (w) => w === h, Hx = zb(38), zx = zb(40), Qy = (h) => h >= 37 && h <= 40, EI = {
    isBackward: zb(37),
    isForward: zb(39)
  }, nN = {
    isBackward: zb(39),
    isForward: zb(37)
  }, CI = (h) => {
    const w = h !== void 0 ? h.dom : document, A = w.body.scrollLeft || w.documentElement.scrollLeft, P = w.body.scrollTop || w.documentElement.scrollTop;
    return Me(A, P);
  }, $0 = (h, w, A) => {
    const V = (A !== void 0 ? A.dom : document).defaultView;
    V && V.scrollBy(h, w);
  }, mv = Vu.generate([
    { domRange: ["rng"] },
    {
      relative: [
        "startSitu",
        "finishSitu"
      ]
    },
    {
      exact: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    }
  ]), xI = (h) => mv.exact(h.start, h.soffset, h.finish, h.foffset), TI = (h) => h.match({
    domRange: (w) => nt.fromDom(w.startContainer),
    relative: (w, A) => Tc.getStart(w),
    exact: (w, A, P, V) => w
  }), rN = mv.domRange, P_ = mv.relative, D_ = mv.exact, $_ = (h) => {
    const w = TI(h);
    return Gs(w);
  }, Vx = Fb.create, Vb = {
    domRange: rN,
    relative: P_,
    exact: D_,
    exactFromRange: xI,
    getWin: $_,
    range: Vx
  }, oN = (h, w, A) => {
    var P, V;
    return Ce.from((V = (P = h.dom).caretPositionFromPoint) === null || V === void 0 ? void 0 : V.call(P, w, A)).bind((K) => {
      if (K.offsetNode === null)
        return Ce.none();
      const ie = h.dom.createRange();
      return ie.setStart(K.offsetNode, K.offset), ie.collapse(), Ce.some(ie);
    });
  }, tE = (h, w, A) => {
    var P, V;
    return Ce.from((V = (P = h.dom).caretRangeFromPoint) === null || V === void 0 ? void 0 : V.call(P, w, A));
  }, I_ = (() => document.caretPositionFromPoint ? oN : document.caretRangeFromPoint ? tE : Ce.none)(), _I = (h, w, A) => {
    const P = nt.fromDom(h.document);
    return I_(P, w, A).map((V) => Fb.create(nt.fromDom(V.startContainer), V.startOffset, nt.fromDom(V.endContainer), V.endOffset));
  }, nE = (h, w) => {
    const A = es(h);
    return A === "input" ? Tc.after(h) : bt([
      "br",
      "img"
    ], A) ? w === 0 ? Tc.before(h) : Tc.after(h) : Tc.on(h, w);
  }, OI = (h, w) => {
    const A = h.fold(Tc.before, nE, Tc.after), P = w.fold(Tc.before, nE, Tc.after);
    return Vb.relative(A, P);
  }, Pn = (h, w, A, P) => {
    const V = nE(h, w), K = nE(A, P);
    return Vb.relative(V, K);
  }, ac = (h, w, A, P) => {
    const K = tu(h).dom.createRange();
    return K.setStart(h.dom, w), K.setEnd(A.dom, P), K;
  }, pv = (h, w, A, P) => {
    const V = ac(h, w, A, P), K = os(h, A) && w === P;
    return V.collapsed && !K;
  }, _i = (h) => Ce.from(h.getSelection()), bm = (h, w) => {
    _i(h).each((A) => {
      A.removeAllRanges(), A.addRange(w);
    });
  }, Ux = (h, w, A, P, V) => {
    const K = uv(h, w, A, P, V);
    bm(h, K);
  }, rE = (h, w, A, P, V, K) => {
    w.collapse(A.dom, P), w.extend(V.dom, K);
  }, uh = (h, w) => Rx(h, w).match({
    ltr: (A, P, V, K) => {
      Ux(h, A, P, V, K);
    },
    rtl: (A, P, V, K) => {
      _i(h).each((ie) => {
        if (ie.setBaseAndExtent)
          ie.setBaseAndExtent(A.dom, P, V.dom, K);
        else if (ie.extend)
          try {
            rE(h, ie, A, P, V, K);
          } catch {
            Ux(h, V, K, A, P);
          }
        else
          Ux(h, V, K, A, P);
      });
    }
  }), Wx = (h, w, A, P, V) => {
    const K = Pn(w, A, P, V);
    uh(h, K);
  }, jx = (h, w, A) => {
    const P = OI(w, A);
    uh(h, P);
  }, I0 = (h) => {
    if (h.rangeCount > 0) {
      const w = h.getRangeAt(0), A = h.getRangeAt(h.rangeCount - 1);
      return Ce.some(Fb.create(nt.fromDom(w.startContainer), w.startOffset, nt.fromDom(A.endContainer), A.endOffset));
    } else
      return Ce.none();
  }, sN = (h) => {
    if (h.anchorNode === null || h.focusNode === null)
      return I0(h);
    {
      const w = nt.fromDom(h.anchorNode), A = nt.fromDom(h.focusNode);
      return pv(w, h.anchorOffset, A, h.focusOffset) ? Ce.some(Fb.create(w, h.anchorOffset, A, h.focusOffset)) : I0(h);
    }
  }, oE = (h, w, A = !0) => {
    const V = (A ? qw : T0)(h, w);
    bm(h, V);
  }, M_ = (h) => _i(h).filter((w) => w.rangeCount > 0).bind(sN), F_ = (h) => M_(h).map((w) => Vb.exact(w.start, w.soffset, w.finish, w.foffset)), AI = (h, w) => {
    const A = Kw(h, w);
    return x_(A);
  }, dh = (h, w, A) => _I(h, w, A), qx = (h) => {
    _i(h).each((w) => w.removeAllRanges());
  }, M0 = (h) => ({
    elementFromPoint: ($t, Gn) => nt.fromPoint(nt.fromDom(h.document), $t, Gn),
    getRect: ($t) => $t.dom.getBoundingClientRect(),
    getRangedRect: ($t, Gn, Or, jr) => {
      const da = Vb.exact($t, Gn, Or, jr);
      return AI(h, da);
    },
    getSelection: () => F_(h).map(($t) => Yw(h, $t)),
    fromSitus: ($t) => {
      const Gn = Vb.relative($t.start, $t.finish);
      return Yw(h, Gn);
    },
    situsFromPoint: ($t, Gn) => dh(h, $t, Gn).map((Or) => Px.create(Or.start, Or.soffset, Or.finish, Or.foffset)),
    clearSelection: () => {
      qx(h);
    },
    collapseSelection: ($t = !1) => {
      F_(h).each((Gn) => Gn.fold((Or) => Or.collapse($t), (Or, jr) => {
        const da = $t ? Or : jr;
        jx(h, da, da);
      }, (Or, jr, da, _c) => {
        const ui = $t ? Or : da, bd = $t ? jr : _c;
        Wx(h, ui, bd, ui, bd);
      }));
    },
    setSelection: ($t) => {
      Wx(h, $t.start, $t.soffset, $t.finish, $t.foffset);
    },
    setRelativeSelection: ($t, Gn) => {
      jx(h, $t, Gn);
    },
    selectNode: ($t) => {
      oE(h, $t, !1);
    },
    selectContents: ($t) => {
      oE(h, $t);
    },
    getInnerHeight: () => h.innerHeight,
    getScrollY: () => CI(nt.fromDom(h.document)).top,
    scrollBy: ($t, Gn) => {
      $0($t, Gn, nt.fromDom(h.document));
    }
  }), Tl = (h, w) => ({
    rows: h,
    cols: w
  }), Yi = (h, w, A, P) => {
    const V = M0(h), K = wq(V, w, A, P);
    return {
      clearstate: K.clearstate,
      mousedown: K.mousedown,
      mouseover: K.mouseover,
      mouseup: K.mouseup
    };
  }, Gx = (h) => Dm(h, lr).exists(Wp), sE = (h, w) => Gx(h) || Gx(w), Zx = (h, w, A, P) => {
    const V = M0(h), K = () => (P.clear(w), Ce.none());
    return {
      keydown: (Ae, Ue, ct, Yt, On, Tn) => {
        const It = Ae.raw, An = It.which, $t = It.shiftKey === !0;
        return Wr(w, P.selectedSelector).fold(() => (Qy(An) && !$t && P.clearBeforeUpdate(w), Qy(An) && $t && !sE(Ue, Yt) ? Ce.none : zx(An) && $t ? be(tN, V, w, A, Bx, Yt, Ue, P.selectRange) : Hx(An) && $t ? be(tN, V, w, A, D0, Yt, Ue, P.selectRange) : zx(An) ? be(lh, V, A, Bx, Yt, Ue, R_) : Hx(An) ? be(lh, V, A, D0, Yt, Ue, Yy) : Ce.none), (Or) => {
          const jr = (da) => () => an(da, (ui) => __(ui.rows, ui.cols, w, Or, P)).fold(() => Kp(w, P.firstSelectedSelector, P.lastSelectedSelector).map((ui) => {
            const bd = zx(An) || Tn.isForward(An) ? Tc.after : Tc.before;
            return V.setRelativeSelection(Tc.on(ui.first, 0), bd(ui.table)), P.clear(w), Mb.create(Ce.none(), !0);
          }), (ui) => Ce.some(Mb.create(Ce.none(), !0)));
          return Qy(An) && $t && !sE(Ue, Yt) ? Ce.none : zx(An) && $t ? jr([Tl(1, 0)]) : Hx(An) && $t ? jr([Tl(-1, 0)]) : Tn.isBackward(An) && $t ? jr([
            Tl(0, -1),
            Tl(-1, 0)
          ]) : Tn.isForward(An) && $t ? jr([
            Tl(0, 1),
            Tl(1, 0)
          ]) : Qy(An) && !$t ? K : Ce.none;
        })();
      },
      keyup: (Ae, Ue, ct, Yt, On) => Wr(w, P.selectedSelector).fold(() => {
        const Tn = Ae.raw, It = Tn.which;
        return Tn.shiftKey === !0 && Qy(It) && sE(Ue, Yt) ? _0(w, A, Ue, ct, Yt, On, P.selectRange) : Ce.none();
      }, Ce.none)
    };
  }, aE = (h, w, A, P) => {
    const V = M0(h);
    return (K, ie) => {
      P.clearBeforeUpdate(w), Ul(K, ie, A).each((ve) => {
        const Ae = ve.boxes.getOr([]);
        P.selectRange(w, Ae, ve.start, ve.finish), V.selectContents(ie), V.collapseSelection();
      });
    };
  }, iE = (h, w) => {
    const A = Yu(h, w);
    return A === void 0 || A === "" ? [] : A.split(" ");
  }, F0 = (h, w, A) => {
    const V = iE(h, w).concat([A]);
    return ia(h, w, V.join(" ")), !0;
  }, aN = (h, w, A) => {
    const P = xt(iE(h, w), (V) => V !== A);
    return P.length > 0 ? ia(h, w, P.join(" ")) : ea(h, w), !1;
  }, cE = (h) => h.dom.classList !== void 0, iN = (h) => iE(h, "class"), cN = (h, w) => F0(h, "class", w), lN = (h, w) => aN(h, "class", w), ym = (h, w) => {
    cE(h) ? h.dom.classList.add(w) : cN(h, w);
  }, jl = (h) => {
    (cE(h) ? h.dom.classList : iN(h)).length === 0 && ea(h, "class");
  }, rp = (h, w) => {
    cE(h) ? h.dom.classList.remove(w) : lN(h, w), jl(h);
  }, vd = (h, w) => cE(h) && h.dom.classList.contains(w), lE = (h, w) => {
    Ne(w, (A) => {
      rp(h, A);
    });
  }, Kx = (h) => (w) => {
    ym(w, h);
  }, uN = (h) => (w) => {
    lE(w, h);
  }, hv = {
    byClass: (h) => {
      const w = Kx(h.selected), A = uN([
        h.selected,
        h.lastSelected,
        h.firstSelected
      ]), P = (K) => {
        const ie = Rc(K, h.selectedSelector);
        Ne(ie, A);
      };
      return {
        clearBeforeUpdate: P,
        clear: P,
        selectRange: (K, ie, ve, Ae) => {
          P(K), Ne(ie, w), ym(ve, h.firstSelected), ym(Ae, h.lastSelected);
        },
        selectedSelector: h.selectedSelector,
        firstSelectedSelector: h.firstSelectedSelector,
        lastSelectedSelector: h.lastSelectedSelector
      };
    },
    byAttr: (h, w, A) => {
      const P = (Ae) => {
        ea(Ae, h.selected), ea(Ae, h.firstSelected), ea(Ae, h.lastSelected);
      }, V = (Ae) => {
        ia(Ae, h.selected, "1");
      }, K = (Ae) => {
        ie(Ae), A();
      }, ie = (Ae) => {
        const Ue = Rc(Ae, `${h.selectedSelector},${h.firstSelectedSelector},${h.lastSelectedSelector}`);
        Ne(Ue, P);
      };
      return {
        clearBeforeUpdate: ie,
        clear: K,
        selectRange: (Ae, Ue, ct, Yt) => {
          K(Ae), Ne(Ue, V), ia(ct, h.firstSelected, "1"), ia(Yt, h.lastSelected, "1"), w(Ue, ct, Yt);
        },
        selectedSelector: h.selectedSelector,
        firstSelectedSelector: h.firstSelectedSelector,
        lastSelectedSelector: h.lastSelectedSelector
      };
    }
  }, dE = (h, w, A, P) => {
    switch (h.tag) {
      case "none":
        return w();
      case "single":
        return P(h.element);
      case "multiple":
        return A(h.elements);
    }
  }, L_ = () => ({ tag: "none" }), dN = (h) => ({
    tag: "multiple",
    elements: h
  }), fN = (h) => ({
    tag: "single",
    element: h
  }), B_ = (h, w, A) => ({ get: () => Ay(h(), A).fold(() => w().fold(L_, fN), dN) }), Yx = (h, w) => {
    const A = h.slice(0, w[w.length - 1].row + 1), P = wa(A);
    return Zt(P, (V) => {
      const K = V.cells.slice(0, w[w.length - 1].column + 1);
      return st(K, (ie) => ie.element);
    });
  }, Fs = (h, w) => {
    const A = h.slice(w[0].row + w[0].rowspan - 1, h.length), P = wa(A);
    return Zt(P, (V) => {
      const K = V.cells.slice(w[0].column + w[0].colspan - 1, V.cells.length);
      return st(K, (ie) => ie.element);
    });
  }, gv = (h, w, A) => {
    const P = ye.fromTable(h);
    return Zh(P, w).map((K) => {
      const ie = Xg(P, A, !1), { rows: ve } = Aa(ie), Ae = Yx(ve, K), Ue = Fs(ve, K);
      return {
        upOrLeftCells: Ae,
        downOrRightCells: Ue
      };
    });
  }, mN = (h, w, A, P, V, K, ie) => ({
    target: h,
    x: w,
    y: A,
    stop: P,
    prevent: V,
    kill: K,
    raw: ie
  }), H_ = (h) => {
    const w = nt.fromDom(kn(h).getOr(h.target)), A = () => h.stopPropagation(), P = () => h.preventDefault(), V = he(P, A);
    return mN(w, h.clientX, h.clientY, A, P, V, h);
  }, z_ = (h, w) => (A) => {
    h(A) && w(H_(A));
  }, Xy = (h, w, A, P, V) => {
    const K = z_(A, P);
    return h.dom.addEventListener(w, K, V), { unbind: be(U_, h, w, K, V) };
  }, V_ = (h, w, A, P) => Xy(h, w, A, P, !1), U_ = (h, w, A, P) => {
    h.dom.removeEventListener(w, A, P);
  }, NI = Ie, L0 = (h, w, A) => V_(h, w, NI, A), B0 = H_, W_ = (h) => !vd(nt.fromDom(h.target), "ephox-snooker-resizer-bar"), j_ = (h, w) => {
    const A = B_(() => nt.fromDom(h.getBody()), () => fb(Vl(h), Um(h)), Qp.selectedSelector), P = (Ae, Ue, ct) => {
      gi(Ue).each((On) => {
        const Tn = um(h), It = ci(Q, nt.fromDom(h.getDoc()), Tn), An = Wd(h), $t = gv(On, { selection: An }, It);
        r_(h, Ae, Ue, ct, $t);
      });
    }, V = () => o_(h), K = hv.byAttr(Qp, P, V);
    return h.on("init", (Ae) => {
      const Ue = h.getWin(), ct = zd(h), Yt = Um(h), On = () => {
        const ks = h.selection, Su = nt.fromDom(ks.getStart()), _l = nt.fromDom(ks.getEnd());
        us(gi, [
          Su,
          _l
        ]).fold(() => K.clear(ct), Q);
      }, Tn = Yi(Ue, ct, Yt, K), It = Zx(Ue, ct, Yt, K), An = aE(Ue, ct, Yt, K), $t = (ks) => ks.raw.shiftKey === !0;
      h.on("TableSelectorChange", (ks) => An(ks.start, ks.finish));
      const Gn = (ks, Su) => {
        $t(ks) && (Su.kill && ks.kill(), Su.selection.each((_l) => {
          const If = Vb.relative(_l.start, _l.finish), Qd = Kw(Ue, If);
          h.selection.setRng(Qd);
        }));
      }, Or = (ks) => {
        const Su = B0(ks);
        if (Su.raw.shiftKey && Qy(Su.raw.which)) {
          const _l = h.selection.getRng(), If = nt.fromDom(_l.startContainer), Qd = nt.fromDom(_l.endContainer);
          It.keyup(Su, If, _l.startOffset, Qd, _l.endOffset).each((jb) => {
            Gn(Su, jb);
          });
        }
      }, jr = (ks) => {
        const Su = B0(ks);
        w.hide();
        const _l = h.selection.getRng(), If = nt.fromDom(_l.startContainer), Qd = nt.fromDom(_l.endContainer), jb = Qv(EI, nN)(nt.fromDom(h.selection.getStart()));
        It.keydown(Su, If, _l.startOffset, Qd, _l.endOffset, jb).each((ju) => {
          Gn(Su, ju);
        }), w.show();
      }, da = (ks) => ks.button === 0, _c = (ks) => ks.buttons === void 0 ? !0 : (ks.buttons & 1) !== 0, ui = (ks) => {
        Tn.clearstate();
      }, bd = (ks) => {
        da(ks) && W_(ks) && Tn.mousedown(B0(ks));
      }, e1 = (ks) => {
        _c(ks) && W_(ks) && Tn.mouseover(B0(ks));
      }, t1 = (ks) => {
        da(ks) && W_(ks) && Tn.mouseup(B0(ks));
      }, nT = (() => {
        const ks = eE(nt.fromDom(ct)), Su = eE(0);
        return { touchEnd: (If) => {
          const Qd = nt.fromDom(If.target);
          if (Qa("td")(Qd) || Qa("th")(Qd)) {
            const jb = ks.get(), ju = Su.get();
            os(jb, Qd) && If.timeStamp - ju < 300 && (If.preventDefault(), An(Qd, Qd));
          }
          ks.set(Qd), Su.set(If.timeStamp);
        } };
      })();
      h.on("dragstart", ui), h.on("mousedown", bd), h.on("mouseover", e1), h.on("mouseup", t1), h.on("touchend", nT.touchEnd), h.on("keyup", Or), h.on("keydown", jr), h.on("NodeChange", On);
    }), h.on("PreInit", () => {
      h.serializer.addTempAttr(Qp.firstSelected), h.serializer.addTempAttr(Qp.lastSelected);
    }), {
      getSelectedCells: () => dE(A.get(), G([]), (Ae) => st(Ae, (Ue) => Ue.dom), (Ae) => [Ae.dom]),
      clearSelectedCells: (Ae) => K.clear(nt.fromDom(Ae))
    };
  }, op = (h) => {
    let w = [];
    return {
      bind: (K) => {
        if (K === void 0)
          throw new Error("Event bind error: undefined handler");
        w.push(K);
      },
      unbind: (K) => {
        w = xt(w, (ie) => ie !== K);
      },
      trigger: (...K) => {
        const ie = {};
        Ne(h, (ve, Ae) => {
          ie[ve] = K[Ae];
        }), Ne(w, (ve) => {
          ve(ie);
        });
      }
    };
  }, Ub = (h) => {
    const w = nn(h, (P) => ({
      bind: P.bind,
      unbind: P.unbind
    })), A = nn(h, (P) => P.trigger);
    return {
      registry: w,
      trigger: A
    };
  }, RI = (h, w) => {
    let A = null;
    const P = () => {
      O(A) || (clearTimeout(A), A = null);
    };
    return {
      cancel: P,
      throttle: (...K) => {
        P(), A = setTimeout(() => {
          A = null, h.apply(null, K);
        }, w);
      }
    };
  }, fE = (h) => h.slice(0).sort(), PI = (h, w) => {
    throw new Error("All required keys (" + fE(h).join(", ") + ") were not specified. Specified keys were: " + fE(w).join(", ") + ".");
  }, Yd = (h) => {
    throw new Error("Unsupported keys for object: " + fE(h).join(", "));
  }, ql = (h, w) => {
    if (!C(w))
      throw new Error("The " + h + " fields must be an array. Was: " + w + ".");
    Ne(w, (A) => {
      if (!v(A))
        throw new Error("The value " + A + " in the " + h + " fields was not a string.");
    });
  }, Jy = (h, w) => {
    throw new Error("All values need to be of type: " + w + ". Keys (" + fE(h).join(", ") + ") were not.");
  }, c5 = (h) => {
    const w = fE(h);
    oe(w, (P, V) => V < w.length - 1 && P === w[V + 1]).each((P) => {
      throw new Error("The field: " + P + " occurs more than once in the combined fields: [" + w.join(", ") + "].");
    });
  }, pN = (h, w) => DI(h, w, {
    validate: ne,
    label: "function"
  }), DI = (h, w, A) => {
    if (w.length === 0)
      throw new Error("You must specify at least one required field.");
    return ql("required", w), c5(w), (P) => {
      const V = ht(P);
      Jt(w, (ve) => bt(V, ve)) || PI(w, V), h(w, V);
      const ie = xt(w, (ve) => !A.validate(P[ve], ve));
      return ie.length > 0 && Jy(ie, A.label), P;
    };
  }, ho = (h, w) => {
    const A = xt(w, (P) => !bt(h, P));
    A.length > 0 && Yd(A);
  }, q_ = (h) => pN(ho, h), hN = q_([
    "compare",
    "extract",
    "mutate",
    "sink"
  ]), G_ = q_([
    "element",
    "start",
    "stop",
    "destroy"
  ]), $I = q_([
    "forceDrop",
    "drop",
    "move",
    "delayDrop"
  ]), II = () => {
    let h = Ce.none();
    const w = () => {
      h = Ce.none();
    }, A = (K, ie) => {
      const ve = h.map((Ae) => K.compare(Ae, ie));
      return h = Ce.some(ie), ve;
    }, P = (K, ie) => {
      ie.extract(K).each((Ae) => {
        A(ie, Ae).each((ct) => {
          V.trigger.move(ct);
        });
      });
    }, V = Ub({ move: op(["info"]) });
    return {
      onEvent: P,
      reset: w,
      events: V.registry
    };
  }, gN = () => {
    const h = Ub({ move: op(["info"]) });
    return {
      onEvent: Q,
      reset: Q,
      events: h.registry
    };
  }, MI = () => {
    const h = gN(), w = II();
    let A = h;
    return {
      on: () => {
        A.reset(), A = w;
      },
      off: () => {
        A.reset(), A = h;
      },
      isOn: () => A === w,
      onEvent: (ve, Ae) => {
        A.onEvent(ve, Ae);
      },
      events: w.events
    };
  }, zn = (h, w, A) => {
    let P = !1;
    const V = Ub({
      start: op([]),
      stop: op([])
    }), K = MI(), ie = () => {
      It.stop(), K.isOn() && (K.off(), V.trigger.stop());
    }, ve = RI(ie, 200), Ae = ($t) => {
      It.start($t), K.on(), V.trigger.start();
    }, Ue = ($t) => {
      ve.cancel(), K.onEvent($t, w);
    };
    K.events.move.bind(($t) => {
      w.mutate(h, $t.info);
    });
    const ct = () => {
      P = !0;
    }, Yt = () => {
      P = !1;
    }, On = () => P, Tn = ($t) => (...Gn) => {
      P && $t.apply(null, Gn);
    }, It = w.sink($I({
      forceDrop: ie,
      drop: Tn(ie),
      move: Tn(Ue),
      delayDrop: Tn(ve.throttle)
    }), A), An = () => {
      It.destroy();
    };
    return {
      element: It.element,
      go: Ae,
      on: ct,
      off: Yt,
      isActive: On,
      destroy: An,
      events: V.registry
    };
  }, Wb = (h) => {
    const w = h.replace(/\./g, "-");
    return { resolve: (P) => w + "-" + P };
  }, mE = Wb("ephox-dragster").resolve, pE = (h) => {
    const w = {
      layerClass: mE("blocker"),
      ...h
    }, A = nt.fromTag("div");
    return ia(A, "role", "presentation"), Mi(A, {
      position: "fixed",
      left: "0px",
      top: "0px",
      width: "100%",
      height: "100%"
    }), ym(A, mE("blocker")), ym(A, w.layerClass), {
      element: G(A),
      destroy: () => {
        Ra(A);
      }
    };
  };
  var LI = hN({
    compare: (h, w) => Me(w.left - h.left, w.top - h.top),
    extract: (h) => Ce.some(Me(h.x, h.y)),
    sink: (h, w) => {
      const A = pE(w), P = L0(A.element(), "mousedown", h.forceDrop), V = L0(A.element(), "mouseup", h.drop), K = L0(A.element(), "mousemove", h.move), ie = L0(A.element(), "mouseout", h.delayDrop), ve = () => {
        A.destroy(), V.unbind(), K.unbind(), ie.unbind(), P.unbind();
      }, Ae = (ct) => {
        ss(ct, A.element());
      }, Ue = () => {
        Ra(A.element());
      };
      return G_({
        element: A.element,
        start: Ae,
        stop: Ue,
        destroy: ve
      });
    },
    mutate: (h, w) => {
      h.mutate(w.left, w.top);
    }
  });
  const bN = (h, w = {}) => {
    var A;
    const P = (A = w.mode) !== null && A !== void 0 ? A : LI;
    return zn(h, P, w);
  }, vv = Wb("ephox-snooker").resolve, yN = () => {
    const h = Ub({
      drag: op([
        "xDelta",
        "yDelta"
      ])
    });
    return {
      mutate: (A, P) => {
        h.trigger.drag(A, P);
      },
      events: h.registry
    };
  }, BI = () => {
    const h = Ub({
      drag: op([
        "xDelta",
        "yDelta",
        "target"
      ])
    });
    let w = Ce.none();
    const A = yN();
    return A.events.drag.bind((K) => {
      w.each((ie) => {
        h.trigger.drag(K.xDelta, K.yDelta, ie);
      });
    }), {
      assign: (K) => {
        w = Ce.some(K);
      },
      get: () => w,
      mutate: A.mutate,
      events: h.registry
    };
  }, hE = (h, w, A, P, V) => {
    const K = nt.fromTag("div");
    return Mi(K, {
      position: "absolute",
      left: w - P / 2 + "px",
      top: A + "px",
      height: V + "px",
      width: P + "px"
    }), Nl(K, {
      "data-column": h,
      role: "presentation"
    }), K;
  }, HI = (h, w, A, P, V) => {
    const K = nt.fromTag("div");
    return Mi(K, {
      position: "absolute",
      left: w + "px",
      top: A - V / 2 + "px",
      height: V + "px",
      width: P + "px"
    }), Nl(K, {
      "data-row": h,
      role: "presentation"
    }), K;
  }, SN = vv("resizer-bar"), Z_ = vv("resizer-rows"), wN = vv("resizer-cols"), Qx = 7, zI = (h, w) => Zt(h.all, (A, P) => w(A.element) ? [P] : []), VI = (h, w) => {
    const A = [];
    return _n(h.grid.columns, (P) => {
      ye.getColumnAt(h, P).map((K) => K.element).forall(w) && A.push(P);
    }), xt(A, (P) => {
      const V = ye.filterItems(h, (K) => K.column === P);
      return Jt(V, (K) => w(K.element));
    });
  }, H0 = (h) => {
    const w = Rc(h.parent(), "." + SN);
    Ne(w, Ra);
  }, K_ = (h, w, A) => {
    const P = h.origin();
    Ne(w, (V) => {
      V.each((K) => {
        const ie = A(P, K);
        ym(ie, SN), ss(h.parent(), ie);
      });
    });
  }, EN = (h, w, A, P) => {
    K_(h, w, (V, K) => {
      const ie = hE(K.col, K.x - V.left, A.top - V.top, Qx, P);
      return ym(ie, wN), ie;
    });
  }, UI = (h, w, A, P) => {
    K_(h, w, (V, K) => {
      const ie = HI(K.row, A.left - V.left, K.y - V.top, P, Qx);
      return ym(ie, Z_), ie;
    });
  }, WI = (h, w, A, P, V) => {
    const K = Wn(A), ie = w.isResizable, ve = P.length > 0 ? Un.positions(P, A) : [], Ae = ve.length > 0 ? zI(h, ie) : [], Ue = xt(ve, (Tn, It) => at(Ae, (An) => It === An));
    UI(w, Ue, K, au(A));
    const ct = V.length > 0 ? Ua.positions(V, A) : [], Yt = ct.length > 0 ? VI(h, ie) : [], On = xt(ct, (Tn, It) => at(Yt, (An) => It === An));
    EN(w, On, K, H(A));
  }, Xx = (h, w) => {
    if (H0(h), h.isResizable(w)) {
      const A = ye.fromTable(w), P = pl(A), V = cu(A);
      WI(A, h, w, P, V);
    }
  }, lg = (h, w) => {
    const A = Rc(h.parent(), "." + SN);
    Ne(A, w);
  }, Jx = (h) => {
    lg(h, (w) => {
      zs(w, "display", "none");
    });
  }, Wo = (h) => {
    lg(h, (w) => {
      zs(w, "display", "block");
    });
  }, jI = (h) => vd(h, Z_), bv = (h) => vd(h, wN), ug = vv("resizer-bar-dragging"), eT = (h) => {
    const w = BI(), A = bN(w, {});
    let P = Ce.none();
    const V = (It, An) => Ce.from(Yu(It, An));
    w.events.drag.bind((It) => {
      V(It.target, "data-row").each((An) => {
        const $t = Da(It.target, "top");
        zs(It.target, "top", $t + It.yDelta + "px");
      }), V(It.target, "data-column").each((An) => {
        const $t = Da(It.target, "left");
        zs(It.target, "left", $t + It.xDelta + "px");
      });
    });
    const K = (It, An) => {
      const $t = Da(It, An), Gn = is(It, "data-initial-" + An, 0);
      return $t - Gn;
    };
    A.events.stop.bind(() => {
      w.get().each((It) => {
        P.each((An) => {
          V(It, "data-row").each(($t) => {
            const Gn = K(It, "top");
            ea(It, "data-initial-top"), Tn.trigger.adjustHeight(An, Gn, parseInt($t, 10));
          }), V(It, "data-column").each(($t) => {
            const Gn = K(It, "left");
            ea(It, "data-initial-left"), Tn.trigger.adjustWidth(An, Gn, parseInt($t, 10));
          }), Xx(h, An);
        });
      });
    });
    const ie = (It, An) => {
      Tn.trigger.startAdjust(), w.assign(It), ia(It, "data-initial-" + An, Da(It, An)), ym(It, ug), zs(It, "opacity", "0.2"), A.go(h.parent());
    }, ve = L0(h.parent(), "mousedown", (It) => {
      jI(It.target) && ie(It.target, "top"), bv(It.target) && ie(It.target, "left");
    }), Ae = (It) => os(It, h.view()), Ue = (It) => ni(It, "table", Ae).filter(Wp), ct = L0(h.view(), "mouseover", (It) => {
      Ue(It.target).fold(() => {
        ca(It.target) && H0(h);
      }, (An) => {
        A.isActive() && (P = Ce.some(An), Xx(h, An));
      });
    }), Yt = () => {
      ve.unbind(), ct.unbind(), A.destroy(), H0(h);
    }, On = (It) => {
      Xx(h, It);
    }, Tn = Ub({
      adjustHeight: op([
        "table",
        "delta",
        "row"
      ]),
      adjustWidth: op([
        "table",
        "delta",
        "column"
      ]),
      startAdjust: op([])
    });
    return {
      destroy: Yt,
      refresh: On,
      on: A.on,
      off: A.off,
      hideBars: be(Jx, h),
      showBars: be(Wo, h),
      events: Tn.registry
    };
  }, tT = { create: (h, w, A) => {
    const P = Un, V = Ua, K = eT(h), ie = Ub({
      beforeResize: op([
        "table",
        "type"
      ]),
      afterResize: op([
        "table",
        "type"
      ]),
      startDrag: op([])
    });
    return K.events.adjustHeight.bind((ve) => {
      const Ae = ve.table;
      ie.trigger.beforeResize(Ae, "row");
      const Ue = P.delta(ve.delta, Ae);
      c0(Ae, Ue, ve.row, P), ie.trigger.afterResize(Ae, "row");
    }), K.events.startAdjust.bind((ve) => {
      ie.trigger.startDrag();
    }), K.events.adjustWidth.bind((ve) => {
      const Ae = ve.table;
      ie.trigger.beforeResize(Ae, "col");
      const Ue = V.delta(ve.delta, Ae), ct = A(Ae);
      Ab(Ae, Ue, ve.column, w, ct), ie.trigger.afterResize(Ae, "col");
    }), {
      on: K.on,
      off: K.off,
      refreshBars: K.refresh,
      hideBars: K.hideBars,
      showBars: K.showBars,
      destroy: K.destroy,
      events: ie.registry
    };
  } }, Y_ = {
    only: (h, w) => {
      const A = Pd(h) ? Hs(h) : h;
      return {
        parent: G(A),
        view: G(h),
        origin: G(Me(0, 0)),
        isResizable: w
      };
    },
    detached: (h, w, A) => {
      const P = () => Wn(w);
      return {
        parent: G(w),
        view: G(h),
        origin: P,
        isResizable: A
      };
    },
    body: (h, w, A) => ({
      parent: G(w),
      view: G(h),
      origin: G(Me(0, 0)),
      isResizable: A
    })
  }, qI = () => {
    const h = nt.fromTag("div");
    return Mi(h, {
      position: "static",
      height: "0",
      width: "0",
      padding: "0",
      margin: "0",
      border: "0"
    }), ss(as(), h), h;
  }, Q_ = (h, w) => h.inline ? Y_.body(nt.fromDom(h.getBody()), qI(), w) : Y_.only(nt.fromDom(h.getDoc()), w), GI = (h, w) => {
    h.inline && Ra(w.parent());
  }, yo = (h) => Z(h) && h.nodeName === "TABLE", $f = "bar-", Sv = (h) => Yu(h, "data-mce-resize") !== "false", ZI = (h) => {
    const w = ye.fromTable(h);
    ye.hasColumns(w) || Ne(Pc(h), (A) => {
      const P = hi(A, "width");
      zs(A, "width", P), ea(A, "width");
    });
  }, V0 = (h) => {
    const w = P0(), A = P0(), P = P0();
    let V, K;
    const ie = (It) => Cl(h, It), ve = () => zp(h) ? dw() : YC(), Ae = (It) => gb(It).columns, Ue = (It, An, $t) => {
      const Gn = Ru(An, "e");
      if (K === "" && Gd(It), $t !== V && K !== "") {
        zs(It, "width", K);
        const Or = ve(), jr = ie(It), da = zp(h) || Gn ? Ae(It) - 1 : 0;
        Ab(It, $t - V, da, Or, jr);
      } else if (V1(K)) {
        const Or = parseFloat(K.replace("%", "")), jr = $t * Or / V;
        zs(It, "width", jr + "%");
      }
      nb(K) && ZI(It);
    }, ct = () => {
      A.on((It) => {
        It.destroy();
      }), P.on((It) => {
        GI(h, It);
      });
    };
    return h.on("init", () => {
      const It = Q_(h, Sv);
      if (P.set(It), WC(h) && Zg(h)) {
        const An = ve(), $t = tT.create(It, An, ie);
        $t.on(), $t.events.startDrag.bind((Gn) => {
          w.set(h.selection.getRng());
        }), $t.events.beforeResize.bind((Gn) => {
          const Or = Gn.table.dom;
          Dw(h, Or, Vd(Or), jp(Or), $f + Gn.type);
        }), $t.events.afterResize.bind((Gn) => {
          const Or = Gn.table, jr = Or.dom;
          dm(Or), w.on((da) => {
            h.selection.setRng(da), h.focus();
          }), $w(h, jr, Vd(jr), jp(jr), $f + Gn.type), h.undoManager.add();
        }), A.set($t);
      }
    }), h.on("ObjectResizeStart", (It) => {
      const An = It.target;
      if (yo(An)) {
        const $t = nt.fromDom(An);
        Ne(h.dom.select(".mce-clonedresizable"), (Gn) => {
          h.dom.addClass(Gn, "mce-" + xy(h) + "-columns");
        }), !Db($t) && Vp(h) ? $b($t) : !Pb($t) && Sf(h) && Gd($t), b0($t) && Nu(It.origin, $f) && Gd($t), V = It.width, K = Up(h) ? "" : ow(h, An).getOr("");
      }
    }), h.on("ObjectResized", (It) => {
      const An = It.target;
      if (yo(An)) {
        const $t = nt.fromDom(An), Gn = It.origin;
        Nu(Gn, "corner-") && Ue($t, Gn, It.width), dm($t), cv(h, $t.dom, sh);
      }
    }), h.on("SwitchMode", () => {
      A.on((It) => {
        h.mode.isReadOnly() ? It.hideBars() : It.showBars();
      });
    }), h.on("dragstart dragend", (It) => {
      A.on((An) => {
        It.type === "dragstart" ? (An.hideBars(), An.off()) : (An.on(), An.showBars());
      });
    }), h.on("remove", () => {
      ct();
    }), {
      refresh: (It) => {
        A.on((An) => An.refreshBars(nt.fromDom(It)));
      },
      hide: () => {
        A.on((It) => It.hideBars());
      },
      show: () => {
        A.on((It) => It.showBars());
      }
    };
  }, Po = (h) => {
    Gg(h);
    const w = V0(h), A = j_(h, w), P = h0(h, w, A);
    return og(h, P), S_(h, P), ZC(h, P), {
      getSelectedCells: A.getSelectedCells,
      clearSelectedCells: A.clearSelectedCells
    };
  }, KI = (h) => ({ table: Po(h) });
  var X_ = () => {
    r.add("dom", KI);
  };
  X_();
})();
(function() {
  const r = Object.getPrototypeOf, o = (t, a, u) => {
    var p;
    return u(t, a.prototype) ? !0 : ((p = t.constructor) === null || p === void 0 ? void 0 : p.name) === a.name;
  }, c = (t) => {
    const a = typeof t;
    return t === null ? "null" : a === "object" && Array.isArray(t) ? "array" : a === "object" && o(t, String, (u, p) => p.isPrototypeOf(u)) ? "string" : a;
  }, i = (t) => (a) => c(a) === t, d = (t) => (a) => typeof a === t, m = (t) => (a) => t === a, v = (t, a) => C(t) && o(t, a, (u, p) => r(u) === p), g = i("string"), C = i("object"), O = (t) => v(t, Object), R = i("array"), I = m(null), L = d("boolean"), Z = m(void 0), ne = (t) => t == null, se = (t) => !ne(t), Q = d("function"), he = d("number"), ue = (t, a) => {
    if (R(t)) {
      for (let u = 0, p = t.length; u < p; ++u)
        if (!a(t[u]))
          return !1;
      return !0;
    }
    return !1;
  }, G = () => {
  }, me = (t) => () => t(), we = (t, a) => (...u) => t(a.apply(null, u)), be = (t, a) => (u) => t(a(u)), q = (t) => () => t, Te = (t) => t, Le = (t, a) => t === a;
  function je(t, ...a) {
    return (...u) => {
      const p = a.concat(u);
      return t.apply(null, p);
    };
  }
  const Ie = (t) => (a) => !t(a), Ce = (t) => () => {
    throw new Error(t);
  }, pt = (t) => t(), sn = q(!1), Lt = q(!0);
  class z {
    constructor(a, u) {
      this.tag = a, this.value = u;
    }
    static some(a) {
      return new z(!0, a);
    }
    static none() {
      return z.singletonNone;
    }
    fold(a, u) {
      return this.tag ? u(this.value) : a();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(a) {
      return this.tag ? z.some(a(this.value)) : z.none();
    }
    bind(a) {
      return this.tag ? a(this.value) : z.none();
    }
    exists(a) {
      return this.tag && a(this.value);
    }
    forall(a) {
      return !this.tag || a(this.value);
    }
    filter(a) {
      return !this.tag || a(this.value) ? this : z.none();
    }
    getOr(a) {
      return this.tag ? this.value : a;
    }
    or(a) {
      return this.tag ? this : a;
    }
    getOrThunk(a) {
      return this.tag ? this.value : a();
    }
    orThunk(a) {
      return this.tag ? this : a();
    }
    getOrDie(a) {
      if (this.tag)
        return this.value;
      throw new Error(a ?? "Called getOrDie on None");
    }
    static from(a) {
      return se(a) ? z.some(a) : z.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(a) {
      this.tag && a(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  z.singletonNone = new z(!1);
  const bt = Array.prototype.slice, at = Array.prototype.indexOf, _n = Array.prototype.push, st = (t, a) => at.call(t, a), Ne = (t, a) => {
    const u = st(t, a);
    return u === -1 ? z.none() : z.some(u);
  }, vt = (t, a) => st(t, a) > -1, Gt = (t, a) => {
    for (let u = 0, p = t.length; u < p; u++) {
      const y = t[u];
      if (a(y, u))
        return !0;
    }
    return !1;
  }, xt = (t, a) => {
    const u = [];
    for (let p = 0; p < t; p++)
      u.push(a(p));
    return u;
  }, cn = (t, a) => {
    const u = [];
    for (let p = 0; p < t.length; p += a) {
      const y = bt.call(t, p, p + a);
      u.push(y);
    }
    return u;
  }, He = (t, a) => {
    const u = t.length, p = new Array(u);
    for (let y = 0; y < u; y++) {
      const x = t[y];
      p[y] = a(x, y);
    }
    return p;
  }, ut = (t, a) => {
    for (let u = 0, p = t.length; u < p; u++) {
      const y = t[u];
      a(y, u);
    }
  }, oe = (t, a) => {
    for (let u = t.length - 1; u >= 0; u--) {
      const p = t[u];
      a(p, u);
    }
  }, qn = (t, a) => {
    const u = [], p = [];
    for (let y = 0, x = t.length; y < x; y++) {
      const k = t[y];
      (a(k, y) ? u : p).push(k);
    }
    return {
      pass: u,
      fail: p
    };
  }, Rn = (t, a) => {
    const u = [];
    for (let p = 0, y = t.length; p < y; p++) {
      const x = t[p];
      a(x, p) && u.push(x);
    }
    return u;
  }, Zt = (t, a, u) => (oe(t, (p, y) => {
    u = a(u, p, y);
  }), u), Jt = (t, a, u) => (ut(t, (p, y) => {
    u = a(u, p, y);
  }), u), wo = (t, a, u) => {
    for (let p = 0, y = t.length; p < y; p++) {
      const x = t[p];
      if (a(x, p))
        return z.some(x);
      if (u(x, p))
        break;
    }
    return z.none();
  }, Ge = (t, a) => wo(t, a, sn), qt = (t, a) => {
    for (let u = 0, p = t.length; u < p; u++) {
      const y = t[u];
      if (a(y, u))
        return z.some(u);
    }
    return z.none();
  }, St = (t) => {
    const a = [];
    for (let u = 0, p = t.length; u < p; ++u) {
      if (!R(t[u]))
        throw new Error("Arr.flatten item " + u + " was not an array, input: " + t);
      _n.apply(a, t[u]);
    }
    return a;
  }, ke = (t, a) => St(He(t, a)), Ct = (t, a) => {
    for (let u = 0, p = t.length; u < p; ++u) {
      const y = t[u];
      if (a(y, u) !== !0)
        return !1;
    }
    return !0;
  }, an = (t) => {
    const a = bt.call(t, 0);
    return a.reverse(), a;
  }, ht = (t, a) => Rn(t, (u) => !vt(a, u)), bn = (t, a) => {
    const u = {};
    for (let p = 0, y = t.length; p < y; p++) {
      const x = t[p];
      u[String(x)] = a(x, p);
    }
    return u;
  }, Ye = (t) => [t], nn = (t, a) => {
    const u = bt.call(t, 0);
    return u.sort(a), u;
  }, Bt = (t, a) => a >= 0 && a < t.length ? z.some(t[a]) : z.none(), $n = (t) => Bt(t, 0), mr = (t) => Bt(t, t.length - 1), gr = Q(Array.from) ? Array.from : (t) => bt.call(t), Vr = (t, a) => {
    for (let u = 0; u < t.length; u++) {
      const p = a(t[u], u);
      if (p.isSome())
        return p;
    }
    return z.none();
  }, Xr = Object.keys, pc = Object.hasOwnProperty, Eo = (t, a) => {
    const u = Xr(t);
    for (let p = 0, y = u.length; p < y; p++) {
      const x = u[p], k = t[x];
      a(k, x);
    }
  }, uo = (t, a) => Es(t, (u, p) => ({
    k: p,
    v: a(u, p)
  })), Es = (t, a) => {
    const u = {};
    return Eo(t, (p, y) => {
      const x = a(p, y);
      u[x.k] = x.v;
    }), u;
  }, br = (t) => (a, u) => {
    t[u] = a;
  }, hs = (t, a, u, p) => {
    Eo(t, (y, x) => {
      (a(y, x) ? u : p)(y, x);
    });
  }, Ps = (t, a) => {
    const u = {}, p = {};
    return hs(t, a, br(u), br(p)), {
      t: u,
      f: p
    };
  }, qo = (t, a) => {
    const u = {};
    return hs(t, a, br(u), G), u;
  }, hc = (t, a) => {
    const u = [];
    return Eo(t, (p, y) => {
      u.push(a(p, y));
    }), u;
  }, Co = (t, a) => {
    const u = Xr(t);
    for (let p = 0, y = u.length; p < y; p++) {
      const x = u[p], k = t[x];
      if (a(k, x, t))
        return z.some(k);
    }
    return z.none();
  }, fl = (t) => hc(t, Te), fn = (t, a) => Yr(t, a) ? z.from(t[a]) : z.none(), Yr = (t, a) => pc.call(t, a), xa = (t, a) => Yr(t, a) && t[a] !== void 0 && t[a] !== null, $i = (t, a, u = Le) => t.exists((p) => u(p, a)), Kc = (t, a, u = Le) => gc(t, a, u).getOr(t.isNone() && a.isNone()), wi = (t) => {
    const a = [], u = (p) => {
      a.push(p);
    };
    for (let p = 0; p < t.length; p++)
      t[p].each(u);
    return a;
  }, es = (t) => {
    const a = [];
    for (let u = 0; u < t.length; u++) {
      const p = t[u];
      if (p.isSome())
        a.push(p.getOrDie());
      else
        return z.none();
    }
    return z.some(a);
  }, gc = (t, a, u) => t.isSome() && a.isSome() ? z.some(u(t.getOrDie(), a.getOrDie())) : z.none(), Xl = (t, a, u, p) => t.isSome() && a.isSome() && u.isSome() ? z.some(p(t.getOrDie(), a.getOrDie(), u.getOrDie())) : z.none(), gs = (t, a) => t != null ? z.some(a(t)) : z.none(), lr = (t, a) => t ? z.some(a) : z.none(), Ei = (t, a) => t + a, Jl = (t, a) => t.substring(a), Pd = (t, a, u) => a === "" || t.length >= a.length && t.substr(u, u + a.length) === a, Xf = (t, a) => ia(t, a) ? Jl(t, a.length) : t, Qa = (t, a) => Nl(t, a) ? t : Ei(t, a), Xa = (t, a, u = 0, p) => {
    const y = t.indexOf(a, u);
    return y !== -1 ? Z(p) ? !0 : y + a.length <= p : !1;
  }, ia = (t, a) => Pd(t, a, 0), Nl = (t, a) => Pd(t, a, t.length - a.length), Yu = ((t) => (a) => a.replace(t, ""))(/^\s+|\s+$/g), vc = (t) => t.length > 0, ea = (t) => !vc(t), bc = (t) => t.style !== void 0 && Q(t.style.getPropertyValue), Qu = (t, a) => {
    const p = (a || document).createElement("div");
    if (p.innerHTML = t, !p.hasChildNodes() || p.childNodes.length > 1) {
      const y = "HTML does not have a single root node";
      throw console.error(y, t), new Error(y);
    }
    return Ou(p.childNodes[0]);
  }, wp = (t, a) => {
    const p = (a || document).createElement(t);
    return Ou(p);
  }, of = (t, a) => {
    const p = (a || document).createTextNode(t);
    return Ou(p);
  }, Ou = (t) => {
    if (t == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: t };
  }, nt = {
    fromHtml: Qu,
    fromTag: wp,
    fromText: of,
    fromDom: Ou,
    fromPoint: (t, a, u) => z.from(t.dom.elementFromPoint(a, u)).map(Ou)
  }, Ja = typeof window < "u" ? window : Function("return this;")(), eu = (t, a) => {
    let u = a ?? Ja;
    for (let p = 0; p < t.length && u !== void 0 && u !== null; ++p)
      u = u[t[p]];
    return u;
  }, Ep = (t, a) => {
    const u = t.split(".");
    return eu(u, a);
  }, Jf = (t, a) => Ep(t, a), os = (t, a) => {
    const u = Jf(t, a);
    if (u == null)
      throw new Error(t + " not available on this browser");
    return u;
  }, Cp = Object.getPrototypeOf, Am = (t) => os("HTMLElement", t), tu = (t) => {
    const a = Ep("ownerDocument.defaultView", t);
    return C(t) && (Am(a).prototype.isPrototypeOf(t) || /^HTML\w*Element$/.test(Cp(t).constructor.name));
  }, em = 9, Hs = 11, Gs = 1, Ac = 3, kc = (t) => t.dom.nodeName.toLowerCase(), Xu = (t) => t.dom.nodeType, Ju = (t) => (a) => Xu(a) === t, ed = (t) => $o(t) && tu(t.dom), $o = Ju(Gs), ei = Ju(Ac), Rl = Ju(em), td = Ju(Hs), Xi = (t) => (a) => $o(a) && kc(a) === t, Zs = (t, a) => {
    const u = t.dom;
    if (u.nodeType !== Gs)
      return !1;
    {
      const p = u;
      if (p.matches !== void 0)
        return p.matches(a);
      if (p.msMatchesSelector !== void 0)
        return p.msMatchesSelector(a);
      if (p.webkitMatchesSelector !== void 0)
        return p.webkitMatchesSelector(a);
      if (p.mozMatchesSelector !== void 0)
        return p.mozMatchesSelector(a);
      throw new Error("Browser lacks native selectors");
    }
  }, ss = (t) => t.nodeType !== Gs && t.nodeType !== em && t.nodeType !== Hs || t.childElementCount === 0, yc = (t, a) => {
    const u = a === void 0 ? document : a.dom;
    return ss(u) ? [] : He(u.querySelectorAll(t), nt.fromDom);
  }, tm = (t, a) => {
    const u = a === void 0 ? document : a.dom;
    return ss(u) ? z.none() : z.from(u.querySelector(t)).map(nt.fromDom);
  }, Io = (t, a) => t.dom === a.dom, za = (t, a) => {
    const u = t.dom, p = a.dom;
    return u === p ? !1 : u.contains(p);
  }, ti = (t) => nt.fromDom(t.dom.ownerDocument), Ra = (t) => Rl(t) ? t : ti(t), Pl = (t) => nt.fromDom(Ra(t).dom.documentElement), nu = (t) => nt.fromDom(Ra(t).dom.defaultView), Ii = (t) => z.from(t.dom.parentNode).map(nt.fromDom), Dl = (t) => Ii(t), $l = (t) => z.from(t.dom.parentElement).map(nt.fromDom), km = (t, a) => {
    const u = Q(a) ? a : sn;
    let p = t.dom;
    const y = [];
    for (; p.parentNode !== null && p.parentNode !== void 0; ) {
      const x = p.parentNode, k = nt.fromDom(x);
      if (y.push(k), u(k) === !0)
        break;
      p = x;
    }
    return y;
  }, Il = (t) => z.from(t.dom.offsetParent).map(nt.fromDom), xp = (t) => z.from(t.dom.nextSibling).map(nt.fromDom), Nc = (t) => He(t.dom.childNodes, nt.fromDom), ku = (t, a) => {
    const u = t.dom.childNodes;
    return z.from(u[a]).map(nt.fromDom);
  }, sf = (t) => ku(t, 0), Nm = (t, a) => ({
    element: t,
    offset: a
  }), Tp = (t, a) => {
    const u = Nc(t);
    return u.length > 0 && a < u.length ? Nm(u[a], 0) : Nm(t, a);
  }, Se = (t) => td(t) && se(t.dom.host), Ve = Q(Element.prototype.attachShadow) && Q(Node.prototype.getRootNode), tt = q(Ve), wt = Ve ? (t) => nt.fromDom(t.dom.getRootNode()) : Ra, en = (t) => Se(t) ? t : nt.fromDom(Ra(t).dom.body), ur = (t) => Yo(t).isSome(), Yo = (t) => {
    const a = wt(t);
    return Se(a) ? z.some(a) : z.none();
  }, Lr = (t) => nt.fromDom(t.dom.host), Nr = (t) => {
    if (tt() && se(t.target)) {
      const a = nt.fromDom(t.target);
      if ($o(a) && Ks(a) && t.composed && t.composedPath) {
        const u = t.composedPath();
        if (u)
          return $n(u);
      }
    }
    return z.from(t.target);
  }, Ks = (t) => se(t.dom.shadowRoot), fo = (t) => {
    const a = ei(t) ? t.dom.parentNode : t.dom;
    if (a == null || a.ownerDocument === null)
      return !1;
    const u = a.ownerDocument;
    return Yo(nt.fromDom(a)).fold(() => u.body.contains(a), be(fo, Lr));
  }, ta = () => Yc(nt.fromDom(document)), Yc = (t) => {
    const a = t.dom.body;
    if (a == null)
      throw new Error("Body is not available yet");
    return nt.fromDom(a);
  }, Rm = (t, a, u) => {
    if (g(u) || L(u) || he(u))
      t.setAttribute(a, u + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", a, ":: Value ", u, ":: Element ", t), new Error("Attribute value was not simple");
  }, kn = (t, a, u) => {
    Rm(t.dom, a, u);
  }, Pm = (t, a) => {
    const u = t.dom;
    Eo(a, (p, y) => {
      Rm(u, y, p);
    });
  }, ca = (t, a) => {
    const u = t.dom.getAttribute(a);
    return u === null ? void 0 : u;
  }, as = (t, a) => z.from(ca(t, a)), _p = (t, a) => {
    const u = t.dom;
    return u && u.hasAttribute ? u.hasAttribute(a) : !1;
  }, vs = (t, a) => {
    t.dom.removeAttribute(a);
  }, Wv = (t) => Jt(t.dom.attributes, (a, u) => (a[u.name] = u.value, a), {}), Va = (t, a, u) => {
    if (!g(u))
      throw console.error("Invalid call to CSS.set. Property ", a, ":: Value ", u, ":: Element ", t), new Error("CSS value must be a string: " + u);
    bc(t) && t.style.setProperty(a, u);
  }, Sc = (t, a) => {
    bc(t) && t.style.removeProperty(a);
  }, Sr = (t, a, u) => {
    const p = t.dom;
    Va(p, a, u);
  }, Rc = (t, a) => {
    const u = t.dom;
    Eo(a, (p, y) => {
      Va(u, y, p);
    });
  }, rn = (t, a) => {
    const u = t.dom;
    Eo(a, (p, y) => {
      p.fold(() => {
        Sc(u, y);
      }, (x) => {
        Va(u, y, x);
      });
    });
  }, na = (t, a) => {
    const u = t.dom, y = window.getComputedStyle(u).getPropertyValue(a);
    return y === "" && !fo(t) ? Dm(u, a) : y;
  }, Dm = (t, a) => bc(t) ? t.style.getPropertyValue(a) : "", Ta = (t, a) => {
    const u = t.dom, p = Dm(u, a);
    return z.from(p).filter((y) => y.length > 0);
  }, bs = (t) => {
    const a = {}, u = t.dom;
    if (bc(u))
      for (let p = 0; p < u.style.length; p++) {
        const y = u.style.item(p);
        a[y] = u.style[y];
      }
    return a;
  }, Dd = (t, a, u) => {
    const p = nt.fromTag(t);
    return Sr(p, a, u), Ta(p, a).isSome();
  }, Ur = (t, a) => {
    const u = t.dom;
    Sc(u, a), $i(as(t, "style").map(Yu), "") && vs(t, "style");
  }, Qc = (t) => t.dom.offsetWidth, ni = (t, a) => {
    const u = ($, B) => {
      if (!he(B) && !B.match(/^[0-9]+$/))
        throw new Error(t + ".set accepts only positive integer values. Value was " + B);
      const j = $.dom;
      bc(j) && (j.style[t] = B + "px");
    }, p = ($) => {
      const B = a($);
      if (B <= 0 || B === null) {
        const j = na($, t);
        return parseFloat(j) || 0;
      }
      return B;
    }, y = p, x = ($, B) => Jt(B, (j, Y) => {
      const re = na($, Y), le = re === void 0 ? 0 : parseInt(re, 10);
      return isNaN(le) ? j : j + le;
    }, 0);
    return {
      set: u,
      get: p,
      getOuter: y,
      aggregate: x,
      max: ($, B, j) => {
        const Y = x($, j);
        return B > Y ? B - Y : 0;
      }
    };
  }, Xc = ni("height", (t) => {
    const a = t.dom;
    return fo(t) ? a.getBoundingClientRect().height : a.offsetHeight;
  }), Ds = (t) => Xc.get(t), af = (t) => Xc.getOuter(t), _a = (t, a) => {
    const u = [
      "margin-top",
      "border-top-width",
      "padding-top",
      "padding-bottom",
      "border-bottom-width",
      "margin-bottom"
    ], p = Xc.max(t, a, u);
    Sr(t, "max-height", p + "px");
  }, $d = (t, a) => ({
    left: t,
    top: a,
    translate: (p, y) => $d(t + p, a + y)
  }), Oo = $d, Nu = (t) => {
    const a = t.getBoundingClientRect();
    return Oo(a.left, a.top);
  }, Ru = (t, a) => t !== void 0 ? t : a !== void 0 ? a : 0, Jc = (t) => {
    const a = t.dom.ownerDocument, u = a.body, p = a.defaultView, y = a.documentElement;
    if (u === t.dom)
      return Oo(u.offsetLeft, u.offsetTop);
    const x = Ru(p == null ? void 0 : p.pageYOffset, y.scrollTop), k = Ru(p == null ? void 0 : p.pageXOffset, y.scrollLeft), $ = Ru(y.clientTop, u.clientTop), B = Ru(y.clientLeft, u.clientLeft);
    return Ml(t).translate(k - B, x - $);
  }, Ml = (t) => {
    const a = t.dom, p = a.ownerDocument.body;
    return p === a ? Oo(p.offsetLeft, p.offsetTop) : fo(t) ? Nu(a) : Oo(0, 0);
  }, Op = ni("width", (t) => t.dom.offsetWidth), no = (t, a) => Op.set(t, a), Oa = (t) => Op.get(t), Pa = (t) => Op.getOuter(t), jv = (t, a) => {
    const u = [
      "margin-left",
      "border-left-width",
      "padding-left",
      "padding-right",
      "border-right-width",
      "margin-right"
    ], p = Op.max(t, a, u);
    Sr(t, "max-width", p + "px");
  }, zs = (t) => {
    let a = !1, u;
    return (...p) => (a || (a = !0, u = t.apply(null, p)), u);
  }, Mi = (t, a, u, p) => {
    const y = t.isiOS() && /ipad/i.test(u) === !0, x = t.isiOS() && !y, k = t.isiOS() || t.isAndroid(), $ = k || p("(pointer:coarse)"), B = y || !x && k && p("(min-device-width:768px)"), j = x || k && !B, Y = a.isSafari() && t.isiOS() && /safari/i.test(u) === !1, re = !j && !B && !Y;
    return {
      isiPad: q(y),
      isiPhone: q(x),
      isTablet: q(B),
      isPhone: q(j),
      isTouch: q($),
      isAndroid: t.isAndroid,
      isiOS: t.isiOS,
      isWebView: q(Y),
      isDesktop: q(re)
    };
  }, hi = (t, a) => {
    for (let u = 0; u < t.length; u++) {
      const p = t[u];
      if (p.test(a))
        return p;
    }
  }, Fh = (t, a) => {
    const u = hi(t, a);
    if (!u)
      return {
        major: 0,
        minor: 0
      };
    const p = (y) => Number(a.replace(u, "$" + y));
    return $m(p(1), p(2));
  }, Lh = (t, a) => {
    const u = String(a).toLowerCase();
    return t.length === 0 ? Fl() : Fh(t, u);
  }, Fl = () => $m(0, 0), $m = (t, a) => ({
    major: t,
    minor: a
  }), is = {
    nu: $m,
    detect: Lh,
    unknown: Fl
  }, ru = (t, a) => Vr(a.brands, (u) => {
    const p = u.brand.toLowerCase();
    return Ge(t, (y) => {
      var x;
      return p === ((x = y.brand) === null || x === void 0 ? void 0 : x.toLowerCase());
    }).map((y) => ({
      current: y.name,
      version: is.nu(parseInt(u.version, 10), 0)
    }));
  }), Ji = (t, a) => {
    const u = String(a).toLowerCase();
    return Ge(t, (p) => p.search(u));
  }, ri = (t, a) => Ji(t, a).map((u) => {
    const p = is.detect(u.versionRegexes, a);
    return {
      current: u.name,
      version: p
    };
  }), Da = (t, a) => Ji(t, a).map((u) => {
    const p = is.detect(u.versionRegexes, a);
    return {
      current: u.name,
      version: p
    };
  }), Vs = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/, Ll = (t) => (a) => Xa(a, t), cf = [
    {
      name: "Edge",
      versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
      search: (t) => Xa(t, "edge/") && Xa(t, "chrome") && Xa(t, "safari") && Xa(t, "applewebkit")
    },
    {
      name: "Chromium",
      brand: "Chromium",
      versionRegexes: [
        /.*?chrome\/([0-9]+)\.([0-9]+).*/,
        Vs
      ],
      search: (t) => Xa(t, "chrome") && !Xa(t, "chromeframe")
    },
    {
      name: "IE",
      versionRegexes: [
        /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
        /.*?rv:([0-9]+)\.([0-9]+).*/
      ],
      search: (t) => Xa(t, "msie") || Xa(t, "trident")
    },
    {
      name: "Opera",
      versionRegexes: [
        Vs,
        /.*?opera\/([0-9]+)\.([0-9]+).*/
      ],
      search: Ll("opera")
    },
    {
      name: "Firefox",
      versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
      search: Ll("firefox")
    },
    {
      name: "Safari",
      versionRegexes: [
        Vs,
        /.*?cpu os ([0-9]+)_([0-9]+).*/
      ],
      search: (t) => (Xa(t, "safari") || Xa(t, "mobile/")) && Xa(t, "applewebkit")
    }
  ], nm = [
    {
      name: "Windows",
      search: Ll("win"),
      versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
    },
    {
      name: "iOS",
      search: (t) => Xa(t, "iphone") || Xa(t, "ipad"),
      versionRegexes: [
        /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
        /.*cpu os ([0-9]+)_([0-9]+).*/,
        /.*cpu iphone os ([0-9]+)_([0-9]+).*/
      ]
    },
    {
      name: "Android",
      search: Ll("android"),
      versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
    },
    {
      name: "macOS",
      search: Ll("mac os x"),
      versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
    },
    {
      name: "Linux",
      search: Ll("linux"),
      versionRegexes: []
    },
    {
      name: "Solaris",
      search: Ll("sunos"),
      versionRegexes: []
    },
    {
      name: "FreeBSD",
      search: Ll("freebsd"),
      versionRegexes: []
    },
    {
      name: "ChromeOS",
      search: Ll("cros"),
      versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
    }
  ], Bh = {
    browsers: q(cf),
    oses: q(nm)
  }, Ap = "Edge", Pc = "Chromium", kp = "IE", gi = "Opera", Pu = "Firefox", Np = "Safari", nd = () => Im({
    current: void 0,
    version: is.unknown()
  }), Im = (t) => {
    const a = t.current, u = t.version, p = (y) => () => a === y;
    return {
      current: a,
      version: u,
      isEdge: p(Ap),
      isChromium: p(Pc),
      isIE: p(kp),
      isOpera: p(gi),
      isFirefox: p(Pu),
      isSafari: p(Np)
    };
  }, wc = {
    unknown: nd,
    nu: Im,
    edge: q(Ap),
    chromium: q(Pc),
    ie: q(kp),
    opera: q(gi),
    firefox: q(Pu),
    safari: q(Np)
  }, Mm = "Windows", Id = "iOS", Ig = "Android", Mg = "Linux", lf = "macOS", Ec = "Solaris", Fg = "FreeBSD", Fe = "ChromeOS", uf = () => Bl({
    current: void 0,
    version: is.unknown()
  }), Bl = (t) => {
    const a = t.current, u = t.version, p = (y) => () => a === y;
    return {
      current: a,
      version: u,
      isWindows: p(Mm),
      isiOS: p(Id),
      isAndroid: p(Ig),
      isMacOS: p(lf),
      isLinux: p(Mg),
      isSolaris: p(Ec),
      isFreeBSD: p(Fg),
      isChromeOS: p(Fe)
    };
  }, Fm = {
    unknown: uf,
    nu: Bl,
    windows: q(Mm),
    ios: q(Id),
    android: q(Ig),
    linux: q(Mg),
    macos: q(lf),
    solaris: q(Ec),
    freebsd: q(Fg),
    chromeos: q(Fe)
  }, Lm = { detect: (t, a, u) => {
    const p = Bh.browsers(), y = Bh.oses(), x = a.bind((B) => ru(p, B)).orThunk(() => ri(p, t)).fold(wc.unknown, wc.nu), k = Da(y, t).fold(Fm.unknown, Fm.nu), $ = Mi(k, x, t, u);
    return {
      browser: x,
      os: k,
      deviceType: $
    };
  } }, Je = (t) => window.matchMedia(t).matches;
  let Wt = zs(() => Lm.detect(navigator.userAgent, z.from(navigator.userAgentData), Je));
  const Ft = () => Wt(), er = (t, a, u, p, y, x, k) => ({
    target: t,
    x: a,
    y: u,
    stop: p,
    prevent: y,
    kill: x,
    raw: k
  }), Qr = (t) => {
    const a = nt.fromDom(Nr(t).getOr(t.target)), u = () => t.stopPropagation(), p = () => t.preventDefault(), y = we(p, u);
    return er(a, t.clientX, t.clientY, u, p, y, t);
  }, No = (t, a) => (u) => {
    t(u) && a(Qr(u));
  }, Qo = (t, a, u, p, y) => {
    const x = No(u, p);
    return t.dom.addEventListener(a, x, y), { unbind: je(qv, t, a, x, y) };
  }, Xo = (t, a, u, p) => Qo(t, a, u, p, !1), Rp = (t, a, u, p) => Qo(t, a, u, p, !0), qv = (t, a, u, p) => {
    t.dom.removeEventListener(a, u, p);
  }, $a = (t, a) => {
    Ii(t).each((p) => {
      p.dom.insertBefore(a.dom, t.dom);
    });
  }, Hl = (t, a) => {
    xp(t).fold(() => {
      Ii(t).each((y) => {
        oi(y, a);
      });
    }, (p) => {
      $a(p, a);
    });
  }, Bg = (t, a) => {
    sf(t).fold(() => {
      oi(t, a);
    }, (p) => {
      t.dom.insertBefore(a.dom, p.dom);
    });
  }, oi = (t, a) => {
    t.dom.appendChild(a.dom);
  }, ga = (t, a, u) => {
    ku(t, u).fold(() => {
      oi(t, a);
    }, (p) => {
      $a(p, a);
    });
  }, Du = (t, a) => {
    ut(a, (u) => {
      oi(t, u);
    });
  }, ys = (t) => {
    t.dom.textContent = "", ut(Nc(t), (a) => {
      ou(a);
    });
  }, ou = (t) => {
    const a = t.dom;
    a.parentNode !== null && a.parentNode.removeChild(a);
  }, ec = (t) => {
    const a = t !== void 0 ? t.dom : document, u = a.body.scrollLeft || a.documentElement.scrollLeft, p = a.body.scrollTop || a.documentElement.scrollTop;
    return Oo(u, p);
  }, Bm = (t, a, u) => {
    const y = (u !== void 0 ? u.dom : document).defaultView;
    y && y.scrollTo(t, a);
  }, Gv = (t) => {
    const a = t === void 0 ? window : t;
    return Ft().browser.isFirefox() ? z.none() : z.from(a.visualViewport);
  }, Pp = (t, a, u, p) => ({
    x: t,
    y: a,
    width: u,
    height: p,
    right: t + u,
    bottom: a + p
  }), Hh = (t) => {
    const a = t === void 0 ? window : t, u = a.document, p = ec(nt.fromDom(u));
    return Gv(a).fold(() => {
      const y = a.document.documentElement, x = y.clientWidth, k = y.clientHeight;
      return Pp(p.left, p.top, x, k);
    }, (y) => Pp(Math.max(y.pageLeft, p.left), Math.max(y.pageTop, p.top), y.width, y.height));
  }, Md = () => nt.fromDom(document), Cc = (t, a) => t.view(a).fold(q([]), (p) => {
    const y = t.owner(p), x = Cc(t, y);
    return [p].concat(x);
  }), Dp = (t, a) => {
    const u = a.owner(t), p = Cc(a, u);
    return z.some(p);
  };
  var zh = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    view: (t) => {
      var a;
      return (t.dom === document ? z.none() : z.from((a = t.dom.defaultView) === null || a === void 0 ? void 0 : a.frameElement)).map(nt.fromDom);
    },
    owner: (t) => ti(t)
  });
  const df = (t) => {
    const a = Md(), u = ec(a);
    return Dp(t, zh).fold(je(Jc, t), (y) => {
      const x = Ml(t), k = Zt(y, ($, B) => {
        const j = Ml(B);
        return {
          left: $.left + j.left,
          top: $.top + j.top
        };
      }, {
        left: 0,
        top: 0
      });
      return Oo(k.left + x.left + u.left, k.top + x.top + u.top);
    });
  }, ff = (t, a, u) => ({
    point: t,
    width: a,
    height: u
  }), rm = (t, a, u, p) => ({
    x: t,
    y: a,
    width: u,
    height: p
  }), cs = (t, a, u, p) => ({
    x: t,
    y: a,
    width: u,
    height: p,
    right: t + u,
    bottom: a + p
  }), Ss = (t) => {
    const a = Jc(t), u = Pa(t), p = af(t);
    return cs(a.left, a.top, u, p);
  }, Fi = (t) => {
    const a = df(t), u = Pa(t), p = af(t);
    return cs(a.left, a.top, u, p);
  }, Hg = (t, a) => {
    const u = Math.max(t.x, a.x), p = Math.max(t.y, a.y), y = Math.min(t.right, a.right), x = Math.min(t.bottom, a.bottom), k = y - u, $ = x - p;
    return cs(u, p, k, $);
  }, Zv = (t, a) => Jt(a, (u, p) => Hg(u, p), t), Ci = () => Hh(window);
  var su = tinymce.util.Tools.resolve("tinymce.ThemeManager");
  const Li = (t) => {
    const a = (x) => x(t), u = q(t), p = () => y, y = {
      tag: !0,
      inner: t,
      fold: (x, k) => k(t),
      isValue: Lt,
      isError: sn,
      map: (x) => Rr.value(x(t)),
      mapError: p,
      bind: a,
      exists: a,
      forall: a,
      getOr: u,
      or: p,
      getOrThunk: u,
      orThunk: p,
      getOrDie: u,
      each: (x) => {
        x(t);
      },
      toOptional: () => z.some(t)
    };
    return y;
  }, au = (t) => {
    const a = () => u, u = {
      tag: !1,
      inner: t,
      fold: (p, y) => p(t),
      isValue: sn,
      isError: Lt,
      map: a,
      mapError: (p) => Rr.error(p(t)),
      bind: a,
      exists: sn,
      forall: Lt,
      getOr: Te,
      or: Te,
      getOrThunk: pt,
      orThunk: pt,
      getOrDie: Ce(String(t)),
      each: G,
      toOptional: z.none
    };
    return u;
  }, Rr = {
    value: Li,
    error: au,
    fromOption: (t, a) => t.fold(() => au(a), Li)
  };
  var el;
  (function(t) {
    t[t.Error = 0] = "Error", t[t.Value = 1] = "Value";
  })(el || (el = {}));
  const mf = (t, a, u) => t.stype === el.Error ? a(t.serror) : u(t.svalue), Ia = (t) => {
    const a = [], u = [];
    return ut(t, (p) => {
      mf(p, (y) => u.push(y), (y) => a.push(y));
    }), {
      values: a,
      errors: u
    };
  }, Bi = (t, a) => t.stype === el.Error ? {
    stype: el.Error,
    serror: a(t.serror)
  } : t, Kv = (t, a) => t.stype === el.Value ? {
    stype: el.Value,
    svalue: a(t.svalue)
  } : t, Hi = (t, a) => t.stype === el.Value ? a(t.svalue) : t, va = (t, a) => t.stype === el.Error ? a(t.serror) : t, ml = (t) => ({
    stype: el.Value,
    svalue: t
  }), Aa = (t) => ({
    stype: el.Error,
    serror: t
  }), $s = {
    fromResult: (t) => t.fold(Aa, ml),
    toResult: (t) => mf(t, Rr.error, Rr.value),
    svalue: ml,
    partition: Ia,
    serror: Aa,
    bind: Hi,
    bindError: va,
    map: Kv,
    mapError: Bi,
    fold: mf
  }, ba = (t, a, u, p) => ({
    tag: "field",
    key: t,
    newKey: a,
    presence: u,
    prop: p
  }), tl = (t, a) => ({
    tag: "custom",
    newKey: t,
    instantiator: a
  }), od = (t, a, u) => {
    switch (t.tag) {
      case "field":
        return a(t.key, t.newKey, t.presence, t.prop);
      case "custom":
        return u(t.newKey, t.instantiator);
    }
  }, Ys = (t, a) => a, zg = (t, a) => O(t) && O(a) ? Vo(t, a) : a, Yv = (t) => (...a) => {
    if (a.length === 0)
      throw new Error("Can't merge zero objects");
    const u = {};
    for (let p = 0; p < a.length; p++) {
      const y = a[p];
      for (const x in y)
        Yr(y, x) && (u[x] = t(u[x], y[x]));
    }
    return u;
  }, Vo = Yv(zg), $u = Yv(Ys), mo = () => ({
    tag: "required",
    process: {}
  }), zi = (t) => ({
    tag: "defaultedThunk",
    process: t
  }), iu = (t) => zi(q(t)), sd = () => ({
    tag: "option",
    process: {}
  }), ye = (t) => ({
    tag: "mergeWithThunk",
    process: t
  }), cu = (t) => ye(q(t)), zm = (t, a) => t.length > 0 ? $s.svalue(Vo(a, $u.apply(void 0, t))) : $s.svalue(a), pl = (t) => we($s.serror, St)(t), Uh = {
    consolidateObj: (t, a) => {
      const u = $s.partition(t);
      return u.errors.length > 0 ? pl(u.errors) : zm(u.values, a);
    },
    consolidateArr: (t) => {
      const a = $s.partition(t);
      return a.errors.length > 0 ? pl(a.errors) : $s.svalue(a.values);
    }
  }, Vg = (t) => C(t) && Xr(t).length > 100 ? " removed due to size" : JSON.stringify(t, null, 2), Iu = (t) => {
    const a = t.length > 10 ? t.slice(0, 10).concat([{
      path: [],
      getErrorInfo: q("... (only showing first ten failures)")
    }]) : t;
    return He(a, (u) => "Failed path: (" + u.path.join(" > ") + `)
` + u.getErrorInfo());
  }, H = (t, a) => $s.serror([{
    path: t,
    getErrorInfo: a
  }]), X = (t, a, u) => H(t, () => 'Could not find valid *required* value for "' + a + '" in ' + Vg(u)), fe = (t, a) => H(t, () => 'Choice schema did not contain choice key: "' + a + '"'), Me = (t, a, u) => H(t, () => 'The chosen schema: "' + u + '" did not exist in branches: ' + Vg(a)), We = (t, a) => H(t, () => "There are unsupported fields: [" + a.join(", ") + "] specified"), Ut = (t, a) => H(t, q(a)), Wn = (t) => {
    const a = (p, y) => $s.bindError(t(y), (x) => Ut(p, x)), u = q("val");
    return {
      extract: a,
      toString: u
    };
  }, xr = Wn($s.svalue), wr = (t, a, u, p) => fn(a, u).fold(() => X(t, u, a), p), pr = (t, a, u, p) => {
    const y = fn(t, a).getOrThunk(() => u(t));
    return p(y);
  }, Us = (t, a, u) => u(fn(t, a)), ra = (t, a, u, p) => {
    const y = fn(t, a).map((x) => x === !0 ? u(t) : x);
    return p(y);
  }, hl = (t, a, u, p, y) => {
    const x = ($) => y.extract(a.concat([p]), $), k = ($) => $.fold(() => $s.svalue(z.none()), (B) => {
      const j = y.extract(a.concat([p]), B);
      return $s.map(j, z.some);
    });
    switch (t.tag) {
      case "required":
        return wr(a, u, p, x);
      case "defaultedThunk":
        return pr(u, p, t.process, x);
      case "option":
        return Us(u, p, k);
      case "defaultedOptionThunk":
        return ra(u, p, t.process, k);
      case "mergeWithThunk":
        return pr(u, p, q({}), ($) => {
          const B = Vo(t.process(u), $);
          return x(B);
        });
    }
  }, Ld = (t, a, u) => {
    const p = {}, y = [];
    for (const x of u)
      od(x, (k, $, B, j) => {
        const Y = hl(B, t, a, k, j);
        $s.fold(Y, (re) => {
          y.push(...re);
        }, (re) => {
          p[$] = re;
        });
      }, (k, $) => {
        p[k] = $(a);
      });
    return y.length > 0 ? $s.serror(y) : $s.svalue(p);
  }, Vi = (t) => ({
    extract: (p, y) => t().extract(p, y),
    toString: () => t().toString()
  }), rw = (t) => Xr(qo(t, se)), xs = (t) => {
    const a = jn(t), u = Zt(t, (y, x) => od(x, (k) => Vo(y, { [k]: !0 }), q(y)), {});
    return {
      extract: (y, x) => {
        const k = L(x) ? [] : rw(x), $ = Rn(k, (B) => !xa(u, B));
        return $.length === 0 ? a.extract(y, x) : We(y, $);
      },
      toString: a.toString
    };
  }, jn = (t) => ({
    extract: (p, y) => Ld(p, y, t),
    toString: () => `obj{
` + He(t, (y) => od(y, (x, k, $, B) => x + " -> " + B.toString(), (x, k) => "state(" + x + ")")).join(`
`) + "}"
  }), pf = (t) => ({
    extract: (p, y) => {
      const x = He(y, (k, $) => t.extract(p.concat(["[" + $ + "]"]), k));
      return Uh.consolidateArr(x);
    },
    toString: () => "array(" + t.toString() + ")"
  }), Un = (t, a) => {
    const u = a !== void 0 ? a : Te;
    return {
      extract: (x, k) => {
        const $ = [];
        for (const B of t) {
          const j = B.extract(x, k);
          if (j.stype === el.Value)
            return {
              stype: el.Value,
              svalue: u(j.svalue)
            };
          $.push(j);
        }
        return Uh.consolidateArr($);
      },
      toString: () => "oneOf(" + He(t, (x) => x.toString()).join(", ") + ")"
    };
  }, Ui = (t, a) => {
    const u = (x, k) => pf(Wn(t)).extract(x, k);
    return {
      extract: (x, k) => {
        const $ = Xr(k), B = u(x, $);
        return $s.bind(B, (j) => {
          const Y = He(j, (re) => ba(re, re, mo(), a));
          return jn(Y).extract(x, k);
        });
      },
      toString: () => "setOf(" + a.toString() + ")"
    };
  }, B1 = (t, a) => {
    const u = zs(a);
    return {
      extract: (x, k) => u().extract(x, k),
      toString: () => u().toString()
    };
  }, hf = we(pf, jn), Ua = q(xr), om = (t, a) => Wn((u) => {
    const p = typeof u;
    return t(u) ? $s.svalue(u) : $s.serror(`Expected type: ${a} but got: ${p}`);
  }), Ug = om(he, "number"), xi = om(g, "string"), ad = om(L, "boolean"), Xv = om(Q, "function"), gf = (t) => {
    if (Object(t) !== t)
      return !0;
    switch ({}.toString.call(t).slice(8, -1)) {
      case "Boolean":
      case "Number":
      case "String":
      case "Date":
      case "RegExp":
      case "Blob":
      case "FileList":
      case "ImageData":
      case "ImageBitmap":
      case "ArrayBuffer":
        return !0;
      case "Array":
      case "Object":
        return Object.keys(t).every((a) => gf(t[a]));
      default:
        return !1;
    }
  }, Jv = Wn((t) => gf(t) ? $s.svalue(t) : $s.serror("Expected value to be acceptable for sending via postMessage")), sm = (t, a, u, p) => fn(u, p).fold(() => Me(t, u, p), (x) => x.extract(t.concat(["branch: " + p]), a)), Qt = (t, a) => ({
    extract: (y, x) => fn(x, t).fold(() => fe(y, t), ($) => sm(y, x, a, $)),
    toString: () => "chooseOn(" + t + "). Possible values: " + Xr(a)
  }), H1 = () => pf(xr), am = (t) => Wn((a) => t(a).fold($s.serror, $s.svalue)), im = (t, a) => Ui((u) => $s.fromResult(t(u)), a), Mu = (t, a, u) => {
    const p = a.extract([t], u);
    return $s.mapError(p, (y) => ({
      input: u,
      errors: y
    }));
  }, Ws = (t, a, u) => $s.toResult(Mu(t, a, u)), Mo = (t) => t.fold((a) => {
    throw new Error(Dc(a));
  }, Te), ya = (t, a, u) => Mo(Ws(t, a, u)), Dc = (t) => `Errors: 
` + Iu(t.errors).join(`
`) + `

Input object: ` + Vg(t.input), ro = (t, a) => Qt(t, uo(a, jn)), $p = (t, a) => B1(t, a), si = ba, Ts = tl, Wg = (t) => am((a) => vt(t, a) ? Rr.value(a) : Rr.error(`Unsupported value: "${a}", choose one of "${t.join(", ")}".`)), Mt = (t) => si(t, t, mo(), Ua()), $c = (t, a) => si(t, t, mo(), a), jg = (t) => $c(t, Ug), xo = (t) => $c(t, xi), ka = (t, a) => si(t, t, mo(), Wg(a)), eb = (t) => $c(t, ad), id = (t) => $c(t, Xv), cd = (t, a) => si(t, t, sd(), Wn((u) => $s.serror("The field: " + t + " is forbidden. " + a))), lu = (t, a) => si(t, t, mo(), jn(a)), Wh = (t, a) => si(t, t, mo(), hf(a)), tc = (t, a) => si(t, t, mo(), pf(a)), Fo = (t) => si(t, t, sd(), Ua()), ai = (t, a) => si(t, t, sd(), a), cm = (t) => ai(t, Ug), nc = (t) => ai(t, xi), Ey = (t, a) => ai(t, Wg(a)), Ip = (t) => ai(t, Xv), lm = (t, a) => ai(t, pf(a)), nl = (t, a) => ai(t, jn(a)), ld = (t, a) => ai(t, xs(a)), lt = (t, a) => si(t, t, iu(a), Ua()), gl = (t, a, u) => si(t, t, iu(a), u), Fu = (t, a) => gl(t, a, Ug), rl = (t, a) => gl(t, a, xi), vl = (t, a, u) => gl(t, a, Wg(u)), vi = (t, a) => gl(t, a, ad), ii = (t, a) => gl(t, a, Xv), Cy = (t, a) => gl(t, a, Jv), bl = (t, a, u) => gl(t, a, pf(u)), vf = (t, a, u) => gl(t, a, jn(u)), sr = (t) => {
    let a = t;
    return {
      get: () => a,
      set: (y) => {
        a = y;
      }
    };
  }, W = { generate: (t) => {
    if (!R(t))
      throw new Error("cases must be an array");
    if (t.length === 0)
      throw new Error("there must be at least one case");
    const a = [], u = {};
    return ut(t, (p, y) => {
      const x = Xr(p);
      if (x.length !== 1)
        throw new Error("one and only one name per case");
      const k = x[0], $ = p[k];
      if (u[k] !== void 0)
        throw new Error("duplicate key detected:" + k);
      if (k === "cata")
        throw new Error("cannot have a case named cata (sorry)");
      if (!R($))
        throw new Error("case arguments must be an array");
      a.push(k), u[k] = (...B) => {
        const j = B.length;
        if (j !== $.length)
          throw new Error("Wrong number of arguments to case " + k + ". Expected " + $.length + " (" + $ + "), got " + j);
        return {
          fold: (...re) => {
            if (re.length !== t.length)
              throw new Error("Wrong number of arguments to fold. Expected " + t.length + ", got " + re.length);
            return re[y].apply(null, B);
          },
          match: (re) => {
            const le = Xr(re);
            if (a.length !== le.length)
              throw new Error("Wrong number of arguments to match. Expected: " + a.join(",") + `
Actual: ` + le.join(","));
            if (!Ct(a, (_e) => vt(le, _e)))
              throw new Error("Not all branches were specified when using match. Specified: " + le.join(", ") + `
Required: ` + a.join(", "));
            return re[k].apply(null, B);
          },
          log: (re) => {
            console.log(re, {
              constructors: a,
              constructor: k,
              params: B
            });
          }
        };
      };
    }), u;
  } };
  W.generate([
    {
      bothErrors: [
        "error1",
        "error2"
      ]
    },
    {
      firstError: [
        "error1",
        "value2"
      ]
    },
    {
      secondError: [
        "value1",
        "error2"
      ]
    },
    {
      bothValues: [
        "value1",
        "value2"
      ]
    }
  ]);
  const de = (t) => {
    const a = [], u = [];
    return ut(t, (p) => {
      p.fold((y) => {
        a.push(y);
      }, (y) => {
        u.push(y);
      });
    }), {
      errors: a,
      values: u
    };
  }, Ee = (t, a) => {
    const u = {};
    return Eo(t, (p, y) => {
      vt(a, y) || (u[y] = p);
    }), u;
  }, qe = (t, a) => ({ [t]: a }), kt = (t) => {
    const a = {};
    return ut(t, (u) => {
      a[u.key] = u.value;
    }), a;
  }, tn = (t, a) => Ee(t, a), Sn = (t, a) => qe(t, a), Xn = (t) => kt(t), Pr = (t, a) => t.length === 0 ? Rr.value(a) : Rr.value(Vo(a, $u.apply(void 0, t))), la = (t) => Rr.error(St(t)), Lo = (t, a) => {
    const u = de(t);
    return u.errors.length > 0 ? la(u.errors) : Pr(u.values, a);
  }, _s = (t) => Q(t) ? t : sn, zl = (t, a, u) => {
    let p = t.dom;
    const y = _s(u);
    for (; p.parentNode; ) {
      p = p.parentNode;
      const x = nt.fromDom(p), k = a(x);
      if (k.isSome())
        return k;
      if (y(x))
        break;
    }
    return z.none();
  }, Ic = (t, a, u) => {
    const p = a(t), y = _s(u);
    return p.orThunk(() => y(t) ? z.none() : zl(t, a, y));
  }, uu = (t, a) => Io(t.element, a.event.target), bf = {
    can: Lt,
    abort: sn,
    run: G
  }, Bd = (t) => {
    if (!xa(t, "can") && !xa(t, "abort") && !xa(t, "run"))
      throw new Error("EventHandler defined by: " + JSON.stringify(t, null, 2) + " does not have can, abort, or run!");
    return {
      ...bf,
      ...t
    };
  }, Mp = (t, a) => (...u) => Jt(t, (p, y) => p && a(y).apply(void 0, u), !0), Ro = (t, a) => (...u) => Jt(t, (p, y) => p || a(y).apply(void 0, u), !1), Fp = (t) => Q(t) ? {
    can: Lt,
    abort: sn,
    run: t
  } : t, qg = (t) => {
    const a = Mp(t, (y) => y.can), u = Ro(t, (y) => y.abort);
    return {
      can: a,
      abort: u,
      run: (...y) => {
        ut(t, (x) => {
          x.run.apply(void 0, y);
        });
      }
    };
  }, Sa = q, du = Sa("touchstart"), jh = Sa("touchmove"), Lp = Sa("touchend"), qr = Sa("touchcancel"), oo = Sa("mousedown"), ci = Sa("mousemove"), rc = Sa("mouseout"), tb = Sa("mouseup"), yf = Sa("mouseover"), oa = Sa("focusin"), fu = Sa("focusout"), ud = Sa("keydown"), Bp = Sa("keyup"), Vm = Sa("input"), Gg = Sa("change"), um = Sa("click"), WC = Sa("transitioncancel"), Hp = Sa("transitionend"), xy = Sa("transitionstart"), zp = Sa("selectstart"), Wa = (t) => q("alloy." + t), Hd = { tap: Wa("tap") }, Sf = Wa("focus"), Vp = Wa("blur.post"), Up = Wa("paste.post"), Zg = Wa("receive"), Lu = Wa("execute"), Na = Wa("focus.item"), wf = Hd.tap, z1 = Wa("longpress"), Ty = Wa("sandbox.close"), _y = Wa("typeahead.cancel"), Wp = Wa("system.init"), yl = Wa("system.touchmove"), zd = Wa("system.touchend"), Um = Wa("system.scroll"), dm = Wa("system.resize"), Vl = Wa("system.attached"), Vd = Wa("system.detached"), jp = Wa("system.dismissRequested"), ow = Wa("system.repositionRequested"), V1 = Wa("focusmanager.shifted"), nb = Wa("slotcontainer.visibility"), qp = Wa("system.external.element.scroll"), rb = Wa("change.tab"), U1 = Wa("dismiss.tab"), ob = Wa("highlight"), sb = Wa("dehighlight"), Jr = (t, a) => {
    qh(t, t.element, a, {});
  }, nr = (t, a, u) => {
    qh(t, t.element, a, u);
  }, Ef = (t) => {
    Jr(t, Lu());
  }, ab = (t, a, u) => {
    qh(t, a, u, {});
  }, qh = (t, a, u, p) => {
    const y = {
      target: a,
      ...p
    };
    t.getSystem().triggerEvent(u, a, y);
  }, M2 = (t, a, u, p) => {
    const y = {
      ...p,
      target: a
    };
    t.getSystem().triggerEvent(u, a, y);
  }, W1 = (t, a, u, p) => {
    t.getSystem().triggerEvent(u, a, p.event);
  }, ls = (t) => Xn(t), j1 = (t, a) => ({
    key: t,
    value: Bd({ abort: a })
  }), Oy = (t, a) => ({
    key: t,
    value: Bd({ can: a })
  }), sw = (t) => ({
    key: t,
    value: Bd({
      run: (a, u) => {
        u.event.prevent();
      }
    })
  }), Pt = (t, a) => ({
    key: t,
    value: Bd({ run: a })
  }), Cf = (t, a, u) => ({
    key: t,
    value: Bd({
      run: (p, y) => {
        a.apply(void 0, [
          p,
          y
        ].concat(u));
      }
    })
  }), jC = (t) => (a) => Pt(t, a), ib = (t) => (a) => ({
    key: t,
    value: Bd({
      run: (u, p) => {
        uu(u, p) && a(u, p);
      }
    })
  }), F2 = (t, a) => Pt(t, (u, p) => {
    u.getSystem().getByUid(a).each((y) => {
      W1(y, y.element, t, p);
    });
  }), Kg = (t, a, u) => {
    const p = a.partUids[u];
    return F2(t, p);
  }, aw = (t, a) => Pt(t, (u, p) => {
    const y = p.event, x = u.getSystem().getByDom(y.target).getOrThunk(() => Ic(y.target, ($) => u.getSystem().getByDom($).toOptional(), sn).getOr(u));
    a(u, x, p);
  }), Gp = (t) => Pt(t, (a, u) => {
    u.cut();
  }), Zp = (t) => Pt(t, (a, u) => {
    u.stop();
  }), xf = (t, a) => ib(t)(a), us = ib(Vl()), Tf = ib(Vd()), cb = ib(Wp()), Ul = jC(Lu()), Wr = (t, a) => {
    const p = (a || document).createElement("div");
    return p.innerHTML = t, Nc(nt.fromDom(p));
  }, lb = (t) => t.dom.innerHTML, Kp = (t, a) => {
    const p = ti(t).dom, y = nt.fromDom(p.createDocumentFragment()), x = Wr(a, p);
    Du(y, x), ys(t), oi(t, y);
  }, Gh = (t) => {
    const a = nt.fromTag("div"), u = nt.fromDom(t.dom.cloneNode(!0));
    return oi(a, u), lb(a);
  }, q1 = (t, a) => nt.fromDom(t.dom.cloneNode(a)), Ay = (t) => q1(t, !1), qC = (t) => q1(t, !0), Sl = (t) => {
    if (Se(t))
      return "#shadow-root";
    {
      const a = Ay(t);
      return Gh(a);
    }
  }, Wm = (t) => Sl(t), Vk = (t, a, u) => Io(a, t.element) && !Io(a, u), G1 = ls([Oy(Sf(), (t, a) => {
    const u = a.event, p = u.originator, y = u.target;
    return Vk(t, p, y) ? (console.warn(Sf() + ` did not get interpreted by the desired target. 
Originator: ` + Wm(p) + `
Target: ` + Wm(y) + `
Check the ` + Sf() + " event handlers"), !1) : !0;
  })]);
  var Yg = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: G1
  });
  let xc = 0;
  const Hn = (t) => {
    const u = (/* @__PURE__ */ new Date()).getTime(), p = Math.floor(Math.random() * 1e9);
    return xc++, t + "_" + p + xc + String(u);
  }, L2 = q("alloy-id-"), iw = q("data-alloy-id"), Yp = L2(), mu = iw(), Qp = (t, a) => {
    const u = Hn(Yp + t);
    return ub(a, u), u;
  }, ub = (t, a) => {
    Object.defineProperty(t.dom, mu, {
      value: a,
      writable: !0
    });
  }, Qg = (t) => {
    const a = $o(t) ? t.dom[mu] : null;
    return z.from(a);
  }, db = (t) => Hn(t), Z1 = Te, Ud = (t) => {
    const a = (y) => `The component must be in a context to execute: ${y}` + (t ? `
` + Wm(t().element) + " is not in context." : ""), u = (y) => () => {
      throw new Error(a(y));
    }, p = (y) => () => {
      console.warn(a(y));
    };
    return {
      debugInfo: q("fake"),
      triggerEvent: p("triggerEvent"),
      triggerFocus: p("triggerFocus"),
      triggerEscape: p("triggerEscape"),
      broadcast: p("broadcast"),
      broadcastOn: p("broadcastOn"),
      broadcastEvent: p("broadcastEvent"),
      build: u("build"),
      buildOrPatch: u("buildOrPatch"),
      addToWorld: u("addToWorld"),
      removeFromWorld: u("removeFromWorld"),
      addToGui: u("addToGui"),
      removeFromGui: u("removeFromGui"),
      getByUid: u("getByUid"),
      getByDom: u("getByDom"),
      isConnected: sn
    };
  }, _f = Ud(), fb = (t, a, u) => {
    const p = u.toString(), y = p.indexOf(")") + 1, x = p.indexOf("("), k = p.substring(x + 1, y - 1).split(/,\s*/);
    return t.toFunctionAnnotation = () => ({
      name: a,
      parameters: Wd(k.slice(0, 1).concat(k.slice(3)))
    }), t;
  }, Wd = (t) => He(t, (a) => Nl(a, "/*") ? a.substring(0, a.length - 2) : a), K1 = (t, a) => {
    const u = t.toString(), p = u.indexOf(")") + 1, y = u.indexOf("("), x = u.substring(y + 1, p - 1).split(/,\s*/);
    return t.toFunctionAnnotation = () => ({
      name: a,
      parameters: Wd(x)
    }), t;
  }, GC = (t, a) => {
    const u = a.toString(), p = u.indexOf(")") + 1, y = u.indexOf("("), x = u.substring(y + 1, p - 1).split(/,\s*/);
    return t.toFunctionAnnotation = () => ({
      name: "OVERRIDE",
      parameters: Wd(x.slice(1))
    }), t;
  }, mb = Hn("alloy-premade"), jm = (t) => (Object.defineProperty(t.element.dom, mb, {
    value: t.uid,
    writable: !0
  }), Sn(mb, t)), ZC = (t) => Yr(t.dom, mb), pb = (t) => fn(t, mb), Xp = (t) => GC((a, ...u) => t(a.getApis(), a, ...u), t), jd = { init: () => ol({ readState: q("No State required") }) }, ol = (t) => t, cw = (t, a) => {
    const u = He(a, (y) => nl(y.name(), [
      Mt("config"),
      lt("state", jd)
    ])), p = Ws("component.behaviours", jn(u), t.behaviours).fold((y) => {
      throw new Error(Dc(y) + `
Complete spec:
` + JSON.stringify(t, null, 2));
    }, Te);
    return {
      list: a,
      data: uo(p, (y) => {
        const x = y.map((k) => ({
          config: k.config,
          state: k.state.init(k.config)
        }));
        return q(x);
      })
    };
  }, lw = (t) => t.list, uw = (t) => t.data, hb = (t, a) => {
    const u = {};
    return Eo(t, (p, y) => {
      Eo(p, (x, k) => {
        const $ = fn(u, k).getOr([]);
        u[k] = $.concat([a(y, x)]);
      });
    }), u;
  }, pu = (t) => ({
    classes: Z(t.classes) ? [] : t.classes,
    attributes: Z(t.attributes) ? {} : t.attributes,
    styles: Z(t.styles) ? {} : t.styles
  }), Bu = (t, a) => ({
    ...t,
    attributes: {
      ...t.attributes,
      ...a.attributes
    },
    styles: {
      ...t.styles,
      ...a.styles
    },
    classes: t.classes.concat(a.classes)
  }), qm = (t, a, u, p) => {
    const y = { ...a };
    ut(u, (Y) => {
      y[Y.name()] = Y.exhibit(t, p);
    });
    const x = hb(y, (Y, re) => ({
      name: Y,
      modification: re
    })), k = (Y) => Zt(Y, (re, le) => ({
      ...le.modification,
      ...re
    }), {}), $ = Zt(x.classes, (Y, re) => re.modification.concat(Y), []), B = k(x.attributes), j = k(x.styles);
    return pu({
      classes: $,
      attributes: B,
      styles: j
    });
  }, Y1 = (t, a, u, p) => {
    try {
      const y = nn(u, (x, k) => {
        const $ = x[a], B = k[a], j = p.indexOf($), Y = p.indexOf(B);
        if (j === -1)
          throw new Error("The ordering for " + t + " does not have an entry for " + $ + `.
Order specified: ` + JSON.stringify(p, null, 2));
        if (Y === -1)
          throw new Error("The ordering for " + t + " does not have an entry for " + B + `.
Order specified: ` + JSON.stringify(p, null, 2));
        return j < Y ? -1 : Y < j ? 1 : 0;
      });
      return Rr.value(y);
    } catch (y) {
      return Rr.error([y]);
    }
  }, KC = (t, a) => ({
    handler: t,
    purpose: a
  }), YC = (t, a) => ({
    cHandler: t,
    purpose: a
  }), dw = (t, a) => YC(je.apply(void 0, [t.handler].concat(a)), t.purpose), gb = (t) => t.cHandler, vb = (t, a) => ({
    name: t,
    handler: a
  }), Q1 = (t, a) => {
    const u = {};
    return ut(t, (p) => {
      u[p.name()] = p.handlers(a);
    }), u;
  }, B2 = (t, a, u) => {
    const p = {
      ...u,
      ...Q1(a, t)
    };
    return hb(p, vb);
  }, X1 = (t, a, u, p) => {
    const y = B2(t, u, p);
    return fw(y, a);
  }, bb = (t) => {
    const a = Fp(t);
    return (u, p, ...y) => {
      const x = [
        u,
        p
      ].concat(y);
      a.abort.apply(void 0, x) ? p.stop() : a.can.apply(void 0, x) && a.run.apply(void 0, x);
    };
  }, H2 = (t, a) => Rr.error(["The event (" + t + `) has more than one behaviour that listens to it.
When this occurs, you must specify an event ordering for the behaviours in your spec (e.g. [ "listing", "toggling" ]).
The behaviours that can trigger it are: ` + JSON.stringify(He(a, (u) => u.name), null, 2)]), ky = (t, a, u) => {
    const p = a[u];
    return p ? Y1("Event: " + u, "name", t, p).map((y) => {
      const x = He(y, (k) => k.handler);
      return qg(x);
    }) : H2(u, t);
  }, fw = (t, a) => {
    const u = hc(t, (p, y) => (p.length === 1 ? Rr.value(p[0].handler) : ky(p, a, y)).map((k) => {
      const $ = bb(k), B = p.length > 1 ? Rn(a[y], (j) => Gt(p, (Y) => Y.name === j)).join(" > ") : p[0].name;
      return Sn(y, KC($, B));
    }));
    return Lo(u, {});
  }, hu = "alloy.base.behaviour", Ny = jn([
    si("dom", "dom", mo(), jn([
      Mt("tag"),
      lt("styles", {}),
      lt("classes", []),
      lt("attributes", {}),
      Fo("value"),
      Fo("innerHtml")
    ])),
    Mt("components"),
    Mt("uid"),
    lt("events", {}),
    lt("apis", {}),
    si("eventOrder", "eventOrder", cu({
      [Lu()]: [
        "disabling",
        hu,
        "toggling",
        "typeaheadevents"
      ],
      [Sf()]: [
        hu,
        "focusing",
        "keying"
      ],
      [Wp()]: [
        hu,
        "disabling",
        "toggling",
        "representing"
      ],
      [Vm()]: [
        hu,
        "representing",
        "streaming",
        "invalidating"
      ],
      [Vd()]: [
        hu,
        "representing",
        "item-events",
        "tooltipping"
      ],
      [oo()]: [
        "focusing",
        hu,
        "item-type-events"
      ],
      [du()]: [
        "focusing",
        hu,
        "item-type-events"
      ],
      [yf()]: [
        "item-type-events",
        "tooltipping"
      ],
      [Zg()]: [
        "receiving",
        "reflecting",
        "tooltipping"
      ]
    }), Ua()),
    Fo("domModification")
  ]), mw = (t) => Ws("custom.definition", Ny, t), J1 = (t) => ({
    ...t.dom,
    uid: t.uid,
    domChildren: He(t.components, (a) => a.element)
  }), Uk = (t) => t.domModification.fold(() => pu({}), pu), e0 = (t) => t.events, Jp = (t, a) => {
    const u = ca(t, a);
    return u === void 0 || u === "" ? [] : u.split(" ");
  }, Gm = (t, a, u) => {
    const y = Jp(t, a).concat([u]);
    return kn(t, a, y.join(" ")), !0;
  }, pw = (t, a, u) => {
    const p = Rn(Jp(t, a), (y) => y !== u);
    return p.length > 0 ? kn(t, a, p.join(" ")) : vs(t, a), !1;
  }, yb = (t) => t.dom.classList !== void 0, t0 = (t) => Jp(t, "class"), QC = (t, a) => Gm(t, "class", a), Is = (t, a) => pw(t, "class", a), Of = (t, a) => vt(t0(t), a) ? Is(t, a) : QC(t, a), ja = (t, a) => {
    yb(t) ? t.dom.classList.add(a) : QC(t, a);
  }, XC = (t) => {
    (yb(t) ? t.dom.classList : t0(t)).length === 0 && vs(t, "class");
  }, ua = (t, a) => {
    yb(t) ? t.dom.classList.remove(a) : Is(t, a), XC(t);
  }, Xg = (t, a) => {
    const u = yb(t) ? t.dom.classList.toggle(a) : Of(t, a);
    return XC(t), u;
  }, Ti = (t, a) => yb(t) && t.dom.classList.contains(a), wa = (t, a) => {
    ut(a, (u) => {
      ja(t, u);
    });
  }, dd = (t, a) => {
    ut(a, (u) => {
      ua(t, u);
    });
  }, hw = (t, a) => {
    ut(a, (u) => {
      Xg(t, u);
    });
  }, oc = (t, a) => Ct(a, (u) => Ti(t, u)), Ry = (t) => {
    const a = t.dom.classList, u = new Array(a.length);
    for (let p = 0; p < a.length; p++) {
      const y = a.item(p);
      y !== null && (u[p] = y);
    }
    return u;
  }, Sb = (t) => yb(t) ? Ry(t) : t0(t), Zm = (t) => t.dom.value, wb = (t, a) => {
    if (a === void 0)
      throw new Error("Value.set was undefined");
    t.dom.value = a;
  }, Zh = (t, a, u) => ku(t, a).map((y) => {
    if (u.exists((k) => !Io(k, y))) {
      const k = u.map(kc).getOr("span"), $ = nt.fromTag(k);
      return $a(y, $), $;
    } else
      return y;
  }), eh = (t, a, u) => {
    u.fold(() => oi(t, a), (p) => {
      Io(p, a) || ($a(p, a), ou(p));
    });
  }, z2 = (t, a, u) => {
    const p = He(a, u), y = Nc(t);
    return ut(y.slice(p.length), ou), p;
  }, JC = (t, a, u, p) => {
    const y = ku(t, a), x = p(u, y), k = Zh(t, a, y);
    return eh(t, x.element, k), x;
  }, Wk = (t, a, u) => z2(t, a, (p, y) => JC(t, y, p, u)), jk = (t, a) => z2(t, a, (u, p) => {
    const y = ku(t, p);
    return eh(t, u, y), u;
  }), Af = (t, a) => {
    const u = Xr(t), p = Xr(a), y = ht(p, u), x = Ps(t, (k, $) => !Yr(a, $) || k !== a[$]).t;
    return {
      toRemove: y,
      toSet: x
    };
  }, wl = (t, a) => {
    const {
      class: u,
      style: p,
      ...y
    } = Wv(a), {
      toSet: x,
      toRemove: k
    } = Af(t.attributes, y), $ = () => {
      ut(k, (mt) => vs(a, mt)), Pm(a, x);
    }, B = bs(a), {
      toSet: j,
      toRemove: Y
    } = Af(t.styles, B), re = () => {
      ut(Y, (mt) => Ur(a, mt)), Rc(a, j);
    }, le = Sb(a), pe = ht(le, t.classes), _e = ht(t.classes, le), ze = () => {
      wa(a, _e), dd(a, pe);
    }, ft = (mt) => {
      Kp(a, mt);
    }, Xe = () => {
      const mt = t.domChildren;
      jk(a, mt);
    }, Ze = () => {
      const mt = a, jt = t.value.getOrUndefined();
      jt !== Zm(mt) && wb(mt, jt ?? "");
    };
    return $(), ze(), re(), t.innerHtml.fold(Xe, ft), Ze(), a;
  }, V2 = (t) => {
    const a = nt.fromTag(t.tag);
    Pm(a, t.attributes), wa(a, t.classes), Rc(a, t.styles), t.innerHtml.each((p) => Kp(a, p));
    const u = t.domChildren;
    return Du(a, u), t.value.each((p) => {
      wb(a, p);
    }), a;
  }, U2 = (t, a) => {
    try {
      const u = wl(t, a);
      return z.some(u);
    } catch {
      return z.none();
    }
  }, Kh = (t) => t.innerHtml.isSome() && t.domChildren.length > 0, Py = (t, a) => {
    const u = (y) => kc(y) === t.tag && !Kh(t) && !ZC(y), p = a.filter(u).bind((y) => U2(t, y)).getOrThunk(() => V2(t));
    return ub(p, t.uid), p;
  }, n0 = (t) => {
    const a = fn(t, "behaviours").getOr({});
    return ke(Xr(a), (u) => {
      const p = a[u];
      return se(p) ? [p.me] : [];
    });
  }, r0 = (t, a) => cw(t, a), Km = (t) => {
    const a = n0(t);
    return r0(t, a);
  }, Eb = (t, a, u) => {
    const p = J1(t), y = Uk(t), x = { "alloy.base.modification": y }, k = a.length > 0 ? qm(u, x, a, p) : y;
    return Bu(p, k);
  }, Yh = (t, a, u) => {
    const p = { "alloy.base.behaviour": e0(t) };
    return X1(u, t.eventOrder, a, p).getOrDie();
  }, Jg = (t, a) => {
    const u = () => mt, p = sr(_f), y = Mo(mw(t)), x = Km(t), k = lw(x), $ = uw(x), B = Eb(y, k, $), j = Py(B, a), Y = Yh(y, k, $), re = sr(y.components), le = (jt) => {
      p.set(jt);
    }, pe = () => {
      p.set(Ud(u));
    }, _e = () => {
      const jt = Nc(j), Dt = ke(jt, (Nt) => p.get().getByDom(Nt).fold(() => [], Ye));
      re.set(Dt);
    }, ze = (jt) => {
      const Dt = $;
      return (Q(Dt[jt.name()]) ? Dt[jt.name()] : () => {
        throw new Error("Could not find " + jt.name() + " in " + JSON.stringify(t, null, 2));
      })();
    }, ft = (jt) => Q($[jt.name()]), Xe = () => y.apis, Ze = (jt) => $[jt]().map((Dt) => Dt.state.readState()).getOr("not enabled"), mt = {
      uid: t.uid,
      getSystem: p.get,
      config: ze,
      hasConfigured: ft,
      spec: t,
      readState: Ze,
      getApis: Xe,
      connect: le,
      disconnect: pe,
      element: j,
      syncComponents: _e,
      components: re.get,
      events: Y
    };
    return mt;
  }, ev = (t, a) => {
    const u = fn(t, "components").getOr([]);
    return a.fold(() => He(u, sl), (p) => He(u, (y, x) => o0(y, ku(p, x))));
  }, ex = (t, a) => {
    const {
      events: u,
      ...p
    } = Z1(t), y = ev(p, a), x = {
      ...p,
      events: {
        ...Yg,
        ...u
      },
      components: y
    };
    return Rr.value(Jg(x, a));
  }, Ma = (t) => {
    const a = nt.fromText(t);
    return tx({ element: a });
  }, tx = (t) => {
    const a = ya("external.component", xs([
      Mt("element"),
      Fo("uid")
    ]), t), u = sr(Ud()), p = ($) => {
      u.set($);
    }, y = () => {
      u.set(Ud(() => k));
    }, x = a.uid.getOrThunk(() => db("external"));
    ub(a.element, x);
    const k = {
      uid: x,
      getSystem: u.get,
      config: z.none,
      hasConfigured: sn,
      connect: p,
      disconnect: y,
      getApis: () => ({}),
      element: a.element,
      spec: t,
      readState: q("No state"),
      syncComponents: G,
      components: q([]),
      events: {}
    };
    return jm(k);
  }, Cb = db, nx = (t) => Yr(t, "uid"), o0 = (t, a) => pb(t).getOrThunk(() => {
    const u = nx(t) ? t : {
      uid: Cb(""),
      ...t
    };
    return ex(u, a).getOrDie();
  }), sl = (t) => o0(t, z.none()), Hu = jm;
  var rx = (t, a, u, p, y) => t(u, p) ? z.some(u) : Q(y) && y(u) ? z.none() : a(u, p, y);
  const tv = (t, a, u) => {
    let p = t.dom;
    const y = Q(u) ? u : sn;
    for (; p.parentNode; ) {
      p = p.parentNode;
      const x = nt.fromDom(p);
      if (a(x))
        return z.some(x);
      if (y(x))
        break;
    }
    return z.none();
  }, nv = (t, a, u) => rx((y, x) => x(y), tv, t, a, u), W2 = (t, a) => {
    const u = (y) => a(nt.fromDom(y));
    return Ge(t.dom.childNodes, u).map(nt.fromDom);
  }, ox = (t, a) => {
    const u = (p) => {
      for (let y = 0; y < p.childNodes.length; y++) {
        const x = nt.fromDom(p.childNodes[y]);
        if (a(x))
          return z.some(x);
        const k = u(p.childNodes[y]);
        if (k.isSome())
          return k;
      }
      return z.none();
    };
    return u(t.dom);
  }, gw = (t, a, u) => nv(t, a, u).isSome(), zu = (t, a, u) => tv(t, (p) => Zs(p, a), u), s0 = (t, a) => W2(t, (u) => Zs(u, a)), qa = (t, a) => tm(a, t), fm = (t, a, u) => rx((y, x) => Zs(y, x), zu, t, a, u), xb = "aria-controls", Qh = (t) => nv(t, (u) => {
    if (!$o(u))
      return !1;
    const p = ca(u, "id");
    return p !== void 0 && p.indexOf(xb) > -1;
  }).bind((u) => {
    const p = ca(u, "id"), y = wt(u);
    return qa(y, `[${xb}="${p}"]`);
  }), rv = () => {
    const t = Hn(xb);
    return {
      id: t,
      link: (p) => {
        kn(p, xb, t);
      },
      unlink: (p) => {
        vs(p, xb);
      }
    };
  }, ov = (t, a) => Qh(a).exists((u) => th(t, u)), th = (t, a) => gw(a, (u) => Io(u, t.element), sn) || ov(t, a), sx = "unknown";
  var sv;
  (function(t) {
    t[t.STOP = 0] = "STOP", t[t.NORMAL = 1] = "NORMAL", t[t.LOGGING = 2] = "LOGGING";
  })(sv || (sv = {}));
  const Xh = sr({}), Jh = (t, a) => {
    const u = [], p = (/* @__PURE__ */ new Date()).getTime();
    return {
      logEventCut: (y, x, k) => {
        u.push({
          outcome: "cut",
          target: x,
          purpose: k
        });
      },
      logEventStopped: (y, x, k) => {
        u.push({
          outcome: "stopped",
          target: x,
          purpose: k
        });
      },
      logNoParent: (y, x, k) => {
        u.push({
          outcome: "no-parent",
          target: x,
          purpose: k
        });
      },
      logEventNoHandlers: (y, x) => {
        u.push({
          outcome: "no-handlers-left",
          target: x
        });
      },
      logEventResponse: (y, x, k) => {
        u.push({
          outcome: "response",
          purpose: k,
          target: x
        });
      },
      write: () => {
        const y = (/* @__PURE__ */ new Date()).getTime();
        vt([
          "mousemove",
          "mouseover",
          "mouseout",
          Wp()
        ], t) || console.log(t, {
          event: t,
          time: y - p,
          target: a.dom,
          sequence: He(u, (x) => vt([
            "cut",
            "stopped",
            "response"
          ], x.outcome) ? "{" + x.purpose + "} " + x.outcome + " at (" + Wm(x.target) + ")" : x.outcome)
        });
      }
    };
  }, vw = (t, a, u) => {
    switch (fn(Xh.get(), t).orThunk(() => {
      const y = Xr(Xh.get());
      return Vr(y, (x) => t.indexOf(x) > -1 ? z.some(Xh.get()[x]) : z.none());
    }).getOr(sv.NORMAL)) {
      case sv.NORMAL:
        return u(Tb());
      case sv.LOGGING: {
        const y = Jh(t, a), x = u(y);
        return y.write(), x;
      }
      case sv.STOP:
        return !0;
    }
  }, j2 = [
    "alloy/data/Fields",
    "alloy/debugging/Debugging"
  ], bw = () => {
    const t = new Error();
    if (t.stack !== void 0) {
      const a = t.stack.split(`
`);
      return Ge(a, (u) => u.indexOf("alloy") > 0 && !Gt(j2, (p) => u.indexOf(p) > -1)).getOr(sx);
    } else
      return sx;
  }, q2 = {
    logEventCut: G,
    logEventStopped: G,
    logNoParent: G,
    logEventNoHandlers: G,
    logEventResponse: G,
    write: G
  }, a0 = (t, a, u) => vw(t, a, u), Tb = q(q2), Vu = q([
    Mt("menu"),
    Mt("selectedMenu")
  ]), ax = q([
    Mt("item"),
    Mt("selectedItem")
  ]);
  q(jn(ax().concat(Vu())));
  const _b = q(jn(ax())), ix = lu("initSize", [
    Mt("numColumns"),
    Mt("numRows")
  ]), G2 = () => $c("markers", _b()), Dy = () => lu("markers", [Mt("backgroundMenu")].concat(Vu()).concat(ax())), eg = (t) => lu("markers", He(t, Mt)), i0 = (t, a, u) => (bw(), si(a, a, u, am((p) => Rr.value((...y) => p.apply(void 0, y))))), po = (t) => i0("onHandler", t, iu(G)), Uu = (t) => i0("onKeyboardHandler", t, iu(z.none)), mm = (t) => i0("onHandler", t, mo()), Ob = (t) => i0("onKeyboardHandler", t, mo()), ds = (t, a) => Ts(t, q(a)), Ab = (t) => Ts(t, Te), c0 = q(ix), bi = (t, a, u, p, y, x, k, $ = !1) => ({
    x: t,
    y: a,
    bubble: u,
    direction: p,
    placement: y,
    restriction: x,
    label: `${k}-${y}`,
    alwaysFit: $
  }), pm = W.generate([
    { southeast: [] },
    { southwest: [] },
    { northeast: [] },
    { northwest: [] },
    { south: [] },
    { north: [] },
    { east: [] },
    { west: [] }
  ]), nh = (t, a, u, p, y, x, k, $, B) => t.fold(a, u, p, y, x, k, $, B), l0 = (t, a, u, p) => t.fold(a, a, p, p, a, p, u, u), $y = (t, a, u, p) => t.fold(a, p, a, p, u, u, a, p), Iy = pm.southeast, yw = pm.southwest, u0 = pm.northeast, qd = pm.northwest, kf = pm.south, Z2 = pm.north, yt = pm.east, av = pm.west, iv = (t, a, u, p) => {
    const y = t + a;
    return y > p ? u : y < u ? p : y;
  }, fd = (t, a, u) => Math.min(Math.max(t, a), u), Sw = (t, a) => {
    switch (a) {
      case 1:
        return t.x;
      case 0:
        return t.x + t.width;
      case 2:
        return t.y;
      case 3:
        return t.y + t.height;
    }
  }, sa = (t, a) => bn([
    "left",
    "right",
    "top",
    "bottom"
  ], (u) => fn(a, u).map((p) => Sw(t, p))), d0 = (t, a, u) => {
    const p = (B, j) => a[B].map((Y) => {
      const re = B === "top" || B === "bottom", le = re ? u.top : u.left, _e = (B === "left" || B === "top" ? Math.max : Math.min)(Y, j) + le;
      return re ? fd(_e, t.y, t.bottom) : fd(_e, t.x, t.right);
    }).getOr(j), y = p("left", t.x), x = p("top", t.y), k = p("right", t.right), $ = p("bottom", t.bottom);
    return cs(y, x, k - y, $ - x);
  }, rh = "layout", ww = (t) => t.x, f0 = (t, a) => t.x + t.width / 2 - a.width / 2, Ew = (t, a) => t.x + t.width - a.width, My = (t, a) => t.y - a.height, kb = (t) => t.y + t.height, Cw = (t, a) => t.y + t.height / 2 - a.height / 2, K2 = (t) => t.x + t.width, Ga = (t, a) => t.x - a.width, Wi = (t, a, u) => bi(ww(t), kb(t), u.southeast(), Iy(), "southeast", sa(t, {
    left: 1,
    top: 3
  }), rh), Mc = (t, a, u) => bi(Ew(t, a), kb(t), u.southwest(), yw(), "southwest", sa(t, {
    right: 0,
    top: 3
  }), rh), ji = (t, a, u) => bi(ww(t), My(t, a), u.northeast(), u0(), "northeast", sa(t, {
    left: 1,
    bottom: 2
  }), rh), Br = (t, a, u) => bi(Ew(t, a), My(t, a), u.northwest(), qd(), "northwest", sa(t, {
    right: 0,
    bottom: 2
  }), rh), El = (t, a, u) => bi(f0(t, a), My(t, a), u.north(), Z2(), "north", sa(t, { bottom: 2 }), rh), Os = (t, a, u) => bi(f0(t, a), kb(t), u.south(), kf(), "south", sa(t, { top: 3 }), rh), qi = (t, a, u) => bi(K2(t), Cw(t, a), u.east(), yt(), "east", sa(t, { left: 0 }), rh), Fy = (t, a, u) => bi(Ga(t, a), Cw(t, a), u.west(), av(), "west", sa(t, { right: 1 }), rh), Ym = () => [
    Wi,
    Mc,
    ji,
    Br,
    Os,
    El,
    qi,
    Fy
  ], Ly = () => [
    Mc,
    Wi,
    Br,
    ji,
    Os,
    El,
    qi,
    Fy
  ], xw = () => [
    ji,
    Br,
    Wi,
    Mc,
    El,
    Os
  ], cx = () => [
    Br,
    ji,
    Mc,
    Wi,
    El,
    Os
  ], m0 = () => [
    Wi,
    Mc,
    ji,
    Br,
    Os,
    El
  ], Tw = () => [
    Mc,
    Wi,
    Br,
    ji,
    Os,
    El
  ], _w = (t, a) => a.universal ? t : Rn(t, (u) => vt(a.channels, u));
  var Qm = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: (t) => ls([Pt(Zg(), (a, u) => {
      const p = t.channels, y = Xr(p), x = u, k = _w(y, x);
      ut(k, ($) => {
        const B = p[$], j = B.schema, Y = ya("channel[" + $ + `] data
Receiver: ` + Wm(a.element), j, x.data);
        B.onReceive(a, Y);
      });
    })])
  }), lx = [$c("channels", im(Rr.value, xs([
    mm("onReceive"),
    lt("schema", Ua())
  ])))];
  const oh = (t, a, u) => Ul((p) => {
    u(p, t, a);
  }), li = (t, a, u) => cb((p, y) => {
    u(p, t, a);
  }), Gi = (t, a, u, p, y, x) => {
    const k = xs(t), $ = nl(a, [ld("config", t)]);
    return hm(k, $, a, u, p, y, x);
  }, Q2 = (t, a, u, p, y, x) => {
    const k = t, $ = nl(a, [ai("config", t)]);
    return hm(k, $, a, u, p, y, x);
  }, gu = (t, a, u) => fb((y, ...x) => {
    const k = [y].concat(x);
    return y.config({ name: q(t) }).fold(() => {
      throw new Error("We could not find any behaviour configuration for: " + t + ". Using API: " + u);
    }, ($) => {
      const B = Array.prototype.slice.call(k, 1);
      return a.apply(void 0, [
        y,
        $.config,
        $.state
      ].concat(B));
    });
  }, u, a), qk = (t) => ({
    key: t,
    value: void 0
  }), hm = (t, a, u, p, y, x, k) => {
    const $ = (re) => xa(re, u) ? re[u]() : z.none(), B = uo(y, (re, le) => gu(u, re, le)), Y = {
      ...uo(x, (re, le) => K1(re, le)),
      ...B,
      revoke: je(qk, u),
      config: (re) => {
        const le = ya(u + "-config", t, re);
        return {
          key: u,
          value: {
            config: le,
            me: Y,
            configAsRaw: zs(() => ya(u + "-config", t, re)),
            initialConfig: re,
            state: k
          }
        };
      },
      schema: q(a),
      exhibit: (re, le) => gc($(re), fn(p, "exhibit"), (pe, _e) => _e(le, pe.config, pe.state)).getOrThunk(() => pu({})),
      name: q(u),
      handlers: (re) => $(re).map((le) => fn(p, "events").getOr(() => ({}))(le.config, le.state)).getOr({})
    };
    return Y;
  }, mn = (t) => Xn(t), Ow = xs([
    Mt("fields"),
    Mt("name"),
    lt("active", {}),
    lt("apis", {}),
    lt("state", jd),
    lt("extra", {})
  ]), Zi = (t) => {
    const a = ya("Creating behaviour: " + t.name, Ow, t);
    return Gi(a.fields, a.name, a.active, a.apis, a.extra, a.state);
  }, Aw = xs([
    Mt("branchKey"),
    Mt("branches"),
    Mt("name"),
    lt("active", {}),
    lt("apis", {}),
    lt("state", jd),
    lt("extra", {})
  ]), tg = (t) => {
    const a = ya("Creating behaviour: " + t.name, Aw, t);
    return Q2(ro(a.branchKey, a.branches), a.name, a.active, a.apis, a.extra, a.state);
  }, By = q(void 0), vu = Zi({
    fields: lx,
    name: "receiving",
    active: Qm
  });
  var Hy = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    exhibit: (t, a) => pu({
      classes: [],
      styles: a.useFixed() ? {} : { position: "relative" }
    })
  });
  const Fa = (t, a = !1) => t.dom.focus({ preventScroll: a }), gm = (t) => t.dom.blur(), zy = (t) => {
    const a = wt(t).dom;
    return t.dom === a.activeElement;
  }, Xm = (t = Md()) => z.from(t.dom.activeElement).map(nt.fromDom), Nf = (t) => Xm(wt(t)).filter((a) => t.dom.contains(a.dom)), Fn = (t, a) => {
    const u = wt(a), p = Xm(u).bind((x) => {
      const k = ($) => Io(x, $);
      return k(a) ? z.some(a) : ox(a, k);
    }), y = t(a);
    return p.each((x) => {
      Xm(u).filter((k) => Io(k, x)).fold(() => {
        Fa(x);
      }, G);
    }), y;
  }, md = (t, a, u, p, y) => {
    const x = (k) => k + "px";
    return {
      position: t,
      left: a.map(x),
      top: u.map(x),
      right: p.map(x),
      bottom: y.map(x)
    };
  }, kw = (t) => ({
    ...t,
    position: z.some(t.position)
  }), Jm = (t, a) => {
    rn(t, kw(a));
  }, Uo = W.generate([
    { none: [] },
    {
      relative: [
        "x",
        "y",
        "width",
        "height"
      ]
    },
    {
      fixed: [
        "x",
        "y",
        "width",
        "height"
      ]
    }
  ]), Nw = (t, a, u, p, y, x) => {
    const k = a.rect, $ = k.x - u, B = k.y - p, j = k.width, Y = k.height, re = y - ($ + j), le = x - (B + Y), pe = z.some($), _e = z.some(B), ze = z.some(re), ft = z.some(le), Xe = z.none();
    return nh(a.direction, () => md(t, pe, _e, Xe, Xe), () => md(t, Xe, _e, ze, Xe), () => md(t, pe, Xe, Xe, ft), () => md(t, Xe, Xe, ze, ft), () => md(t, pe, _e, Xe, Xe), () => md(t, pe, Xe, Xe, ft), () => md(t, pe, _e, Xe, Xe), () => md(t, Xe, _e, ze, Xe));
  }, pd = (t, a) => t.fold(() => {
    const u = a.rect;
    return md("absolute", z.some(u.x), z.some(u.y), z.none(), z.none());
  }, (u, p, y, x) => Nw("absolute", a, u, p, y, x), (u, p, y, x) => Nw("fixed", a, u, p, y, x)), p0 = (t, a) => {
    const u = je(df, a), p = t.fold(u, u, () => {
      const k = ec();
      return df(a).translate(-k.left, -k.top);
    }), y = Pa(a), x = af(a);
    return cs(p.left, p.top, y, x);
  }, X2 = (t, a) => a.fold(() => t.fold(Ci, Ci, cs), (u) => t.fold(q(u), q(u), () => {
    const p = aa(t, u.x, u.y);
    return cs(p.left, p.top, u.width, u.height);
  })), aa = (t, a, u) => {
    const p = Oo(a, u), y = () => {
      const x = ec();
      return p.translate(-x.left, -x.top);
    };
    return t.fold(q(p), q(p), y);
  }, J2 = (t, a, u, p) => t.fold(a, u, p);
  Uo.none;
  const al = Uo.relative, ng = Uo.fixed, e_ = (t, a) => ({
    anchorBox: t,
    origin: a
  }), t_ = (t, a) => e_(t, a), Rw = "data-alloy-placement", n_ = (t, a) => {
    kn(t, Rw, a);
  }, dx = (t) => as(t, Rw), fx = (t) => vs(t, Rw), Vy = W.generate([
    { fit: ["reposition"] },
    {
      nofit: [
        "reposition",
        "visibleW",
        "visibleH",
        "isVisible"
      ]
    }
  ]), mx = (t, a) => {
    const {
      x: u,
      y: p,
      right: y,
      bottom: x
    } = a, { x: k, y: $, right: B, bottom: j, width: Y, height: re } = t, le = k >= u && k <= y, pe = $ >= p && $ <= x, _e = le && pe, ze = B <= y && B >= u, ft = j <= x && j >= p, Xe = ze && ft, Ze = Math.min(Y, k >= u ? y - k : B - u), mt = Math.min(re, $ >= p ? x - $ : j - p);
    return {
      originInBounds: _e,
      sizeInBounds: Xe,
      visibleW: Ze,
      visibleH: mt
    };
  }, Pw = (t, a) => {
    const {
      x: u,
      y: p,
      right: y,
      bottom: x
    } = a, { x: k, y: $, width: B, height: j } = t, Y = Math.max(u, y - B), re = Math.max(p, x - j), le = fd(k, u, Y), pe = fd($, p, re), _e = Math.min(le + B, y) - le, ze = Math.min(pe + j, x) - pe;
    return cs(le, pe, _e, ze);
  }, cv = (t, a, u) => {
    const p = q(a.bottom - u.y), y = q(u.bottom - a.y), x = l0(t, y, y, p), k = q(a.right - u.x), $ = q(u.right - a.x);
    return {
      maxWidth: $y(t, $, $, k),
      maxHeight: x
    };
  }, r_ = (t, a, u, p) => {
    const y = t.bubble, x = y.offset, k = d0(p, t.restriction, x), $ = t.x + x.left, B = t.y + x.top, j = cs($, B, a, u), { originInBounds: Y, sizeInBounds: re, visibleW: le, visibleH: pe } = mx(j, k), _e = Y && re, ze = _e ? j : Pw(j, k), ft = ze.width > 0 && ze.height > 0, { maxWidth: Xe, maxHeight: Ze } = cv(t.direction, ze, p), mt = {
      rect: ze,
      maxHeight: Ze,
      maxWidth: Xe,
      direction: t.direction,
      placement: t.placement,
      classes: {
        on: y.classesOn,
        off: y.classesOff
      },
      layout: t.label,
      testY: B
    };
    return _e || t.alwaysFit ? Vy.fit(mt) : Vy.nofit(mt, le, pe, ft);
  }, o_ = (t, a, u, p, y, x) => {
    const k = p.width, $ = p.height, B = (Y, re, le, pe, _e) => {
      const ze = Y(u, p, y, t, x), ft = r_(ze, k, $, x);
      return ft.fold(q(ft), (Xe, Ze, mt, jt) => (_e === jt ? mt > pe || Ze > le : !_e && jt) ? ft : Vy.nofit(re, le, pe, _e));
    };
    return Jt(a, (Y, re) => {
      const le = je(B, re);
      return Y.fold(q(Y), le);
    }, Vy.nofit({
      rect: u,
      maxHeight: p.height,
      maxWidth: p.width,
      direction: Iy(),
      placement: "southeast",
      classes: {
        on: [],
        off: []
      },
      layout: "none",
      testY: u.y
    }, -1, -1, !1)).fold(Te, Te);
  }, Dw = (t) => {
    const a = sr(z.none()), u = () => a.get().each(t);
    return {
      clear: () => {
        u(), a.set(z.none());
      },
      isSet: () => a.get().isSome(),
      get: () => a.get(),
      set: ($) => {
        u(), a.set(z.some($));
      }
    };
  }, $w = () => Dw((t) => t.destroy()), sh = () => Dw((t) => t.unbind()), Gr = () => {
    const t = Dw(G);
    return {
      ...t,
      on: (u) => t.get().each(u)
    };
  }, Iw = Lt, Cl = (t, a, u) => Xo(t, a, Iw, u), h0 = (t, a, u) => Rp(t, a, Iw, u), Fc = Qr, bu = [
    "top",
    "bottom",
    "right",
    "left"
  ], g0 = "data-alloy-transition-timer", px = (t, a) => oc(t, a.classes), s_ = (t, a, u) => u.exists((p) => {
    const y = t.mode;
    return y === "all" ? !0 : p[y] !== a[y];
  }), hx = (t, a) => {
    const u = (p) => parseFloat(p).toFixed(3);
    return Co(a, (p, y) => {
      const x = t[y].map(u), k = p.map(u);
      return !Kc(x, k);
    }).isSome();
  }, Nb = (t) => {
    const a = (x) => {
      const $ = na(t, x).split(/\s*,\s*/);
      return Rn($, vc);
    }, u = (x) => {
      if (g(x) && /^[\d.]+/.test(x)) {
        const k = parseFloat(x);
        return Nl(x, "ms") ? k : k * 1e3;
      } else
        return 0;
    }, p = a("transition-delay"), y = a("transition-duration");
    return Jt(y, (x, k, $) => {
      const B = u(p[$]) + u(k);
      return Math.max(x, B);
    }, 0);
  }, gx = (t, a) => {
    const u = sh(), p = sh();
    let y;
    const x = (j) => {
      var Y;
      const re = (Y = j.raw.pseudoElement) !== null && Y !== void 0 ? Y : "";
      return Io(j.target, t) && ea(re) && vt(bu, j.raw.propertyName);
    }, k = (j) => {
      if (ne(j) || x(j)) {
        u.clear(), p.clear();
        const Y = j == null ? void 0 : j.raw.type;
        (ne(Y) || Y === Hp()) && (clearTimeout(y), vs(t, g0), dd(t, a.classes));
      }
    }, $ = Cl(t, xy(), (j) => {
      x(j) && ($.unbind(), u.set(Cl(t, Hp(), k)), p.set(Cl(t, WC(), k)));
    }), B = Nb(t);
    requestAnimationFrame(() => {
      y = setTimeout(k, B + 17), kn(t, g0, y);
    });
  }, Gk = (t, a) => {
    wa(t, a.classes), as(t, g0).each((u) => {
      clearTimeout(parseInt(u, 10)), vs(t, g0);
    }), gx(t, a);
  }, ah = (t, a, u, p, y, x) => {
    const k = s_(p, y, x);
    if (k || px(t, p)) {
      Sr(t, "position", u.position);
      const $ = p0(a, t), B = pd(a, {
        ...y,
        rect: $
      }), j = bn(bu, (Y) => B[Y]);
      hx(u, j) && (rn(t, j), k && Gk(t, p), Qc(t));
    } else
      dd(t, p.classes);
  }, a_ = (t) => ({
    width: Pa(t),
    height: af(t)
  }), Rb = (t, a, u, p) => {
    Ur(a, "max-height"), Ur(a, "max-width");
    const y = a_(a);
    return o_(a, p.preference, t, y, u, p.bounds);
  }, i_ = (t, a) => {
    const u = a.classes;
    dd(t, u.off), wa(t, u.on);
  }, v0 = (t, a, u) => {
    const p = u.maxHeightFunction;
    p(t, a.maxHeight);
  }, Mw = (t, a, u) => {
    const p = u.maxWidthFunction;
    p(t, a.maxWidth);
  }, lv = (t, a, u) => {
    const p = pd(u.origin, a);
    u.transition.each((y) => {
      ah(t, u.origin, p, y, a, u.lastPlacement);
    }), Jm(t, p);
  }, c_ = (t, a) => {
    n_(t, a.placement);
  }, vx = (t, a) => {
    _a(t, Math.floor(a));
  }, bx = q((t, a) => {
    vx(t, a), Rc(t, {
      "overflow-x": "hidden",
      "overflow-y": "auto"
    });
  }), vm = q((t, a) => {
    vx(t, a);
  }), yx = (t, a, u) => t[a] === void 0 ? u : t[a], Fw = (t, a, u, p, y, x, k, $) => {
    const B = yx(k, "maxHeightFunction", bx()), j = yx(k, "maxWidthFunction", G), Y = t.anchorBox, re = t.origin, le = {
      bounds: X2(re, x),
      origin: re,
      preference: p,
      maxHeightFunction: B,
      maxWidthFunction: j,
      lastPlacement: y,
      transition: $
    };
    return l_(Y, a, u, le);
  }, l_ = (t, a, u, p) => {
    const y = Rb(t, a, u, p);
    return lv(a, y, p), c_(a, y), i_(a, y), v0(a, y, p), Mw(a, y, p), {
      layout: y.layout,
      placement: y.placement
    };
  }, Sx = [
    "valignCentre",
    "alignLeft",
    "alignRight",
    "alignCentre",
    "top",
    "bottom",
    "left",
    "right",
    "inset"
  ], ep = (t, a, u, p = 1) => {
    const y = t * p, x = a * p, k = (B) => fn(u, B).getOr([]), $ = (B, j, Y) => {
      const re = ht(Sx, Y);
      return {
        offset: Oo(B, j),
        classesOn: ke(Y, k),
        classesOff: ke(re, k)
      };
    };
    return {
      southeast: () => $(-t, a, [
        "top",
        "alignLeft"
      ]),
      southwest: () => $(t, a, [
        "top",
        "alignRight"
      ]),
      south: () => $(-t / 2, a, [
        "top",
        "alignCentre"
      ]),
      northeast: () => $(-t, -a, [
        "bottom",
        "alignLeft"
      ]),
      northwest: () => $(t, -a, [
        "bottom",
        "alignRight"
      ]),
      north: () => $(-t / 2, -a, [
        "bottom",
        "alignCentre"
      ]),
      east: () => $(t, -a / 2, [
        "valignCentre",
        "left"
      ]),
      west: () => $(-t, -a / 2, [
        "valignCentre",
        "right"
      ]),
      insetNortheast: () => $(y, x, [
        "top",
        "alignLeft",
        "inset"
      ]),
      insetNorthwest: () => $(-y, x, [
        "top",
        "alignRight",
        "inset"
      ]),
      insetNorth: () => $(-y / 2, x, [
        "top",
        "alignCentre",
        "inset"
      ]),
      insetSoutheast: () => $(y, -x, [
        "bottom",
        "alignLeft",
        "inset"
      ]),
      insetSouthwest: () => $(-y, -x, [
        "bottom",
        "alignRight",
        "inset"
      ]),
      insetSouth: () => $(-y / 2, -x, [
        "bottom",
        "alignCentre",
        "inset"
      ]),
      insetEast: () => $(-y, -x / 2, [
        "valignCentre",
        "right",
        "inset"
      ]),
      insetWest: () => $(y, -x / 2, [
        "valignCentre",
        "left",
        "inset"
      ])
    };
  }, Pb = () => ep(0, 0, {}), Db = Te, b0 = (t, a) => (u) => Uy(u) === "rtl" ? a : t, Uy = (t) => na(t, "direction") === "rtl" ? "rtl" : "ltr";
  var Gd;
  (function(t) {
    t.TopToBottom = "toptobottom", t.BottomToTop = "bottomtotop";
  })(Gd || (Gd = {}));
  const $b = "data-alloy-vertical-dir", Wy = (t) => gw(t, (a) => $o(a) && ca(a, "data-alloy-vertical-dir") === Gd.BottomToTop), rg = () => nl("layouts", [
    Mt("onLtr"),
    Mt("onRtl"),
    Fo("onBottomLtr"),
    Fo("onBottomRtl")
  ]), y0 = (t, a, u, p, y, x, k) => {
    const $ = k.map(Wy).getOr(!1), B = a.layouts.map((pe) => pe.onLtr(t)), j = a.layouts.map((pe) => pe.onRtl(t)), Y = $ ? a.layouts.bind((pe) => pe.onBottomLtr.map((_e) => _e(t))).or(B).getOr(y) : B.getOr(u), re = $ ? a.layouts.bind((pe) => pe.onBottomRtl.map((_e) => _e(t))).or(j).getOr(x) : j.getOr(p);
    return b0(Y, re)(t);
  }, u_ = (t, a, u) => {
    const p = a.hotspot, y = p0(u, p.element), x = y0(t.element, a, m0(), Tw(), xw(), cx(), z.some(a.hotspot.element));
    return z.some(Db({
      anchorBox: y,
      bubble: a.bubble.getOr(Pb()),
      overrides: a.overrides,
      layouts: x
    }));
  };
  var d_ = [
    Mt("hotspot"),
    Fo("bubble"),
    lt("overrides", {}),
    rg(),
    ds("placement", u_)
  ];
  const wx = (t, a, u) => {
    const p = aa(u, a.x, a.y), y = cs(p.left, p.top, a.width, a.height), x = y0(t.element, a, Ym(), Ly(), Ym(), Ly(), z.none());
    return z.some(Db({
      anchorBox: y,
      bubble: a.bubble,
      overrides: a.overrides,
      layouts: x
    }));
  };
  var f_ = [
    Mt("x"),
    Mt("y"),
    lt("height", 0),
    lt("width", 0),
    lt("bubble", Pb()),
    lt("overrides", {}),
    rg(),
    ds("placement", wx)
  ];
  const Lw = W.generate([
    { screen: ["point"] },
    {
      absolute: [
        "point",
        "scrollLeft",
        "scrollTop"
      ]
    }
  ]), m_ = (t) => t.fold(Te, (a, u, p) => a.translate(-u, -p)), p_ = (t) => t.fold(Te, Te), Ex = (t) => Jt(t, (a, u) => a.translate(u.left, u.top), Oo(0, 0)), h_ = (t) => {
    const a = He(t, m_);
    return Ex(a);
  }, Cx = (t) => {
    const a = He(t, p_);
    return Ex(a);
  }, g_ = Lw.screen, S0 = Lw.absolute, v_ = (t, a, u) => {
    const p = nu(u.root).dom, y = (x) => {
      const k = ti(x), $ = ti(t.element);
      return Io(k, $);
    };
    return z.from(p.frameElement).map(nt.fromDom).filter(y).map(Jc);
  }, xx = (t, a, u) => {
    const p = ti(t.element), y = ec(p), x = v_(t, a, u).getOr(y);
    return S0(x, y.left, y.top);
  }, Ib = (t, a, u, p) => {
    const y = g_(Oo(t, a));
    return z.some(ff(y, u, p));
  }, Bw = (t, a, u, p, y) => t.map((x) => {
    const k = [
      a,
      x.point
    ], $ = J2(p, () => Cx(k), () => Cx(k), () => h_(k)), B = rm($.left, $.top, x.width, x.height), j = u.showAbove ? xw() : m0(), Y = u.showAbove ? cx() : Tw(), re = y0(y, u, j, Y, j, Y, z.none());
    return Db({
      anchorBox: B,
      bubble: u.bubble.getOr(Pb()),
      overrides: u.overrides,
      layouts: re
    });
  }), Hw = (t, a, u) => {
    const p = xx(t, u, a);
    return a.node.filter(fo).bind((y) => {
      const x = y.dom.getBoundingClientRect(), k = Ib(x.left, x.top, x.width, x.height), $ = a.node.getOr(t.element);
      return Bw(k, p, a, u, $);
    });
  };
  var zw = [
    Mt("node"),
    Mt("root"),
    Fo("bubble"),
    rg(),
    lt("overrides", {}),
    lt("showAbove", !1),
    ds("placement", Hw)
  ];
  const w0 = "\uFEFF", E0 = "", C0 = { create: (t, a, u, p) => ({
    start: t,
    soffset: a,
    finish: u,
    foffset: p
  }) }, x0 = W.generate([
    { before: ["element"] },
    {
      on: [
        "element",
        "offset"
      ]
    },
    { after: ["element"] }
  ]), b_ = (t, a, u, p) => t.fold(a, u, p), jy = (t) => t.fold(Te, Te, Te), _x = x0.before, y_ = x0.on, Vw = x0.after, hd = {
    before: _x,
    on: y_,
    after: Vw,
    cata: b_,
    getStart: jy
  }, og = W.generate([
    { domRange: ["rng"] },
    {
      relative: [
        "startSitu",
        "finishSitu"
      ]
    },
    {
      exact: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    }
  ]), S_ = (t) => og.exact(t.start, t.soffset, t.finish, t.foffset), Uw = (t) => t.match({
    domRange: (a) => nt.fromDom(a.startContainer),
    relative: (a, u) => hd.getStart(a),
    exact: (a, u, p, y) => a
  }), w_ = og.domRange, E_ = og.relative, Ww = og.exact, Ox = (t) => {
    const a = Uw(t);
    return nu(a);
  }, jw = C0.create, Tc = {
    domRange: w_,
    relative: E_,
    exact: Ww,
    exactFromRange: S_,
    getWin: Ox,
    range: jw
  }, Zk = (t, a) => {
    a.fold((u) => {
      t.setStartBefore(u.dom);
    }, (u, p) => {
      t.setStart(u.dom, p);
    }, (u) => {
      t.setStartAfter(u.dom);
    });
  }, Mb = (t, a) => {
    a.fold((u) => {
      t.setEndBefore(u.dom);
    }, (u, p) => {
      t.setEnd(u.dom, p);
    }, (u) => {
      t.setEndAfter(u.dom);
    });
  }, T0 = (t, a, u) => {
    const p = t.document.createRange();
    return Zk(p, a), Mb(p, u), p;
  }, qw = (t, a, u, p, y) => {
    const x = t.document.createRange();
    return x.setStart(a.dom, u), x.setEnd(p.dom, y), x;
  }, Gw = (t) => ({
    left: t.left,
    top: t.top,
    right: t.right,
    bottom: t.bottom,
    width: t.width,
    height: t.height
  }), Ax = (t) => {
    const a = t.getClientRects(), u = a.length > 0 ? a[0] : t.getBoundingClientRect();
    return u.width > 0 || u.height > 0 ? z.some(u).map(Gw) : z.none();
  }, kx = (t) => {
    const a = t.getBoundingClientRect();
    return a.width > 0 || a.height > 0 ? z.some(a).map(Gw) : z.none();
  }, ih = W.generate([
    {
      ltr: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    },
    {
      rtl: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    }
  ]), uv = (t, a, u) => a(nt.fromDom(u.startContainer), u.startOffset, nt.fromDom(u.endContainer), u.endOffset), C_ = (t, a) => a.match({
    domRange: (u) => ({
      ltr: q(u),
      rtl: z.none
    }),
    relative: (u, p) => ({
      ltr: zs(() => T0(t, u, p)),
      rtl: zs(() => z.some(T0(t, p, u)))
    }),
    exact: (u, p, y, x) => ({
      ltr: zs(() => qw(t, u, p, y, x)),
      rtl: zs(() => z.some(qw(t, y, x, u, p)))
    })
  }), x_ = (t, a) => {
    const u = a.ltr();
    return u.collapsed ? a.rtl().filter((y) => y.collapsed === !1).map((y) => ih.rtl(nt.fromDom(y.endContainer), y.endOffset, nt.fromDom(y.startContainer), y.startOffset)).getOrThunk(() => uv(t, ih.ltr, u)) : uv(t, ih.ltr, u);
  }, qy = (t, a) => {
    const u = C_(t, a);
    return x_(t, u);
  }, Zw = (t, a) => qy(t, a).match({
    ltr: (p, y, x, k) => {
      const $ = t.document.createRange();
      return $.setStart(p.dom, y), $.setEnd(x.dom, k), $;
    },
    rtl: (p, y, x, k) => {
      const $ = t.document.createRange();
      return $.setStart(x.dom, k), $.setEnd(p.dom, y), $;
    }
  });
  ih.ltr, ih.rtl;
  const Nx = (t, a, u) => Rn(km(t, u), a), Ki = (t, a) => yc(a, t), Rx = (t, a, u, p) => {
    const x = ti(t).dom.createRange();
    return x.setStart(t.dom, a), x.setEnd(u.dom, p), x;
  }, Kw = (t, a, u, p) => {
    const y = Rx(t, a, u, p), x = Io(t, u) && a === p;
    return y.collapsed && !x;
  }, Kk = (t) => z.from(t.getSelection()), Fb = (t) => {
    if (t.rangeCount > 0) {
      const a = t.getRangeAt(0), u = t.getRangeAt(t.rangeCount - 1);
      return z.some(C0.create(nt.fromDom(a.startContainer), a.startOffset, nt.fromDom(u.endContainer), u.endOffset));
    } else
      return z.none();
  }, T_ = (t) => {
    if (t.anchorNode === null || t.focusNode === null)
      return Fb(t);
    {
      const a = nt.fromDom(t.anchorNode), u = nt.fromDom(t.focusNode);
      return Kw(a, t.anchorOffset, u, t.focusOffset) ? z.some(C0.create(a, t.anchorOffset, u, t.focusOffset)) : Fb(t);
    }
  }, Px = (t) => Kk(t).filter((a) => a.rangeCount > 0).bind(T_), Yw = (t, a) => {
    const u = Zw(t, a);
    return Ax(u);
  }, Gy = (t, a) => {
    const u = Zw(t, a);
    return kx(u);
  }, Lb = ((t, a) => {
    const u = (x) => {
      if (!t(x))
        throw new Error("Can only get " + a + " value of a " + a + " node");
      return p(x).getOr("");
    }, p = (x) => t(x) ? z.from(x.dom.nodeValue) : z.none();
    return {
      get: u,
      getOption: p,
      set: (x, k) => {
        if (!t(x))
          throw new Error("Can only set raw " + a + " value of a " + a + " node");
        x.dom.nodeValue = k;
      }
    };
  })(ei, "text"), __ = (t) => Lb.get(t), sg = (t, a) => ({
    element: t,
    offset: a
  }), Dx = (t, a) => {
    const u = Nc(t);
    if (u.length === 0)
      return sg(t, a);
    if (a < u.length)
      return sg(u[a], 0);
    {
      const p = u[u.length - 1], y = ei(p) ? __(p).length : Nc(p).length;
      return sg(p, y);
    }
  }, ag = (t, a) => ei(t) ? sg(t, a) : Dx(t, a), ig = (t) => t.foffset !== void 0, S = (t, a) => a.getSelection.getOrThunk(() => () => Px(t))().map((p) => {
    if (ig(p)) {
      const y = ag(p.start, p.soffset), x = ag(p.finish, p.foffset);
      return Tc.range(y.element, y.offset, x.element, x.offset);
    } else
      return p;
  }), T = (t, a, u) => {
    const p = nu(a.root).dom, y = xx(t, u, a), x = S(p, a).bind((B) => {
      if (ig(B))
        return Gy(p, Tc.exactFromRange(B)).orThunk(() => {
          const Y = nt.fromText(w0);
          $a(B.start, Y);
          const re = Yw(p, Tc.exact(Y, 0, Y, 1));
          return ou(Y), re;
        }).bind((Y) => Ib(Y.left, Y.top, Y.width, Y.height));
      {
        const j = uo(B, (re) => re.dom.getBoundingClientRect()), Y = {
          left: Math.min(j.firstCell.left, j.lastCell.left),
          right: Math.max(j.firstCell.right, j.lastCell.right),
          top: Math.min(j.firstCell.top, j.lastCell.top),
          bottom: Math.max(j.firstCell.bottom, j.lastCell.bottom)
        };
        return Ib(Y.left, Y.top, Y.right - Y.left, Y.bottom - Y.top);
      }
    }), $ = S(p, a).bind((B) => ig(B) ? $o(B.start) ? z.some(B.start) : $l(B.start) : z.some(B.firstCell)).getOr(t.element);
    return Bw(x, y, a, u, $);
  };
  var F = [
    Fo("getSelection"),
    Mt("root"),
    Fo("bubble"),
    rg(),
    lt("overrides", {}),
    lt("showAbove", !1),
    ds("placement", T)
  ];
  const ee = "link-layout", ge = (t) => t.x + t.width, De = (t, a) => t.x - a.width, Qe = (t, a) => t.y - a.height + t.height, it = (t) => t.y, At = (t, a, u) => bi(ge(t), it(t), u.southeast(), Iy(), "southeast", sa(t, {
    left: 0,
    top: 2
  }), ee), vn = (t, a, u) => bi(De(t, a), it(t), u.southwest(), yw(), "southwest", sa(t, {
    right: 1,
    top: 2
  }), ee), gn = (t, a, u) => bi(ge(t), Qe(t, a), u.northeast(), u0(), "northeast", sa(t, {
    left: 0,
    bottom: 3
  }), ee), Nn = (t, a, u) => bi(De(t, a), Qe(t, a), u.northwest(), qd(), "northwest", sa(t, {
    right: 1,
    bottom: 3
  }), ee), ir = () => [
    At,
    vn,
    gn,
    Nn
  ], Dr = () => [
    vn,
    At,
    Nn,
    gn
  ], io = (t, a, u) => {
    const p = p0(u, a.item.element), y = y0(t.element, a, ir(), Dr(), ir(), Dr(), z.none());
    return z.some(Db({
      anchorBox: p,
      bubble: Pb(),
      overrides: a.overrides,
      layouts: y
    }));
  };
  var Bo = [
    Mt("item"),
    rg(),
    lt("overrides", {}),
    ds("placement", io)
  ], eo = ro("type", {
    selection: F,
    node: zw,
    hotspot: d_,
    submenu: Bo,
    makeshift: f_
  });
  const fs = [
    tc("classes", xi),
    vl("mode", "all", [
      "all",
      "layout",
      "placement"
    ])
  ], As = [
    lt("useFixed", sn),
    Fo("getBounds")
  ], Lc = [
    $c("anchor", eo),
    nl("transition", fs)
  ], xl = () => {
    const t = document.documentElement;
    return ng(0, 0, t.clientWidth, t.clientHeight);
  }, Zd = (t) => {
    const a = Jc(t.element), u = t.element.dom.getBoundingClientRect();
    return al(a.left, a.top, u.width, u.height);
  }, sc = (t, a, u, p, y, x) => {
    const k = t_(a.anchorBox, t);
    return Fw(k, p.element, a.bubble, a.layouts, y, u, a.overrides, x);
  }, Kd = (t, a, u, p, y) => {
    const x = z.none();
    Ms(t, a, u, p, y, x);
  }, Ms = (t, a, u, p, y, x) => {
    const k = ya("placement.info", jn(Lc), y), $ = k.anchor, B = p.element, j = u.get(p.uid);
    Fn(() => {
      Sr(B, "position", "fixed");
      const Y = Ta(B, "visibility");
      Sr(B, "visibility", "hidden");
      const re = a.useFixed() ? xl() : Zd(t);
      $.placement(t, $, re).each((le) => {
        const pe = x.orThunk(() => a.getBounds.map(pt)), _e = sc(re, le, pe, p, j, k.transition);
        u.set(p.uid, _e);
      }), Y.fold(() => {
        Ur(B, "visibility");
      }, (le) => {
        Sr(B, "visibility", le);
      }), Ta(B, "left").isNone() && Ta(B, "top").isNone() && Ta(B, "right").isNone() && Ta(B, "bottom").isNone() && $i(Ta(B, "position"), "fixed") && Ur(B, "position");
    }, B);
  };
  var Yk = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    position: Kd,
    positionWithinBounds: Ms,
    getMode: (t, a, u) => a.useFixed() ? "fixed" : "absolute",
    reset: (t, a, u, p) => {
      const y = p.element;
      ut([
        "position",
        "left",
        "right",
        "top",
        "bottom"
      ], (x) => Ur(y, x)), fx(y), u.clear(p.uid);
    }
  }), Bb = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: () => {
      let t = {};
      return ol({
        readState: () => t,
        clear: (y) => {
          se(y) ? delete t[y] : t = {};
        },
        set: (y, x) => {
          t[y] = x;
        },
        get: (y) => fn(t, y)
      });
    }
  });
  const Wl = Zi({
    fields: As,
    name: "positioning",
    active: Hy,
    apis: Yk,
    state: Bb
  }), O0 = (t) => t.getSystem().isConnected(), Qw = (t) => {
    Jr(t, Vd());
    const a = t.components();
    ut(a, Qw);
  }, A0 = (t) => {
    const a = t.components();
    ut(a, A0), Jr(t, Vl());
  }, A_ = (t, a) => {
    t.getSystem().addToWorld(a), fo(t.element) && A0(a);
  }, k0 = (t) => {
    Qw(t), t.getSystem().removeFromWorld(t);
  }, Zy = (t, a) => {
    oi(t.element, a.element);
  }, ch = (t) => {
    ut(t.components(), (a) => ou(a.element)), ys(t.element), t.syncComponents();
  }, gI = (t, a, u) => {
    const p = t.components();
    ch(t);
    const y = u(a), x = ht(p, y);
    ut(x, (k) => {
      Qw(k), t.getSystem().removeFromWorld(k);
    }), ut(y, (k) => {
      O0(k) ? Zy(t, k) : (t.getSystem().addToWorld(k), Zy(t, k), fo(t.element) && A0(k));
    }), t.syncComponents();
  }, vI = (t, a, u) => {
    const p = t.components(), y = ke(a, ($) => pb($).toArray());
    ut(p, ($) => {
      vt(y, $) || k0($);
    });
    const x = u(a), k = ht(p, x);
    ut(k, ($) => {
      O0($) && k0($);
    }), ut(x, ($) => {
      O0($) || A_(t, $);
    }), t.syncComponents();
  }, Hb = (t, a) => {
    N0(t, a, oi);
  }, N0 = (t, a, u) => {
    t.getSystem().addToWorld(a), u(t.element, a.element), fo(t.element) && A0(a), t.syncComponents();
  }, Ix = (t) => {
    Qw(t), ou(t.element), t.getSystem().removeFromWorld(t);
  }, cg = (t) => {
    const a = Ii(t.element).bind((u) => t.getSystem().getByDom(u).toOptional());
    Ix(t), a.each((u) => {
      u.syncComponents();
    });
  }, k_ = (t) => {
    const a = t.components();
    ut(a, Ix), ys(t.element), t.syncComponents();
  }, il = (t, a) => {
    tp(t, a, oi);
  }, fv = (t, a) => {
    tp(t, a, Hl);
  }, tp = (t, a, u) => {
    u(t, a.element);
    const p = Nc(a.element);
    ut(p, (y) => {
      a.getByDom(y).each(A0);
    });
  }, R0 = (t) => {
    const a = Nc(t.element);
    ut(a, (u) => {
      t.getByDom(u).each(Qw);
    }), ou(t.element);
  }, yu = (t, a, u, p) => {
    u.get().each((k) => {
      k_(t);
    });
    const y = a.getAttachPoint(t);
    Hb(y, t);
    const x = t.getSystem().build(p);
    return Hb(t, x), u.set(x), x;
  }, gd = (t, a, u, p) => {
    const y = yu(t, a, u, p);
    return a.onOpen(t, y), y;
  }, Wu = (t, a, u, p) => u.get().map(() => yu(t, a, u, p)), np = (t, a, u, p, y) => {
    Xw(t, a), gd(t, a, u, p), y(), Jw(t, a);
  }, Mx = (t, a, u) => {
    u.get().each((p) => {
      k_(t), cg(t), a.onClose(t, p), u.clear();
    });
  }, Rf = (t, a, u) => u.isOpen(), Ky = (t, a, u, p) => Rf(t, a, u) && u.get().exists((y) => a.isPartOf(t, y, p)), N_ = (t, a, u) => u.get(), bI = (t, a, u, p) => {
    Ta(t.element, a).fold(() => {
      vs(t.element, u);
    }, (y) => {
      kn(t.element, u, y);
    }), Sr(t.element, a, p);
  }, Qk = (t, a, u) => {
    as(t.element, u).fold(() => Ur(t.element, a), (p) => Sr(t.element, a, p));
  }, Xw = (t, a, u) => {
    const p = a.getAttachPoint(t);
    Sr(t.element, "position", Wl.getMode(p)), bI(t, "visibility", a.cloakVisibilityAttr, "hidden");
  }, Xk = (t) => Gt([
    "top",
    "left",
    "right",
    "bottom"
  ], (a) => Ta(t, a).isSome()), Jw = (t, a, u) => {
    Xk(t.element) || Ur(t.element, "position"), Qk(t, "visibility", a.cloakVisibilityAttr);
  };
  var Fx = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    cloak: Xw,
    decloak: Jw,
    open: gd,
    openWhileCloaked: np,
    close: Mx,
    isOpen: Rf,
    isPartOf: Ky,
    getState: N_,
    setContent: Wu
  }), Jk = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: (t, a) => ls([Pt(Ty(), (u, p) => {
      Mx(u, t, a);
    })])
  }), SI = [
    po("onOpen"),
    po("onClose"),
    Mt("isPartOf"),
    Mt("getAttachPoint"),
    lt("cloakVisibilityAttr", "data-precloak-visibility")
  ], eN = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: () => {
      const t = Gr(), a = q("not-implemented");
      return ol({
        readState: a,
        isOpen: t.isSet,
        clear: t.clear,
        set: t.set,
        get: t.get
      });
    }
  });
  const bo = Zi({
    fields: SI,
    name: "sandboxing",
    active: Jk,
    apis: Fx,
    state: eN
  }), lh = q("dismiss.popups"), Yy = q("reposition.popups"), R_ = q("mouse.released"), tN = xs([
    lt("isExtraPart", sn),
    nl("fireEventInstead", [lt("event", jp())])
  ]), eE = (t) => {
    const a = ya("Dismissal", tN, t);
    return {
      [lh()]: {
        schema: xs([Mt("target")]),
        onReceive: (u, p) => {
          bo.isOpen(u) && (bo.isPartOf(u, p.target) || a.isExtraPart(u, p.target) || a.fireEventInstead.fold(() => bo.close(u), (x) => Jr(u, x.event)));
        }
      }
    };
  }, wI = xs([
    nl("fireEventInstead", [lt("event", ow())]),
    id("doReposition")
  ]), P0 = (t) => {
    const a = ya("Reposition", wI, t);
    return {
      [Yy()]: {
        onReceive: (u) => {
          bo.isOpen(u) && a.fireEventInstead.fold(() => a.doReposition(u), (p) => Jr(u, p.event));
        }
      }
    };
  }, Lx = (t, a, u) => {
    a.store.manager.onLoad(t, a, u);
  }, Pf = (t, a, u) => {
    a.store.manager.onUnload(t, a, u);
  };
  var zb = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    onLoad: Lx,
    onUnload: Pf,
    setValue: (t, a, u, p) => {
      a.store.manager.setValue(t, a, u, p);
    },
    getValue: (t, a, u) => a.store.manager.getValue(t, a, u),
    getState: (t, a, u) => u
  }), zx = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: (t, a) => {
      const u = t.resetOnDom ? [
        us((p, y) => {
          Lx(p, t, a);
        }),
        Tf((p, y) => {
          Pf(p, t, a);
        })
      ] : [li(t, a, Lx)];
      return ls(u);
    }
  });
  const Qy = () => {
    const t = sr(null), a = () => ({
      mode: "memory",
      value: t.get()
    }), u = () => t.get() === null, p = () => {
      t.set(null);
    };
    return ol({
      set: t.set,
      get: t.get,
      isNotSet: u,
      clear: p,
      readState: a
    });
  }, EI = () => ol({ readState: G }), nN = () => {
    const t = sr({}), a = sr({});
    return ol({
      readState: () => ({
        mode: "dataset",
        dataByValue: t.get(),
        dataByText: a.get()
      }),
      lookup: (k) => fn(t.get(), k).orThunk(() => fn(a.get(), k)),
      update: (k) => {
        const $ = t.get(), B = a.get(), j = {}, Y = {};
        ut(k, (re) => {
          j[re.value] = re, fn(re, "meta").each((le) => {
            fn(le, "text").each((pe) => {
              Y[pe] = re;
            });
          });
        }), t.set({
          ...$,
          ...j
        }), a.set({
          ...B,
          ...Y
        });
      },
      clear: () => {
        t.set({}), a.set({});
      }
    });
  };
  var $0 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    memory: Qy,
    dataset: nN,
    manual: EI,
    init: (t) => t.store.manager.state(t)
  });
  const mv = (t, a, u, p) => {
    const y = a.store;
    u.update([p]), y.setValue(t, p), a.onSetValue(t, p);
  }, xI = (t, a, u) => {
    const p = a.store, y = p.getDataKey(t);
    return u.lookup(y).getOrThunk(() => p.getFallbackEntry(y));
  }, TI = (t, a, u) => {
    a.store.initialValue.each((y) => {
      mv(t, a, u, y);
    });
  }, rN = (t, a, u) => {
    u.clear();
  };
  var P_ = [
    Fo("initialValue"),
    Mt("getFallbackEntry"),
    Mt("getDataKey"),
    Mt("setValue"),
    ds("manager", {
      setValue: mv,
      getValue: xI,
      onLoad: TI,
      onUnload: rN,
      state: nN
    })
  ];
  const D_ = (t, a, u) => a.store.getValue(t), $_ = (t, a, u, p) => {
    a.store.setValue(t, p), a.onSetValue(t, p);
  }, Vx = (t, a, u) => {
    a.store.initialValue.each((p) => {
      a.store.setValue(t, p);
    });
  };
  var Vb = [
    Mt("getValue"),
    lt("setValue", G),
    Fo("initialValue"),
    ds("manager", {
      setValue: $_,
      getValue: D_,
      onLoad: Vx,
      onUnload: G,
      state: jd.init
    })
  ];
  const oN = (t, a, u, p) => {
    u.set(p), a.onSetValue(t, p);
  }, tE = (t, a, u) => u.get(), I_ = (t, a, u) => {
    a.store.initialValue.each((p) => {
      u.isNotSet() && u.set(p);
    });
  }, _I = (t, a, u) => {
    u.clear();
  };
  var nE = [
    Fo("initialValue"),
    ds("manager", {
      setValue: oN,
      getValue: tE,
      onLoad: I_,
      onUnload: _I,
      state: Qy
    })
  ], OI = [
    gl("store", { mode: "memory" }, ro("mode", {
      memory: nE,
      manual: Vb,
      dataset: P_
    })),
    po("onSetValue"),
    lt("resetOnDom", !1)
  ];
  const Pn = Zi({
    fields: OI,
    name: "representing",
    active: zx,
    apis: zb,
    extra: {
      setValueFrom: (t, a) => {
        const u = Pn.getValue(a);
        Pn.setValue(t, u);
      }
    },
    state: $0
  }), ac = (t, a) => vf(t, {}, He(a, (u) => cd(u.name(), "Cannot configure " + u.name() + " for " + t)).concat([Ts("dump", Te)])), pv = (t) => t.dump, _i = (t, a) => ({
    ...mn(a),
    ...t.dump
  }), bm = {
    field: ac,
    augment: _i,
    get: pv
  }, Ux = "placeholder", rE = W.generate([
    {
      single: [
        "required",
        "valueThunk"
      ]
    },
    {
      multiple: [
        "required",
        "valueThunks"
      ]
    }
  ]), uh = (t) => Yr(t, "uiType"), Wx = (t, a, u, p) => t.exists((y) => y !== u.owner) ? rE.single(!0, q(u)) : fn(p, u.name).fold(() => {
    throw new Error("Unknown placeholder component: " + u.name + `
Known: [` + Xr(p) + `]
Namespace: ` + t.getOr("none") + `
Spec: ` + JSON.stringify(u, null, 2));
  }, (y) => y.replace()), jx = (t, a, u, p) => uh(u) && u.uiType === Ux ? Wx(t, a, u, p) : rE.single(!1, q(u)), I0 = (t, a, u, p) => jx(t, a, u, p).fold((x, k) => {
    const $ = uh(u) ? k(a, u.config, u.validated) : k(a), B = fn($, "components").getOr([]), j = ke(B, (Y) => I0(t, a, Y, p));
    return [{
      ...$,
      components: j
    }];
  }, (x, k) => {
    if (uh(u)) {
      const $ = k(a, u.config, u.validated);
      return u.validated.preprocess.getOr(Te)($);
    } else
      return k(a);
  }), sN = (t, a, u, p) => ke(u, (y) => I0(t, a, y, p)), oE = (t, a) => {
    let u = !1;
    const p = () => u, y = () => {
      if (u)
        throw new Error("Trying to use the same placeholder more than once: " + t);
      return u = !0, a;
    }, x = () => a.fold((k, $) => k, (k, $) => k);
    return {
      name: q(t),
      required: x,
      used: p,
      replace: y
    };
  }, M_ = (t, a, u, p) => {
    const y = uo(p, (k, $) => oE($, k)), x = sN(t, a, u, y);
    return Eo(y, (k) => {
      if (k.used() === !1 && k.required())
        throw new Error("Placeholder: " + k.name() + ` was not found in components list
Namespace: ` + t.getOr("none") + `
Components: ` + JSON.stringify(a.components, null, 2));
    }), x;
  }, F_ = rE.single, AI = rE.multiple, dh = q(Ux), qx = W.generate([
    { required: ["data"] },
    { external: ["data"] },
    { optional: ["data"] },
    { group: ["data"] }
  ]), M0 = lt("factory", { sketch: Te }), Tl = lt("schema", []), Yi = Mt("name"), Gx = si("pname", "pname", zi((t) => "<alloy." + Hn(t.name) + ">"), Ua()), sE = Ts("schema", () => [Fo("preprocess")]), Zx = lt("defaults", q({})), aE = lt("overrides", q({})), iE = jn([
    M0,
    Tl,
    Yi,
    Gx,
    Zx,
    aE
  ]), F0 = jn([
    M0,
    Tl,
    Yi,
    Zx,
    aE
  ]), aN = jn([
    M0,
    Tl,
    Yi,
    Gx,
    Zx,
    aE
  ]), cE = jn([
    M0,
    sE,
    Yi,
    Mt("unit"),
    Gx,
    Zx,
    aE
  ]), iN = (t) => t.fold(z.some, z.none, z.some, z.some), cN = (t) => {
    const a = (u) => u.name;
    return t.fold(a, a, a, a);
  }, lN = (t) => t.fold(Te, Te, Te, Te), ym = (t, a) => (u) => {
    const p = ya("Converting part type", a, u);
    return t(p);
  }, jl = ym(qx.required, iE), rp = ym(qx.external, F0), vd = ym(qx.optional, aN), lE = ym(qx.group, cE), Kx = q("entirety");
  var uN = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    required: jl,
    external: rp,
    optional: vd,
    group: lE,
    asNamedPart: iN,
    name: cN,
    asCommon: lN,
    original: Kx
  });
  const uE = (t, a, u, p) => Vo(a.defaults(t, u, p), u, { uid: t.partUids[a.name] }, a.overrides(t, u, p)), kI = (t, a, u) => {
    const p = {}, y = {};
    return ut(u, (x) => {
      x.fold((k) => {
        p[k.pname] = F_(!0, ($, B, j) => k.factory.sketch(uE($, k, B, j)));
      }, (k) => {
        const $ = a.parts[k.name];
        y[k.name] = q(k.factory.sketch(uE(a, k, $[Kx()]), $));
      }, (k) => {
        p[k.pname] = F_(!1, ($, B, j) => k.factory.sketch(uE($, k, B, j)));
      }, (k) => {
        p[k.pname] = AI(!0, ($, B, j) => {
          const Y = $[k.name];
          return He(Y, (re) => k.factory.sketch(Vo(k.defaults($, re, j), re, k.overrides($, re))));
        });
      });
    }), {
      internals: q(p),
      externals: q(y)
    };
  }, hv = (t, a) => {
    const u = {};
    return ut(a, (p) => {
      iN(p).each((y) => {
        const x = dE(t, y.pname);
        u[y.name] = (k) => {
          const $ = ya("Part: " + y.name + " in " + t, jn(y.schema), k);
          return {
            ...x,
            config: k,
            validated: $
          };
        };
      });
    }), u;
  }, dE = (t, a) => ({
    uiType: dh(),
    owner: t,
    name: a
  }), L_ = (t, a, u) => ({
    uiType: dh(),
    owner: t,
    name: a,
    config: u,
    validated: {}
  }), dN = (t) => ke(t, (a) => a.fold(z.none, z.some, z.none, z.none).map((u) => lu(u.name, u.schema.concat([Ab(Kx())]))).toArray()), fN = (t) => He(t, cN), B_ = (t, a, u) => kI(t, a, u), Yx = (t, a, u) => M_(z.some(t), a, a.components, u), Fs = (t, a, u) => {
    const p = a.partUids[u];
    return t.getSystem().getByUid(p).toOptional();
  }, gv = (t, a, u) => Fs(t, a, u).getOrDie("Could not find part: " + u), mN = (t, a, u) => {
    const p = {}, y = a.partUids, x = t.getSystem();
    return ut(u, (k) => {
      p[k] = q(x.getByUid(y[k]));
    }), p;
  }, H_ = (t, a) => {
    const u = t.getSystem();
    return uo(a.partUids, (p, y) => q(u.getByUid(p)));
  }, z_ = (t) => Xr(t.partUids), Xy = (t, a, u) => {
    const p = {}, y = a.partUids, x = t.getSystem();
    return ut(u, (k) => {
      p[k] = q(x.getByUid(y[k]).getOrDie());
    }), p;
  }, V_ = (t, a) => {
    const u = fN(a);
    return Xn(He(u, (p) => ({
      key: p,
      value: t + "-" + p
    })));
  }, U_ = (t) => si("partUids", "partUids", ye((a) => V_(a.uid, t)), Ua());
  var NI = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    generate: hv,
    generateOne: L_,
    schemas: dN,
    names: fN,
    substitutes: B_,
    components: Yx,
    defaultUids: V_,
    defaultUidsSchema: U_,
    getAllParts: H_,
    getAllPartNames: z_,
    getPart: Fs,
    getPartOrDie: gv,
    getParts: mN,
    getPartsOrDie: Xy
  });
  const L0 = (t, a) => (t.length > 0 ? [lu("parts", t)] : []).concat([
    Mt("uid"),
    lt("dom", {}),
    lt("components", []),
    Ab("originalSpec"),
    lt("debug.sketcher", {})
  ]).concat(a), B0 = (t, a, u, p, y) => {
    const x = L0(p, y);
    return ya(t + " [SpecSchema]", xs(x.concat(a)), u);
  }, W_ = (t, a, u, p) => {
    const y = Ub(p), x = B0(t, a, y, [], []);
    return u(x, y);
  }, j_ = (t, a, u, p, y) => {
    const x = Ub(y), k = dN(u), $ = U_(u), B = B0(t, a, x, k, [$]), j = B_(t, B, u), Y = Yx(t, B, j.internals());
    return p(B, Y, x, j.externals());
  }, op = (t) => Yr(t, "uid"), Ub = (t) => op(t) ? t : {
    ...t,
    uid: db("uid")
  }, RI = (t) => t.uid !== void 0, fE = xs([
    Mt("name"),
    Mt("factory"),
    Mt("configFields"),
    lt("apis", {}),
    lt("extraApis", {})
  ]), PI = xs([
    Mt("name"),
    Mt("factory"),
    Mt("configFields"),
    Mt("partFields"),
    lt("apis", {}),
    lt("extraApis", {})
  ]), Yd = (t) => {
    const a = ya("Sketcher for " + t.name, fE, t), u = (x) => W_(a.name, a.configFields, a.factory, x), p = uo(a.apis, Xp), y = uo(a.extraApis, (x, k) => K1(x, k));
    return {
      name: a.name,
      configFields: a.configFields,
      sketch: u,
      ...p,
      ...y
    };
  }, ql = (t) => {
    const a = ya("Sketcher for " + t.name, PI, t), u = (k) => j_(a.name, a.configFields, a.partFields, a.factory, k), p = hv(a.name, a.partFields), y = uo(a.apis, Xp), x = uo(a.extraApis, (k, $) => K1(k, $));
    return {
      name: a.name,
      partFields: a.partFields,
      configFields: a.configFields,
      sketch: u,
      parts: p,
      ...y,
      ...x
    };
  }, Jy = (t) => Xi("input")(t) && ca(t, "type") !== "radio" || Xi("textarea")(t);
  var pN = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    getCurrent: (t, a, u) => a.find(t)
  });
  const DI = [Mt("find")], ho = Zi({
    fields: DI,
    name: "composing",
    apis: pN
  }), q_ = [
    "input",
    "button",
    "textarea",
    "select"
  ], hN = (t, a, u) => {
    (a.disabled() ? vN : mE)(t, a);
  }, G_ = (t, a) => a.useNative === !0 && vt(q_, kc(t.element)), $I = (t) => _p(t.element, "disabled"), II = (t) => {
    kn(t.element, "disabled", "disabled");
  }, gN = (t) => {
    vs(t.element, "disabled");
  }, MI = (t) => ca(t.element, "aria-disabled") === "true", zn = (t) => {
    kn(t.element, "aria-disabled", "true");
  }, Wb = (t) => {
    kn(t.element, "aria-disabled", "false");
  }, vN = (t, a, u) => {
    a.disableClass.each((y) => {
      ja(t.element, y);
    }), (G_(t, a) ? II : zn)(t), a.onDisabled(t);
  }, mE = (t, a, u) => {
    a.disableClass.each((y) => {
      ua(t.element, y);
    }), (G_(t, a) ? gN : Wb)(t), a.onEnabled(t);
  }, pE = (t, a) => G_(t, a) ? $I(t) : MI(t);
  var l5 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    enable: mE,
    disable: vN,
    isDisabled: pE,
    onLoad: hN,
    set: (t, a, u, p) => {
      (p ? vN : mE)(t, a);
    }
  }), LI = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    exhibit: (t, a) => pu({ classes: a.disabled() ? a.disableClass.toArray() : [] }),
    events: (t, a) => ls([
      j1(Lu(), (u, p) => pE(u, t)),
      li(t, a, hN)
    ])
  }), bN = [
    ii("disabled", sn),
    lt("useNative", !0),
    Fo("disableClass"),
    po("onDisabled"),
    po("onEnabled")
  ];
  const yr = Zi({
    fields: bN,
    name: "disabling",
    active: LI,
    apis: l5
  }), vv = (t, a, u, p) => {
    const y = Ki(t.element, "." + a.highlightClass);
    ut(y, (x) => {
      Gt(p, ($) => Io($.element, x)) || (ua(x, a.highlightClass), t.getSystem().getByDom(x).each(($) => {
        a.onDehighlight(t, $), Jr($, sb());
      }));
    });
  }, yN = (t, a, u) => vv(t, a, u, []), BI = (t, a, u, p) => {
    Qx(t, a, u, p) && (ua(p.element, a.highlightClass), a.onDehighlight(t, p), Jr(p, sb()));
  }, hE = (t, a, u, p) => {
    vv(t, a, u, [p]), Qx(t, a, u, p) || (ja(p.element, a.highlightClass), a.onHighlight(t, p), Jr(p, ob()));
  }, HI = (t, a, u) => {
    H0(t, a).each((p) => {
      hE(t, a, u, p);
    });
  }, SN = (t, a, u) => {
    K_(t, a).each((p) => {
      hE(t, a, u, p);
    });
  }, Z_ = (t, a, u, p) => {
    VI(t, a, u, p).fold((y) => {
      throw y;
    }, (y) => {
      hE(t, a, u, y);
    });
  }, wN = (t, a, u, p) => {
    const y = Xx(t, a);
    Ge(y, p).each((k) => {
      hE(t, a, u, k);
    });
  }, Qx = (t, a, u, p) => Ti(p.element, a.highlightClass), zI = (t, a, u) => qa(t.element, "." + a.highlightClass).bind((p) => t.getSystem().getByDom(p).toOptional()), VI = (t, a, u, p) => {
    const y = Ki(t.element, "." + a.itemClass);
    return z.from(y[p]).fold(() => Rr.error(new Error("No element found with index " + p)), t.getSystem().getByDom);
  }, H0 = (t, a, u) => qa(t.element, "." + a.itemClass).bind((p) => t.getSystem().getByDom(p).toOptional()), K_ = (t, a, u) => {
    const p = Ki(t.element, "." + a.itemClass);
    return (p.length > 0 ? z.some(p[p.length - 1]) : z.none()).bind((x) => t.getSystem().getByDom(x).toOptional());
  }, EN = (t, a, u, p) => {
    const y = Ki(t.element, "." + a.itemClass);
    return qt(y, (k) => Ti(k, a.highlightClass)).bind((k) => {
      const $ = iv(k, p, 0, y.length - 1);
      return t.getSystem().getByDom(y[$]).toOptional();
    });
  }, UI = (t, a, u) => EN(t, a, u, -1), WI = (t, a, u) => EN(t, a, u, 1), Xx = (t, a, u) => {
    const p = Ki(t.element, "." + a.itemClass);
    return wi(He(p, (y) => t.getSystem().getByDom(y).toOptional()));
  };
  var lg = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    dehighlightAll: yN,
    dehighlight: BI,
    highlight: hE,
    highlightFirst: HI,
    highlightLast: SN,
    highlightAt: Z_,
    highlightBy: wN,
    isHighlighted: Qx,
    getHighlighted: zI,
    getFirst: H0,
    getLast: K_,
    getPrevious: UI,
    getNext: WI,
    getCandidates: Xx
  }), Jx = [
    Mt("highlightClass"),
    Mt("itemClass"),
    po("onHighlight"),
    po("onDehighlight")
  ];
  const Wo = Zi({
    fields: Jx,
    name: "highlighting",
    apis: lg
  }), jI = [8], bv = [9], ug = [13], eT = [27], Df = [32], tT = [37], yv = [38], z0 = [39], gE = [40], Y_ = (t, a, u) => {
    const p = an(t.slice(0, a)), y = an(t.slice(a + 1));
    return Ge(p.concat(y), u);
  }, qI = (t, a, u) => {
    const p = an(t.slice(0, a));
    return Ge(p, u);
  }, Q_ = (t, a, u) => {
    const p = t.slice(0, a), y = t.slice(a + 1);
    return Ge(y.concat(p), u);
  }, GI = (t, a, u) => {
    const p = t.slice(a + 1);
    return Ge(p, u);
  }, yo = (t) => (a) => {
    const u = a.raw;
    return vt(t, u.which);
  }, $f = (t) => (a) => Ct(t, (u) => u(a)), Sv = (t) => t.raw.shiftKey === !0, ZI = (t) => t.raw.ctrlKey === !0, V0 = Ie(Sv), Po = (t, a) => ({
    matches: t,
    classification: a
  }), KI = (t, a) => Ge(t, (p) => p.matches(a)).map((p) => p.classification), X_ = (t, a, u) => {
    a.exists((y) => u.exists((x) => Io(x, y))) || nr(t, V1(), {
      prevFocus: a,
      newFocus: u
    });
  }, h = () => {
    const t = (u) => Nf(u.element);
    return {
      get: t,
      set: (u, p) => {
        const y = t(u);
        u.getSystem().triggerFocus(p, u.element);
        const x = t(u);
        X_(u, y, x);
      }
    };
  }, w = () => {
    const t = (u) => Wo.getHighlighted(u).map((p) => p.element);
    return {
      get: t,
      set: (u, p) => {
        const y = t(u);
        u.getSystem().getByDom(p).fold(G, (k) => {
          Wo.highlight(u, k);
        });
        const x = t(u);
        X_(u, y, x);
      }
    };
  };
  var A;
  (function(t) {
    t.OnFocusMode = "onFocus", t.OnEnterOrSpaceMode = "onEnterOrSpace", t.OnApiMode = "onApi";
  })(A || (A = {}));
  const P = (t, a, u, p, y) => {
    const x = () => t.concat([
      lt("focusManager", h()),
      gl("focusInside", "onFocus", am((j) => vt([
        "onFocus",
        "onEnterOrSpace",
        "onApi"
      ], j) ? Rr.value(j) : Rr.error("Invalid value for focusInside"))),
      ds("handler", B),
      ds("state", a),
      ds("sendFocusIn", y)
    ]), k = (j, Y, re, le, pe) => {
      const _e = re(j, Y, le, pe);
      return KI(_e, Y.event).bind((ze) => ze(j, Y, le, pe));
    }, B = {
      schema: x,
      processKey: k,
      toEvents: (j, Y) => {
        const re = j.focusInside !== A.OnFocusMode ? z.none() : y(j).map((_e) => Pt(Sf(), (ze, ft) => {
          _e(ze, j, Y), ft.stop();
        })), le = (_e, ze) => {
          const ft = yo(Df.concat(ug))(ze.event);
          j.focusInside === A.OnEnterOrSpaceMode && ft && uu(_e, ze) && y(j).each((Xe) => {
            Xe(_e, j, Y), ze.stop();
          });
        }, pe = [
          Pt(ud(), (_e, ze) => {
            k(_e, ze, u, j, Y).fold(() => {
              le(_e, ze);
            }, (ft) => {
              ze.stop();
            });
          }),
          Pt(Bp(), (_e, ze) => {
            k(_e, ze, p, j, Y).each((ft) => {
              ze.stop();
            });
          })
        ];
        return ls(re.toArray().concat(pe));
      }
    };
    return B;
  }, V = (t) => {
    const a = [
      Fo("onEscape"),
      Fo("onEnter"),
      lt("selector", '[data-alloy-tabstop="true"]:not(:disabled)'),
      lt("firstTabstop", 0),
      lt("useTabstopAt", Lt),
      Fo("visibilitySelector")
    ].concat([t]), u = (Xe, Ze) => {
      const mt = Xe.visibilitySelector.bind((jt) => fm(Ze, jt)).getOr(Ze);
      return Ds(mt) > 0;
    }, p = (Xe, Ze) => {
      const mt = Ki(Xe.element, Ze.selector), jt = Rn(mt, (Dt) => u(Ze, Dt));
      return z.from(jt[Ze.firstTabstop]);
    }, y = (Xe, Ze) => Ze.focusManager.get(Xe).bind((mt) => fm(mt, Ze.selector)), x = (Xe, Ze) => u(Xe, Ze) && Xe.useTabstopAt(Ze), k = (Xe, Ze, mt) => {
      p(Xe, Ze).each((jt) => {
        Ze.focusManager.set(Xe, jt);
      });
    }, $ = (Xe, Ze, mt, jt, Dt) => Dt(Ze, mt, (Nt) => x(jt, Nt)).fold(() => jt.cyclic ? z.some(!0) : z.none(), (Nt) => (jt.focusManager.set(Xe, Nt), z.some(!0))), B = (Xe, Ze, mt, jt) => {
      const Dt = Ki(Xe.element, mt.selector);
      return y(Xe, mt).bind((Nt) => qt(Dt, je(Io, Nt)).bind((En) => $(Xe, Dt, En, mt, jt)));
    }, j = (Xe, Ze, mt) => {
      const jt = mt.cyclic ? Y_ : qI;
      return B(Xe, Ze, mt, jt);
    }, Y = (Xe, Ze, mt) => {
      const jt = mt.cyclic ? Q_ : GI;
      return B(Xe, Ze, mt, jt);
    }, re = (Xe) => Dl(Xe).bind(sf).exists((Ze) => Io(Ze, Xe)), le = (Xe, Ze, mt) => y(Xe, mt).filter((jt) => !mt.useTabstopAt(jt)).bind((jt) => (re(jt) ? j : Y)(Xe, Ze, mt)), pe = (Xe, Ze, mt) => mt.onEnter.bind((jt) => jt(Xe, Ze)), _e = (Xe, Ze, mt) => mt.onEscape.bind((jt) => jt(Xe, Ze)), ze = q([
      Po($f([
        Sv,
        yo(bv)
      ]), j),
      Po(yo(bv), Y),
      Po($f([
        V0,
        yo(ug)
      ]), pe)
    ]), ft = q([
      Po(yo(eT), _e),
      Po(yo(bv), le)
    ]);
    return P(a, jd.init, ze, ft, () => z.some(k));
  };
  var K = V(Ts("cyclic", sn)), ie = V(Ts("cyclic", Lt));
  const ve = (t, a, u) => (ab(t, u, Lu()), z.some(!0)), Ae = (t, a, u) => Jy(u) && yo(Df)(a.event) ? z.none() : ve(t, a, u), Ue = (t, a) => z.some(!0), ct = [
    lt("execute", Ae),
    lt("useSpace", !1),
    lt("useEnter", !0),
    lt("useControlEnter", !1),
    lt("useDown", !1)
  ], Yt = (t, a, u) => u.execute(t, a, t.element), On = (t, a, u, p) => {
    const y = u.useSpace && !Jy(t.element) ? Df : [], x = u.useEnter ? ug : [], k = u.useDown ? gE : [], $ = y.concat(x).concat(k);
    return [Po(yo($), Yt)].concat(u.useControlEnter ? [Po($f([
      ZI,
      yo(ug)
    ]), Yt)] : []);
  }, Tn = (t, a, u, p) => u.useSpace && !Jy(t.element) ? [Po(yo(Df), Ue)] : [];
  var It = P(ct, jd.init, On, Tn, () => z.none());
  const An = () => {
    const t = Gr();
    return ol({
      readState: () => t.get().map((y) => ({
        numRows: String(y.numRows),
        numColumns: String(y.numColumns)
      })).getOr({
        numRows: "?",
        numColumns: "?"
      }),
      setGridSize: (y, x) => {
        t.set({
          numRows: y,
          numColumns: x
        });
      },
      getNumRows: () => t.get().map((y) => y.numRows),
      getNumColumns: () => t.get().map((y) => y.numColumns)
    });
  };
  var Gn = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    flatgrid: An,
    init: (t) => t.state(t)
  });
  const Or = (t) => (a, u, p, y) => {
    const x = t(a.element);
    return ui(x, a, u, p, y);
  }, jr = (t, a) => {
    const u = b0(t, a);
    return Or(u);
  }, da = (t, a) => {
    const u = b0(a, t);
    return Or(u);
  }, _c = (t) => (a, u, p, y) => ui(t, a, u, p, y), ui = (t, a, u, p, y) => p.focusManager.get(a).bind((k) => t(a.element, k, p, y)).map((k) => (p.focusManager.set(a, k), !0)), bd = _c, e1 = _c, t1 = _c, J_ = (t) => t.offsetWidth <= 0 && t.offsetHeight <= 0, nT = (t) => !J_(t.dom), ks = (t, a) => qt(t, a).map((u) => ({
    index: u,
    candidates: t
  })), Su = (t, a, u) => {
    const p = (k) => Io(k, a), y = Ki(t, u), x = Rn(y, nT);
    return ks(x, p);
  }, _l = (t, a) => qt(t, (u) => Io(a, u)), If = (t, a, u, p) => {
    const y = Math.floor(a / u), x = a % u;
    return p(y, x).bind((k) => {
      const $ = k.row * u + k.column;
      return $ >= 0 && $ < t.length ? z.some(t[$]) : z.none();
    });
  }, Qd = (t, a, u, p, y) => If(t, a, p, (x, k) => {
    const B = x === u - 1 ? t.length - x * p : p, j = iv(k, y, 0, B - 1);
    return z.some({
      row: x,
      column: j
    });
  }), jb = (t, a, u, p, y) => If(t, a, p, (x, k) => {
    const $ = iv(x, y, 0, u - 1), j = $ === u - 1 ? t.length - $ * p : p, Y = fd(k, 0, j - 1);
    return z.some({
      row: $,
      column: Y
    });
  }), ju = (t, a, u, p) => Qd(t, a, u, p, 1), eO = (t, a, u, p) => Qd(t, a, u, p, -1), vE = (t, a, u, p) => jb(t, a, u, p, -1), dg = (t, a, u, p) => jb(t, a, u, p, 1), Gl = [
    Mt("selector"),
    lt("execute", Ae),
    Uu("onEscape"),
    lt("captureTab", !1),
    c0()
  ], bE = (t, a, u) => {
    qa(t.element, a.selector).each((p) => {
      a.focusManager.set(t, p);
    });
  }, CN = (t, a) => a.focusManager.get(t).bind((u) => fm(u, a.selector)), xN = (t, a, u, p) => CN(t, u).bind((y) => u.execute(t, a, y)), U0 = (t) => (a, u, p, y) => Su(a, u, p.selector).bind((x) => t(x.candidates, x.index, y.getNumRows().getOr(p.initSize.numRows), y.getNumColumns().getOr(p.initSize.numColumns))), TN = (t, a, u) => u.captureTab ? z.some(!0) : z.none(), rT = (t, a, u) => u.onEscape(t, a), _N = U0(eO), n1 = U0(ju), d5 = U0(vE), Cq = U0(dg), xq = q([
    Po(yo(tT), jr(_N, n1)),
    Po(yo(z0), da(_N, n1)),
    Po(yo(yv), bd(d5)),
    Po(yo(gE), e1(Cq)),
    Po($f([
      Sv,
      yo(bv)
    ]), TN),
    Po($f([
      V0,
      yo(bv)
    ]), TN),
    Po(yo(Df.concat(ug)), xN)
  ]), Tq = q([
    Po(yo(eT), rT),
    Po(yo(Df), Ue)
  ]);
  var _q = P(Gl, An, xq, Tq, () => z.some(bE));
  const f5 = (t, a, u, p, y) => {
    const x = ($) => kc($) === "button" && ca($, "disabled") === "disabled", k = ($, B, j) => y($, B, p, 0, j.length - 1, j[B], (Y) => x(j[Y]) ? k($, Y, j) : z.from(j[Y]));
    return Su(t, u, a).bind(($) => {
      const B = $.index, j = $.candidates;
      return k(B, B, j);
    });
  }, m5 = (t, a, u, p) => f5(t, a, u, p, (y, x, k, $, B, j, Y) => {
    const re = fd(x + k, $, B);
    return re === y ? z.from(j) : Y(re);
  }), oT = (t, a, u, p) => f5(t, a, u, p, (y, x, k, $, B, j, Y) => {
    const re = iv(x, k, $, B);
    return re === y ? z.none() : Y(re);
  }), YI = [
    Mt("selector"),
    lt("getInitial", z.none),
    lt("execute", Ae),
    Uu("onEscape"),
    lt("executeOnMove", !1),
    lt("allowVertical", !0),
    lt("allowHorizontal", !0),
    lt("cycles", !0)
  ], Oq = (t, a) => a.focusManager.get(t).bind((u) => fm(u, a.selector)), p5 = (t, a, u) => Oq(t, u).bind((p) => u.execute(t, a, p)), h5 = (t, a, u) => {
    a.getInitial(t).orThunk(() => qa(t.element, a.selector)).each((p) => {
      a.focusManager.set(t, p);
    });
  }, g5 = (t, a, u) => (u.cycles ? oT : m5)(t, u.selector, a, -1), v5 = (t, a, u) => (u.cycles ? oT : m5)(t, u.selector, a, 1), sp = (t) => (a, u, p, y) => t(a, u, p, y).bind(() => p.executeOnMove ? p5(a, u, p) : z.some(!0)), Aq = (t, a, u) => u.onEscape(t, a), kq = (t, a, u, p) => {
    const y = [...u.allowHorizontal ? tT : []].concat(u.allowVertical ? yv : []), x = [...u.allowHorizontal ? z0 : []].concat(u.allowVertical ? gE : []);
    return [
      Po(yo(y), sp(jr(g5, v5))),
      Po(yo(x), sp(da(g5, v5))),
      Po(yo(ug), p5),
      Po(yo(Df), p5)
    ];
  }, Nq = q([
    Po(yo(Df), Ue),
    Po(yo(eT), Aq)
  ]);
  var Rq = P(YI, jd.init, kq, Nq, () => z.some(h5));
  const ON = (t, a, u) => z.from(t[a]).bind((p) => z.from(p[u]).map((y) => ({
    rowIndex: a,
    columnIndex: u,
    cell: y
  }))), yE = (t, a, u, p) => {
    const x = t[a].length, k = iv(u, p, 0, x - 1);
    return ON(t, a, k);
  }, AN = (t, a, u, p) => {
    const y = iv(u, p, 0, t.length - 1), x = t[y].length, k = fd(a, 0, x - 1);
    return ON(t, y, k);
  }, b5 = (t, a, u, p) => {
    const x = t[a].length, k = fd(u + p, 0, x - 1);
    return ON(t, a, k);
  }, kN = (t, a, u, p) => {
    const y = fd(u + p, 0, t.length - 1), x = t[y].length, k = fd(a, 0, x - 1);
    return ON(t, y, k);
  }, NN = (t, a, u) => yE(t, a, u, 1), QI = (t, a, u) => yE(t, a, u, -1), Pq = (t, a, u) => AN(t, u, a, -1), Dq = (t, a, u) => AN(t, u, a, 1), $q = (t, a, u) => b5(t, a, u, -1), Iq = (t, a, u) => b5(t, a, u, 1), Mq = (t, a, u) => kN(t, u, a, -1), Fq = (t, a, u) => kN(t, u, a, 1), y5 = [
    lu("selectors", [
      Mt("row"),
      Mt("cell")
    ]),
    lt("cycles", !0),
    lt("previousSelector", z.none),
    lt("execute", Ae)
  ], XI = (t, a, u) => {
    a.previousSelector(t).orThunk(() => {
      const y = a.selectors;
      return qa(t.element, y.cell);
    }).each((y) => {
      a.focusManager.set(t, y);
    });
  }, Lq = (t, a, u) => Nf(t.element).bind((p) => u.execute(t, a, p)), Bq = (t, a) => He(t, (u) => Ki(u, a.selectors.cell)), RN = (t, a) => (u, p, y) => {
    const x = y.cycles ? t : a;
    return fm(p, y.selectors.row).bind((k) => {
      const $ = Ki(k, y.selectors.cell);
      return _l($, p).bind((B) => {
        const j = Ki(u, y.selectors.row);
        return _l(j, k).bind((Y) => {
          const re = Bq(j, y);
          return x(re, Y, B).map((le) => le.cell);
        });
      });
    });
  }, S5 = RN(QI, $q), W0 = RN(NN, Iq), w5 = RN(Pq, Mq), Hq = RN(Dq, Fq), JI = q([
    Po(yo(tT), jr(S5, W0)),
    Po(yo(z0), da(S5, W0)),
    Po(yo(yv), bd(w5)),
    Po(yo(gE), e1(Hq)),
    Po(yo(Df.concat(ug)), Lq)
  ]), zq = q([Po(yo(Df), Ue)]);
  var E5 = P(y5, jd.init, JI, zq, () => z.some(XI));
  const C5 = [
    Mt("selector"),
    lt("execute", Ae),
    lt("moveOnTab", !1)
  ], eM = (t, a, u) => u.focusManager.get(t).bind((p) => u.execute(t, a, p)), x5 = (t, a, u) => {
    qa(t.element, a.selector).each((p) => {
      a.focusManager.set(t, p);
    });
  }, tM = (t, a, u) => oT(t, u.selector, a, -1), T5 = (t, a, u) => oT(t, u.selector, a, 1), Vq = (t, a, u, p) => u.moveOnTab ? t1(tM)(t, a, u, p) : z.none(), Uq = (t, a, u, p) => u.moveOnTab ? t1(T5)(t, a, u, p) : z.none(), nM = q([
    Po(yo(yv), t1(tM)),
    Po(yo(gE), t1(T5)),
    Po($f([
      Sv,
      yo(bv)
    ]), Vq),
    Po($f([
      V0,
      yo(bv)
    ]), Uq),
    Po(yo(ug), eM),
    Po(yo(Df), eM)
  ]), Wq = q([Po(yo(Df), Ue)]);
  var jq = P(C5, jd.init, nM, Wq, () => z.some(x5));
  const qq = [
    Uu("onSpace"),
    Uu("onEnter"),
    Uu("onShiftEnter"),
    Uu("onLeft"),
    Uu("onRight"),
    Uu("onTab"),
    Uu("onShiftTab"),
    Uu("onUp"),
    Uu("onDown"),
    Uu("onEscape"),
    lt("stopSpaceKeyup", !1),
    Fo("focusIn")
  ], Gq = (t, a, u) => [
    Po(yo(Df), u.onSpace),
    Po($f([
      V0,
      yo(ug)
    ]), u.onEnter),
    Po($f([
      Sv,
      yo(ug)
    ]), u.onShiftEnter),
    Po($f([
      Sv,
      yo(bv)
    ]), u.onShiftTab),
    Po($f([
      V0,
      yo(bv)
    ]), u.onTab),
    Po(yo(yv), u.onUp),
    Po(yo(gE), u.onDown),
    Po(yo(tT), u.onLeft),
    Po(yo(z0), u.onRight),
    Po(yo(Df), u.onSpace)
  ], _5 = (t, a, u) => [
    ...u.stopSpaceKeyup ? [Po(yo(Df), Ue)] : [],
    Po(yo(eT), u.onEscape)
  ];
  var Zq = P(qq, jd.init, Gq, _5, (t) => t.focusIn);
  const Kq = K.schema(), Yq = ie.schema(), O5 = Rq.schema(), Qq = _q.schema(), Xq = E5.schema(), A5 = It.schema(), Jq = jq.schema(), eG = Zq.schema();
  var PN = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    acyclic: Kq,
    cyclic: Yq,
    flow: O5,
    flatgrid: Qq,
    matrix: Xq,
    execution: A5,
    menu: Jq,
    special: eG
  });
  const tG = (t) => xa(t, "setGridSize"), ar = tg({
    branchKey: "mode",
    branches: PN,
    name: "keying",
    active: {
      events: (t, a) => t.handler.toEvents(t, a)
    },
    apis: {
      focusIn: (t, a, u) => {
        a.sendFocusIn(a).fold(() => {
          t.getSystem().triggerFocus(t.element, t.element);
        }, (p) => {
          p(t, a, u);
        });
      },
      setGridSize: (t, a, u, p, y) => {
        tG(u) ? u.setGridSize(p, y) : console.error("Layout does not support setGridSize");
      }
    },
    state: Gn
  }), yd = (t, a) => {
    Fn(() => {
      gI(t, a, () => He(a, t.getSystem().build));
    }, t.element);
  }, k5 = (t, a) => {
    Fn(() => {
      vI(t, a, () => Wk(t.element, a, t.getSystem().buildOrPatch));
    }, t.element);
  }, N5 = (t, a, u, p) => {
    k0(a);
    const y = JC(t.element, u, p, t.getSystem().buildOrPatch);
    A_(t, y), t.syncComponents();
  }, DN = (t, a, u) => {
    const p = t.getSystem().build(u);
    N0(t, p, a);
  }, nG = (t, a, u, p) => {
    cg(a), DN(t, (y, x) => ga(y, x, u), p);
  }, R5 = (t, a, u, p) => (a.reuseDom ? k5 : yd)(t, p), P5 = (t, a, u, p) => {
    DN(t, oi, p);
  }, rG = (t, a, u, p) => {
    DN(t, Bg, p);
  }, oG = (t, a, u, p) => {
    const y = $N(t);
    Ge(y, (k) => Io(p.element, k.element)).each(cg);
  }, $N = (t, a) => t.components(), D5 = (t, a, u, p, y) => {
    const x = $N(t);
    return z.from(x[p]).map((k) => (y.fold(() => cg(k), ($) => {
      (a.reuseDom ? N5 : nG)(t, k, p, $);
    }), k));
  };
  var aG = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    append: P5,
    prepend: rG,
    remove: oG,
    replaceAt: D5,
    replaceBy: (t, a, u, p, y) => {
      const x = $N(t);
      return qt(x, p).bind((k) => D5(t, a, u, k, y));
    },
    set: R5,
    contents: $N
  });
  const $r = Zi({
    fields: [vi("reuseDom", !0)],
    name: "replacing",
    apis: aG
  }), $5 = (t, a) => {
    const u = ls(a);
    return Zi({
      fields: [Mt("enabled")],
      name: t,
      active: { events: q(u) }
    });
  }, Hr = (t, a) => {
    const u = $5(t, a);
    return {
      key: t,
      value: {
        config: {},
        me: u,
        configAsRaw: q({}),
        initialConfig: {},
        state: jd
      }
    };
  }, rM = (t, a) => {
    a.ignore || (Fa(t.element), a.onFocus(t));
  };
  var iG = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    focus: rM,
    blur: (t, a) => {
      a.ignore || gm(t.element);
    },
    isFocused: (t) => zy(t.element)
  }), I5 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    exhibit: (t, a) => {
      const u = a.ignore ? {} : { attributes: { tabindex: "-1" } };
      return pu(u);
    },
    events: (t) => ls([Pt(Sf(), (a, u) => {
      rM(a, t), u.stop();
    })].concat(t.stopMousedown ? [Pt(oo(), (a, u) => {
      u.event.prevent();
    })] : []))
  }), j0 = [
    po("onFocus"),
    lt("stopMousedown", !1),
    lt("ignore", !1)
  ];
  const Er = Zi({
    fields: j0,
    name: "focusing",
    active: I5,
    apis: iG
  }), M5 = (t) => ({ init: () => {
    const u = sr(t);
    return {
      get: () => u.get(),
      set: ($) => u.set($),
      clear: () => u.set(t),
      readState: () => u.get()
    };
  } }), oM = (t, a, u) => {
    const p = a.aria;
    p.update(t, p, u.get());
  }, lG = (t, a, u) => {
    a.toggleClass.each((p) => {
      u.get() ? ja(t.element, p) : ua(t.element, p);
    });
  }, tO = (t, a, u, p) => {
    const y = u.get();
    u.set(p), lG(t, a, u), oM(t, a, u), y !== p && a.onToggled(t, p);
  }, F5 = (t, a, u) => {
    tO(t, a, u, !u.get());
  }, uG = (t, a, u) => {
    tO(t, a, u, !0);
  }, L5 = (t, a, u) => {
    tO(t, a, u, !1);
  }, sM = (t, a, u) => u.get(), IN = (t, a, u) => {
    tO(t, a, u, a.selected);
  };
  var dG = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    onLoad: IN,
    toggle: F5,
    isOn: sM,
    on: uG,
    off: L5,
    set: tO
  }), B5 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    exhibit: () => pu({}),
    events: (t, a) => {
      const u = oh(t, a, F5), p = li(t, a, IN);
      return ls(St([
        t.toggleOnExecute ? [u] : [],
        [p]
      ]));
    }
  });
  const mG = (t, a, u) => {
    kn(t.element, "aria-pressed", u), a.syncWithExpanded && sT(t, a, u);
  }, pG = (t, a, u) => {
    kn(t.element, "aria-selected", u);
  }, nO = (t, a, u) => {
    kn(t.element, "aria-checked", u);
  }, sT = (t, a, u) => {
    kn(t.element, "aria-expanded", u);
  };
  var H5 = [
    lt("selected", !1),
    Fo("toggleClass"),
    lt("toggleOnExecute", !0),
    po("onToggled"),
    gl("aria", { mode: "none" }, ro("mode", {
      pressed: [
        lt("syncWithExpanded", !1),
        ds("update", mG)
      ],
      checked: [ds("update", nO)],
      expanded: [ds("update", sT)],
      selected: [ds("update", pG)],
      none: [ds("update", G)]
    }))
  ];
  const Zr = Zi({
    fields: H5,
    name: "toggling",
    active: B5,
    apis: dG,
    state: M5(!1)
  }), r1 = () => {
    const t = (a, u) => {
      u.stop(), Ef(a);
    };
    return [
      Pt(um(), t),
      Pt(wf(), t),
      Gp(du()),
      Gp(oo())
    ];
  }, wv = (t) => {
    const a = (u) => Ul((p, y) => {
      u(p), y.stop();
    });
    return ls(St([
      t.map(a).toArray(),
      r1()
    ]));
  }, z5 = "alloy.item-hover", V5 = "alloy.item-focus", aM = "alloy.item-toggled", qb = (t) => {
    (Nf(t.element).isNone() || Er.isFocused(t)) && (Er.isFocused(t) || Er.focus(t), nr(t, z5, { item: t }));
  }, MN = (t) => {
    nr(t, V5, { item: t });
  }, hG = (t, a) => {
    nr(t, aM, {
      item: t,
      state: a
    });
  }, iM = q(z5), U5 = q(V5), W5 = q(aM), cM = (t) => t.toggling.map((a) => a.exclusive ? "menuitemradio" : "menuitemcheckbox").getOr("menuitem"), j5 = (t) => ({
    aria: { mode: "checked" },
    ...qo(t, (a, u) => u !== "exclusive"),
    onToggled: (a, u) => {
      Q(t.onToggled) && t.onToggled(a, u), hG(a, u);
    }
  }), gG = (t) => ({
    dom: t.dom,
    domModification: {
      ...t.domModification,
      attributes: {
        role: cM(t),
        ...t.domModification.attributes,
        "aria-haspopup": t.hasSubmenu,
        ...t.hasSubmenu ? { "aria-expanded": !1 } : {}
      }
    },
    behaviours: bm.augment(t.itemBehaviours, [
      t.toggling.fold(Zr.revoke, (a) => Zr.config(j5(a))),
      Er.config({
        ignore: t.ignoreFocus,
        stopMousedown: t.ignoreFocus,
        onFocus: (a) => {
          MN(a);
        }
      }),
      ar.config({ mode: "execution" }),
      Pn.config({
        store: {
          mode: "memory",
          initialValue: t.data
        }
      }),
      Hr("item-type-events", [
        ...r1(),
        Pt(yf(), qb),
        Pt(Na(), Er.focus)
      ])
    ]),
    components: t.components,
    eventOrder: t.eventOrder
  }), vG = [
    Mt("data"),
    Mt("components"),
    Mt("dom"),
    lt("hasSubmenu", !1),
    Fo("toggling"),
    bm.field("itemBehaviours", [
      Zr,
      Er,
      ar,
      Pn
    ]),
    lt("ignoreFocus", !1),
    lt("domModification", {}),
    ds("builder", gG),
    lt("eventOrder", {})
  ], bG = (t) => ({
    dom: t.dom,
    components: t.components,
    events: ls([Zp(Na())])
  }), FN = [
    Mt("dom"),
    Mt("components"),
    ds("builder", bG)
  ], rO = q("item-widget"), oO = q([jl({
    name: "widget",
    overrides: (t) => ({
      behaviours: mn([Pn.config({
        store: {
          mode: "manual",
          getValue: (a) => t.data,
          setValue: G
        }
      })])
    })
  })]), yG = (t) => {
    const a = B_(rO(), t, oO()), u = Yx(rO(), t, a.internals()), p = (x) => Fs(x, t, "widget").map((k) => (ar.focusIn(k), k)), y = (x, k) => Jy(k.event.target) ? z.none() : (() => (t.autofocus && k.setSource(x.element), z.none()))();
    return {
      dom: t.dom,
      components: u,
      domModification: t.domModification,
      events: ls([
        Ul((x, k) => {
          p(x).each(($) => {
            k.stop();
          });
        }),
        Pt(yf(), qb),
        Pt(Na(), (x, k) => {
          t.autofocus ? p(x) : Er.focus(x);
        })
      ]),
      behaviours: bm.augment(t.widgetBehaviours, [
        Pn.config({
          store: {
            mode: "memory",
            initialValue: t.data
          }
        }),
        Er.config({
          ignore: t.ignoreFocus,
          onFocus: (x) => {
            MN(x);
          }
        }),
        ar.config({
          mode: "special",
          focusIn: t.autofocus ? (x) => {
            p(x);
          } : By(),
          onLeft: y,
          onRight: y,
          onEscape: (x, k) => !Er.isFocused(x) && !t.autofocus ? (Er.focus(x), z.some(!0)) : (t.autofocus && k.setSource(x.element), z.none())
        })
      ])
    };
  }, SG = [
    Mt("uid"),
    Mt("data"),
    Mt("components"),
    Mt("dom"),
    lt("autofocus", !1),
    lt("ignoreFocus", !1),
    bm.field("widgetBehaviours", [
      Pn,
      Er,
      ar
    ]),
    lt("domModification", {}),
    U_(oO()),
    ds("builder", yG)
  ], q5 = ro("type", {
    widget: SG,
    item: vG,
    separator: FN
  }), G5 = (t, a) => ({
    mode: "flatgrid",
    selector: "." + t.markers.item,
    initSize: {
      numColumns: a.initSize.numColumns,
      numRows: a.initSize.numRows
    },
    focusManager: t.focusManager
  }), Z5 = (t, a) => ({
    mode: "matrix",
    selectors: {
      row: a.rowSelector,
      cell: "." + t.markers.item
    },
    previousSelector: a.previousSelector,
    focusManager: t.focusManager
  }), K5 = (t, a) => ({
    mode: "menu",
    selector: "." + t.markers.item,
    moveOnTab: a.moveOnTab,
    focusManager: t.focusManager
  }), wG = q([lE({
    factory: {
      sketch: (t) => {
        const a = ya("menu.spec item", q5, t);
        return a.builder(a);
      }
    },
    name: "items",
    unit: "item",
    defaults: (t, a) => Yr(a, "uid") ? a : {
      ...a,
      uid: db("item")
    },
    overrides: (t, a) => ({
      type: a.type,
      ignoreFocus: t.fakeFocus,
      domModification: { classes: [t.markers.item] }
    })
  })]), lM = q([
    Mt("value"),
    Mt("items"),
    Mt("dom"),
    Mt("components"),
    lt("eventOrder", {}),
    ac("menuBehaviours", [
      Wo,
      Pn,
      ho,
      ar
    ]),
    gl("movement", {
      mode: "menu",
      moveOnTab: !0
    }, ro("mode", {
      grid: [
        c0(),
        ds("config", G5)
      ],
      matrix: [
        ds("config", Z5),
        Mt("rowSelector"),
        lt("previousSelector", z.none)
      ],
      menu: [
        lt("moveOnTab", !0),
        ds("config", K5)
      ]
    })),
    G2(),
    lt("fakeFocus", !1),
    lt("focusManager", h()),
    po("onHighlight"),
    po("onDehighlight")
  ]), Y5 = q("alloy.menu-focus"), EG = (t, a) => {
    const u = Ki(t.element, '[role="menuitemradio"][aria-checked="true"]');
    ut(u, (p) => {
      Io(p, a.element) || t.getSystem().getByDom(p).each((y) => {
        Zr.off(y);
      });
    });
  }, CG = (t, a, u, p) => ({
    uid: t.uid,
    dom: t.dom,
    markers: t.markers,
    behaviours: _i(t.menuBehaviours, [
      Wo.config({
        highlightClass: t.markers.selectedItem,
        itemClass: t.markers.item,
        onHighlight: t.onHighlight,
        onDehighlight: t.onDehighlight
      }),
      Pn.config({
        store: {
          mode: "memory",
          initialValue: t.value
        }
      }),
      ho.config({ find: z.some }),
      ar.config(t.movement.config(t, t.movement))
    ]),
    events: ls([
      Pt(U5(), (y, x) => {
        const k = x.event;
        y.getSystem().getByDom(k.target).each(($) => {
          Wo.highlight(y, $), x.stop(), nr(y, Y5(), {
            menu: y,
            item: $
          });
        });
      }),
      Pt(iM(), (y, x) => {
        const k = x.event.item;
        Wo.highlight(y, k);
      }),
      Pt(W5(), (y, x) => {
        const { item: k, state: $ } = x.event;
        $ && ca(k.element, "role") === "menuitemradio" && EG(y, k);
      })
    ]),
    components: a,
    eventOrder: t.eventOrder,
    domModification: { attributes: { role: "menu" } }
  }), wE = ql({
    name: "Menu",
    configFields: lM(),
    partFields: wG(),
    factory: CG
  }), Q5 = (t) => Es(t, (a, u) => ({
    k: a,
    v: u
  })), X5 = (t, a, u, p) => fn(u, p).bind((y) => fn(t, y).bind((x) => {
    const k = X5(t, a, u, x);
    return z.some([x].concat(k));
  })).getOr([]), xG = (t, a) => {
    const u = {};
    Eo(t, (k, $) => {
      ut(k, (B) => {
        u[B] = $;
      });
    });
    const p = a, y = Q5(a), x = uo(y, (k, $) => [$].concat(X5(u, p, y, $)));
    return uo(u, (k) => fn(x, k).getOr([k]));
  }, J5 = () => {
    const t = sr({}), a = sr({}), u = sr({}), p = Gr(), y = sr({}), x = () => {
      t.set({}), a.set({}), u.set({}), p.clear();
    }, k = () => p.get().isNone(), $ = (Dt, Nt) => {
      a.set({
        ...a.get(),
        [Dt]: {
          type: "prepared",
          menu: Nt
        }
      });
    }, B = (Dt, Nt, hn, En) => {
      p.set(Dt), t.set(hn), a.set(Nt), y.set(En);
      const zr = xG(En, hn);
      u.set(zr);
    }, j = (Dt) => Co(t.get(), (Nt, hn) => Nt === Dt), Y = (Dt, Nt, hn) => ze(Dt).bind((En) => j(Dt).bind((zr) => Nt(zr).map((Yn) => ({
      triggeredMenu: En,
      triggeringItem: Yn,
      triggeringPath: hn
    })))), re = (Dt, Nt) => {
      const hn = Rn(Xe(Dt).toArray(), (En) => ze(En).isSome());
      return fn(u.get(), Dt).bind((En) => {
        const zr = an(hn.concat(En)), Yn = ke(zr, (hr, Cr) => Y(hr, Nt, zr.slice(0, Cr + 1)).fold(() => $i(p.get(), hr) ? [] : [z.none()], (ns) => [z.some(ns)]));
        return es(Yn);
      });
    }, le = (Dt) => fn(t.get(), Dt).map((Nt) => {
      const hn = fn(u.get(), Dt).getOr([]);
      return [Nt].concat(hn);
    }), pe = (Dt) => fn(u.get(), Dt).bind((Nt) => Nt.length > 1 ? z.some(Nt.slice(1)) : z.none()), _e = (Dt) => fn(u.get(), Dt), ze = (Dt) => ft(Dt).bind(aT), ft = (Dt) => fn(a.get(), Dt), Xe = (Dt) => fn(t.get(), Dt);
    return {
      setMenuBuilt: $,
      setContents: B,
      expand: le,
      refresh: _e,
      collapse: pe,
      lookupMenu: ft,
      lookupItem: Xe,
      otherMenus: (Dt) => {
        const Nt = y.get();
        return ht(Xr(Nt), Dt);
      },
      getPrimary: () => p.get().bind(ze),
      getMenus: () => a.get(),
      clear: x,
      isClear: k,
      getTriggeringPath: re
    };
  }, aT = (t) => t.type === "prepared" ? z.some(t.menu) : z.none(), e6 = {
    init: J5,
    extractPreparedMenu: aT
  }, iT = Hn("tiered-menu-item-highlight"), LN = Hn("tiered-menu-item-dehighlight");
  var Sd;
  (function(t) {
    t[t.HighlightMenuAndItem = 0] = "HighlightMenuAndItem", t[t.HighlightJustMenu = 1] = "HighlightJustMenu", t[t.HighlightNone = 2] = "HighlightNone";
  })(Sd || (Sd = {}));
  const t6 = (t, a) => {
    const u = Gr(), p = (Cn, Zn, Ar) => uo(Ar, (go, vr) => {
      const Mr = () => wE.sketch({
        ...go,
        value: vr,
        markers: t.markers,
        fakeFocus: t.fakeFocus,
        onHighlight: (Bs, jo) => {
          nr(Bs, iT, {
            menuComp: Bs,
            itemComp: jo
          });
        },
        onDehighlight: (Bs, jo) => {
          nr(Bs, LN, {
            menuComp: Bs,
            itemComp: jo
          });
        },
        focusManager: t.fakeFocus ? w() : h()
      });
      return vr === Zn ? {
        type: "prepared",
        menu: Cn.getSystem().build(Mr())
      } : {
        type: "notbuilt",
        nbMenu: Mr
      };
    }), y = e6.init(), x = (Cn) => {
      const Zn = p(Cn, t.data.primary, t.data.menus), Ar = B();
      return y.setContents(t.data.primary, Zn, t.data.expansions, Ar), y.getPrimary();
    }, k = (Cn) => Pn.getValue(Cn).value, $ = (Cn, Zn, Ar) => Vr(Zn, (go) => {
      if (!go.getSystem().isConnected())
        return z.none();
      const vr = Wo.getCandidates(go);
      return Ge(vr, (Mr) => k(Mr) === Ar);
    }), B = (Cn) => uo(t.data.menus, (Zn, Ar) => ke(Zn.items, (go) => go.type === "separator" ? [] : [go.data.value])), j = Wo.highlight, Y = (Cn, Zn) => {
      j(Cn, Zn), Wo.getHighlighted(Zn).orThunk(() => Wo.getFirst(Zn)).each((Ar) => {
        t.fakeFocus ? Wo.highlight(Zn, Ar) : ab(Cn, Ar.element, Na());
      });
    }, re = (Cn, Zn) => wi(He(Zn, (Ar) => Cn.lookupMenu(Ar).bind((go) => go.type === "prepared" ? z.some(go.menu) : z.none()))), le = (Cn, Zn, Ar) => {
      const go = re(Zn, Zn.otherMenus(Ar));
      ut(go, (vr) => {
        dd(vr.element, [t.markers.backgroundMenu]), t.stayInDom || $r.remove(Cn, vr);
      });
    }, pe = (Cn) => u.get().getOrThunk(() => {
      const Zn = {}, Ar = Ki(Cn.element, `.${t.markers.item}`), go = Rn(Ar, (vr) => ca(vr, "aria-haspopup") === "true");
      return ut(go, (vr) => {
        Cn.getSystem().getByDom(vr).each((Mr) => {
          const Bs = k(Mr);
          Zn[Bs] = Mr;
        });
      }), u.set(Zn), Zn;
    }), _e = (Cn, Zn) => {
      const Ar = pe(Cn);
      Eo(Ar, (go, vr) => {
        const Mr = vt(Zn, vr);
        kn(go.element, "aria-expanded", Mr);
      });
    }, ze = (Cn, Zn, Ar) => z.from(Ar[0]).bind((go) => Zn.lookupMenu(go).bind((vr) => {
      if (vr.type === "notbuilt")
        return z.none();
      {
        const Mr = vr.menu, Bs = re(Zn, Ar.slice(1));
        return ut(Bs, (jo) => {
          ja(jo.element, t.markers.backgroundMenu);
        }), fo(Mr.element) || $r.append(Cn, Hu(Mr)), dd(Mr.element, [t.markers.backgroundMenu]), Y(Cn, Mr), le(Cn, Zn, Ar), z.some(Mr);
      }
    }));
    let ft;
    (function(Cn) {
      Cn[Cn.HighlightSubmenu = 0] = "HighlightSubmenu", Cn[Cn.HighlightParent = 1] = "HighlightParent";
    })(ft || (ft = {}));
    const Xe = (Cn, Zn, Ar) => {
      if (Ar.type === "notbuilt") {
        const go = Cn.getSystem().build(Ar.nbMenu());
        return y.setMenuBuilt(Zn, go), go;
      } else
        return Ar.menu;
    }, Ze = (Cn, Zn, Ar = ft.HighlightSubmenu) => {
      if (Zn.hasConfigured(yr) && yr.isDisabled(Zn))
        return z.some(Zn);
      {
        const go = k(Zn);
        return y.expand(go).bind((vr) => (_e(Cn, vr), z.from(vr[0]).bind((Mr) => y.lookupMenu(Mr).bind((Bs) => {
          const jo = Xe(Cn, Mr, Bs);
          return fo(jo.element) || $r.append(Cn, Hu(jo)), t.onOpenSubmenu(Cn, Zn, jo, an(vr)), Ar === ft.HighlightSubmenu ? (Wo.highlightFirst(jo), ze(Cn, y, vr)) : (Wo.dehighlightAll(jo), z.some(Zn));
        }))));
      }
    }, mt = (Cn, Zn) => {
      const Ar = k(Zn);
      return y.collapse(Ar).bind((go) => (_e(Cn, go), ze(Cn, y, go).map((vr) => (t.onCollapseMenu(Cn, Zn, vr), vr))));
    }, jt = (Cn, Zn) => {
      const Ar = k(Zn);
      return y.refresh(Ar).bind((go) => (_e(Cn, go), ze(Cn, y, go)));
    }, Dt = (Cn, Zn) => Jy(Zn.element) ? z.none() : Ze(Cn, Zn, ft.HighlightSubmenu), Nt = (Cn, Zn) => Jy(Zn.element) ? z.none() : mt(Cn, Zn), hn = (Cn, Zn) => mt(Cn, Zn).orThunk(() => t.onEscape(Cn, Zn).map(() => Cn)), En = (Cn) => (Zn, Ar) => fm(Ar.getSource(), `.${t.markers.item}`).bind((go) => Zn.getSystem().getByDom(go).toOptional().bind((vr) => Cn(Zn, vr).map(Lt))), zr = ls([
      Pt(Y5(), (Cn, Zn) => {
        const Ar = Zn.event.item;
        y.lookupItem(k(Ar)).each(() => {
          const go = Zn.event.menu;
          Wo.highlight(Cn, go);
          const vr = k(Zn.event.item);
          y.refresh(vr).each((Mr) => le(Cn, y, Mr));
        });
      }),
      Ul((Cn, Zn) => {
        const Ar = Zn.event.target;
        Cn.getSystem().getByDom(Ar).each((go) => {
          k(go).indexOf("collapse-item") === 0 && mt(Cn, go), Ze(Cn, go, ft.HighlightSubmenu).fold(() => {
            t.onExecute(Cn, go);
          }, G);
        });
      }),
      us((Cn, Zn) => {
        x(Cn).each((Ar) => {
          $r.append(Cn, Hu(Ar)), t.onOpenMenu(Cn, Ar), t.highlightOnOpen === Sd.HighlightMenuAndItem ? Y(Cn, Ar) : t.highlightOnOpen === Sd.HighlightJustMenu && j(Cn, Ar);
        });
      }),
      Pt(iT, (Cn, Zn) => {
        t.onHighlightItem(Cn, Zn.event.menuComp, Zn.event.itemComp);
      }),
      Pt(LN, (Cn, Zn) => {
        t.onDehighlightItem(Cn, Zn.event.menuComp, Zn.event.itemComp);
      }),
      ...t.navigateOnHover ? [Pt(iM(), (Cn, Zn) => {
        const Ar = Zn.event.item;
        jt(Cn, Ar), Ze(Cn, Ar, ft.HighlightParent), t.onHover(Cn, Ar);
      })] : []
    ]), Yn = (Cn) => Wo.getHighlighted(Cn).bind(Wo.getHighlighted), hr = (Cn) => {
      Yn(Cn).each((Zn) => {
        mt(Cn, Zn);
      });
    }, Cr = (Cn) => {
      y.getPrimary().each((Zn) => {
        Y(Cn, Zn);
      });
    }, ns = (Cn) => z.from(Cn.components()[0]).filter((Zn) => ca(Zn.element, "role") === "menu"), ko = {
      collapseMenu: hr,
      highlightPrimary: Cr,
      repositionMenus: (Cn) => {
        y.getPrimary().bind((Ar) => Yn(Cn).bind((go) => {
          const vr = k(go), Mr = fl(y.getMenus()), Bs = wi(He(Mr, e6.extractPreparedMenu));
          return y.getTriggeringPath(vr, (jo) => $(Cn, Bs, jo));
        }).map((go) => ({
          primary: Ar,
          triggeringPath: go
        }))).fold(() => {
          ns(Cn).each((Ar) => {
            t.onRepositionMenu(Cn, Ar, []);
          });
        }, ({ primary: Ar, triggeringPath: go }) => {
          t.onRepositionMenu(Cn, Ar, go);
        });
      }
    };
    return {
      uid: t.uid,
      dom: t.dom,
      markers: t.markers,
      behaviours: _i(t.tmenuBehaviours, [
        ar.config({
          mode: "special",
          onRight: En(Dt),
          onLeft: En(Nt),
          onEscape: En(hn),
          focusIn: (Cn, Zn) => {
            y.getPrimary().each((Ar) => {
              ab(Cn, Ar.element, Na());
            });
          }
        }),
        Wo.config({
          highlightClass: t.markers.selectedMenu,
          itemClass: t.markers.menu
        }),
        ho.config({
          find: (Cn) => Wo.getHighlighted(Cn)
        }),
        $r.config({})
      ]),
      eventOrder: t.eventOrder,
      apis: ko,
      events: zr
    };
  }, TG = q("collapse-item"), _G = (t, a, u) => ({
    primary: t,
    menus: a,
    expansions: u
  }), n6 = (t, a) => ({
    primary: t,
    menus: Sn(t, a),
    expansions: {}
  }), OG = (t) => ({
    value: Hn(TG()),
    meta: { text: t }
  }), q0 = Yd({
    name: "TieredMenu",
    configFields: [
      Ob("onExecute"),
      Ob("onEscape"),
      mm("onOpenMenu"),
      mm("onOpenSubmenu"),
      po("onRepositionMenu"),
      po("onCollapseMenu"),
      lt("highlightOnOpen", Sd.HighlightMenuAndItem),
      lu("data", [
        Mt("primary"),
        Mt("menus"),
        Mt("expansions")
      ]),
      lt("fakeFocus", !1),
      po("onHighlightItem"),
      po("onDehighlightItem"),
      po("onHover"),
      Dy(),
      Mt("dom"),
      lt("navigateOnHover", !0),
      lt("stayInDom", !1),
      ac("tmenuBehaviours", [
        ar,
        Wo,
        ho,
        $r
      ]),
      lt("eventOrder", {})
    ],
    apis: {
      collapseMenu: (t, a) => {
        t.collapseMenu(a);
      },
      highlightPrimary: (t, a) => {
        t.highlightPrimary(a);
      },
      repositionMenus: (t, a) => {
        t.repositionMenus(a);
      }
    },
    factory: t6,
    extraApis: {
      tieredData: _G,
      singleData: n6,
      collapseItem: OG
    }
  }), AG = (t, a, u, p, y) => {
    const x = () => t.lazySink(a), k = p.type === "horizontal" ? {
      layouts: {
        onLtr: () => m0(),
        onRtl: () => Tw()
      }
    } : {}, $ = (j) => j.length === 2, B = (j) => $(j) ? k : {};
    return q0.sketch({
      dom: { tag: "div" },
      data: p.data,
      markers: p.menu.markers,
      highlightOnOpen: p.menu.highlightOnOpen,
      fakeFocus: p.menu.fakeFocus,
      onEscape: () => (bo.close(a), t.onEscape.map((j) => j(a)), z.some(!0)),
      onExecute: () => z.some(!0),
      onOpenMenu: (j, Y) => {
        Wl.positionWithinBounds(x().getOrDie(), Y, u, y());
      },
      onOpenSubmenu: (j, Y, re, le) => {
        const pe = x().getOrDie();
        Wl.position(pe, re, {
          anchor: {
            type: "submenu",
            item: Y,
            ...B(le)
          }
        });
      },
      onRepositionMenu: (j, Y, re) => {
        const le = x().getOrDie();
        Wl.positionWithinBounds(le, Y, u, y()), ut(re, (pe) => {
          const _e = B(pe.triggeringPath);
          Wl.position(le, pe.triggeredMenu, {
            anchor: {
              type: "submenu",
              item: pe.triggeringItem,
              ..._e
            }
          });
        });
      }
    });
  }, kG = (t, a) => {
    const u = (le, pe) => t.getRelated(le).exists((ze) => th(ze, pe)), p = (le, pe) => {
      bo.setContent(le, pe);
    }, y = (le, pe, _e) => {
      const ze = z.none;
      x(le, pe, _e, ze);
    }, x = (le, pe, _e, ze) => {
      const ft = t.lazySink(le).getOrDie();
      bo.openWhileCloaked(le, pe, () => Wl.positionWithinBounds(ft, le, _e, ze())), Pn.setValue(le, z.some({
        mode: "position",
        config: _e,
        getBounds: ze
      }));
    }, k = (le, pe, _e) => {
      $(le, pe, _e, z.none);
    }, $ = (le, pe, _e, ze) => {
      const ft = AG(t, le, pe, _e, ze);
      bo.open(le, ft), Pn.setValue(le, z.some({
        mode: "menu",
        menu: ft
      }));
    }, B = (le) => {
      bo.isOpen(le) && (Pn.setValue(le, z.none()), bo.close(le));
    }, j = (le) => bo.getState(le), Y = (le) => {
      bo.isOpen(le) && Pn.getValue(le).each((pe) => {
        switch (pe.mode) {
          case "menu":
            bo.getState(le).each(q0.repositionMenus);
            break;
          case "position":
            const _e = t.lazySink(le).getOrDie();
            Wl.positionWithinBounds(_e, le, pe.config, pe.getBounds());
            break;
        }
      });
    }, re = {
      setContent: p,
      showAt: y,
      showWithinBounds: x,
      showMenuAt: k,
      showMenuWithinBounds: $,
      hide: B,
      getContent: j,
      reposition: Y,
      isOpen: bo.isOpen
    };
    return {
      uid: t.uid,
      dom: t.dom,
      behaviours: _i(t.inlineBehaviours, [
        bo.config({
          isPartOf: (le, pe, _e) => th(pe, _e) || u(le, _e),
          getAttachPoint: (le) => t.lazySink(le).getOrDie(),
          onOpen: (le) => {
            t.onShow(le);
          },
          onClose: (le) => {
            t.onHide(le);
          }
        }),
        Pn.config({
          store: {
            mode: "memory",
            initialValue: z.none()
          }
        }),
        vu.config({
          channels: {
            ...eE({
              isExtraPart: a.isExtraPart,
              ...t.fireDismissalEventInstead.map((le) => ({ fireEventInstead: { event: le.event } })).getOr({})
            }),
            ...P0({
              ...t.fireRepositionEventInstead.map((le) => ({ fireEventInstead: { event: le.event } })).getOr({}),
              doReposition: Y
            })
          }
        })
      ]),
      eventOrder: t.eventOrder,
      apis: re
    };
  }, La = Yd({
    name: "InlineView",
    configFields: [
      Mt("lazySink"),
      po("onShow"),
      po("onHide"),
      Ip("onEscape"),
      ac("inlineBehaviours", [
        bo,
        Pn,
        vu
      ]),
      nl("fireDismissalEventInstead", [lt("event", jp())]),
      nl("fireRepositionEventInstead", [lt("event", ow())]),
      lt("getRelated", z.none),
      lt("isExtraPart", sn),
      lt("eventOrder", z.none)
    ],
    factory: kG,
    apis: {
      showAt: (t, a, u, p) => {
        t.showAt(a, u, p);
      },
      showWithinBounds: (t, a, u, p, y) => {
        t.showWithinBounds(a, u, p, y);
      },
      showMenuAt: (t, a, u, p) => {
        t.showMenuAt(a, u, p);
      },
      showMenuWithinBounds: (t, a, u, p, y) => {
        t.showMenuWithinBounds(a, u, p, y);
      },
      hide: (t, a) => {
        t.hide(a);
      },
      isOpen: (t, a) => t.isOpen(a),
      getContent: (t, a) => t.getContent(a),
      setContent: (t, a, u) => {
        t.setContent(a, u);
      },
      reposition: (t, a) => {
        t.reposition(a);
      }
    }
  });
  var EE = tinymce.util.Tools.resolve("tinymce.util.Delay");
  const cl = Yd({
    name: "Button",
    factory: (t) => {
      const a = wv(t.action), u = t.dom.tag, p = (x) => fn(t.dom, "attributes").bind((k) => fn(k, x)), y = () => {
        if (u === "button") {
          const x = p("type").getOr("button"), k = p("role").map(($) => ({ role: $ })).getOr({});
          return {
            type: x,
            ...k
          };
        } else
          return { role: t.role.getOr(p("role").getOr("button")) };
      };
      return {
        uid: t.uid,
        dom: t.dom,
        components: t.components,
        events: a,
        behaviours: bm.augment(t.buttonBehaviours, [
          Er.config({}),
          ar.config({
            mode: "execution",
            useSpace: !0,
            useEnter: !0
          })
        ]),
        domModification: { attributes: y() },
        eventOrder: t.eventOrder
      };
    },
    configFields: [
      lt("uid", void 0),
      Mt("dom"),
      lt("components", []),
      bm.field("buttonBehaviours", [
        Er,
        ar
      ]),
      Fo("action"),
      Fo("role"),
      lt("eventOrder", {})
    ]
  }), NG = (t) => {
    const a = t.dom.attributes !== void 0 ? t.dom.attributes : [];
    return Jt(a, (u, p) => p.name === "class" ? u : {
      ...u,
      [p.name]: p.value
    }, {});
  }, RG = (t) => Array.prototype.slice.call(t.dom.classList, 0), o1 = (t) => {
    const a = nt.fromHtml(t), u = Nc(a), p = NG(a), y = RG(a), x = u.length === 0 ? {} : { innerHtml: lb(a) };
    return {
      tag: kc(a),
      classes: y,
      attributes: p,
      ...x
    };
  }, ms = (t) => {
    const a = RI(t) && xa(t, "uid") ? t.uid : db("memento");
    return {
      get: (x) => x.getSystem().getByUid(a).getOrDie(),
      getOpt: (x) => x.getSystem().getByUid(a).toOptional(),
      asSpec: () => ({
        ...t,
        uid: a
      })
    };
  };
  /*! @license DOMPurify 3.1.7 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.1.7/LICENSE */
  const {
    entries: uM,
    setPrototypeOf: dM,
    isFrozen: PG,
    getPrototypeOf: DG,
    getOwnPropertyDescriptor: $G
  } = Object;
  let {
    freeze: Sm,
    seal: fg,
    create: o6
  } = Object, {
    apply: BN,
    construct: fM
  } = typeof Reflect < "u" && Reflect;
  Sm || (Sm = function(a) {
    return a;
  }), fg || (fg = function(a) {
    return a;
  }), BN || (BN = function(a, u, p) {
    return a.apply(u, p);
  }), fM || (fM = function(a, u) {
    return new a(...u);
  });
  const HN = fh(Array.prototype.forEach), s6 = fh(Array.prototype.pop), sO = fh(Array.prototype.push), zN = fh(String.prototype.toLowerCase), s1 = fh(String.prototype.toString), a6 = fh(String.prototype.match), aO = fh(String.prototype.replace), CE = fh(String.prototype.indexOf), i6 = fh(String.prototype.trim), Ev = fh(Object.prototype.hasOwnProperty), Ol = fh(RegExp.prototype.test), iO = mh(TypeError);
  function fh(t) {
    return function(a) {
      for (var u = arguments.length, p = new Array(u > 1 ? u - 1 : 0), y = 1; y < u; y++)
        p[y - 1] = arguments[y];
      return BN(t, a, p);
    };
  }
  function mh(t) {
    return function() {
      for (var a = arguments.length, u = new Array(a), p = 0; p < a; p++)
        u[p] = arguments[p];
      return fM(t, u);
    };
  }
  function js(t, a) {
    let u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : zN;
    dM && dM(t, null);
    let p = a.length;
    for (; p--; ) {
      let y = a[p];
      if (typeof y == "string") {
        const x = u(y);
        x !== y && (PG(a) || (a[p] = x), y = x);
      }
      t[y] = !0;
    }
    return t;
  }
  function c6(t) {
    for (let a = 0; a < t.length; a++)
      Ev(t, a) || (t[a] = null);
    return t;
  }
  function G0(t) {
    const a = o6(null);
    for (const [u, p] of uM(t))
      Ev(t, u) && (Array.isArray(p) ? a[u] = c6(p) : p && typeof p == "object" && p.constructor === Object ? a[u] = G0(p) : a[u] = p);
    return a;
  }
  function cO(t, a) {
    for (; t !== null; ) {
      const p = $G(t, a);
      if (p) {
        if (p.get)
          return fh(p.get);
        if (typeof p.value == "function")
          return fh(p.value);
      }
      t = DG(t);
    }
    function u() {
      return null;
    }
    return u;
  }
  const VN = Sm(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), mM = Sm(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), pM = Sm(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), IG = Sm(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), cT = Sm(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), hM = Sm(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), gM = Sm(["#text"]), vM = Sm(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), UN = Sm(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), l6 = Sm(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), WN = Sm(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), u6 = fg(/\{\{[\w\W]*|[\w\W]*\}\}/gm), MG = fg(/<%[\w\W]*|[\w\W]*%>/gm), bM = fg(/\${[\w\W]*}/gm), d6 = fg(/^data-[\-\w.\u00B7-\uFFFF]/), FG = fg(/^aria-[\-\w]+$/), f6 = fg(
    /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
    // eslint-disable-line no-useless-escape
  ), LG = fg(/^(?:\w+script|data):/i), yM = fg(
    /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
    // eslint-disable-line no-control-regex
  ), m6 = fg(/^html$/i), lO = fg(/^[a-z][.\w]*(-[.\w]+)+$/i);
  var uO = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    MUSTACHE_EXPR: u6,
    ERB_EXPR: MG,
    TMPLIT_EXPR: bM,
    DATA_ATTR: d6,
    ARIA_ATTR: FG,
    IS_ALLOWED_URI: f6,
    IS_SCRIPT_OR_DATA: LG,
    ATTR_WHITESPACE: yM,
    DOCTYPE_NAME: m6,
    CUSTOM_ELEMENT: lO
  });
  const lT = {
    element: 1,
    attribute: 2,
    text: 3,
    cdataSection: 4,
    entityReference: 5,
    // Deprecated
    entityNode: 6,
    // Deprecated
    progressingInstruction: 7,
    comment: 8,
    document: 9,
    documentType: 10,
    documentFragment: 11,
    notation: 12
    // Deprecated
  }, p6 = function() {
    return typeof window > "u" ? null : window;
  }, BG = function(a, u) {
    if (typeof a != "object" || typeof a.createPolicy != "function")
      return null;
    let p = null;
    const y = "data-tt-policy-suffix";
    u && u.hasAttribute(y) && (p = u.getAttribute(y));
    const x = "dompurify" + (p ? "#" + p : "");
    try {
      return a.createPolicy(x, {
        createHTML(k) {
          return k;
        },
        createScriptURL(k) {
          return k;
        }
      });
    } catch {
      return console.warn("TrustedTypes policy " + x + " could not be created."), null;
    }
  };
  function h6() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : p6();
    const a = (vo) => h6(vo);
    if (a.version = "3.1.7", a.removed = [], !t || !t.document || t.document.nodeType !== lT.document)
      return a.isSupported = !1, a;
    let {
      document: u
    } = t;
    const p = u, y = p.currentScript, {
      DocumentFragment: x,
      HTMLTemplateElement: k,
      Node: $,
      Element: B,
      NodeFilter: j,
      NamedNodeMap: Y = t.NamedNodeMap || t.MozNamedAttrMap,
      HTMLFormElement: re,
      DOMParser: le,
      trustedTypes: pe
    } = t, _e = B.prototype, ze = cO(_e, "cloneNode"), ft = cO(_e, "remove"), Xe = cO(_e, "nextSibling"), Ze = cO(_e, "childNodes"), mt = cO(_e, "parentNode");
    if (typeof k == "function") {
      const vo = u.createElement("template");
      vo.content && vo.content.ownerDocument && (u = vo.content.ownerDocument);
    }
    let jt, Dt = "";
    const {
      implementation: Nt,
      createNodeIterator: hn,
      createDocumentFragment: En,
      getElementsByTagName: zr
    } = u, {
      importNode: Yn
    } = p;
    let hr = {};
    a.isSupported = typeof uM == "function" && typeof mt == "function" && Nt && Nt.createHTMLDocument !== void 0;
    const {
      MUSTACHE_EXPR: Cr,
      ERB_EXPR: ns,
      TMPLIT_EXPR: dr,
      DATA_ATTR: ko,
      ARIA_ATTR: Cn,
      IS_SCRIPT_OR_DATA: Zn,
      ATTR_WHITESPACE: Ar,
      CUSTOM_ELEMENT: go
    } = uO;
    let {
      IS_ALLOWED_URI: vr
    } = uO, Mr = null;
    const Bs = js({}, [...VN, ...mM, ...pM, ...cT, ...gM]);
    let jo = null;
    const Gu = js({}, [...vM, ...UN, ...l6, ...WN]);
    let Ca = Object.seal(o6(null, {
      tagNameCheck: {
        writable: !0,
        configurable: !1,
        enumerable: !0,
        value: null
      },
      attributeNameCheck: {
        writable: !0,
        configurable: !1,
        enumerable: !0,
        value: null
      },
      allowCustomizedBuiltInElements: {
        writable: !0,
        configurable: !1,
        enumerable: !0,
        value: !1
      }
    })), Wf = null, xg = null, xS = !0, TS = !0, QE = !1, OD = !0, _S = !1, kL = !0, XE = !1, NL = !1, Fre = !1, AD = !1, W9 = !1, j9 = !1, Tle = !0, _le = !1;
    const c0e = "user-content-";
    let Lre = !0, RL = !1, kD = {}, ND = null;
    const Ole = js({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
    let Ale = null;
    const kle = js({}, ["audio", "video", "img", "source", "image", "track"]);
    let Bre = null;
    const Nle = js({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), q9 = "http://www.w3.org/1998/Math/MathML", G9 = "http://www.w3.org/2000/svg", JE = "http://www.w3.org/1999/xhtml";
    let RD = JE, Hre = !1, zre = null;
    const l0e = js({}, [q9, G9, JE], s1);
    let PL = null;
    const u0e = ["application/xhtml+xml", "text/html"], d0e = "text/html";
    let jf = null, PD = null;
    const f0e = u.createElement("form"), Rle = function(Ot) {
      return Ot instanceof RegExp || Ot instanceof Function;
    }, Vre = function() {
      let Ot = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!(PD && PD === Ot)) {
        if ((!Ot || typeof Ot != "object") && (Ot = {}), Ot = G0(Ot), PL = // eslint-disable-next-line unicorn/prefer-includes
        u0e.indexOf(Ot.PARSER_MEDIA_TYPE) === -1 ? d0e : Ot.PARSER_MEDIA_TYPE, jf = PL === "application/xhtml+xml" ? s1 : zN, Mr = Ev(Ot, "ALLOWED_TAGS") ? js({}, Ot.ALLOWED_TAGS, jf) : Bs, jo = Ev(Ot, "ALLOWED_ATTR") ? js({}, Ot.ALLOWED_ATTR, jf) : Gu, zre = Ev(Ot, "ALLOWED_NAMESPACES") ? js({}, Ot.ALLOWED_NAMESPACES, s1) : l0e, Bre = Ev(Ot, "ADD_URI_SAFE_ATTR") ? js(
          G0(Nle),
          // eslint-disable-line indent
          Ot.ADD_URI_SAFE_ATTR,
          // eslint-disable-line indent
          jf
          // eslint-disable-line indent
        ) : Nle, Ale = Ev(Ot, "ADD_DATA_URI_TAGS") ? js(
          G0(kle),
          // eslint-disable-line indent
          Ot.ADD_DATA_URI_TAGS,
          // eslint-disable-line indent
          jf
          // eslint-disable-line indent
        ) : kle, ND = Ev(Ot, "FORBID_CONTENTS") ? js({}, Ot.FORBID_CONTENTS, jf) : Ole, Wf = Ev(Ot, "FORBID_TAGS") ? js({}, Ot.FORBID_TAGS, jf) : {}, xg = Ev(Ot, "FORBID_ATTR") ? js({}, Ot.FORBID_ATTR, jf) : {}, kD = Ev(Ot, "USE_PROFILES") ? Ot.USE_PROFILES : !1, xS = Ot.ALLOW_ARIA_ATTR !== !1, TS = Ot.ALLOW_DATA_ATTR !== !1, QE = Ot.ALLOW_UNKNOWN_PROTOCOLS || !1, OD = Ot.ALLOW_SELF_CLOSE_IN_ATTR !== !1, _S = Ot.SAFE_FOR_TEMPLATES || !1, kL = Ot.SAFE_FOR_XML !== !1, XE = Ot.WHOLE_DOCUMENT || !1, AD = Ot.RETURN_DOM || !1, W9 = Ot.RETURN_DOM_FRAGMENT || !1, j9 = Ot.RETURN_TRUSTED_TYPE || !1, Fre = Ot.FORCE_BODY || !1, Tle = Ot.SANITIZE_DOM !== !1, _le = Ot.SANITIZE_NAMED_PROPS || !1, Lre = Ot.KEEP_CONTENT !== !1, RL = Ot.IN_PLACE || !1, vr = Ot.ALLOWED_URI_REGEXP || f6, RD = Ot.NAMESPACE || JE, Ca = Ot.CUSTOM_ELEMENT_HANDLING || {}, Ot.CUSTOM_ELEMENT_HANDLING && Rle(Ot.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Ca.tagNameCheck = Ot.CUSTOM_ELEMENT_HANDLING.tagNameCheck), Ot.CUSTOM_ELEMENT_HANDLING && Rle(Ot.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Ca.attributeNameCheck = Ot.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), Ot.CUSTOM_ELEMENT_HANDLING && typeof Ot.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (Ca.allowCustomizedBuiltInElements = Ot.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), _S && (TS = !1), W9 && (AD = !0), kD && (Mr = js({}, gM), jo = [], kD.html === !0 && (js(Mr, VN), js(jo, vM)), kD.svg === !0 && (js(Mr, mM), js(jo, UN), js(jo, WN)), kD.svgFilters === !0 && (js(Mr, pM), js(jo, UN), js(jo, WN)), kD.mathMl === !0 && (js(Mr, cT), js(jo, l6), js(jo, WN))), Ot.ADD_TAGS && (Mr === Bs && (Mr = G0(Mr)), js(Mr, Ot.ADD_TAGS, jf)), Ot.ADD_ATTR && (jo === Gu && (jo = G0(jo)), js(jo, Ot.ADD_ATTR, jf)), Ot.ADD_URI_SAFE_ATTR && js(Bre, Ot.ADD_URI_SAFE_ATTR, jf), Ot.FORBID_CONTENTS && (ND === Ole && (ND = G0(ND)), js(ND, Ot.FORBID_CONTENTS, jf)), Lre && (Mr["#text"] = !0), XE && js(Mr, ["html", "head", "body"]), Mr.table && (js(Mr, ["tbody"]), delete Wf.tbody), Ot.TRUSTED_TYPES_POLICY) {
          if (typeof Ot.TRUSTED_TYPES_POLICY.createHTML != "function")
            throw iO('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
          if (typeof Ot.TRUSTED_TYPES_POLICY.createScriptURL != "function")
            throw iO('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
          jt = Ot.TRUSTED_TYPES_POLICY, Dt = jt.createHTML("");
        } else
          jt === void 0 && (jt = BG(pe, y)), jt !== null && typeof Dt == "string" && (Dt = jt.createHTML(""));
        Sm && Sm(Ot), PD = Ot;
      }
    }, Ple = js({}, ["mi", "mo", "mn", "ms", "mtext"]), Dle = js({}, ["annotation-xml"]), m0e = js({}, ["title", "style", "font", "a", "script"]), $le = js({}, [...mM, ...pM, ...IG]), Ile = js({}, [...cT, ...hM]), p0e = function(Ot) {
      let or = mt(Ot);
      (!or || !or.tagName) && (or = {
        namespaceURI: RD,
        tagName: "template"
      });
      const to = zN(Ot.tagName), Uc = zN(or.tagName);
      return zre[Ot.namespaceURI] ? Ot.namespaceURI === G9 ? or.namespaceURI === JE ? to === "svg" : or.namespaceURI === q9 ? to === "svg" && (Uc === "annotation-xml" || Ple[Uc]) : !!$le[to] : Ot.namespaceURI === q9 ? or.namespaceURI === JE ? to === "math" : or.namespaceURI === G9 ? to === "math" && Dle[Uc] : !!Ile[to] : Ot.namespaceURI === JE ? or.namespaceURI === G9 && !Dle[Uc] || or.namespaceURI === q9 && !Ple[Uc] ? !1 : !Ile[to] && (m0e[to] || !$le[to]) : !!(PL === "application/xhtml+xml" && zre[Ot.namespaceURI]) : !1;
    }, OS = function(Ot) {
      sO(a.removed, {
        element: Ot
      });
      try {
        mt(Ot).removeChild(Ot);
      } catch {
        ft(Ot);
      }
    }, DL = function(Ot, or) {
      try {
        sO(a.removed, {
          attribute: or.getAttributeNode(Ot),
          from: or
        });
      } catch {
        sO(a.removed, {
          attribute: null,
          from: or
        });
      }
      if (or.removeAttribute(Ot), Ot === "is" && !jo[Ot])
        if (AD || W9)
          try {
            OS(or);
          } catch {
          }
        else
          try {
            or.setAttribute(Ot, "");
          } catch {
          }
    }, Mle = function(Ot) {
      let or = null, to = null;
      if (Fre)
        Ot = "<remove></remove>" + Ot;
      else {
        const qf = a6(Ot, /^[\r\n\t ]+/);
        to = qf && qf[0];
      }
      PL === "application/xhtml+xml" && RD === JE && (Ot = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + Ot + "</body></html>");
      const Uc = jt ? jt.createHTML(Ot) : Ot;
      if (RD === JE)
        try {
          or = new le().parseFromString(Uc, PL);
        } catch {
        }
      if (!or || !or.documentElement) {
        or = Nt.createDocument(RD, "template", null);
        try {
          or.documentElement.innerHTML = Hre ? Dt : Uc;
        } catch {
        }
      }
      const mp = or.body || or.documentElement;
      return Ot && to && mp.insertBefore(u.createTextNode(to), mp.childNodes[0] || null), RD === JE ? zr.call(or, XE ? "html" : "body")[0] : XE ? or.documentElement : mp;
    }, Fle = function(Ot) {
      return hn.call(
        Ot.ownerDocument || Ot,
        Ot,
        // eslint-disable-next-line no-bitwise
        j.SHOW_ELEMENT | j.SHOW_COMMENT | j.SHOW_TEXT | j.SHOW_PROCESSING_INSTRUCTION | j.SHOW_CDATA_SECTION,
        null
      );
    }, Lle = function(Ot) {
      return Ot instanceof re && (typeof Ot.nodeName != "string" || typeof Ot.textContent != "string" || typeof Ot.removeChild != "function" || !(Ot.attributes instanceof Y) || typeof Ot.removeAttribute != "function" || typeof Ot.setAttribute != "function" || typeof Ot.namespaceURI != "string" || typeof Ot.insertBefore != "function" || typeof Ot.hasChildNodes != "function");
    }, Ble = function(Ot) {
      return typeof $ == "function" && Ot instanceof $;
    }, eC = function(Ot, or, to) {
      hr[Ot] && HN(hr[Ot], (Uc) => {
        Uc.call(a, or, to, PD);
      });
    }, Hle = function(Ot) {
      let or = null;
      if (eC("beforeSanitizeElements", Ot, null), Lle(Ot))
        return OS(Ot), !0;
      const to = jf(Ot.nodeName);
      if (eC("uponSanitizeElement", Ot, {
        tagName: to,
        allowedTags: Mr
      }), Ot.hasChildNodes() && !Ble(Ot.firstElementChild) && Ol(/<[/\w]/g, Ot.innerHTML) && Ol(/<[/\w]/g, Ot.textContent) || Ot.nodeType === lT.progressingInstruction || kL && Ot.nodeType === lT.comment && Ol(/<[/\w]/g, Ot.data))
        return OS(Ot), !0;
      if (!Mr[to] || Wf[to]) {
        if (!Wf[to] && Vle(to) && (Ca.tagNameCheck instanceof RegExp && Ol(Ca.tagNameCheck, to) || Ca.tagNameCheck instanceof Function && Ca.tagNameCheck(to)))
          return !1;
        if (Lre && !ND[to]) {
          const Uc = mt(Ot) || Ot.parentNode, mp = Ze(Ot) || Ot.childNodes;
          if (mp && Uc) {
            const qf = mp.length;
            for (let Tg = qf - 1; Tg >= 0; --Tg) {
              const AS = ze(mp[Tg], !0);
              AS.__removalCount = (Ot.__removalCount || 0) + 1, Uc.insertBefore(AS, Xe(Ot));
            }
          }
        }
        return OS(Ot), !0;
      }
      return Ot instanceof B && !p0e(Ot) || (to === "noscript" || to === "noembed" || to === "noframes") && Ol(/<\/no(script|embed|frames)/i, Ot.innerHTML) ? (OS(Ot), !0) : (_S && Ot.nodeType === lT.text && (or = Ot.textContent, HN([Cr, ns, dr], (Uc) => {
        or = aO(or, Uc, " ");
      }), Ot.textContent !== or && (sO(a.removed, {
        element: Ot.cloneNode()
      }), Ot.textContent = or)), eC("afterSanitizeElements", Ot, null), !1);
    }, zle = function(Ot, or, to) {
      if (Tle && (or === "id" || or === "name") && (to in u || to in f0e))
        return !1;
      if (!(TS && !xg[or] && Ol(ko, or))) {
        if (!(xS && Ol(Cn, or))) {
          if (!jo[or] || xg[or]) {
            if (
              // First condition does a very basic check if a) it's basically a valid custom element tagname AND
              // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
              !(Vle(Ot) && (Ca.tagNameCheck instanceof RegExp && Ol(Ca.tagNameCheck, Ot) || Ca.tagNameCheck instanceof Function && Ca.tagNameCheck(Ot)) && (Ca.attributeNameCheck instanceof RegExp && Ol(Ca.attributeNameCheck, or) || Ca.attributeNameCheck instanceof Function && Ca.attributeNameCheck(or)) || // Alternative, second condition checks if it's an `is`-attribute, AND
              // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              or === "is" && Ca.allowCustomizedBuiltInElements && (Ca.tagNameCheck instanceof RegExp && Ol(Ca.tagNameCheck, to) || Ca.tagNameCheck instanceof Function && Ca.tagNameCheck(to)))
            )
              return !1;
          } else if (!Bre[or]) {
            if (!Ol(vr, aO(to, Ar, ""))) {
              if (!((or === "src" || or === "xlink:href" || or === "href") && Ot !== "script" && CE(to, "data:") === 0 && Ale[Ot])) {
                if (!(QE && !Ol(Zn, aO(to, Ar, "")))) {
                  if (to)
                    return !1;
                }
              }
            }
          }
        }
      }
      return !0;
    }, Vle = function(Ot) {
      return Ot !== "annotation-xml" && a6(Ot, go);
    }, Ule = function(Ot) {
      eC("beforeSanitizeAttributes", Ot, null);
      const {
        attributes: or
      } = Ot;
      if (!or)
        return;
      const to = {
        attrName: "",
        attrValue: "",
        keepAttr: !0,
        allowedAttributes: jo
      };
      let Uc = or.length;
      for (; Uc--; ) {
        const mp = or[Uc], {
          name: qf,
          namespaceURI: Tg,
          value: AS
        } = mp, $L = jf(qf);
        let _m = qf === "value" ? AS : i6(AS);
        const g0e = _m;
        if (to.attrName = $L, to.attrValue = _m, to.keepAttr = !0, to.forceKeepAttr = void 0, eC("uponSanitizeAttribute", Ot, to), _m = to.attrValue, to.forceKeepAttr)
          continue;
        if (!to.keepAttr) {
          DL(qf, Ot);
          continue;
        }
        if (!OD && Ol(/\/>/i, _m)) {
          DL(qf, Ot);
          continue;
        }
        _S && HN([Cr, ns, dr], (jle) => {
          _m = aO(_m, jle, " ");
        });
        const Wle = jf(Ot.nodeName);
        if (!zle(Wle, $L, _m)) {
          DL(qf, Ot);
          continue;
        }
        if (_le && ($L === "id" || $L === "name") && (DL(qf, Ot), _m = c0e + _m), kL && Ol(/((--!?|])>)|<\/(style|title)/i, _m)) {
          DL(qf, Ot);
          continue;
        }
        if (jt && typeof pe == "object" && typeof pe.getAttributeType == "function" && !Tg)
          switch (pe.getAttributeType(Wle, $L)) {
            case "TrustedHTML": {
              _m = jt.createHTML(_m);
              break;
            }
            case "TrustedScriptURL": {
              _m = jt.createScriptURL(_m);
              break;
            }
          }
        if (_m !== g0e)
          try {
            Tg ? Ot.setAttributeNS(Tg, qf, _m) : Ot.setAttribute(qf, _m), Lle(Ot) ? OS(Ot) : s6(a.removed);
          } catch {
          }
      }
      eC("afterSanitizeAttributes", Ot, null);
    }, h0e = function vo(Ot) {
      let or = null;
      const to = Fle(Ot);
      for (eC("beforeSanitizeShadowDOM", Ot, null); or = to.nextNode(); )
        eC("uponSanitizeShadowNode", or, null), !Hle(or) && (or.content instanceof x && vo(or.content), Ule(or));
      eC("afterSanitizeShadowDOM", Ot, null);
    };
    return a.sanitize = function(vo) {
      let Ot = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, or = null, to = null, Uc = null, mp = null;
      if (Hre = !vo, Hre && (vo = "<!-->"), typeof vo != "string" && !Ble(vo))
        if (typeof vo.toString == "function") {
          if (vo = vo.toString(), typeof vo != "string")
            throw iO("dirty is not a string, aborting");
        } else
          throw iO("toString is not a function");
      if (!a.isSupported)
        return vo;
      if (NL || Vre(Ot), a.removed = [], typeof vo == "string" && (RL = !1), RL) {
        if (vo.nodeName) {
          const AS = jf(vo.nodeName);
          if (!Mr[AS] || Wf[AS])
            throw iO("root node is forbidden and cannot be sanitized in-place");
        }
      } else if (vo instanceof $)
        or = Mle("<!---->"), to = or.ownerDocument.importNode(vo, !0), to.nodeType === lT.element && to.nodeName === "BODY" || to.nodeName === "HTML" ? or = to : or.appendChild(to);
      else {
        if (!AD && !_S && !XE && // eslint-disable-next-line unicorn/prefer-includes
        vo.indexOf("<") === -1)
          return jt && j9 ? jt.createHTML(vo) : vo;
        if (or = Mle(vo), !or)
          return AD ? null : j9 ? Dt : "";
      }
      or && Fre && OS(or.firstChild);
      const qf = Fle(RL ? vo : or);
      for (; Uc = qf.nextNode(); )
        Hle(Uc) || (Uc.content instanceof x && h0e(Uc.content), Ule(Uc));
      if (RL)
        return vo;
      if (AD) {
        if (W9)
          for (mp = En.call(or.ownerDocument); or.firstChild; )
            mp.appendChild(or.firstChild);
        else
          mp = or;
        return (jo.shadowroot || jo.shadowrootmode) && (mp = Yn.call(p, mp, !0)), mp;
      }
      let Tg = XE ? or.outerHTML : or.innerHTML;
      return XE && Mr["!doctype"] && or.ownerDocument && or.ownerDocument.doctype && or.ownerDocument.doctype.name && Ol(m6, or.ownerDocument.doctype.name) && (Tg = "<!DOCTYPE " + or.ownerDocument.doctype.name + `>
` + Tg), _S && HN([Cr, ns, dr], (AS) => {
        Tg = aO(Tg, AS, " ");
      }), jt && j9 ? jt.createHTML(Tg) : Tg;
    }, a.setConfig = function() {
      let vo = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      Vre(vo), NL = !0;
    }, a.clearConfig = function() {
      PD = null, NL = !1;
    }, a.isValidAttribute = function(vo, Ot, or) {
      PD || Vre({});
      const to = jf(vo), Uc = jf(Ot);
      return zle(to, Uc, or);
    }, a.addHook = function(vo, Ot) {
      typeof Ot == "function" && (hr[vo] = hr[vo] || [], sO(hr[vo], Ot));
    }, a.removeHook = function(vo) {
      if (hr[vo])
        return s6(hr[vo]);
    }, a.removeHooks = function(vo) {
      hr[vo] && (hr[vo] = []);
    }, a.removeAllHooks = function() {
      hr = {};
    }, a;
  }
  var HG = h6();
  const g6 = (t) => HG().sanitize(t);
  var Mf = tinymce.util.Tools.resolve("tinymce.util.I18n");
  const v6 = {
    indent: !0,
    outdent: !0,
    "table-insert-column-after": !0,
    "table-insert-column-before": !0,
    "paste-column-after": !0,
    "paste-column-before": !0,
    "unordered-list": !0,
    "list-bull-circle": !0,
    "list-bull-default": !0,
    "list-bull-square": !0
  }, SM = "temporary-placeholder", dO = (t) => () => fn(t, SM).getOr("!not found!"), wM = (t, a) => {
    const u = t.toLowerCase();
    if (Mf.isRtl()) {
      const p = Qa(u, "-rtl");
      return Yr(a, p) ? p : u;
    } else
      return u;
  }, EM = (t, a) => fn(a, wM(t, a)), b6 = (t, a) => {
    const u = a();
    return EM(t, u).getOrThunk(dO(u));
  }, zG = (t, a, u) => {
    const p = a();
    return EM(t, p).or(u).getOrThunk(dO(p));
  }, VG = (t) => Mf.isRtl() ? Yr(v6, t) : !1, jN = () => Hr("add-focusable", [us((t) => {
    s0(t.element, "svg").each((a) => kn(a, "focusable", "false"));
  })]), y6 = (t, a, u, p) => {
    var y, x;
    const k = VG(a) ? ["tox-icon--flip"] : [], $ = fn(u, wM(a, u)).or(p).getOrThunk(dO(u));
    return {
      dom: {
        tag: t.tag,
        attributes: (y = t.attributes) !== null && y !== void 0 ? y : {},
        classes: t.classes.concat(k),
        innerHtml: $
      },
      behaviours: mn([
        ...(x = t.behaviours) !== null && x !== void 0 ? x : [],
        jN()
      ])
    };
  }, mg = (t, a, u, p = z.none()) => y6(a, t, u(), p), CM = (t, a, u) => {
    const p = u(), y = Ge(t, (x) => Yr(p, wM(x, p)));
    return y6(a, y.getOr(SM), p, z.none());
  }, S6 = {
    success: "checkmark",
    error: "warning",
    err: "error",
    warning: "warning",
    warn: "warning",
    info: "info"
  }, xM = Yd({
    name: "Notification",
    factory: (t) => {
      const a = ms({
        dom: o1(`<p>${g6(t.translationProvider(t.text))}</p>`),
        behaviours: mn([$r.config({})])
      }), u = (pe) => ({
        dom: {
          tag: "div",
          classes: ["tox-bar"],
          styles: { width: `${pe}%` }
        }
      }), p = (pe) => ({
        dom: {
          tag: "div",
          classes: ["tox-text"],
          innerHtml: `${pe}%`
        }
      }), y = ms({
        dom: {
          tag: "div",
          classes: t.progress ? [
            "tox-progress-bar",
            "tox-progress-indicator"
          ] : ["tox-progress-bar"]
        },
        components: [
          {
            dom: {
              tag: "div",
              classes: ["tox-bar-container"]
            },
            components: [u(0)]
          },
          p(0)
        ],
        behaviours: mn([$r.config({})])
      }), $ = {
        updateProgress: (pe, _e) => {
          pe.getSystem().isConnected() && y.getOpt(pe).each((ze) => {
            $r.set(ze, [
              {
                dom: {
                  tag: "div",
                  classes: ["tox-bar-container"]
                },
                components: [u(_e)]
              },
              p(_e)
            ]);
          });
        },
        updateText: (pe, _e) => {
          if (pe.getSystem().isConnected()) {
            const ze = a.get(pe);
            $r.set(ze, [Ma(_e)]);
          }
        }
      }, B = St([
        t.icon.toArray(),
        t.level.toArray(),
        t.level.bind((pe) => z.from(S6[pe])).toArray()
      ]), j = ms(cl.sketch({
        dom: {
          tag: "button",
          classes: [
            "tox-notification__dismiss",
            "tox-button",
            "tox-button--naked",
            "tox-button--icon"
          ]
        },
        components: [mg("close", {
          tag: "span",
          classes: ["tox-icon"],
          attributes: { "aria-label": t.translationProvider("Close") }
        }, t.iconProvider)],
        action: (pe) => {
          t.onAction(pe);
        }
      })), Y = CM(B, {
        tag: "div",
        classes: ["tox-notification__icon"]
      }, t.iconProvider), re = {
        dom: {
          tag: "div",
          classes: ["tox-notification__body"]
        },
        components: [a.asSpec()],
        behaviours: mn([$r.config({})])
      }, le = [
        Y,
        re
      ];
      return {
        uid: t.uid,
        dom: {
          tag: "div",
          attributes: { role: "alert" },
          classes: t.level.map((pe) => [
            "tox-notification",
            "tox-notification--in",
            `tox-notification--${pe}`
          ]).getOr([
            "tox-notification",
            "tox-notification--in"
          ])
        },
        behaviours: mn([
          Er.config({}),
          Hr("notification-events", [Pt(oa(), (pe) => {
            j.getOpt(pe).each(Er.focus);
          })])
        ]),
        components: le.concat(t.progress ? [y.asSpec()] : []).concat(t.closeButton ? [j.asSpec()] : []),
        apis: $
      };
    },
    configFields: [
      Fo("level"),
      Mt("progress"),
      Fo("icon"),
      Mt("onAction"),
      Mt("text"),
      Mt("iconProvider"),
      Mt("translationProvider"),
      vi("closeButton", !0)
    ],
    apis: {
      updateProgress: (t, a, u) => {
        t.updateProgress(a, u);
      },
      updateText: (t, a, u) => {
        t.updateText(a, u);
      }
    }
  });
  var TM = (t, a, u) => {
    const p = a.backstage.shared, y = () => {
      const B = Ss(nt.fromDom(t.getContentAreaContainer())), j = Ci(), Y = fd(j.x, B.x, B.right), re = fd(j.y, B.y, B.bottom), le = Math.max(B.right, j.right), pe = Math.max(B.bottom, j.bottom);
      return z.some(cs(Y, re, le - Y, pe - re));
    };
    return {
      open: (B, j) => {
        const Y = () => {
          j(), La.hide(le);
        }, re = sl(xM.sketch({
          text: B.text,
          level: vt([
            "success",
            "error",
            "warning",
            "warn",
            "info"
          ], B.type) ? B.type : void 0,
          progress: B.progressBar === !0,
          icon: B.icon,
          closeButton: B.closeButton,
          onAction: Y,
          iconProvider: p.providers.icons,
          translationProvider: p.providers.translate
        })), le = sl(La.sketch({
          dom: {
            tag: "div",
            classes: ["tox-notifications-container"]
          },
          lazySink: p.getSink,
          fireDismissalEventInstead: {},
          ...p.header.isPositionedAtTop() ? {} : { fireRepositionEventInstead: {} }
        }));
        u.add(le), he(B.timeout) && B.timeout > 0 && EE.setEditorTimeout(t, () => {
          Y();
        }, B.timeout);
        const _e = {
          close: Y,
          reposition: () => {
            const ze = Hu(re), ft = { maxHeightFunction: vm() }, Xe = t.notificationManager.getNotifications();
            if (Xe[0] === _e) {
              const Ze = {
                ...p.anchors.banner(),
                overrides: ft
              };
              La.showWithinBounds(le, ze, { anchor: Ze }, y);
            } else
              Ne(Xe, _e).each((Ze) => {
                const mt = Xe[Ze - 1].getEl(), jt = {
                  type: "node",
                  root: ta(),
                  node: z.some(nt.fromDom(mt)),
                  overrides: ft,
                  layouts: {
                    onRtl: () => [Os],
                    onLtr: () => [Os]
                  }
                };
                La.showWithinBounds(le, ze, { anchor: jt }, y);
              });
          },
          text: (ze) => {
            xM.updateText(re, ze);
          },
          settings: B,
          getEl: () => re.element.dom,
          progressBar: {
            value: (ze) => {
              xM.updateProgress(re, ze);
            }
          }
        };
        return _e;
      },
      close: (B) => {
        B.close();
      },
      getArgs: (B) => B.settings
    };
  }, uT = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"), WG = tinymce.util.Tools.resolve("tinymce.EditorManager"), dT = tinymce.util.Tools.resolve("tinymce.Env"), ph;
  (function(t) {
    t.default = "wrap", t.floating = "floating", t.sliding = "sliding", t.scrolling = "scrolling";
  })(ph || (ph = {}));
  var fO;
  (function(t) {
    t.auto = "auto", t.top = "top", t.bottom = "bottom";
  })(fO || (fO = {}));
  const Ls = (t) => (a) => a.options.get(t), xE = (t) => (a) => z.from(t(a)), w6 = (t) => {
    const a = dT.deviceType.isPhone(), u = dT.deviceType.isTablet() || a, p = t.options.register, y = (k) => g(k) || k === !1, x = (k) => g(k) || he(k);
    p("skin", {
      processor: (k) => g(k) || k === !1,
      default: "oxide"
    }), p("skin_url", { processor: "string" }), p("height", {
      processor: x,
      default: Math.max(t.getElement().offsetHeight, 400)
    }), p("width", {
      processor: x,
      default: uT.DOM.getStyle(t.getElement(), "width")
    }), p("min_height", {
      processor: "number",
      default: 100
    }), p("min_width", { processor: "number" }), p("max_height", { processor: "number" }), p("max_width", { processor: "number" }), p("style_formats", { processor: "object[]" }), p("style_formats_merge", {
      processor: "boolean",
      default: !1
    }), p("style_formats_autohide", {
      processor: "boolean",
      default: !1
    }), p("line_height_formats", {
      processor: "string",
      default: "1 1.1 1.2 1.3 1.4 1.5 2"
    }), p("font_family_formats", {
      processor: "string",
      default: "Andale Mono=andale mono,monospace;Arial=arial,helvetica,sans-serif;Arial Black=arial black,sans-serif;Book Antiqua=book antiqua,palatino,serif;Comic Sans MS=comic sans ms,sans-serif;Courier New=courier new,courier,monospace;Georgia=georgia,palatino,serif;Helvetica=helvetica,arial,sans-serif;Impact=impact,sans-serif;Symbol=symbol;Tahoma=tahoma,arial,helvetica,sans-serif;Terminal=terminal,monaco,monospace;Times New Roman=times new roman,times,serif;Trebuchet MS=trebuchet ms,geneva,sans-serif;Verdana=verdana,geneva,sans-serif;Webdings=webdings;Wingdings=wingdings,zapf dingbats"
    }), p("font_size_formats", {
      processor: "string",
      default: "8pt 10pt 12pt 14pt 18pt 24pt 36pt"
    }), p("font_size_input_default_unit", {
      processor: "string",
      default: "pt"
    }), p("block_formats", {
      processor: "string",
      default: "Paragraph=p;Heading 1=h1;Heading 2=h2;Heading 3=h3;Heading 4=h4;Heading 5=h5;Heading 6=h6;Preformatted=pre"
    }), p("content_langs", { processor: "object[]" }), p("removed_menuitems", {
      processor: "string",
      default: ""
    }), p("menubar", {
      processor: (k) => g(k) || L(k),
      default: !a
    }), p("menu", {
      processor: "object",
      default: {}
    }), p("toolbar", {
      processor: (k) => L(k) || g(k) || R(k) ? {
        value: k,
        valid: !0
      } : {
        valid: !1,
        message: "Must be a boolean, string or array."
      },
      default: !0
    }), xt(9, (k) => {
      p("toolbar" + (k + 1), { processor: "string" });
    }), p("toolbar_mode", {
      processor: "string",
      default: u ? "scrolling" : "floating"
    }), p("toolbar_groups", {
      processor: "object",
      default: {}
    }), p("toolbar_location", {
      processor: "string",
      default: fO.auto
    }), p("toolbar_persist", {
      processor: "boolean",
      default: !1
    }), p("toolbar_sticky", {
      processor: "boolean",
      default: t.inline
    }), p("toolbar_sticky_offset", {
      processor: "number",
      default: 0
    }), p("fixed_toolbar_container", {
      processor: "string",
      default: ""
    }), p("fixed_toolbar_container_target", { processor: "object" }), p("ui_mode", {
      processor: "string",
      default: "combined"
    }), p("file_picker_callback", { processor: "function" }), p("file_picker_validator_handler", { processor: "function" }), p("file_picker_types", { processor: "string" }), p("typeahead_urls", {
      processor: "boolean",
      default: !0
    }), p("anchor_top", {
      processor: y,
      default: "#top"
    }), p("anchor_bottom", {
      processor: y,
      default: "#bottom"
    }), p("draggable_modal", {
      processor: "boolean",
      default: !1
    }), p("statusbar", {
      processor: "boolean",
      default: !0
    }), p("elementpath", {
      processor: "boolean",
      default: !0
    }), p("branding", {
      processor: "boolean",
      default: !0
    }), p("promotion", {
      processor: "boolean",
      default: !0
    }), p("resize", {
      processor: (k) => k === "both" || L(k),
      default: !dT.deviceType.isTouch()
    }), p("sidebar_show", { processor: "string" }), p("help_accessibility", {
      processor: "boolean",
      default: t.hasPlugin("help")
    }), p("default_font_stack", {
      processor: "string[]",
      default: []
    });
  }, mO = Ls("readonly"), _M = Ls("height"), OM = Ls("width"), AM = xE(Ls("min_width")), kM = xE(Ls("min_height")), qN = xE(Ls("max_width")), NM = xE(Ls("max_height")), RM = xE(Ls("style_formats")), E6 = Ls("style_formats_merge"), C6 = Ls("style_formats_autohide"), GN = Ls("content_langs"), Z0 = Ls("removed_menuitems"), fT = Ls("toolbar_mode"), x6 = Ls("toolbar_groups"), pO = Ls("toolbar_location"), T6 = Ls("fixed_toolbar_container"), jG = Ls("fixed_toolbar_container_target"), _6 = Ls("toolbar_persist"), PM = Ls("toolbar_sticky_offset"), O6 = Ls("menubar"), hO = Ls("toolbar"), DM = Ls("file_picker_callback"), ZN = Ls("file_picker_validator_handler"), A6 = Ls("font_size_input_default_unit"), $M = Ls("file_picker_types"), k6 = Ls("typeahead_urls"), mT = Ls("anchor_top"), N6 = Ls("anchor_bottom"), R6 = Ls("draggable_modal"), KN = Ls("statusbar"), YN = Ls("elementpath"), IM = Ls("branding"), QN = Ls("resize"), P6 = Ls("paste_as_text"), D6 = Ls("sidebar_show"), XN = Ls("promotion"), $6 = Ls("help_accessibility"), I6 = Ls("default_font_stack"), MM = (t) => t.options.get("skin") === !1, JN = (t) => t.options.get("menubar") !== !1, eR = (t) => {
    const a = t.options.get("skin_url");
    if (MM(t))
      return a;
    if (a)
      return t.documentBaseURI.toAbsolute(a);
    {
      const u = t.options.get("skin");
      return WG.baseURL + "/skins/ui/" + u;
    }
  }, tR = (t) => z.from(t.options.get("skin_url")), M6 = (t) => t.options.get("line_height_formats").split(" "), nR = (t) => {
    const a = hO(t), u = g(a), p = R(a) && a.length > 0;
    return !gO(t) && (p || u || a === !0);
  }, FM = (t) => {
    const a = xt(9, (p) => t.options.get("toolbar" + (p + 1))), u = Rn(a, g);
    return lr(u.length > 0, u);
  }, gO = (t) => FM(t).fold(() => {
    const a = hO(t);
    return ue(a, g) && a.length > 0;
  }, Lt), LM = (t) => pO(t) === fO.bottom, F6 = (t) => {
    var a;
    if (!t.inline)
      return z.none();
    const u = (a = T6(t)) !== null && a !== void 0 ? a : "";
    if (u.length > 0)
      return qa(ta(), u);
    const p = jG(t);
    return se(p) ? z.some(nt.fromDom(p)) : z.none();
  }, K0 = (t) => t.inline && F6(t).isSome(), BM = (t) => F6(t).getOrThunk(() => en(wt(nt.fromDom(t.getElement())))), HM = (t) => t.inline && !JN(t) && !nR(t) && !gO(t), vO = (t) => (t.options.get("toolbar_sticky") || t.inline) && !K0(t) && !HM(t), a1 = (t) => !K0(t) && t.options.get("ui_mode") === "split", L6 = (t) => {
    const a = t.options.get("menu");
    return uo(a, (u) => ({
      ...u,
      items: u.items
    }));
  };
  var qG = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    get ToolbarMode() {
      return ph;
    },
    get ToolbarLocation() {
      return fO;
    },
    register: w6,
    getSkinUrl: eR,
    getSkinUrlOption: tR,
    isReadOnly: mO,
    isSkinDisabled: MM,
    getHeightOption: _M,
    getWidthOption: OM,
    getMinWidthOption: AM,
    getMinHeightOption: kM,
    getMaxWidthOption: qN,
    getMaxHeightOption: NM,
    getUserStyleFormats: RM,
    shouldMergeStyleFormats: E6,
    shouldAutoHideStyleFormats: C6,
    getLineHeightFormats: M6,
    getContentLanguages: GN,
    getRemovedMenuItems: Z0,
    isMenubarEnabled: JN,
    isMultipleToolbars: gO,
    isToolbarEnabled: nR,
    isToolbarPersist: _6,
    getMultipleToolbarsOption: FM,
    getUiContainer: BM,
    useFixedContainer: K0,
    isSplitUiMode: a1,
    getToolbarMode: fT,
    isDraggableModal: R6,
    isDistractionFree: HM,
    isStickyToolbar: vO,
    getStickyToolbarOffset: PM,
    getToolbarLocation: pO,
    isToolbarLocationBottom: LM,
    getToolbarGroups: x6,
    getMenus: L6,
    getMenubar: O6,
    getToolbar: hO,
    getFilePickerCallback: DM,
    getFilePickerTypes: $M,
    useTypeaheadUrls: k6,
    getAnchorTop: mT,
    getAnchorBottom: N6,
    getFilePickerValidatorHandler: ZN,
    getFontSizeInputDefaultUnit: A6,
    useStatusBar: KN,
    useElementPath: YN,
    promotionEnabled: XN,
    useBranding: IM,
    getResize: QN,
    getPasteAsText: P6,
    getSidebarShow: D6,
    useHelpAccessibility: $6,
    getDefaultFontStack: I6
  });
  const B6 = "[data-mce-autocompleter]", H6 = (t) => fm(t, B6), GG = (t) => qa(t, B6), zM = { setup: (t, a) => {
    const u = (y, x) => {
      nr(y, ud(), { raw: x });
    }, p = () => t.getMenu().bind(Wo.getHighlighted);
    a.on("keydown", (y) => {
      const x = y.which;
      t.isActive() && (t.isMenuOpen() ? x === 13 ? (p().each(Ef), y.preventDefault()) : x === 40 ? (p().fold(() => {
        t.getMenu().each(Wo.highlightFirst);
      }, (k) => {
        u(k, y);
      }), y.preventDefault(), y.stopImmediatePropagation()) : (x === 37 || x === 38 || x === 39) && p().each((k) => {
        u(k, y), y.preventDefault(), y.stopImmediatePropagation();
      }) : (x === 13 || x === 38 || x === 40) && t.cancelIfNecessary());
    }), a.on("NodeChange", (y) => {
      t.isActive() && !t.isProcessingAction() && H6(nt.fromDom(y.element)).isNone() && t.cancelIfNecessary();
    });
  } };
  var VM;
  (function(t) {
    t[t.CLOSE_ON_EXECUTE = 0] = "CLOSE_ON_EXECUTE", t[t.BUBBLE_TO_SANDBOX = 1] = "BUBBLE_TO_SANDBOX";
  })(VM || (VM = {}));
  var Cv = VM;
  const UM = "tox-menu-nav__js", rR = "tox-collection__item", WM = "tox-swatch", ZG = {
    normal: UM,
    color: WM
  }, z6 = "tox-collection__item--enabled", KG = "tox-collection__group-heading", V6 = "tox-collection__item-icon", jM = "tox-collection__item-label", YG = "tox-collection__item-accessory", U6 = "tox-collection__item-caret", QG = "tox-collection__item-checkmark", Y0 = "tox-collection__item--active", W6 = "tox-collection__item-container", qM = "tox-collection__item-container--column", j6 = "tox-collection__item-container--row", XG = "tox-collection__item-container--align-right", JG = "tox-collection__item-container--align-left", q6 = "tox-collection__item-container--valign-top", eZ = "tox-collection__item-container--valign-middle", GM = "tox-collection__item-container--valign-bottom", oR = (t) => fn(ZG, t).getOr(UM), G6 = (t) => t === "color" ? "tox-swatches" : "tox-menu", bO = (t) => ({
    backgroundMenu: "tox-background-menu",
    selectedMenu: "tox-selected-menu",
    selectedItem: "tox-collection__item--active",
    hasIcons: "tox-menu--has-icons",
    menu: G6(t),
    tieredMenu: "tox-tiered-menu"
  }), Gb = (t) => {
    const a = bO(t);
    return {
      backgroundMenu: a.backgroundMenu,
      selectedMenu: a.selectedMenu,
      menu: a.menu,
      selectedItem: a.selectedItem,
      item: oR(t)
    };
  }, Z6 = (t, a, u) => {
    const p = bO(u);
    return {
      tag: "div",
      classes: St([
        [
          p.menu,
          `tox-menu-${a}-column`
        ],
        t ? [p.hasIcons] : []
      ])
    };
  }, Zb = [wE.parts.items({})], pT = (t, a, u) => {
    const p = bO(u);
    return {
      dom: {
        tag: "div",
        classes: St([[p.tieredMenu]])
      },
      markers: Gb(u)
    };
  }, K6 = q([
    Fo("data"),
    lt("inputAttributes", {}),
    lt("inputStyles", {}),
    lt("tag", "input"),
    lt("inputClasses", []),
    po("onSetValue"),
    lt("styles", {}),
    lt("eventOrder", {}),
    ac("inputBehaviours", [
      Pn,
      Er
    ]),
    lt("selectOnFocus", !0)
  ]), Y6 = (t) => mn([Er.config({
    onFocus: t.selectOnFocus ? (a) => {
      const u = a.element, p = Zm(u);
      u.dom.setSelectionRange(0, p.length);
    } : G
  })]), tZ = (t) => ({
    ...Y6(t),
    ..._i(t.inputBehaviours, [Pn.config({
      store: {
        mode: "manual",
        ...t.data.map((a) => ({ initialValue: a })).getOr({}),
        getValue: (a) => Zm(a.element),
        setValue: (a, u) => {
          Zm(a.element) !== u && wb(a.element, u);
        }
      },
      onSetValue: t.onSetValue
    })])
  }), Q6 = (t) => ({
    tag: t.tag,
    attributes: {
      type: "text",
      ...t.inputAttributes
    },
    styles: t.inputStyles,
    classes: t.inputClasses
  }), yO = (t, a) => ({
    uid: t.uid,
    dom: Q6(t),
    components: [],
    behaviours: tZ(t),
    eventOrder: t.eventOrder
  }), TE = Yd({
    name: "Input",
    configFields: K6(),
    factory: yO
  }), ZM = Hn("refetch-trigger-event"), sR = Hn("redirect-menu-item-interaction"), X6 = "tox-menu__searcher", hT = (t) => qa(t.element, `.${X6}`).bind((a) => t.getSystem().getByDom(a).toOptional()), aR = hT, nZ = (t, a) => {
    Pn.setValue(t, a.fetchPattern), t.element.dom.selectionStart = a.selectionStart, t.element.dom.selectionEnd = a.selectionEnd;
  }, KM = (t) => {
    const a = Pn.getValue(t), u = t.element.dom.selectionStart, p = t.element.dom.selectionEnd;
    return {
      fetchPattern: a,
      selectionStart: u,
      selectionEnd: p
    };
  }, J6 = (t, a) => {
    as(a.element, "id").each((u) => kn(t.element, "aria-activedescendant", u));
  }, rZ = (t) => {
    const a = (y, x) => (x.cut(), z.none()), u = (y, x) => {
      const k = {
        interactionEvent: x.event,
        eventType: x.event.raw.type
      };
      return nr(y, sR, k), z.some(!0);
    }, p = "searcher-events";
    return {
      dom: {
        tag: "div",
        classes: [rR]
      },
      components: [TE.sketch({
        inputClasses: [
          X6,
          "tox-textfield"
        ],
        inputAttributes: {
          ...t.placeholder.map((y) => ({ placeholder: t.i18n(y) })).getOr({}),
          type: "search",
          "aria-autocomplete": "list"
        },
        inputBehaviours: mn([
          Hr(p, [
            Pt(Vm(), (y) => {
              Jr(y, ZM);
            }),
            Pt(ud(), (y, x) => {
              x.event.raw.key === "Escape" && x.stop();
            })
          ]),
          ar.config({
            mode: "special",
            onLeft: a,
            onRight: a,
            onSpace: a,
            onEnter: u,
            onEscape: u,
            onUp: u,
            onDown: u
          })
        ]),
        eventOrder: {
          keydown: [
            p,
            ar.name()
          ]
        }
      })]
    };
  }, iR = "tox-collection--results__js", e8 = (t) => {
    var a;
    return t.dom ? {
      ...t,
      dom: {
        ...t.dom,
        attributes: {
          ...(a = t.dom.attributes) !== null && a !== void 0 ? a : {},
          id: Hn("aria-item-search-result-id"),
          "aria-selected": "false"
        }
      }
    } : t;
  }, YM = (t, a) => (u) => {
    const p = cn(u, a);
    return He(p, (y) => ({
      dom: t,
      components: y
    }));
  }, oZ = (t) => ({
    dom: {
      tag: "div",
      classes: [
        "tox-menu",
        "tox-swatches-menu"
      ]
    },
    components: [{
      dom: {
        tag: "div",
        classes: ["tox-swatches"]
      },
      components: [wE.parts.items({
        preprocess: t !== "auto" ? YM({
          tag: "div",
          classes: ["tox-swatches__row"]
        }, t) : Te
      })]
    }]
  }), sZ = (t) => ({
    dom: {
      tag: "div",
      classes: [
        "tox-menu",
        "tox-collection",
        "tox-collection--toolbar",
        "tox-collection--toolbar-lg"
      ]
    },
    components: [wE.parts.items({
      preprocess: YM({
        tag: "div",
        classes: ["tox-collection__group"]
      }, t)
    })]
  }), QM = (t, a) => {
    const u = [];
    let p = [];
    return ut(t, (y, x) => {
      a(y, x) ? (p.length > 0 && u.push(p), p = [], (Yr(y.dom, "innerHtml") || y.components && y.components.length > 0) && p.push(y)) : p.push(y);
    }), p.length > 0 && u.push(p), He(u, (y) => ({
      dom: {
        tag: "div",
        classes: ["tox-collection__group"]
      },
      components: y
    }));
  }, cR = (t, a, u) => wE.parts.items({
    preprocess: (p) => {
      const y = He(p, u);
      return t !== "auto" && t > 1 ? YM({
        tag: "div",
        classes: ["tox-collection__group"]
      }, t)(y) : QM(y, (x, k) => a[k].type === "separator");
    }
  }), t8 = (t, a, u = !0) => ({
    dom: {
      tag: "div",
      classes: [
        "tox-menu",
        "tox-collection"
      ].concat(t === 1 ? ["tox-collection--list"] : ["tox-collection--grid"])
    },
    components: [cR(t, a, Te)]
  }), n8 = (t, a, u = !0) => {
    const p = Hn("aria-controls-search-results");
    return {
      dom: {
        tag: "div",
        classes: [
          "tox-menu",
          "tox-collection",
          iR
        ].concat(t === 1 ? ["tox-collection--list"] : ["tox-collection--grid"]),
        attributes: { id: p }
      },
      components: [cR(t, a, e8)]
    };
  }, SO = (t, a, u) => {
    const p = Hn("aria-controls-search-results");
    return {
      dom: {
        tag: "div",
        classes: [
          "tox-menu",
          "tox-collection"
        ].concat(t === 1 ? ["tox-collection--list"] : ["tox-collection--grid"])
      },
      components: [
        rZ({
          i18n: Mf.translate,
          placeholder: u.placeholder
        }),
        {
          dom: {
            tag: "div",
            classes: [
              ...t === 1 ? ["tox-collection--list"] : ["tox-collection--grid"],
              iR
            ],
            attributes: { id: p }
          },
          components: [cR(t, a, e8)]
        }
      ]
    };
  }, r8 = (t, a = !0) => ({
    dom: {
      tag: "div",
      classes: [
        "tox-collection",
        "tox-collection--horizontal"
      ]
    },
    components: [wE.parts.items({ preprocess: (u) => QM(u, (p, y) => t[y].type === "separator") })]
  }), lR = (t) => Gt(t, (a) => "icon" in a && a.icon !== void 0), i1 = (t) => (console.error(Dc(t)), console.log(t), z.none()), o8 = (t, a, u, p, y) => {
    const x = r8(u);
    return {
      value: t,
      dom: x.dom,
      components: x.components,
      items: u
    };
  }, XM = (t, a, u, p, y) => {
    const x = () => y.menuType !== "searchable" ? t8(p, u) : y.searchMode.searchMode === "search-with-field" ? SO(p, u, y.searchMode) : n8(p, u);
    if (y.menuType === "color") {
      const k = oZ(p);
      return {
        value: t,
        dom: k.dom,
        components: k.components,
        items: u
      };
    } else if (y.menuType === "normal" && p === "auto") {
      const k = t8(p, u);
      return {
        value: t,
        dom: k.dom,
        components: k.components,
        items: u
      };
    } else if (y.menuType === "normal" || y.menuType === "searchable") {
      const k = x();
      return {
        value: t,
        dom: k.dom,
        components: k.components,
        items: u
      };
    } else if (y.menuType === "listpreview" && p !== "auto") {
      const k = sZ(p);
      return {
        value: t,
        dom: k.dom,
        components: k.components,
        items: u
      };
    } else
      return {
        value: t,
        dom: Z6(a, p, y.menuType),
        components: Zb,
        items: u
      };
  }, Qi = xo("type"), uR = xo("name"), dR = xo("label"), Kb = xo("text"), JM = xo("title"), s8 = xo("icon"), wO = xo("value"), a8 = id("fetch"), eF = id("getSubmenuItems"), Q0 = id("onAction"), i8 = id("onItemAction"), X0 = ii("onSetup", () => G), c8 = nc("name"), J0 = nc("text"), wm = nc("icon"), fR = nc("tooltip"), mR = nc("label"), l8 = nc("shortcut"), _E = Ip("select"), pR = vi("active", !1), tF = vi("borderless", !1), Em = vi("enabled", !0), hR = vi("primary", !1), nF = (t) => lt("columns", t), gR = lt("meta", {}), vR = ii("onAction", G), c1 = (t) => rl("type", t), bR = (t) => si("name", "name", zi(() => Hn(`${t}-name`)), xi), aZ = (t) => si("value", "value", zi(() => Hn(`${t}-value`)), Ua()), rF = jn([
    Qi,
    J0
  ]), u8 = (t) => Ws("separatormenuitem", rF, t), d8 = jn([
    c1("autocompleteitem"),
    pR,
    Em,
    gR,
    wO,
    J0,
    wm
  ]), f8 = (t) => Ws("Autocompleter.Separator", rF, t), iZ = (t) => Ws("Autocompleter.Item", d8, t), gT = [
    Em,
    fR,
    wm,
    J0,
    X0
  ], cZ = jn([
    Qi,
    Q0
  ].concat(gT)), m8 = (t) => Ws("toolbarbutton", cZ, t), oF = [pR].concat(gT), lZ = jn(oF.concat([
    Qi,
    Q0
  ])), sF = (t) => Ws("ToggleButton", lZ, t), vT = [
    ii("predicate", sn),
    vl("scope", "node", [
      "node",
      "editor"
    ]),
    vl("position", "selection", [
      "node",
      "selection",
      "line"
    ])
  ], p8 = gT.concat([
    c1("contextformbutton"),
    hR,
    Q0,
    Ts("original", Te)
  ]), uZ = oF.concat([
    c1("contextformbutton"),
    hR,
    Q0,
    Ts("original", Te)
  ]), dZ = gT.concat([c1("contextformbutton")]), fZ = oF.concat([c1("contextformtogglebutton")]), mZ = ro("type", {
    contextformbutton: p8,
    contextformtogglebutton: uZ
  }), pZ = jn([
    c1("contextform"),
    ii("initValue", q("")),
    mR,
    tc("commands", mZ),
    ai("launch", ro("type", {
      contextformbutton: dZ,
      contextformtogglebutton: fZ
    }))
  ].concat(vT)), yR = (t) => Ws("ContextForm", pZ, t), hZ = jn([
    c1("contexttoolbar"),
    xo("items")
  ].concat(vT)), h8 = (t) => Ws("ContextToolbar", hZ, t), gZ = [
    Qi,
    xo("src"),
    nc("alt"),
    bl("classes", [], xi)
  ], g8 = jn(gZ), v8 = [
    Qi,
    Kb,
    c8,
    bl("classes", ["tox-collection__item-label"], xi)
  ], vZ = jn(v8), aF = Vi(() => Qt("type", {
    cardimage: g8,
    cardtext: vZ,
    cardcontainer: b8
  })), b8 = jn([
    Qi,
    rl("direction", "horizontal"),
    rl("align", "left"),
    rl("valign", "middle"),
    tc("items", aF)
  ]), OE = [
    Em,
    J0,
    l8,
    aZ("menuitem"),
    gR
  ], y8 = jn([
    Qi,
    mR,
    tc("items", aF),
    X0,
    vR
  ].concat(OE)), bZ = (t) => Ws("cardmenuitem", y8, t), yZ = jn([
    Qi,
    pR,
    wm
  ].concat(OE)), SZ = (t) => Ws("choicemenuitem", yZ, t), S8 = [
    Qi,
    xo("fancytype"),
    vR
  ], w8 = [lt("initData", {})].concat(S8), E8 = [
    Ip("select"),
    vf("initData", {}, [
      vi("allowCustomColors", !0),
      rl("storageKey", "default"),
      lm("colors", Ua())
    ])
  ].concat(S8), wZ = ro("fancytype", {
    inserttable: w8,
    colorswatch: E8
  }), EZ = (t) => Ws("fancymenuitem", wZ, t), CZ = jn([
    Qi,
    X0,
    vR,
    wm
  ].concat(OE)), xZ = (t) => Ws("menuitem", CZ, t), TZ = jn([
    Qi,
    eF,
    X0,
    wm
  ].concat(OE)), C8 = (t) => Ws("nestedmenuitem", TZ, t), _Z = jn([
    Qi,
    wm,
    pR,
    X0,
    Q0
  ].concat(OE)), OZ = (t) => Ws("togglemenuitem", _Z, t), EO = (t, a, u) => {
    const p = Ki(t.element, "." + u);
    if (p.length > 0) {
      const y = qt(p, (x) => {
        const k = x.dom.getBoundingClientRect().top, $ = p[0].dom.getBoundingClientRect().top;
        return Math.abs(k - $) > a;
      }).getOr(p.length);
      return z.some({
        numColumns: y,
        numRows: Math.ceil(p.length / y)
      });
    } else
      return z.none();
  }, iF = (t, a) => mn([Hr(t, a)]), CO = {
    namedEvents: iF,
    unnamedEvents: (t) => iF(Hn("unnamed-events"), t)
  }, cF = Hn("tooltip.exclusive"), xO = Hn("tooltip.show"), TO = Hn("tooltip.hide"), lF = (t, a, u) => {
    t.getSystem().broadcastOn([cF], {});
  };
  var x8 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    hideAllExclusive: lF,
    setComponents: (t, a, u, p) => {
      u.getTooltip().each((y) => {
        y.getSystem().isConnected() && $r.set(y, p);
      });
    }
  }), kZ = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: (t, a) => {
      const u = (y) => {
        a.getTooltip().each((x) => {
          cg(x), t.onHide(y, x), a.clearTooltip();
        }), a.clearTimer();
      }, p = (y) => {
        if (!a.isShowing()) {
          lF(y);
          const x = t.lazySink(y).getOrDie(), k = y.getSystem().build({
            dom: t.tooltipDom,
            components: t.tooltipComponents,
            events: ls(t.mode === "normal" ? [
              Pt(yf(), ($) => {
                Jr(y, xO);
              }),
              Pt(rc(), ($) => {
                Jr(y, TO);
              })
            ] : []),
            behaviours: mn([$r.config({})])
          });
          a.setTooltip(k), Hb(x, k), t.onShow(y, k), Wl.position(x, k, { anchor: t.anchor(y) });
        }
      };
      return ls(St([
        [
          Pt(xO, (y) => {
            a.resetTimer(() => {
              p(y);
            }, t.delay);
          }),
          Pt(TO, (y) => {
            a.resetTimer(() => {
              u(y);
            }, t.delay);
          }),
          Pt(Zg(), (y, x) => {
            const k = x;
            k.universal || vt(k.channels, cF) && u(y);
          }),
          Tf((y) => {
            u(y);
          })
        ],
        t.mode === "normal" ? [
          Pt(oa(), (y) => {
            Jr(y, xO);
          }),
          Pt(Vp(), (y) => {
            Jr(y, TO);
          }),
          Pt(yf(), (y) => {
            Jr(y, xO);
          }),
          Pt(rc(), (y) => {
            Jr(y, TO);
          })
        ] : [
          Pt(ob(), (y, x) => {
            Jr(y, xO);
          }),
          Pt(sb(), (y) => {
            Jr(y, TO);
          })
        ]
      ]));
    }
  }), NZ = [
    Mt("lazySink"),
    Mt("tooltipDom"),
    lt("exclusive", !0),
    lt("tooltipComponents", []),
    lt("delay", 300),
    vl("mode", "normal", [
      "normal",
      "follow-highlight"
    ]),
    lt("anchor", (t) => ({
      type: "hotspot",
      hotspot: t,
      layouts: {
        onLtr: q([
          Os,
          El,
          Wi,
          ji,
          Mc,
          Br
        ]),
        onRtl: q([
          Os,
          El,
          Wi,
          ji,
          Mc,
          Br
        ])
      }
    })),
    po("onHide"),
    po("onShow")
  ], uF = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: () => {
      const t = Gr(), a = Gr(), u = () => {
        t.on(clearTimeout);
      }, p = (x, k) => {
        u(), t.set(setTimeout(x, k));
      }, y = q("not-implemented");
      return ol({
        getTooltip: a.get,
        isShowing: a.isSet,
        setTooltip: a.set,
        clearTooltip: a.clear,
        clearTimer: u,
        resetTimer: p,
        readState: y
      });
    }
  });
  const T8 = Zi({
    fields: NZ,
    name: "tooltipping",
    active: kZ,
    state: uF,
    apis: x8
  }), RZ = (t) => t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), dF = "silver.readonly", _8 = jn([eb("readonly")]), SR = (t, a) => {
    const p = t.mainUi.outerContainer.element, y = [
      t.mainUi.mothership,
      ...t.uiMotherships
    ];
    a && ut(y, (x) => {
      x.broadcastOn([lh()], { target: p });
    }), ut(y, (x) => {
      x.broadcastOn([dF], { readonly: a });
    });
  }, O8 = (t, a) => {
    t.on("init", () => {
      t.mode.isReadOnly() && SR(a, !0);
    }), t.on("SwitchMode", () => SR(a, t.mode.isReadOnly())), mO(t) && t.mode.set("readonly");
  }, Bc = () => vu.config({
    channels: {
      [dF]: {
        schema: _8,
        onReceive: (t, a) => {
          yr.set(t, a.readonly);
        }
      }
    }
  }), ip = {
    item: (t) => yr.config({
      disabled: t,
      disableClass: "tox-collection__item--state-disabled"
    }),
    button: (t) => yr.config({ disabled: t }),
    splitButton: (t) => yr.config({
      disabled: t,
      disableClass: "tox-tbtn--disabled"
    }),
    toolbarButton: (t) => yr.config({
      disabled: t,
      disableClass: "tox-tbtn--disabled",
      useNative: !1
    })
  }, AE = (t, a) => {
    const u = t.getApi(a);
    return (p) => {
      p(u);
    };
  }, l1 = (t, a) => us((u) => {
    AE(t, u)((y) => {
      const x = t.onSetup(y);
      Q(x) && a.set(x);
    });
  }), pg = (t, a) => Tf((u) => AE(t, u)(a.get())), wR = (t, a) => Ul((u, p) => {
    AE(t, u)(t.onAction), !t.triggersSubmenu && a === Cv.CLOSE_ON_EXECUTE && (u.getSystem().isConnected() && Jr(u, Ty()), p.stop());
  }), fF = {
    [Lu()]: [
      "disabling",
      "alloy.base.behaviour",
      "toggling",
      "item-events"
    ]
  }, kE = wi, Yb = (t, a, u, p) => {
    const y = sr(G);
    return {
      type: "item",
      dom: a.dom,
      components: kE(a.optComponents),
      data: t.data,
      eventOrder: fF,
      hasSubmenu: t.triggersSubmenu,
      itemBehaviours: mn([
        Hr("item-events", [
          wR(t, u),
          l1(t, y),
          pg(t, y)
        ]),
        ip.item(() => !t.enabled || p.isDisabled()),
        Bc(),
        $r.config({})
      ].concat(t.itemBehaviours))
    };
  }, bT = (t) => ({
    value: t.value,
    meta: {
      text: t.text.getOr(""),
      ...t.meta
    }
  }), k8 = (t) => {
    const a = dT.os.isMacOS() || dT.os.isiOS(), y = a ? {
      alt: "",
      ctrl: "",
      shift: "",
      meta: "",
      access: ""
    } : {
      meta: "Ctrl",
      access: "Shift+Alt"
    }, x = t.split("+"), k = He(x, ($) => {
      const B = $.toLowerCase().trim();
      return Yr(y, B) ? y[B] : $;
    });
    return a ? k.join("") : k.join("+");
  }, hh = (t, a, u = [V6]) => mg(t, {
    tag: "div",
    classes: u
  }, a), Ff = (t) => ({
    dom: {
      tag: "div",
      classes: [jM]
    },
    components: [Ma(Mf.translate(t))]
  }), yT = (t, a) => ({
    dom: {
      tag: "div",
      classes: a,
      innerHtml: t
    }
  }), gh = (t, a) => ({
    dom: {
      tag: "div",
      classes: [jM]
    },
    components: [{
      dom: {
        tag: t.tag,
        styles: t.styles
      },
      components: [Ma(Mf.translate(a))]
    }]
  }), DZ = (t) => ({
    dom: {
      tag: "div",
      classes: [YG]
    },
    components: [Ma(k8(t))]
  }), qs = (t) => hh("checkmark", t, [QG]), $Z = (t) => hh("chevron-right", t, [U6]), NE = (t) => hh("chevron-down", t, [U6]), _O = (t, a) => {
    const u = t.direction === "vertical" ? qM : j6, p = t.align === "left" ? JG : XG;
    return {
      dom: {
        tag: "div",
        classes: [
          W6,
          u,
          p,
          (() => {
            switch (t.valign) {
              case "top":
                return q6;
              case "middle":
                return eZ;
              case "bottom":
                return GM;
            }
          })()
        ]
      },
      components: a
    };
  }, N8 = (t, a, u) => ({
    dom: {
      tag: "img",
      classes: a,
      attributes: {
        src: t,
        alt: u.getOr("")
      }
    }
  }), mF = (t, a, u) => {
    const p = "custom", y = "remove", x = t.ariaLabel, k = t.value, $ = t.iconContent.map((j) => zG(j, a.icons, u));
    return {
      dom: (() => {
        const j = WM, Y = $.getOr(""), le = {
          tag: "div",
          attributes: x.map((pe) => ({ title: a.translate(pe) })).getOr({}),
          classes: [j]
        };
        return k === p ? {
          ...le,
          tag: "button",
          classes: [
            ...le.classes,
            "tox-swatches__picker-btn"
          ],
          innerHtml: Y
        } : k === y ? {
          ...le,
          classes: [
            ...le.classes,
            "tox-swatch--remove"
          ],
          innerHtml: Y
        } : se(k) ? {
          ...le,
          attributes: {
            ...le.attributes,
            "data-mce-color": k
          },
          styles: { "background-color": k },
          innerHtml: Y
        } : le;
      })(),
      optComponents: []
    };
  }, ER = (t) => {
    const a = t.map((u) => ({
      attributes: {
        title: Mf.translate(u),
        id: Hn("menu-item")
      }
    })).getOr({});
    return {
      tag: "div",
      classes: [
        UM,
        rR
      ],
      ...a
    };
  }, IZ = (t, a, u, p) => {
    const y = {
      tag: "div",
      classes: [V6]
    }, x = (le) => mg(le, y, a.icons, p), k = () => z.some({ dom: y }), $ = u ? t.iconContent.map(x).orThunk(k) : z.none(), B = t.checkMark, j = z.from(t.meta).fold(() => Ff, (le) => Yr(le, "style") ? je(gh, le.style) : Ff), Y = t.htmlContent.fold(() => t.textContent.map(j), (le) => z.some(yT(le, [jM])));
    return {
      dom: ER(t.ariaLabel),
      optComponents: [
        $,
        Y,
        t.shortcutContent.map(DZ),
        B,
        t.caret
      ]
    };
  }, RE = (t, a, u, p = z.none()) => t.presets === "color" ? mF(t, a, p) : IZ(t, a, u, p), R8 = (t, a) => fn(t, "tooltipWorker").map((u) => [T8.config({
    lazySink: a.getSink,
    tooltipDom: {
      tag: "div",
      classes: ["tox-tooltip-worker-container"]
    },
    tooltipComponents: [],
    anchor: (p) => ({
      type: "submenu",
      item: p,
      overrides: { maxHeightFunction: vm }
    }),
    mode: "follow-highlight",
    onShow: (p, y) => {
      u((x) => {
        T8.setComponents(p, [tx({ element: nt.fromDom(x) })]);
      });
    }
  })]).getOr([]), P8 = (t) => uT.DOM.encode(t), pF = (t, a) => {
    const u = Mf.translate(t), p = P8(u);
    if (a.length > 0) {
      const y = new RegExp(RZ(a), "gi");
      return p.replace(y, (x) => `<span class="tox-autocompleter-highlight">${x}</span>`);
    } else
      return p;
  }, hF = (t, a, u, p, y, x, k, $ = !0) => {
    const B = RE({
      presets: p,
      textContent: z.none(),
      htmlContent: u ? t.text.map((j) => pF(j, a)) : z.none(),
      ariaLabel: t.text,
      iconContent: t.icon,
      shortcutContent: z.none(),
      checkMark: z.none(),
      caret: z.none(),
      value: t.value
    }, k.providers, $, t.icon);
    return Yb({
      data: bT(t),
      enabled: t.enabled,
      getApi: q({}),
      onAction: (j) => y(t.value, t.meta),
      onSetup: q(G),
      triggersSubmenu: !1,
      itemBehaviours: R8(t.meta, k)
    }, B, x, k.providers);
  }, gF = (t, a) => He(t, (u) => {
    switch (u.type) {
      case "cardcontainer":
        return _O(u, gF(u.items, a));
      case "cardimage":
        return N8(u.src, u.classes, u.alt);
      case "cardtext":
        const y = u.name.exists((x) => vt(a.cardText.highlightOn, x)) ? z.from(a.cardText.matchText).getOr("") : "";
        return yT(pF(u.text, y), u.classes);
    }
  }), CR = (t, a, u, p) => {
    const y = (k) => ({
      isEnabled: () => !yr.isDisabled(k),
      setEnabled: ($) => {
        yr.set(k, !$), ut(Ki(k.element, "*"), (B) => {
          k.getSystem().getByDom(B).each((j) => {
            j.hasConfigured(yr) && yr.set(j, !$);
          });
        });
      }
    }), x = {
      dom: ER(t.label),
      optComponents: [z.some({
        dom: {
          tag: "div",
          classes: [
            W6,
            j6
          ]
        },
        components: gF(t.items, p)
      })]
    };
    return Yb({
      data: bT({
        text: z.none(),
        ...t
      }),
      enabled: t.enabled,
      getApi: y,
      onAction: t.onAction,
      onSetup: t.onSetup,
      triggersSubmenu: !1,
      itemBehaviours: z.from(p.itemBehaviours).getOr([])
    }, x, a, u.providers);
  }, MZ = (t, a, u, p, y, x, k, $ = !0) => {
    const B = (Y) => ({
      setActive: (re) => {
        Zr.set(Y, re);
      },
      isActive: () => Zr.isOn(Y),
      isEnabled: () => !yr.isDisabled(Y),
      setEnabled: (re) => yr.set(Y, !re)
    }), j = RE({
      presets: u,
      textContent: a ? t.text : z.none(),
      htmlContent: z.none(),
      ariaLabel: t.text,
      iconContent: t.icon,
      shortcutContent: a ? t.shortcut : z.none(),
      checkMark: a ? z.some(qs(k.icons)) : z.none(),
      caret: z.none(),
      value: t.value
    }, k, $);
    return Vo(Yb({
      data: bT(t),
      enabled: t.enabled,
      getApi: B,
      onAction: (Y) => p(t.value),
      onSetup: (Y) => (Y.setActive(y), G),
      triggersSubmenu: !1,
      itemBehaviours: []
    }, j, x, k), {
      toggling: {
        toggleClass: z6,
        toggleOnExecute: !1,
        selected: t.active,
        exclusive: !0
      }
    });
  }, D8 = hv(rO(), oO()), $8 = (t) => ({ value: F8(t) }), I8 = /^#?([a-f\d])([a-f\d])([a-f\d])$/i, M8 = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, vF = (t) => I8.test(t) || M8.test(t), F8 = (t) => Xf(t, "#").toUpperCase(), FZ = (t) => vF(t) ? z.some({ value: F8(t) }) : z.none(), L8 = (t) => ({ value: t.value.replace(I8, (u, p, y, x) => p + p + y + y + x + x) }), LZ = (t) => {
    const a = L8(t), u = M8.exec(a.value);
    return u === null ? [
      "FFFFFF",
      "FF",
      "FF",
      "FF"
    ] : u;
  }, xR = (t) => {
    const a = t.toString(16);
    return (a.length === 1 ? "0" + a : a).toUpperCase();
  }, u1 = (t) => {
    const a = xR(t.red) + xR(t.green) + xR(t.blue);
    return $8(a);
  }, B8 = Math.min, H8 = Math.max, OO = Math.round, z8 = /^\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i, V8 = /^\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?(?:\.\d+)?)\s*\)\s*$/i, eS = (t, a, u, p) => ({
    red: t,
    green: a,
    blue: u,
    alpha: p
  }), bF = (t) => {
    const a = parseInt(t, 10);
    return a.toString() === t && a >= 0 && a <= 255;
  }, U8 = (t) => {
    let a, u, p;
    const y = (t.hue || 0) % 360;
    let x = t.saturation / 100, k = t.value / 100;
    if (x = H8(0, B8(x, 1)), k = H8(0, B8(k, 1)), x === 0)
      return a = u = p = OO(255 * k), eS(a, u, p, 1);
    const $ = y / 60, B = k * x, j = B * (1 - Math.abs($ % 2 - 1)), Y = k - B;
    switch (Math.floor($)) {
      case 0:
        a = B, u = j, p = 0;
        break;
      case 1:
        a = j, u = B, p = 0;
        break;
      case 2:
        a = 0, u = B, p = j;
        break;
      case 3:
        a = 0, u = j, p = B;
        break;
      case 4:
        a = j, u = 0, p = B;
        break;
      case 5:
        a = B, u = 0, p = j;
        break;
      default:
        a = u = p = 0;
    }
    return a = OO(255 * (a + Y)), u = OO(255 * (u + Y)), p = OO(255 * (p + Y)), eS(a, u, p, 1);
  }, AO = (t) => {
    const a = LZ(t), u = parseInt(a[1], 16), p = parseInt(a[2], 16), y = parseInt(a[3], 16);
    return eS(u, p, y, 1);
  }, W8 = (t, a, u, p) => {
    const y = parseInt(t, 10), x = parseInt(a, 10), k = parseInt(u, 10), $ = parseFloat(p);
    return eS(y, x, k, $);
  }, yF = (t) => {
    if (t === "transparent")
      return z.some(eS(0, 0, 0, 0));
    const a = z8.exec(t);
    if (a !== null)
      return z.some(W8(a[1], a[2], a[3], "1"));
    const u = V8.exec(t);
    return u !== null ? z.some(W8(u[1], u[2], u[3], u[4])) : z.none();
  }, SF = (t) => `rgba(${t.red},${t.green},${t.blue},${t.alpha})`, vh = eS(255, 0, 0, 1), BZ = (t) => {
    t.dispatch("SkinLoaded");
  }, wF = (t, a) => {
    t.dispatch("SkinLoadError", a);
  }, j8 = (t) => {
    t.dispatch("ResizeEditor");
  }, TR = (t, a) => {
    t.dispatch("ResizeContent", a);
  }, HZ = (t, a) => {
    t.dispatch("ScrollContent", a);
  }, EF = (t, a) => {
    t.dispatch("TextColorChange", a);
  }, q8 = (t, a) => {
    t.dispatch("AfterProgressState", { state: a });
  }, G8 = (t, a) => t.dispatch("ResolveName", {
    name: a.nodeName.toLowerCase(),
    target: a
  }), zZ = (t, a) => {
    t.dispatch("ToggleToolbarDrawer", { state: a });
  }, VZ = (t, a) => {
    t.dispatch("StylesTextUpdate", a);
  }, UZ = (t, a) => {
    t.dispatch("AlignTextUpdate", a);
  }, WZ = (t, a) => {
    t.dispatch("FontSizeTextUpdate", a);
  }, jZ = (t, a) => {
    t.dispatch("FontSizeInputTextUpdate", a);
  }, Z8 = (t, a) => {
    t.dispatch("BlocksTextUpdate", a);
  }, K8 = (t, a) => {
    t.dispatch("FontFamilyTextUpdate", a);
  }, kO = (t, a) => () => {
    t(), a();
  }, wd = (t) => hg(t, "NodeChange", (a) => {
    a.setEnabled(t.selection.isEditable());
  }), qZ = (t, a) => (u) => {
    const p = sh(), y = () => {
      u.setActive(t.formatter.match(a));
      const x = t.formatter.formatChanged(a, u.setActive);
      p.set(x);
    };
    return t.initialized ? y() : t.once("init", y), () => {
      t.off("init", y), p.clear();
    };
  }, _R = (t, a) => (u) => {
    const p = wd(t)(u), y = qZ(t, a)(u);
    return () => {
      p(), y();
    };
  }, hg = (t, a, u) => (p) => {
    const y = () => u(p), x = () => {
      u(p), t.on(a, y);
    };
    return t.initialized ? x() : t.once("init", x), () => {
      t.off("init", x), t.off(a, y);
    };
  }, Y8 = (t) => (a) => () => {
    t.undoManager.transact(() => {
      t.focus(), t.execCommand("mceToggleFormat", !1, a.format);
    });
  }, Lf = (t, a) => () => t.execCommand(a);
  var tS = tinymce.util.Tools.resolve("tinymce.util.LocalStorage");
  const CF = {}, xF = (t, a = 10) => {
    const u = tS.getItem(t), p = g(u) ? JSON.parse(u) : [], x = ((j) => a - j.length < 0 ? j.slice(0, a) : j)(p), k = (j) => {
      Ne(x, j).each($), x.unshift(j), x.length > a && x.pop(), tS.setItem(t, JSON.stringify(x));
    }, $ = (j) => {
      x.splice(j, 1);
    };
    return {
      add: k,
      state: () => x.slice(0)
    };
  }, OR = (t) => fn(CF, t).getOrThunk(() => {
    const a = `tinymce-custom-colors-${t}`, u = tS.getItem(a);
    if (ne(u)) {
      const y = tS.getItem("tinymce-custom-colors");
      tS.setItem(a, se(y) ? y : "[]");
    }
    const p = xF(a, 10);
    return CF[t] = p, p;
  }), TF = (t) => He(OR(t).state(), (a) => ({
    type: "choiceitem",
    text: a,
    icon: "checkmark",
    value: a
  })), _F = (t, a) => {
    OR(t).add(a);
  }, NO = (t, a, u) => ({
    hue: t,
    saturation: a,
    value: u
  }), AR = (t) => {
    let a = 0, u = 0, p = 0;
    const y = t.red / 255, x = t.green / 255, k = t.blue / 255, $ = Math.min(y, Math.min(x, k)), B = Math.max(y, Math.max(x, k));
    if ($ === B)
      return p = $, NO(0, 0, p * 100);
    const j = y === $ ? x - k : k === $ ? y - x : k - y;
    return a = y === $ ? 3 : k === $ ? 1 : 5, a = 60 * (a - j / (B - $)), u = (B - $) / B, p = B, NO(Math.round(a), Math.round(u * 100), Math.round(p * 100));
  }, GZ = (t) => AR(AO(t)), Q8 = (t) => u1(U8(t)), ZZ = (t) => FZ(t).orThunk(() => yF(t).map(u1)).getOrThunk(() => {
    const a = document.createElement("canvas");
    a.height = 1, a.width = 1;
    const u = a.getContext("2d");
    u.clearRect(0, 0, a.width, a.height), u.fillStyle = "#FFFFFF", u.fillStyle = t, u.fillRect(0, 0, 1, 1);
    const p = u.getImageData(0, 0, 1, 1).data, y = p[0], x = p[1], k = p[2], $ = p[3];
    return u1(eS(y, x, k, $));
  }), kR = "forecolor", NR = "hilitecolor", X8 = 5, KZ = (t) => {
    const a = [];
    for (let u = 0; u < t.length; u += 2)
      a.push({
        text: t[u + 1],
        value: "#" + ZZ(t[u]).value,
        icon: "checkmark",
        type: "choiceitem"
      });
    return a;
  }, Qb = (t) => (a) => a.options.get(t), OF = "#000000", YZ = (t) => {
    const a = t.options.register, u = (y) => ue(y, g) ? {
      value: KZ(y),
      valid: !0
    } : {
      valid: !1,
      message: "Must be an array of strings."
    }, p = (y) => he(y) && y > 0 ? {
      value: y,
      valid: !0
    } : {
      valid: !1,
      message: "Must be a positive number."
    };
    a("color_map", {
      processor: u,
      default: [
        "#BFEDD2",
        "Light Green",
        "#FBEEB8",
        "Light Yellow",
        "#F8CAC6",
        "Light Red",
        "#ECCAFA",
        "Light Purple",
        "#C2E0F4",
        "Light Blue",
        "#2DC26B",
        "Green",
        "#F1C40F",
        "Yellow",
        "#E03E2D",
        "Red",
        "#B96AD9",
        "Purple",
        "#3598DB",
        "Blue",
        "#169179",
        "Dark Turquoise",
        "#E67E23",
        "Orange",
        "#BA372A",
        "Dark Red",
        "#843FA1",
        "Dark Purple",
        "#236FA1",
        "Dark Blue",
        "#ECF0F1",
        "Light Gray",
        "#CED4D9",
        "Medium Gray",
        "#95A5A6",
        "Gray",
        "#7E8C8D",
        "Dark Gray",
        "#34495E",
        "Navy Blue",
        "#000000",
        "Black",
        "#ffffff",
        "White"
      ]
    }), a("color_map_background", { processor: u }), a("color_map_foreground", { processor: u }), a("color_cols", {
      processor: p,
      default: AF(t)
    }), a("color_cols_foreground", {
      processor: p,
      default: J8(t, kR)
    }), a("color_cols_background", {
      processor: p,
      default: J8(t, NR)
    }), a("custom_colors", {
      processor: "boolean",
      default: !0
    }), a("color_default_foreground", {
      processor: "string",
      default: OF
    }), a("color_default_background", {
      processor: "string",
      default: OF
    });
  }, RR = (t, a) => a === kR && t.options.isSet("color_map_foreground") ? Qb("color_map_foreground")(t) : a === NR && t.options.isSet("color_map_background") ? Qb("color_map_background")(t) : Qb("color_map")(t), AF = (t, a = "default") => Math.max(X8, Math.ceil(Math.sqrt(RR(t, a).length))), J8 = (t, a) => {
    const u = Qb("color_cols")(t), p = AF(t, a);
    return u === AF(t) ? p : u;
  }, eH = (t, a = "default") => Math.round((() => a === kR ? Qb("color_cols_foreground")(t) : a === NR ? Qb("color_cols_background")(t) : Qb("color_cols")(t))()), tH = Qb("custom_colors"), QZ = Qb("color_default_foreground"), XZ = Qb("color_default_background"), nH = "rgba(0, 0, 0, 0)", JZ = (t) => yF(t).exists((a) => a.alpha !== 0), eK = (t) => Ic(t, (a) => {
    if ($o(a)) {
      const u = na(a, "background-color");
      return lr(JZ(u), u);
    } else
      return z.none();
  }).getOr(nH), rH = (t, a) => {
    const u = nt.fromDom(t.selection.getStart()), p = a === "hilitecolor" ? eK(u) : na(u, "color");
    return yF(p).map((y) => "#" + u1(y).value);
  }, tK = (t, a, u) => {
    t.undoManager.transact(() => {
      t.focus(), t.formatter.apply(a, { value: u }), t.nodeChanged();
    });
  }, nK = (t, a) => {
    t.undoManager.transact(() => {
      t.focus(), t.formatter.remove(a, { value: null }, void 0, !0), t.nodeChanged();
    });
  }, PR = (t) => {
    t.addCommand("mceApplyTextcolor", (a, u) => {
      tK(t, a, u);
    }), t.addCommand("mceRemoveTextcolor", (a) => {
      nK(t, a);
    });
  }, kF = (t) => {
    const a = "choiceitem", u = {
      type: a,
      text: "Remove color",
      icon: "color-swatch-remove-color",
      value: "remove"
    };
    return t ? [
      u,
      {
        type: a,
        text: "Custom color",
        icon: "color-picker",
        value: "custom"
      }
    ] : [u];
  }, NF = (t, a, u, p) => {
    u === "custom" ? iH(t)((x) => {
      x.each((k) => {
        _F(a, k), t.execCommand("mceApplyTextcolor", a, k), p(k);
      });
    }, rH(t, a).getOr(OF)) : u === "remove" ? (p(""), t.execCommand("mceRemoveTextcolor", a)) : (p(u), t.execCommand("mceApplyTextcolor", a, u));
  }, RF = (t, a, u) => t.concat(TF(a).concat(kF(u))), oH = (t, a, u) => (p) => {
    p(RF(t, a, u));
  }, PF = (t, a, u) => {
    const p = a === "forecolor" ? "tox-icon-text-color__color" : "tox-icon-highlight-bg-color__color";
    t.setIconFill(p, u);
  }, sH = (t, a) => {
    t.setTooltip(a);
  }, aH = (t, a) => (u) => {
    const p = rH(t, a);
    return $i(p, u.toUpperCase());
  }, RO = (t, a, u) => {
    if (ea(u))
      return a === "forecolor" ? "Text color" : "Background color";
    const p = a === "forecolor" ? "Text color {0}" : "Background color {0}", y = RF(RR(t, a), a, !1), x = Ge(y, (k) => k.value === u).getOr({ text: "" }).text;
    return t.translate([
      p,
      t.translate(x)
    ]);
  }, DF = (t, a, u, p) => {
    t.ui.registry.addSplitButton(a, {
      tooltip: RO(t, u, p.get()),
      presets: "color",
      icon: a === "forecolor" ? "text-color" : "highlight-bg-color",
      select: aH(t, u),
      columns: eH(t, u),
      fetch: oH(RR(t, u), u, tH(t)),
      onAction: (y) => {
        NF(t, u, p.get(), G);
      },
      onItemAction: (y, x) => {
        NF(t, u, x, (k) => {
          p.set(k), EF(t, {
            name: a,
            color: k
          });
        });
      },
      onSetup: (y) => {
        PF(y, a, p.get());
        const x = (k) => {
          k.name === a && (PF(y, k.name, k.color), sH(y, RO(t, u, k.color)));
        };
        return t.on("TextColorChange", x), kO(wd(t)(y), () => {
          t.off("TextColorChange", x);
        });
      }
    });
  }, $F = (t, a, u, p, y) => {
    t.ui.registry.addNestedMenuItem(a, {
      text: p,
      icon: a === "forecolor" ? "text-color" : "highlight-bg-color",
      onSetup: (x) => (sH(x, RO(t, u, y.get())), PF(x, a, y.get()), wd(t)(x)),
      getSubmenuItems: () => [{
        type: "fancymenuitem",
        fancytype: "colorswatch",
        select: aH(t, u),
        initData: { storageKey: u },
        onAction: (x) => {
          NF(t, u, x.value, (k) => {
            y.set(k), EF(t, {
              name: a,
              color: k
            });
          });
        }
      }]
    });
  }, iH = (t) => (a, u) => {
    let p = !1;
    const y = ($) => {
      const j = $.getData().colorpicker;
      p ? (a(z.from(j)), $.close()) : t.windowManager.alert(t.translate([
        "Invalid hex color code: {0}",
        j
      ]));
    }, x = ($, B) => {
      B.name === "hex-valid" && (p = B.value);
    }, k = { colorpicker: u };
    t.windowManager.open({
      title: "Color Picker",
      size: "normal",
      body: {
        type: "panel",
        items: [{
          type: "colorpicker",
          name: "colorpicker",
          label: "Color"
        }]
      },
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: k,
      onAction: x,
      onSubmit: y,
      onClose: G,
      onCancel: () => {
        a(z.none());
      }
    });
  }, IF = (t) => {
    PR(t);
    const a = QZ(t), u = XZ(t), p = sr(a), y = sr(u);
    DF(t, "forecolor", "forecolor", p), DF(t, "backcolor", "hilitecolor", y), $F(t, "forecolor", "forecolor", "Text color", p), $F(t, "backcolor", "hilitecolor", "Background color", y);
  }, MF = (t, a, u, p, y, x, k, $) => {
    const B = lR(a), Y = rK(a, u, p, y !== "color" ? "normal" : "color", x, k, $);
    return XM(t, B, Y, p, { menuType: y });
  }, rK = (t, a, u, p, y, x, k) => wi(He(t, ($) => $.type === "choiceitem" ? SZ($).fold(i1, (B) => z.some(MZ(B, u === 1, p, a, x(B.value), y, k, lR(t)))) : z.none())), DR = (t, a) => {
    const u = Gb(a);
    return t === 1 ? {
      mode: "menu",
      moveOnTab: !0
    } : t === "auto" ? {
      mode: "grid",
      selector: "." + u.item,
      initSize: {
        numColumns: 1,
        numRows: 1
      }
    } : {
      mode: "matrix",
      rowSelector: "." + (a === "color" ? "tox-swatches__row" : "tox-collection__group"),
      previousSelector: (y) => a === "color" ? qa(y.element, "[aria-checked=true]") : z.none()
    };
  }, oK = (t, a) => t === 1 ? {
    mode: "menu",
    moveOnTab: !1,
    selector: ".tox-collection__item"
  } : t === "auto" ? {
    mode: "flatgrid",
    selector: ".tox-collection__item",
    initSize: {
      numColumns: 1,
      numRows: 1
    }
  } : {
    mode: "matrix",
    selectors: {
      row: a === "color" ? ".tox-swatches__row" : ".tox-collection__group",
      cell: a === "color" ? `.${WM}` : `.${rR}`
    }
  }, sK = (t, a) => {
    const u = aK(t, a), p = a.colorinput.getColorCols(t.initData.storageKey), y = "color", k = {
      ...MF(Hn("menu-value"), u, ($) => {
        t.onAction({ value: $ });
      }, p, y, Cv.CLOSE_ON_EXECUTE, t.select.getOr(sn), a.shared.providers),
      markers: Gb(y),
      movement: DR(p, y)
    };
    return {
      type: "widget",
      data: { value: Hn("widget-id") },
      dom: {
        tag: "div",
        classes: ["tox-fancymenuitem"]
      },
      autofocus: !0,
      components: [D8.widget(wE.sketch(k))]
    };
  }, aK = (t, a) => {
    const u = t.initData.allowCustomColors && a.colorinput.hasCustomColors();
    return t.initData.colors.fold(() => RF(a.colorinput.getColors(t.initData.storageKey), t.initData.storageKey, u), (p) => p.concat(kF(u)));
  }, cH = Hn("cell-over"), lH = Hn("cell-execute"), iK = (t) => (a, u) => t.shared.providers.translate([
    "{0} columns, {1} rows",
    u,
    a
  ]), cK = (t, a, u) => {
    const p = (k) => nr(k, cH, {
      row: t,
      col: a
    }), y = (k) => nr(k, lH, {
      row: t,
      col: a
    }), x = (k, $) => {
      $.stop(), y(k);
    };
    return sl({
      dom: {
        tag: "div",
        attributes: {
          role: "button",
          "aria-label": u
        }
      },
      behaviours: mn([
        Hr("insert-table-picker-cell", [
          Pt(yf(), Er.focus),
          Pt(Lu(), y),
          Pt(um(), x),
          Pt(wf(), x)
        ]),
        Zr.config({
          toggleClass: "tox-insert-table-picker__selected",
          toggleOnExecute: !1
        }),
        Er.config({ onFocus: p })
      ])
    });
  }, $R = (t, a, u) => {
    const p = [];
    for (let y = 0; y < a; y++) {
      const x = [];
      for (let k = 0; k < u; k++) {
        const $ = t(y + 1, k + 1);
        x.push(cK(y, k, $));
      }
      p.push(x);
    }
    return p;
  }, FF = (t, a, u, p, y) => {
    for (let x = 0; x < p; x++)
      for (let k = 0; k < y; k++)
        Zr.set(t[x][k], x <= a && k <= u);
  }, LF = (t) => ke(t, (a) => He(a, Hu)), BF = (t, a) => Ma(`${a}x${t}`), lK = {
    inserttable: (t, a) => {
      const y = iK(a), x = $R(y, 10, 10), k = BF(0, 0), $ = ms({
        dom: {
          tag: "span",
          classes: ["tox-insert-table-picker__label"]
        },
        components: [k],
        behaviours: mn([$r.config({})])
      });
      return {
        type: "widget",
        data: { value: Hn("widget-id") },
        dom: {
          tag: "div",
          classes: ["tox-fancymenuitem"]
        },
        autofocus: !0,
        components: [D8.widget({
          dom: {
            tag: "div",
            classes: ["tox-insert-table-picker"]
          },
          components: LF(x).concat($.asSpec()),
          behaviours: mn([
            Hr("insert-table-picker", [
              us((B) => {
                $r.set($.get(B), [k]);
              }),
              aw(cH, (B, j, Y) => {
                const { row: re, col: le } = Y.event;
                FF(x, re, le, 10, 10), $r.set($.get(B), [BF(re + 1, le + 1)]);
              }),
              aw(lH, (B, j, Y) => {
                const { row: re, col: le } = Y.event;
                t.onAction({
                  numRows: re + 1,
                  numColumns: le + 1
                }), Jr(B, Ty());
              })
            ]),
            ar.config({
              initSize: {
                numRows: 10,
                numColumns: 10
              },
              mode: "flatgrid",
              selector: '[role="button"]'
            })
          ])
        })]
      };
    },
    colorswatch: sK
  }, HF = (t, a) => fn(lK, t.fancytype).map((u) => u(t, a)), zF = (t, a, u, p = !0, y = !1) => {
    const x = y ? NE(u.icons) : $Z(u.icons), k = (B) => ({
      isEnabled: () => !yr.isDisabled(B),
      setEnabled: (j) => yr.set(B, !j),
      setIconFill: (j, Y) => {
        qa(B.element, `svg path[class="${j}"], rect[class="${j}"]`).each((re) => {
          kn(re, "fill", Y);
        });
      },
      setTooltip: (j) => {
        const Y = u.translate(j);
        Pm(B.element, {
          "aria-label": Y,
          title: Y
        });
      }
    }), $ = RE({
      presets: "normal",
      iconContent: t.icon,
      textContent: t.text,
      htmlContent: z.none(),
      ariaLabel: t.text,
      caret: z.some(x),
      checkMark: z.none(),
      shortcutContent: t.shortcut
    }, u, p);
    return Yb({
      data: bT(t),
      getApi: k,
      enabled: t.enabled,
      onAction: G,
      onSetup: t.onSetup,
      triggersSubmenu: !0,
      itemBehaviours: []
    }, $, a, u);
  }, IR = (t, a, u, p = !0) => {
    const y = (k) => ({
      isEnabled: () => !yr.isDisabled(k),
      setEnabled: ($) => yr.set(k, !$)
    }), x = RE({
      presets: "normal",
      iconContent: t.icon,
      textContent: t.text,
      htmlContent: z.none(),
      ariaLabel: t.text,
      caret: z.none(),
      checkMark: z.none(),
      shortcutContent: t.shortcut
    }, u, p);
    return Yb({
      data: bT(t),
      getApi: y,
      enabled: t.enabled,
      onAction: t.onAction,
      onSetup: t.onSetup,
      triggersSubmenu: !1,
      itemBehaviours: []
    }, x, a, u);
  }, uH = (t) => ({
    type: "separator",
    dom: {
      tag: "div",
      classes: [
        rR,
        KG
      ]
    },
    components: t.text.map(Ma).toArray()
  }), uK = (t, a, u, p = !0) => {
    const y = (k) => ({
      setActive: ($) => {
        Zr.set(k, $);
      },
      isActive: () => Zr.isOn(k),
      isEnabled: () => !yr.isDisabled(k),
      setEnabled: ($) => yr.set(k, !$)
    }), x = RE({
      iconContent: t.icon,
      textContent: t.text,
      htmlContent: z.none(),
      ariaLabel: t.text,
      checkMark: z.some(qs(u.icons)),
      caret: z.none(),
      shortcutContent: t.shortcut,
      presets: "normal",
      meta: t.meta
    }, u, p);
    return Vo(Yb({
      data: bT(t),
      enabled: t.enabled,
      getApi: y,
      onAction: t.onAction,
      onSetup: t.onSetup,
      triggersSubmenu: !1,
      itemBehaviours: []
    }, x, a, u), {
      toggling: {
        toggleClass: z6,
        toggleOnExecute: !1,
        selected: t.active
      }
    });
  }, dK = hF, dH = uH, fK = IR, mK = zF, pK = uK, hK = HF, gK = CR;
  var vK = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    getCoupled: (t, a, u, p) => u.getOrCreate(t, a, p),
    getExistingCoupled: (t, a, u, p) => u.getExisting(t, a, p)
  }), bK = [$c("others", im(Rr.value, Ua()))], fH = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: () => {
      const t = {}, a = (x, k) => {
        if (Xr(x.others).length === 0)
          throw new Error("Cannot find any known coupled components");
        return fn(t, k);
      }, u = (x, k, $) => a(k, $).getOrThunk(() => {
        const j = fn(k.others, $).getOrDie("No information found for coupled component: " + $)(x), Y = x.getSystem().build(j);
        return t[$] = Y, Y;
      }), p = (x, k, $) => a(k, $).orThunk(() => (fn(k.others, $).getOrDie("No information found for coupled component: " + $), z.none())), y = q({});
      return ol({
        readState: y,
        getExisting: p,
        getOrCreate: u
      });
    }
  });
  const yi = Zi({
    fields: bK,
    name: "coupling",
    apis: vK,
    state: fH
  }), VF = (t) => {
    let a = z.none(), u = [];
    const p = (j) => VF((Y) => {
      y((re) => {
        Y(j(re));
      });
    }), y = (j) => {
      k() ? B(j) : u.push(j);
    }, x = (j) => {
      k() || (a = z.some(j), $(u), u = []);
    }, k = () => a.isSome(), $ = (j) => {
      ut(j, B);
    }, B = (j) => {
      a.each((Y) => {
        setTimeout(() => {
          j(Y);
        }, 0);
      });
    };
    return t(x), {
      get: y,
      map: p,
      isReady: k
    };
  }, yK = {
    nu: VF,
    pure: (t) => VF((a) => {
      a(t);
    })
  }, SK = (t) => {
    setTimeout(() => {
      throw t;
    }, 0);
  }, nS = (t) => {
    const a = (B) => {
      t().then(B, SK);
    };
    return {
      map: (B) => nS(() => t().then(B)),
      bind: (B) => nS(() => t().then((j) => B(j).toPromise())),
      anonBind: (B) => nS(() => t().then(() => B.toPromise())),
      toLazy: () => yK.nu(a),
      toCached: () => {
        let B = null;
        return nS(() => (B === null && (B = t()), B));
      },
      toPromise: t,
      get: a
    };
  }, wu = {
    nu: (t) => nS(() => new Promise(t)),
    pure: (t) => nS(() => Promise.resolve(t))
  }, mH = q("sink"), pH = q(vd({
    name: mH(),
    overrides: q({
      dom: { tag: "div" },
      behaviours: mn([Wl.config({ useFixed: Lt })]),
      events: ls([
        Gp(ud()),
        Gp(oo()),
        Gp(um())
      ])
    })
  })), hH = (t, a) => {
    const u = t.getHotspot(a).getOr(a), p = "hotspot", y = t.getAnchorOverrides();
    return t.layouts.fold(() => ({
      type: p,
      hotspot: u,
      overrides: y
    }), (x) => ({
      type: p,
      hotspot: u,
      overrides: y,
      layouts: x
    }));
  }, wK = (t, a, u) => {
    const p = t.fetch;
    return p(u).map(a);
  }, EK = (t, a, u, p, y, x, k) => {
    const $ = wK(t, a, p), B = gH(p, t);
    return $.map((j) => j.bind((Y) => z.from(q0.sketch({
      ...x.menu(),
      uid: db(""),
      data: Y,
      highlightOnOpen: k,
      onOpenMenu: (re, le) => {
        const pe = B().getOrDie();
        Wl.position(pe, le, { anchor: u }), bo.decloak(y);
      },
      onOpenSubmenu: (re, le, pe) => {
        const _e = B().getOrDie();
        Wl.position(_e, pe, {
          anchor: {
            type: "submenu",
            item: le
          }
        }), bo.decloak(y);
      },
      onRepositionMenu: (re, le, pe) => {
        const _e = B().getOrDie();
        Wl.position(_e, le, { anchor: u }), ut(pe, (ze) => {
          Wl.position(_e, ze.triggeredMenu, {
            anchor: {
              type: "submenu",
              item: ze.triggeringItem
            }
          });
        });
      },
      onEscape: () => (Er.focus(p), bo.close(y), z.some(!0))
    }))));
  }, MR = (t, a, u, p, y, x, k) => {
    const $ = hH(t, u);
    return EK(t, a, $, u, p, y, k).map((j) => (j.fold(() => {
      bo.isOpen(p) && bo.close(p);
    }, (Y) => {
      bo.cloak(p), bo.open(p, Y), x(p);
    }), p));
  }, CK = (t, a, u, p, y, x, k) => (bo.close(p), wu.pure(p)), UF = (t, a, u, p, y, x) => {
    const k = yi.getCoupled(u, "sandbox");
    return (bo.isOpen(k) ? CK : MR)(t, a, u, k, p, y, x);
  }, xK = (t, a, u) => {
    const p = ho.getCurrent(a).getOr(a), y = Oa(t.element);
    u ? Sr(p.element, "min-width", y + "px") : no(p.element, y);
  }, gH = (t, a) => t.getSystem().getByUid(a.uid + "-" + mH()).map((u) => () => Rr.value(u)).getOrThunk(() => a.lazySink.fold(() => () => Rr.error(new Error("No internal sink is specified, nor could an external sink be found")), (u) => () => u(t))), vH = (t) => {
    bo.getState(t).each((a) => {
      q0.repositionMenus(a);
    });
  }, WF = (t, a, u) => {
    const p = rv(), y = ($, B) => {
      const j = hH(t, a);
      p.link(a.element), t.matchWidth && xK(j.hotspot, B, t.useMinWidth), t.onOpen(j, $, B), u !== void 0 && u.onOpen !== void 0 && u.onOpen($, B);
    }, x = ($, B) => {
      p.unlink(a.element), u !== void 0 && u.onClose !== void 0 && u.onClose($, B);
    }, k = gH(a, t);
    return {
      dom: {
        tag: "div",
        classes: t.sandboxClasses,
        attributes: {
          id: p.id,
          role: "listbox"
        }
      },
      behaviours: bm.augment(t.sandboxBehaviours, [
        Pn.config({
          store: {
            mode: "memory",
            initialValue: a
          }
        }),
        bo.config({
          onOpen: y,
          onClose: x,
          isPartOf: ($, B, j) => th(B, j) || th(a, j),
          getAttachPoint: () => k().getOrDie()
        }),
        ho.config({
          find: ($) => bo.getState($).bind((B) => ho.getCurrent(B))
        }),
        vu.config({
          channels: {
            ...eE({ isExtraPart: sn }),
            ...P0({ doReposition: vH })
          }
        })
      ])
    };
  }, bH = (t) => {
    const a = yi.getCoupled(t, "sandbox");
    vH(a);
  }, jF = () => [
    lt("sandboxClasses", []),
    bm.field("sandboxBehaviours", [
      ho,
      vu,
      bo,
      Pn
    ])
  ], TK = q([
    Mt("dom"),
    Mt("fetch"),
    po("onOpen"),
    Uu("onExecute"),
    lt("getHotspot", z.some),
    lt("getAnchorOverrides", q({})),
    rg(),
    ac("dropdownBehaviours", [
      Zr,
      yi,
      ar,
      Er
    ]),
    Mt("toggleClass"),
    lt("eventOrder", {}),
    Fo("lazySink"),
    lt("matchWidth", !1),
    lt("useMinWidth", !1),
    Fo("role")
  ].concat(jF())), _K = q([
    rp({
      schema: [
        Dy(),
        lt("fakeFocus", !1)
      ],
      name: "menu",
      defaults: (t) => ({ onExecute: t.onExecute })
    }),
    pH()
  ]), OK = (t, a, u, p) => {
    const y = (Y) => fn(t.dom, "attributes").bind((re) => fn(re, Y)), x = (Y) => {
      bo.getState(Y).each((re) => {
        q0.highlightPrimary(re);
      });
    }, k = (Y, re, le) => UF(t, Te, Y, p, re, le), $ = (Y) => {
      k(Y, x, Sd.HighlightMenuAndItem).get(G);
    }, B = {
      expand: (Y) => {
        Zr.isOn(Y) || k(Y, G, Sd.HighlightNone).get(G);
      },
      open: (Y) => {
        Zr.isOn(Y) || k(Y, G, Sd.HighlightMenuAndItem).get(G);
      },
      refetch: (Y) => yi.getExistingCoupled(Y, "sandbox").fold(() => k(Y, G, Sd.HighlightMenuAndItem).map(G), (le) => MR(t, Te, Y, le, p, G, Sd.HighlightMenuAndItem).map(G)),
      isOpen: Zr.isOn,
      close: (Y) => {
        Zr.isOn(Y) && k(Y, G, Sd.HighlightMenuAndItem).get(G);
      },
      repositionMenus: (Y) => {
        Zr.isOn(Y) && bH(Y);
      }
    }, j = (Y, re) => (Ef(Y), z.some(!0));
    return {
      uid: t.uid,
      dom: t.dom,
      components: a,
      behaviours: _i(t.dropdownBehaviours, [
        Zr.config({
          toggleClass: t.toggleClass,
          aria: { mode: "expanded" }
        }),
        yi.config({
          others: {
            sandbox: (Y) => WF(t, Y, {
              onOpen: () => Zr.on(Y),
              onClose: () => Zr.off(Y)
            })
          }
        }),
        ar.config({
          mode: "special",
          onSpace: j,
          onEnter: j,
          onDown: (Y, re) => {
            if (bh.isOpen(Y)) {
              const le = yi.getCoupled(Y, "sandbox");
              x(le);
            } else
              bh.open(Y);
            return z.some(!0);
          },
          onEscape: (Y, re) => bh.isOpen(Y) ? (bh.close(Y), z.some(!0)) : z.none()
        }),
        Er.config({})
      ]),
      events: wv(z.some($)),
      eventOrder: {
        ...t.eventOrder,
        [Lu()]: [
          "disabling",
          "toggling",
          "alloy.base.behaviour"
        ]
      },
      apis: B,
      domModification: {
        attributes: {
          "aria-haspopup": "true",
          ...t.role.fold(() => ({}), (Y) => ({ role: Y })),
          ...t.dom.tag === "button" ? { type: y("type").getOr("button") } : {}
        }
      }
    };
  }, bh = ql({
    name: "Dropdown",
    configFields: TK(),
    partFields: _K(),
    factory: OK,
    apis: {
      open: (t, a) => t.open(a),
      refetch: (t, a) => t.refetch(a),
      expand: (t, a) => t.expand(a),
      close: (t, a) => t.close(a),
      isOpen: (t, a) => t.isOpen(a),
      repositionMenus: (t, a) => t.repositionMenus(a)
    }
  }), AK = (t) => {
    switch (t.searchMode) {
      case "no-search":
        return { menuType: "normal" };
      default:
        return {
          menuType: "searchable",
          searchMode: t
        };
    }
  }, kK = (t) => {
    const a = Pn.getValue(t), u = hT(t).map(KM);
    bh.refetch(a).get(() => {
      const p = yi.getCoupled(a, "sandbox");
      u.each((y) => hT(p).each((x) => nZ(x, y)));
    });
  }, NK = (t, a) => {
    RK(t).each((u) => {
      M2(t, u.element, a.event.eventType, a.event.interactionEvent);
    });
  }, RK = (t) => bo.getState(t).bind(Wo.getHighlighted).bind(Wo.getHighlighted), PK = (t) => Ti(t.element, iR) ? z.some(t.element) : qa(t.element, "." + iR), qF = (t, a, u) => {
    aR(t).each((p) => {
      J6(p, u), PK(a).each((x) => {
        as(x, "id").each((k) => kn(p.element, "aria-controls", k));
      });
    }), kn(u.element, "aria-selected", "true");
  }, DK = (t, a, u) => {
    kn(u.element, "aria-selected", "false");
  }, $K = (t) => {
    aR(t).each((a) => Er.focus(a));
  }, IK = (t) => yi.getExistingCoupled(t, "sandbox").bind(hT).map(KM).map((u) => u.fetchPattern).getOr("");
  var PO;
  (function(t) {
    t[t.ContentFocus = 0] = "ContentFocus", t[t.UiFocus = 1] = "UiFocus";
  })(PO || (PO = {}));
  const MK = (t, a, u, p, y) => {
    const x = u.shared.providers, k = ($) => y ? {
      ...$,
      shortcut: z.none(),
      icon: $.text.isSome() ? z.none() : $.icon
    } : $;
    switch (t.type) {
      case "menuitem":
        return xZ(t).fold(i1, ($) => z.some(fK(k($), a, x, p)));
      case "nestedmenuitem":
        return C8(t).fold(i1, ($) => z.some(mK(k($), a, x, p, y)));
      case "togglemenuitem":
        return OZ(t).fold(i1, ($) => z.some(pK(k($), a, x, p)));
      case "separator":
        return u8(t).fold(i1, ($) => z.some(dH($)));
      case "fancymenuitem":
        return EZ(t).fold(i1, ($) => hK($, u));
      default:
        return console.error("Unknown item in general menu", t), z.none();
    }
  }, FK = (t, a, u, p, y, x, k) => {
    const $ = p === 1, B = !$ || lR(t);
    return wi(He(t, (j) => {
      switch (j.type) {
        case "separator":
          return f8(j).fold(i1, (Y) => z.some(dH(Y)));
        case "cardmenuitem":
          return bZ(j).fold(i1, (Y) => z.some(gK({
            ...Y,
            onAction: (re) => {
              Y.onAction(re), u(Y.value, Y.meta);
            }
          }, y, x, {
            itemBehaviours: R8(Y.meta, x),
            cardText: {
              matchText: a,
              highlightOn: k
            }
          })));
        case "autocompleteitem":
        default:
          return iZ(j).fold(i1, (Y) => z.some(dK(Y, a, $, "normal", u, y, x, B)));
      }
    }));
  }, yH = (t, a, u, p, y, x) => {
    const k = lR(a), $ = wi(He(a, (Y) => {
      const re = (pe) => y ? !Yr(pe, "text") : k, le = (pe) => MK(pe, u, p, re(pe), y);
      return Y.type === "nestedmenuitem" && Y.getSubmenuItems().length <= 0 ? le({
        ...Y,
        enabled: !1
      }) : le(Y);
    })), B = AK(x);
    return (y ? o8 : XM)(t, k, $, 1, B);
  }, FR = (t) => q0.singleData(t.value, t), LK = (t, a, u, p) => {
    const y = DR(a, p), x = Gb(p);
    return {
      data: FR({
        ...t,
        movement: y,
        menuBehaviours: CO.unnamedEvents(a !== "auto" ? [] : [us((k, $) => {
          EO(k, 4, x.item).each(({ numColumns: B, numRows: j }) => {
            ar.setGridSize(k, j, B);
          });
        })])
      }),
      menu: {
        markers: Gb(p),
        fakeFocus: u === PO.ContentFocus
      }
    };
  }, BK = (t, a) => H6(nt.fromDom(a.startContainer)).map((u) => {
    const p = t.createRng();
    return p.selectNode(u.dom), p;
  }), HK = { register: (t, a) => {
    const u = Hn("autocompleter"), p = sr(!1), y = sr(!1), x = sl(La.sketch({
      dom: {
        tag: "div",
        classes: ["tox-autocompleter"],
        attributes: { id: u }
      },
      components: [],
      fireDismissalEventInstead: {},
      inlineBehaviours: mn([Hr("dismissAutocompleter", [
        Pt(jp(), () => Y()),
        Pt(ob(), (ft, Xe) => {
          as(Xe.event.target, "id").each((Ze) => kn(nt.fromDom(t.getBody()), "aria-activedescendant", Ze));
        })
      ])]),
      lazySink: a.getSink
    })), k = () => La.isOpen(x), $ = y.get, B = () => {
      if (k()) {
        La.hide(x), t.dom.remove(u, !1);
        const ft = nt.fromDom(t.getBody());
        as(ft, "aria-owns").filter((Xe) => Xe === u).each(() => {
          vs(ft, "aria-owns"), vs(ft, "aria-activedescendant");
        });
      }
    }, j = () => La.getContent(x).bind((ft) => Bt(ft.components(), 0)), Y = () => t.execCommand("mceAutocompleterClose"), re = (ft) => {
      const Xe = Vr(ft, (Ze) => z.from(Ze.columns)).getOr(1);
      return ke(ft, (Ze) => {
        const mt = Ze.items;
        return FK(mt, Ze.matchText, (jt, Dt) => {
          const Nt = t.selection.getRng();
          BK(t.dom, Nt).each((hn) => {
            const En = {
              hide: () => Y(),
              reload: (zr) => {
                B(), t.execCommand("mceAutocompleterReload", !1, { fetchOptions: zr });
              }
            };
            p.set(!0), Ze.onAction(En, hn, jt, Dt), p.set(!1);
          });
        }, Xe, Cv.BUBBLE_TO_SANDBOX, a, Ze.highlightOn);
      });
    }, le = (ft, Xe) => {
      GG(nt.fromDom(t.getBody())).each((Ze) => {
        const mt = Vr(ft, (jt) => z.from(jt.columns)).getOr(1);
        La.showMenuAt(x, {
          anchor: {
            type: "node",
            root: nt.fromDom(t.getBody()),
            node: z.from(Ze)
          }
        }, LK(XM("autocompleter-value", !0, Xe, mt, { menuType: "normal" }), mt, PO.ContentFocus, "normal"));
      }), j().each(Wo.highlightFirst);
    }, pe = (ft) => {
      const Xe = re(ft);
      Xe.length > 0 ? (le(ft, Xe), kn(nt.fromDom(t.getBody()), "aria-owns", u), t.inline || _e()) : B();
    }, _e = () => {
      t.dom.get(u) && t.dom.remove(u, !1);
      const ft = t.getDoc().documentElement, Xe = t.selection.getNode(), Ze = qC(x.element);
      Rc(Ze, {
        border: "0",
        clip: "rect(0 0 0 0)",
        height: "1px",
        margin: "-1px",
        overflow: "hidden",
        padding: "0",
        position: "absolute",
        width: "1px",
        top: `${Xe.offsetTop}px`,
        left: `${Xe.offsetLeft}px`
      }), t.dom.add(ft, Ze.dom), qa(Ze, '[role="menu"]').each((mt) => {
        Ur(mt, "position"), Ur(mt, "max-height");
      });
    };
    t.on("AutocompleterStart", ({ lookupData: ft }) => {
      y.set(!0), p.set(!1), pe(ft);
    }), t.on("AutocompleterUpdate", ({ lookupData: ft }) => pe(ft)), t.on("AutocompleterEnd", () => {
      B(), y.set(!1), p.set(!1);
    });
    const ze = {
      cancelIfNecessary: Y,
      isMenuOpen: k,
      isActive: $,
      isProcessingAction: p.get,
      getMenu: j
    };
    zM.setup(ze, t);
  } }, SH = [
    "visible",
    "hidden",
    "clip"
  ], wH = (t) => Yu(t).length > 0 && !vt(SH, t), GF = (t) => {
    if (ed(t)) {
      const a = na(t, "overflow-x"), u = na(t, "overflow-y");
      return wH(a) || wH(u);
    } else
      return !1;
  }, zK = (t) => {
    const a = Nx(t, GF), u = a.length === 0 ? Yo(t).map(Lr).map((p) => Nx(p, GF)).getOr([]) : a;
    return $n(u).map((p) => ({
      element: p,
      others: u.slice(1)
    }));
  }, rS = (t, a) => a1(t) ? zK(a) : z.none(), ST = (t) => {
    const a = [
      ...He(t.others, Ss),
      Ci()
    ];
    return Zv(Ss(t.element), a);
  }, DO = (t, a, u) => fm(t, a, u).isSome(), EH = (t, a) => {
    let u = null;
    return {
      cancel: () => {
        u !== null && (clearTimeout(u), u = null);
      },
      schedule: (...x) => {
        u = setTimeout(() => {
          t.apply(null, x), u = null;
        }, a);
      }
    };
  }, CH = 5, VK = 400, xH = (t) => {
    const a = t.raw;
    return a.touches === void 0 || a.touches.length !== 1 ? z.none() : z.some(a.touches[0]);
  }, UK = (t, a) => {
    const u = Math.abs(t.clientX - a.x), p = Math.abs(t.clientY - a.y);
    return u > CH || p > CH;
  }, WK = (t) => {
    const a = Gr(), u = sr(!1), p = EH((j) => {
      t.triggerEvent(z1(), j), u.set(!0);
    }, VK), y = (j) => (xH(j).each((Y) => {
      p.cancel();
      const re = {
        x: Y.clientX,
        y: Y.clientY,
        target: j.target
      };
      p.schedule(j), u.set(!1), a.set(re);
    }), z.none()), x = (j) => (p.cancel(), xH(j).each((Y) => {
      a.on((re) => {
        UK(Y, re) && a.clear();
      });
    }), z.none()), k = (j) => {
      p.cancel();
      const Y = (re) => Io(re.target, j.target);
      return a.get().filter(Y).map((re) => u.get() ? (j.prevent(), !1) : t.triggerEvent(wf(), j));
    }, $ = Xn([
      {
        key: du(),
        value: y
      },
      {
        key: jh(),
        value: x
      },
      {
        key: Lp(),
        value: k
      }
    ]);
    return { fireIfReady: (j, Y) => fn($, Y).bind((re) => re(j)) };
  }, jK = (t) => t.raw.which === jI[0] && !vt([
    "input",
    "textarea"
  ], kc(t.target)) && !DO(t.target, '[contenteditable="true"]'), qK = (t, a) => {
    const u = {
      stopBackspace: !0,
      ...a
    }, p = [
      "touchstart",
      "touchmove",
      "touchend",
      "touchcancel",
      "gesturestart",
      "mousedown",
      "mouseup",
      "mouseover",
      "mousemove",
      "mouseout",
      "click"
    ], y = WK(u), x = He(p.concat([
      "selectstart",
      "input",
      "contextmenu",
      "change",
      "transitionend",
      "transitioncancel",
      "drag",
      "dragstart",
      "dragend",
      "dragenter",
      "dragleave",
      "dragover",
      "drop",
      "keyup"
    ]), (pe) => Cl(t, pe, (_e) => {
      y.fireIfReady(_e, pe).each((ft) => {
        ft && _e.kill();
      }), u.triggerEvent(pe, _e) && _e.kill();
    })), k = Gr(), $ = Cl(t, "paste", (pe) => {
      y.fireIfReady(pe, "paste").each((ze) => {
        ze && pe.kill();
      }), u.triggerEvent("paste", pe) && pe.kill(), k.set(setTimeout(() => {
        u.triggerEvent(Up(), pe);
      }, 0));
    }), B = Cl(t, "keydown", (pe) => {
      u.triggerEvent("keydown", pe) ? pe.kill() : u.stopBackspace && jK(pe) && pe.prevent();
    }), j = Cl(t, "focusin", (pe) => {
      u.triggerEvent("focusin", pe) && pe.kill();
    }), Y = Gr(), re = Cl(t, "focusout", (pe) => {
      u.triggerEvent("focusout", pe) && pe.kill(), Y.set(setTimeout(() => {
        u.triggerEvent(Vp(), pe);
      }, 0));
    });
    return { unbind: () => {
      ut(x, (pe) => {
        pe.unbind();
      }), B.unbind(), j.unbind(), re.unbind(), $.unbind(), k.on(clearTimeout), Y.on(clearTimeout);
    } };
  }, TH = (t, a) => {
    const u = fn(t, "target").getOr(a);
    return sr(u);
  }, GK = (t, a) => {
    const u = sr(!1), p = sr(!1);
    return {
      stop: () => {
        u.set(!0);
      },
      cut: () => {
        p.set(!0);
      },
      isStopped: u.get,
      isCut: p.get,
      event: t,
      setSource: a.set,
      getSource: a.get
    };
  }, _H = (t) => {
    const a = sr(!1);
    return {
      stop: () => {
        a.set(!0);
      },
      cut: G,
      isStopped: a.get,
      isCut: sn,
      event: t,
      setSource: Ce("Cannot set source of a broadcasted event"),
      getSource: Ce("Cannot get source of a broadcasted event")
    };
  }, $O = W.generate([
    { stopped: [] },
    { resume: ["element"] },
    { complete: [] }
  ]), OH = (t, a, u, p, y, x) => {
    const k = t(a, p), $ = GK(u, y);
    return k.fold(() => (x.logEventNoHandlers(a, p), $O.complete()), (B) => {
      const j = B.descHandler;
      return gb(j)($), $.isStopped() ? (x.logEventStopped(a, B.element, j.purpose), $O.stopped()) : $.isCut() ? (x.logEventCut(a, B.element, j.purpose), $O.complete()) : Ii(B.element).fold(() => (x.logNoParent(a, B.element, j.purpose), $O.complete()), (re) => (x.logEventResponse(a, B.element, j.purpose), $O.resume(re)));
    });
  }, AH = (t, a, u, p, y, x) => OH(t, a, u, p, y, x).fold(Lt, (k) => AH(t, a, u, k, y, x), sn), ZK = (t, a, u, p, y) => {
    const x = TH(u, p);
    return OH(t, a, u, p, x, y);
  }, KK = (t, a, u) => {
    const p = _H(a);
    return ut(t, (y) => {
      const x = y.descHandler;
      gb(x)(p);
    }), p.isStopped();
  }, ZF = (t, a, u, p) => kH(t, a, u, u.target, p), kH = (t, a, u, p, y) => {
    const x = TH(u, p);
    return AH(t, a, u, p, x, y);
  }, YK = (t, a) => ({
    element: t,
    descHandler: a
  }), QK = (t, a) => ({
    id: t,
    descHandler: a
  }), NH = () => {
    const t = {}, a = (k, $, B) => {
      Eo(B, (j, Y) => {
        const re = t[Y] !== void 0 ? t[Y] : {};
        re[$] = dw(j, k), t[Y] = re;
      });
    }, u = (k, $) => Qg($).bind((B) => fn(k, B)).map((B) => YK($, B));
    return {
      registerId: a,
      unregisterId: (k) => {
        Eo(t, ($, B) => {
          Yr($, k) && delete $[k];
        });
      },
      filterByType: (k) => fn(t, k).map(($) => hc($, (B, j) => QK(j, B))).getOr([]),
      find: (k, $, B) => fn(t, $).bind((j) => Ic(B, (Y) => u(j, Y), k))
    };
  }, RH = () => {
    const t = NH(), a = {}, u = (j) => {
      const Y = j.element;
      return Qg(Y).getOrThunk(() => Qp("uid-", j.element));
    }, p = (j, Y) => {
      const re = a[Y];
      if (re === j)
        x(j);
      else
        throw new Error('The tagId "' + Y + '" is already used by: ' + Wm(re.element) + `
Cannot use it for: ` + Wm(j.element) + `
The conflicting element is` + (fo(re.element) ? " " : " not ") + "already in the DOM");
    }, y = (j) => {
      const Y = u(j);
      xa(a, Y) && p(j, Y);
      const re = [j];
      t.registerId(re, Y, j.events), a[Y] = j;
    }, x = (j) => {
      Qg(j.element).each((Y) => {
        delete a[Y], t.unregisterId(Y);
      });
    };
    return {
      find: (j, Y, re) => t.find(j, Y, re),
      filter: (j) => t.filterByType(j),
      register: y,
      unregister: x,
      getById: (j) => fn(a, j)
    };
  }, Tv = Yd({
    name: "Container",
    factory: (t) => {
      const { attributes: a, ...u } = t.dom;
      return {
        uid: t.uid,
        dom: {
          tag: "div",
          attributes: {
            role: "presentation",
            ...a
          },
          ...u
        },
        components: t.components,
        behaviours: pv(t.containerBehaviours),
        events: t.events,
        domModification: t.domModification,
        eventOrder: t.eventOrder
      };
    },
    configFields: [
      lt("components", []),
      ac("containerBehaviours", []),
      lt("events", {}),
      lt("domModification", {}),
      lt("eventOrder", {})
    ]
  }), LR = (t) => {
    const a = (Xe) => Ii(t.element).fold(Lt, (Ze) => Io(Xe, Ze)), u = RH(), p = (Xe, Ze) => u.find(a, Xe, Ze), y = qK(t.element, {
      triggerEvent: (Xe, Ze) => a0(Xe, Ze.target, (mt) => ZF(p, Xe, Ze, mt))
    }), x = {
      debugInfo: q("real"),
      triggerEvent: (Xe, Ze, mt) => {
        a0(Xe, Ze, (jt) => kH(p, Xe, mt, Ze, jt));
      },
      triggerFocus: (Xe, Ze) => {
        Qg(Xe).fold(() => {
          Fa(Xe);
        }, (mt) => {
          a0(Sf(), Xe, (jt) => (ZK(p, Sf(), {
            originator: Ze,
            kill: G,
            prevent: G,
            target: Xe
          }, Xe, jt), !1));
        });
      },
      triggerEscape: (Xe, Ze) => {
        x.triggerEvent("keydown", Xe.element, Ze.event);
      },
      getByUid: (Xe) => ze(Xe),
      getByDom: (Xe) => ft(Xe),
      build: sl,
      buildOrPatch: o0,
      addToGui: (Xe) => {
        B(Xe);
      },
      removeFromGui: (Xe) => {
        j(Xe);
      },
      addToWorld: (Xe) => {
        k(Xe);
      },
      removeFromWorld: (Xe) => {
        $(Xe);
      },
      broadcast: (Xe) => {
        le(Xe);
      },
      broadcastOn: (Xe, Ze) => {
        pe(Xe, Ze);
      },
      broadcastEvent: (Xe, Ze) => {
        _e(Xe, Ze);
      },
      isConnected: Lt
    }, k = (Xe) => {
      Xe.connect(x), ei(Xe.element) || (u.register(Xe), ut(Xe.components(), k), x.triggerEvent(Wp(), Xe.element, { target: Xe.element }));
    }, $ = (Xe) => {
      ei(Xe.element) || (ut(Xe.components(), $), u.unregister(Xe)), Xe.disconnect();
    }, B = (Xe) => {
      Hb(t, Xe);
    }, j = (Xe) => {
      cg(Xe);
    }, Y = () => {
      y.unbind(), ou(t.element);
    }, re = (Xe) => {
      const Ze = u.filter(Zg());
      ut(Ze, (mt) => {
        const jt = mt.descHandler;
        gb(jt)(Xe);
      });
    }, le = (Xe) => {
      re({
        universal: !0,
        data: Xe
      });
    }, pe = (Xe, Ze) => {
      re({
        universal: !1,
        channels: Xe,
        data: Ze
      });
    }, _e = (Xe, Ze) => {
      const mt = u.filter(Xe);
      return KK(mt, Ze);
    }, ze = (Xe) => u.getById(Xe).fold(() => Rr.error(new Error('Could not find component with uid: "' + Xe + '" in system.')), Rr.value), ft = (Xe) => {
      const Ze = Qg(Xe).getOr("not found");
      return ze(Ze);
    };
    return k(t), {
      root: t,
      element: t.element,
      destroy: Y,
      add: B,
      remove: j,
      getByUid: ze,
      getByDom: ft,
      addToWorld: k,
      removeFromWorld: $,
      broadcast: le,
      broadcastOn: pe,
      broadcastEvent: _e
    };
  }, XK = (t, a) => ({
    dom: {
      tag: "div",
      classes: [
        "tox-bar",
        "tox-form__controls-h-stack"
      ]
    },
    components: He(t.items, a.interpreter)
  }), JK = q([
    lt("prefix", "form-field"),
    ac("fieldBehaviours", [
      ho,
      Pn
    ])
  ]), eY = q([
    vd({
      schema: [Mt("dom")],
      name: "label"
    }),
    vd({
      factory: {
        sketch: (t) => ({
          uid: t.uid,
          dom: {
            tag: "span",
            styles: { display: "none" },
            attributes: { "aria-hidden": "true" },
            innerHtml: t.text
          }
        })
      },
      schema: [Mt("text")],
      name: "aria-descriptor"
    }),
    jl({
      factory: {
        sketch: (t) => {
          const a = tn(t, ["factory"]);
          return t.factory.sketch(a);
        }
      },
      schema: [Mt("factory")],
      name: "field"
    })
  ]), tY = (t, a, u, p) => {
    const y = _i(t.fieldBehaviours, [
      ho.config({
        find: ($) => Fs($, t, "field")
      }),
      Pn.config({
        store: {
          mode: "manual",
          getValue: ($) => ho.getCurrent($).bind(Pn.getValue),
          setValue: ($, B) => {
            ho.getCurrent($).each((j) => {
              Pn.setValue(j, B);
            });
          }
        }
      })
    ]), x = ls([us(($, B) => {
      const j = mN($, t, [
        "label",
        "field",
        "aria-descriptor"
      ]);
      j.field().each((Y) => {
        const re = Hn(t.prefix);
        j.label().each((le) => {
          kn(le.element, "for", re), kn(Y.element, "id", re);
        }), j["aria-descriptor"]().each((le) => {
          const pe = Hn(t.prefix);
          kn(le.element, "id", pe), kn(Y.element, "aria-describedby", pe);
        });
      });
    })]), k = {
      getField: ($) => Fs($, t, "field"),
      getLabel: ($) => Fs($, t, "label")
    };
    return {
      uid: t.uid,
      dom: t.dom,
      components: a,
      behaviours: y,
      events: x,
      apis: k
    };
  }, ps = ql({
    name: "FormField",
    configFields: JK(),
    partFields: eY(),
    factory: tY,
    apis: {
      getField: (t, a) => t.getField(a),
      getLabel: (t, a) => t.getLabel(a)
    }
  });
  var BR = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    exhibit: (t, a) => pu({
      attributes: Xn([{
        key: a.tabAttr,
        value: "true"
      }])
    })
  }), nY = [lt("tabAttr", "data-alloy-tabstop")];
  const Ea = Zi({
    fields: nY,
    name: "tabstopping",
    active: BR
  });
  var rY = tinymce.util.Tools.resolve("tinymce.html.Entities");
  const IO = (t, a, u, p) => {
    const y = sY(t, a, u, p);
    return ps.sketch(y);
  }, oY = (t, a) => IO(t, a, [], []), sY = (t, a, u, p) => ({
    dom: MO(u),
    components: t.toArray().concat([a]),
    fieldBehaviours: mn(p)
  }), Bce = () => MO([]), MO = (t) => ({
    tag: "div",
    classes: ["tox-form__group"].concat(t)
  }), yh = (t, a) => ps.parts.label({
    dom: {
      tag: "label",
      classes: ["tox-label"]
    },
    components: [Ma(a.translate(t))]
  }), Bf = Hn("form-component-change"), wT = Hn("form-close"), oS = Hn("form-cancel"), Xb = Hn("form-action"), FO = Hn("form-submit"), KF = Hn("form-block"), YF = Hn("form-unblock"), PH = Hn("form-tabchange"), DH = Hn("form-resize"), aY = (t, a, u) => {
    const p = t.label.map((pe) => yh(pe, a)), y = a.icons(), x = (pe) => {
      var _e;
      return (_e = y[pe]) !== null && _e !== void 0 ? _e : pe;
    }, k = (pe) => (_e, ze) => {
      fm(ze.event.target, "[data-collection-item-value]").each((ft) => {
        pe(_e, ze, ft, ca(ft, "data-collection-item-value"));
      });
    }, $ = (pe, _e) => {
      const ze = He(_e, (Ze) => {
        const mt = Mf.translate(Ze.text), jt = t.columns === 1 ? `<div class="tox-collection__item-label">${mt}</div>` : "", Dt = `<div class="tox-collection__item-icon">${x(Ze.icon)}</div>`, Nt = {
          _: " ",
          " - ": " ",
          "-": " "
        }, hn = mt.replace(/\_| \- |\-/g, (zr) => Nt[zr]);
        return `<div class="tox-collection__item${a.isDisabled() ? " tox-collection__item--state-disabled" : ""}" tabindex="-1" data-collection-item-value="${rY.encodeAllRaw(Ze.value)}" title="${hn}" aria-label="${hn}">${Dt}${jt}</div>`;
      }), ft = t.columns !== "auto" && t.columns > 1 ? cn(ze, t.columns) : [ze], Xe = He(ft, (Ze) => `<div class="tox-collection__group">${Ze.join("")}</div>`);
      Kp(pe.element, Xe.join(""));
    }, B = k((pe, _e, ze, ft) => {
      _e.stop(), a.isDisabled() || nr(pe, Xb, {
        name: t.name,
        value: ft
      });
    }), j = [
      Pt(yf(), k((pe, _e, ze) => {
        Fa(ze);
      })),
      Pt(um(), B),
      Pt(wf(), B),
      Pt(oa(), k((pe, _e, ze) => {
        qa(pe.element, "." + Y0).each((ft) => {
          ua(ft, Y0);
        }), ja(ze, Y0);
      })),
      Pt(fu(), k((pe) => {
        qa(pe.element, "." + Y0).each((_e) => {
          ua(_e, Y0);
        });
      })),
      Ul(k((pe, _e, ze, ft) => {
        nr(pe, Xb, {
          name: t.name,
          value: ft
        });
      }))
    ], Y = (pe, _e) => He(Ki(pe.element, ".tox-collection__item"), _e), re = ps.parts.field({
      dom: {
        tag: "div",
        classes: ["tox-collection"].concat(t.columns !== 1 ? ["tox-collection--grid"] : ["tox-collection--list"])
      },
      components: [],
      factory: { sketch: Te },
      behaviours: mn([
        yr.config({
          disabled: a.isDisabled,
          onDisabled: (pe) => {
            Y(pe, (_e) => {
              ja(_e, "tox-collection__item--state-disabled"), kn(_e, "aria-disabled", !0);
            });
          },
          onEnabled: (pe) => {
            Y(pe, (_e) => {
              ua(_e, "tox-collection__item--state-disabled"), vs(_e, "aria-disabled");
            });
          }
        }),
        Bc(),
        $r.config({}),
        Pn.config({
          store: {
            mode: "memory",
            initialValue: u.getOr([])
          },
          onSetValue: (pe, _e) => {
            $(pe, _e), t.columns === "auto" && EO(pe, 5, "tox-collection__item").each(({ numRows: ze, numColumns: ft }) => {
              ar.setGridSize(pe, ze, ft);
            }), Jr(pe, DH);
          }
        }),
        Ea.config({}),
        ar.config(oK(t.columns, "normal")),
        Hr("collection-events", j)
      ]),
      eventOrder: {
        [Lu()]: [
          "disabling",
          "alloy.base.behaviour",
          "collection-events"
        ]
      }
    });
    return IO(p, re, ["tox-form__group--collection"], []);
  }, iY = [
    "input",
    "textarea"
  ], $H = (t) => {
    const a = kc(t);
    return vt(iY, a);
  }, IH = (t, a) => {
    const u = a.getRoot(t).getOr(t.element);
    ua(u, a.invalidClass), a.notify.each((p) => {
      $H(t.element) && kn(t.element, "aria-invalid", !1), p.getContainer(t).each((y) => {
        Kp(y, p.validHtml);
      }), p.onValid(t);
    });
  }, QF = (t, a, u, p) => {
    const y = a.getRoot(t).getOr(t.element);
    ja(y, a.invalidClass), a.notify.each((x) => {
      $H(t.element) && kn(t.element, "aria-invalid", !0), x.getContainer(t).each((k) => {
        Kp(k, p);
      }), x.onInvalid(t, p);
    });
  }, PE = (t, a, u) => a.validator.fold(() => wu.pure(Rr.value(!0)), (p) => p.validate(t)), f1 = (t, a, u) => (a.notify.each((p) => {
    p.onValidate(t);
  }), PE(t, a).map((p) => t.getSystem().isConnected() ? p.fold((y) => (QF(t, a, u, y), Rr.error(y)), (y) => (IH(t, a), Rr.value(y))) : Rr.error("No longer in system")));
  var MH = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    markValid: IH,
    markInvalid: QF,
    query: PE,
    run: f1,
    isInvalid: (t, a) => {
      const u = a.getRoot(t).getOr(t.element);
      return Ti(u, a.invalidClass);
    }
  }), HR = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: (t, a) => t.validator.map((u) => ls([Pt(u.onEvent, (p) => {
      f1(p, t, a).get(Te);
    })].concat(u.validateOnLoad ? [us((p) => {
      f1(p, t, a).get(G);
    })] : []))).getOr({})
  }), lY = [
    Mt("invalidClass"),
    lt("getRoot", z.none),
    nl("notify", [
      lt("aria", "alert"),
      lt("getContainer", z.none),
      lt("validHtml", ""),
      po("onValid"),
      po("onInvalid"),
      po("onValidate")
    ]),
    nl("validator", [
      Mt("validate"),
      lt("onEvent", "input"),
      lt("validateOnLoad", !0)
    ])
  ];
  const cp = Zi({
    fields: lY,
    name: "invalidating",
    active: HR,
    apis: MH,
    extra: {
      validation: (t) => (a) => {
        const u = Pn.getValue(a);
        return wu.pure(t(u));
      }
    }
  });
  var uY = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: () => ls([j1(zp(), Lt)]),
    exhibit: () => pu({
      styles: {
        "-webkit-user-select": "none",
        "user-select": "none",
        "-ms-user-select": "none",
        "-moz-user-select": "-moz-none"
      },
      attributes: { unselectable: "on" }
    })
  });
  const LO = Zi({
    fields: [],
    name: "unselecting",
    active: uY
  }), dY = (t, a) => bh.sketch({
    dom: t.dom,
    components: t.components,
    toggleClass: "mce-active",
    dropdownBehaviours: mn([
      ip.button(a.providers.isDisabled),
      Bc(),
      LO.config({}),
      Ea.config({})
    ]),
    layouts: t.layouts,
    sandboxClasses: ["tox-dialog__popups"],
    lazySink: a.getSink,
    fetch: (u) => wu.nu((p) => t.fetch(p)).map((p) => z.from(FR(Vo(MF(Hn("menu-value"), p, (y) => {
      t.onItemAction(u, y);
    }, t.columns, t.presets, Cv.CLOSE_ON_EXECUTE, sn, a.providers), { movement: DR(t.columns, t.presets) })))),
    parts: { menu: pT(!1, 1, t.presets) }
  }), FH = Hn("color-input-change"), LH = Hn("color-swatch-change"), BO = Hn("color-picker-cancel"), fY = (t, a, u, p) => {
    const y = ps.parts.field({
      factory: TE,
      inputClasses: ["tox-textfield"],
      data: p,
      onSetValue: (j) => cp.run(j).get(G),
      inputBehaviours: mn([
        yr.config({ disabled: a.providers.isDisabled }),
        Bc(),
        Ea.config({}),
        cp.config({
          invalidClass: "tox-textbox-field-invalid",
          getRoot: (j) => $l(j.element),
          notify: {
            onValid: (j) => {
              const Y = Pn.getValue(j);
              nr(j, FH, { color: Y });
            }
          },
          validator: {
            validateOnLoad: !1,
            validate: (j) => {
              const Y = Pn.getValue(j);
              if (Y.length === 0)
                return wu.pure(Rr.value(!0));
              {
                const re = nt.fromTag("span");
                Sr(re, "background-color", Y);
                const le = Ta(re, "background-color").fold(() => Rr.error("blah"), (pe) => Rr.value(Y));
                return wu.pure(le);
              }
            }
          }
        })
      ]),
      selectOnFocus: !1
    }), x = t.label.map((j) => yh(j, a.providers)), k = (j, Y) => {
      nr(j, LH, { value: Y });
    }, $ = (j, Y) => {
      B.getOpt(j).each((re) => {
        Y === "custom" ? u.colorPicker((le) => {
          le.fold(() => Jr(re, BO), (pe) => {
            k(re, pe), _F(t.storageKey, pe);
          });
        }, "#ffffff") : Y === "remove" ? k(re, "") : k(re, Y);
      });
    }, B = ms(dY({
      dom: {
        tag: "span",
        attributes: { "aria-label": a.providers.translate("Color swatch") }
      },
      layouts: {
        onRtl: () => [
          Mc,
          Wi,
          Os
        ],
        onLtr: () => [
          Wi,
          Mc,
          Os
        ]
      },
      components: [],
      fetch: oH(u.getColors(t.storageKey), t.storageKey, u.hasCustomColors()),
      columns: u.getColorCols(t.storageKey),
      presets: "color",
      onItemAction: $
    }, a));
    return ps.sketch({
      dom: {
        tag: "div",
        classes: ["tox-form__group"]
      },
      components: x.toArray().concat([{
        dom: {
          tag: "div",
          classes: ["tox-color-input"]
        },
        components: [
          y,
          B.asSpec()
        ]
      }]),
      fieldBehaviours: mn([Hr("form-field-events", [
        Pt(FH, (j, Y) => {
          B.getOpt(j).each((re) => {
            Sr(re.element, "background-color", Y.event.color);
          }), nr(j, Bf, { name: t.name });
        }),
        Pt(LH, (j, Y) => {
          ps.getField(j).each((re) => {
            Pn.setValue(re, Y.event.value), ho.getCurrent(j).each(Er.focus);
          });
        }),
        Pt(BO, (j, Y) => {
          ps.getField(j).each((re) => {
            ho.getCurrent(j).each(Er.focus);
          });
        })
      ])])
    });
  }, XF = vd({
    schema: [Mt("dom")],
    name: "label"
  }), sS = (t) => vd({
    name: "" + t + "-edge",
    overrides: (a) => a.model.manager.edgeActions[t].fold(() => ({}), (p) => ({
      events: ls([
        Cf(du(), (y, x, k) => p(y, k), [a]),
        Cf(oo(), (y, x, k) => p(y, k), [a]),
        Cf(ci(), (y, x, k) => {
          k.mouseIsDown.get() && p(y, k);
        }, [a])
      ])
    }))
  }), mY = sS("top-left"), pY = sS("top"), BH = sS("top-right"), hY = sS("right"), gY = sS("bottom-right"), vY = sS("bottom"), HH = sS("bottom-left"), bY = sS("left"), yY = jl({
    name: "thumb",
    defaults: q({ dom: { styles: { position: "absolute" } } }),
    overrides: (t) => ({
      events: ls([
        Kg(du(), t, "spectrum"),
        Kg(jh(), t, "spectrum"),
        Kg(Lp(), t, "spectrum"),
        Kg(oo(), t, "spectrum"),
        Kg(ci(), t, "spectrum"),
        Kg(tb(), t, "spectrum")
      ])
    })
  }), VR = (t) => Sv(t.event), SY = jl({
    schema: [Ts("mouseIsDown", () => sr(!1))],
    name: "spectrum",
    overrides: (t) => {
      const u = t.model.manager, p = (y, x) => u.getValueFromEvent(x).map((k) => u.setValueFrom(y, t, k));
      return {
        behaviours: mn([
          ar.config({
            mode: "special",
            onLeft: (y, x) => u.onLeft(y, t, VR(x)),
            onRight: (y, x) => u.onRight(y, t, VR(x)),
            onUp: (y, x) => u.onUp(y, t, VR(x)),
            onDown: (y, x) => u.onDown(y, t, VR(x))
          }),
          Ea.config({}),
          Er.config({})
        ]),
        events: ls([
          Pt(du(), p),
          Pt(jh(), p),
          Pt(oo(), p),
          Pt(ci(), (y, x) => {
            t.mouseIsDown.get() && p(y, x);
          })
        ])
      };
    }
  });
  var wY = [
    XF,
    bY,
    hY,
    pY,
    vY,
    mY,
    BH,
    HH,
    gY,
    yY,
    SY
  ];
  const ET = q("slider.change.value"), CY = (t) => t.type.indexOf("touch") !== -1, JF = (t) => {
    const a = t.event.raw;
    if (CY(a)) {
      const u = a;
      return u.touches !== void 0 && u.touches.length === 1 ? z.some(u.touches[0]).map((p) => Oo(p.clientX, p.clientY)) : z.none();
    } else {
      const u = a;
      return u.clientX !== void 0 ? z.some(u).map((p) => Oo(p.clientX, p.clientY)) : z.none();
    }
  }, xY = "top", TY = "right", _Y = "bottom", zH = "left", gg = (t) => t.model.minX, DE = (t) => t.model.minY, UR = (t) => t.model.minX - 1, WR = (t) => t.model.minY - 1, Jb = (t) => t.model.maxX, qu = (t) => t.model.maxY, CT = (t) => t.model.maxX + 1, HO = (t) => t.model.maxY + 1, VH = (t, a, u) => a(t) - u(t), e3 = (t) => VH(t, Jb, gg), t3 = (t) => VH(t, qu, DE), UH = (t) => e3(t) / 2, n3 = (t) => t3(t) / 2, $E = (t, a) => a ? t.stepSize * t.speedMultiplier : t.stepSize, WH = (t) => t.snapToGrid, jH = (t) => t.snapStart, r3 = (t) => t.rounded, jR = (t, a) => t[a + "-edge"] !== void 0, o3 = (t) => jR(t, zH), s3 = (t) => jR(t, TY), a3 = (t) => jR(t, xY), qH = (t) => jR(t, _Y), m1 = (t) => t.model.value.get(), aS = (t, a) => ({
    x: t,
    y: a
  }), vg = (t, a) => {
    nr(t, ET(), { value: a });
  }, OY = (t, a) => {
    vg(t, aS(UR(a), WR(a)));
  }, AY = (t, a) => {
    vg(t, WR(a));
  }, i3 = (t, a) => {
    vg(t, aS(UH(a), WR(a)));
  }, kY = (t, a) => {
    vg(t, aS(CT(a), WR(a)));
  }, GH = (t, a) => {
    vg(t, CT(a));
  }, NY = (t, a) => {
    vg(t, aS(CT(a), n3(a)));
  }, RY = (t, a) => {
    vg(t, aS(CT(a), HO(a)));
  }, PY = (t, a) => {
    vg(t, HO(a));
  }, DY = (t, a) => {
    vg(t, aS(UH(a), HO(a)));
  }, $Y = (t, a) => {
    vg(t, aS(UR(a), HO(a)));
  }, IY = (t, a) => {
    vg(t, UR(a));
  }, MY = (t, a) => {
    vg(t, aS(UR(a), n3(a)));
  }, qR = (t, a, u, p) => t < a ? t : t > u ? u : t === a ? a - 1 : Math.max(a, t - p), GR = (t, a, u, p) => t > u ? t : t < a ? a : t === u ? u + 1 : Math.min(u, t + p), ZH = (t, a, u) => Math.max(a, Math.min(u, t)), FY = (t, a, u, p, y) => y.fold(() => {
    const x = t - a, k = Math.round(x / p) * p;
    return ZH(a + k, a - 1, u + 1);
  }, (x) => {
    const k = (t - x) % p, $ = Math.round(k / p), B = Math.floor((t - x) / p), j = Math.floor((u - x) / p), Y = Math.min(j, B + $), re = x + Y * p;
    return Math.max(x, re);
  }), LY = (t, a, u) => Math.min(u, Math.max(t, a)) - a, KH = (t) => {
    const { min: a, max: u, range: p, value: y, step: x, snap: k, snapStart: $, rounded: B, hasMinEdge: j, hasMaxEdge: Y, minBound: re, maxBound: le, screenRange: pe } = t, _e = j ? a - 1 : a, ze = Y ? u + 1 : u;
    if (y < re)
      return _e;
    if (y > le)
      return ze;
    {
      const ft = LY(y, re, le), Xe = ZH(ft / pe * p + a, _e, ze);
      return k && Xe >= a && Xe <= u ? FY(Xe, a, u, x, $) : B ? Math.round(Xe) : Xe;
    }
  }, YH = (t) => {
    const { min: a, max: u, range: p, value: y, hasMinEdge: x, hasMaxEdge: k, maxBound: $, maxOffset: B, centerMinEdge: j, centerMaxEdge: Y } = t;
    return y < a ? x ? 0 : j : y > u ? k ? $ : Y : (y - a) / p * B;
  }, c3 = "top", l3 = "right", u3 = "bottom", ZR = "left", d3 = "width", BY = "height", _v = (t) => t.element.dom.getBoundingClientRect(), bg = (t, a) => t[a], KR = (t) => {
    const a = _v(t);
    return bg(a, ZR);
  }, QH = (t) => {
    const a = _v(t);
    return bg(a, l3);
  }, YR = (t) => {
    const a = _v(t);
    return bg(a, c3);
  }, QR = (t) => {
    const a = _v(t);
    return bg(a, u3);
  }, ey = (t) => {
    const a = _v(t);
    return bg(a, d3);
  }, XH = (t) => {
    const a = _v(t);
    return bg(a, BY);
  }, xT = (t, a, u) => (t + a) / 2 - u, JH = (t, a) => {
    const u = _v(t), p = _v(a), y = bg(u, ZR), x = bg(u, l3), k = bg(p, ZR);
    return xT(y, x, k);
  }, XR = (t, a) => {
    const u = _v(t), p = _v(a), y = bg(u, c3), x = bg(u, u3), k = bg(p, c3);
    return xT(y, x, k);
  }, JR = (t, a) => {
    nr(t, ET(), { value: a });
  }, f3 = (t, a, u) => {
    const p = {
      min: gg(a),
      max: Jb(a),
      range: e3(a),
      value: u,
      step: $E(a),
      snap: WH(a),
      snapStart: jH(a),
      rounded: r3(a),
      hasMinEdge: o3(a),
      hasMaxEdge: s3(a),
      minBound: KR(t),
      maxBound: QH(t),
      screenRange: ey(t)
    };
    return KH(p);
  }, HY = (t, a, u) => {
    const p = f3(t, a, u);
    return JR(t, p), p;
  }, e7 = (t, a) => {
    const u = gg(a);
    JR(t, u);
  }, zY = (t, a) => {
    const u = Jb(a);
    JR(t, u);
  }, m3 = (t, a, u, p) => {
    const x = (t > 0 ? GR : qR)(m1(u), gg(u), Jb(u), $E(u, p));
    return JR(a, x), z.some(x);
  }, eP = (t) => (a, u, p) => m3(t, a, u, p).map(Lt), p3 = (t) => JF(t).map((u) => u.left), VY = (t, a, u, p, y) => {
    const k = ey(t), $ = p.bind((Y) => z.some(JH(Y, t))).getOr(0), B = y.bind((Y) => z.some(JH(Y, t))).getOr(k), j = {
      min: gg(a),
      max: Jb(a),
      range: e3(a),
      value: u,
      hasMinEdge: o3(a),
      hasMaxEdge: s3(a),
      minBound: KR(t),
      minOffset: 0,
      maxBound: QH(t),
      maxOffset: k,
      centerMinEdge: $,
      centerMaxEdge: B
    };
    return YH(j);
  }, Hf = (t, a, u, p, y, x) => {
    const k = VY(a, x, u, p, y);
    return KR(a) - KR(t) + k;
  }, UY = (t, a, u, p) => {
    const y = m1(u), x = Hf(t, p.getSpectrum(t), y, p.getLeftEdge(t), p.getRightEdge(t), u), k = Oa(a.element) / 2;
    Sr(a.element, "left", x - k + "px");
  }, WY = eP(-1), t7 = eP(1), n7 = z.none, jY = z.none, qY = {
    "top-left": z.none(),
    top: z.none(),
    "top-right": z.none(),
    right: z.some(GH),
    "bottom-right": z.none(),
    bottom: z.none(),
    "bottom-left": z.none(),
    left: z.some(IY)
  };
  var GY = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    setValueFrom: HY,
    setToMin: e7,
    setToMax: zY,
    findValueOfOffset: f3,
    getValueFromEvent: p3,
    findPositionOfValue: Hf,
    setPositionFromValue: UY,
    onLeft: WY,
    onRight: t7,
    onUp: n7,
    onDown: jY,
    edgeActions: qY
  });
  const tP = (t, a) => {
    nr(t, ET(), { value: a });
  }, h3 = (t, a, u) => {
    const p = {
      min: DE(a),
      max: qu(a),
      range: t3(a),
      value: u,
      step: $E(a),
      snap: WH(a),
      snapStart: jH(a),
      rounded: r3(a),
      hasMinEdge: a3(a),
      hasMaxEdge: qH(a),
      minBound: YR(t),
      maxBound: QR(t),
      screenRange: XH(t)
    };
    return KH(p);
  }, ZY = (t, a, u) => {
    const p = h3(t, a, u);
    return tP(t, p), p;
  }, KY = (t, a) => {
    const u = DE(a);
    tP(t, u);
  }, r7 = (t, a) => {
    const u = qu(a);
    tP(t, u);
  }, YY = (t, a, u, p) => {
    const x = (t > 0 ? GR : qR)(m1(u), DE(u), qu(u), $E(u, p));
    return tP(a, x), z.some(x);
  }, o7 = (t) => (a, u, p) => YY(t, a, u, p).map(Lt), QY = (t) => JF(t).map((u) => u.top), s7 = (t, a, u, p, y) => {
    const k = XH(t), $ = p.bind((Y) => z.some(XR(Y, t))).getOr(0), B = y.bind((Y) => z.some(XR(Y, t))).getOr(k), j = {
      min: DE(a),
      max: qu(a),
      range: t3(a),
      value: u,
      hasMinEdge: a3(a),
      hasMaxEdge: qH(a),
      minBound: YR(t),
      minOffset: 0,
      maxBound: QR(t),
      maxOffset: k,
      centerMinEdge: $,
      centerMaxEdge: B
    };
    return YH(j);
  }, zO = (t, a, u, p, y, x) => {
    const k = s7(a, x, u, p, y);
    return YR(a) - YR(t) + k;
  }, XY = (t, a, u, p) => {
    const y = m1(u), x = zO(t, p.getSpectrum(t), y, p.getTopEdge(t), p.getBottomEdge(t), u), k = Ds(a.element) / 2;
    Sr(a.element, "top", x - k + "px");
  }, g3 = z.none, TT = z.none, a7 = o7(-1), i7 = o7(1), c7 = {
    "top-left": z.none(),
    top: z.some(AY),
    "top-right": z.none(),
    right: z.none(),
    "bottom-right": z.none(),
    bottom: z.some(PY),
    "bottom-left": z.none(),
    left: z.none()
  };
  var JY = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    setValueFrom: ZY,
    setToMin: KY,
    setToMax: r7,
    findValueOfOffset: h3,
    getValueFromEvent: QY,
    findPositionOfValue: zO,
    setPositionFromValue: XY,
    onLeft: g3,
    onRight: TT,
    onUp: a7,
    onDown: i7,
    edgeActions: c7
  });
  const nP = (t, a) => {
    nr(t, ET(), { value: a });
  }, IE = (t, a) => ({
    x: t,
    y: a
  }), eQ = (t, a, u) => {
    const p = f3(t, a, u.left), y = h3(t, a, u.top), x = IE(p, y);
    return nP(t, x), x;
  }, tQ = (t, a, u, p, y) => {
    const x = t > 0 ? GR : qR, k = a ? m1(p).x : x(m1(p).x, gg(p), Jb(p), $E(p, y)), $ = a ? x(m1(p).y, DE(p), qu(p), $E(p, y)) : m1(p).y;
    return nP(u, IE(k, $)), z.some(k);
  }, VO = (t, a) => (u, p, y) => tQ(t, a, u, p, y).map(Lt), l7 = (t, a) => {
    const u = gg(a), p = DE(a);
    nP(t, IE(u, p));
  }, v3 = (t, a) => {
    const u = Jb(a), p = qu(a);
    nP(t, IE(u, p));
  }, u7 = (t) => JF(t), Xd = (t, a, u, p) => {
    const y = m1(u), x = Hf(t, p.getSpectrum(t), y.x, p.getLeftEdge(t), p.getRightEdge(t), u), k = zO(t, p.getSpectrum(t), y.y, p.getTopEdge(t), p.getBottomEdge(t), u), $ = Oa(a.element) / 2, B = Ds(a.element) / 2;
    Sr(a.element, "left", x - $ + "px"), Sr(a.element, "top", k - B + "px");
  }, d7 = VO(-1, !1), nQ = VO(1, !1), rQ = VO(-1, !0), f7 = VO(1, !0), oQ = {
    "top-left": z.some(OY),
    top: z.some(i3),
    "top-right": z.some(kY),
    right: z.some(NY),
    "bottom-right": z.some(RY),
    bottom: z.some(DY),
    "bottom-left": z.some($Y),
    left: z.some(MY)
  };
  var sQ = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    setValueFrom: eQ,
    setToMin: l7,
    setToMax: v3,
    getValueFromEvent: u7,
    setPositionFromValue: Xd,
    onLeft: d7,
    onRight: nQ,
    onUp: rQ,
    onDown: f7,
    edgeActions: oQ
  });
  const aQ = [
    lt("stepSize", 1),
    lt("speedMultiplier", 10),
    lt("onChange", G),
    lt("onChoose", G),
    lt("onInit", G),
    lt("onDragStart", G),
    lt("onDragEnd", G),
    lt("snapToGrid", !1),
    lt("rounded", !0),
    Fo("snapStart"),
    $c("model", ro("mode", {
      x: [
        lt("minX", 0),
        lt("maxX", 100),
        Ts("value", (t) => sr(t.mode.minX)),
        Mt("getInitialValue"),
        ds("manager", GY)
      ],
      y: [
        lt("minY", 0),
        lt("maxY", 100),
        Ts("value", (t) => sr(t.mode.minY)),
        Mt("getInitialValue"),
        ds("manager", JY)
      ],
      xy: [
        lt("minX", 0),
        lt("maxX", 100),
        lt("minY", 0),
        lt("maxY", 100),
        Ts("value", (t) => sr({
          x: t.mode.minX,
          y: t.mode.minY
        })),
        Mt("getInitialValue"),
        ds("manager", sQ)
      ]
    })),
    ac("sliderBehaviours", [
      ar,
      Pn
    ]),
    Ts("mouseIsDown", () => sr(!1))
  ], Zl = ql({
    name: "Slider",
    configFields: aQ,
    partFields: wY,
    factory: (t, a, u, p) => {
      const y = (Dt) => gv(Dt, t, "thumb"), x = (Dt) => gv(Dt, t, "spectrum"), k = (Dt) => Fs(Dt, t, "left-edge"), $ = (Dt) => Fs(Dt, t, "right-edge"), B = (Dt) => Fs(Dt, t, "top-edge"), j = (Dt) => Fs(Dt, t, "bottom-edge"), Y = t.model, re = Y.manager, le = (Dt, Nt) => {
        re.setPositionFromValue(Dt, Nt, t, {
          getLeftEdge: k,
          getRightEdge: $,
          getTopEdge: B,
          getBottomEdge: j,
          getSpectrum: x
        });
      }, pe = (Dt, Nt) => {
        Y.value.set(Nt);
        const hn = y(Dt);
        le(Dt, hn);
      }, _e = (Dt, Nt) => {
        pe(Dt, Nt);
        const hn = y(Dt);
        return t.onChange(Dt, hn, Nt), z.some(!0);
      }, ze = (Dt) => {
        re.setToMin(Dt, t);
      }, ft = (Dt) => {
        re.setToMax(Dt, t);
      }, Xe = (Dt) => {
        const Nt = () => {
          Fs(Dt, t, "thumb").each((En) => {
            const zr = Y.value.get();
            t.onChoose(Dt, En, zr);
          });
        }, hn = t.mouseIsDown.get();
        t.mouseIsDown.set(!1), hn && Nt();
      }, Ze = (Dt, Nt) => {
        Nt.stop(), t.mouseIsDown.set(!0), t.onDragStart(Dt, y(Dt));
      }, mt = (Dt, Nt) => {
        Nt.stop(), t.onDragEnd(Dt, y(Dt)), Xe(Dt);
      }, jt = (Dt) => {
        Fs(Dt, t, "spectrum").map(ar.focusIn);
      };
      return {
        uid: t.uid,
        dom: t.dom,
        components: a,
        behaviours: _i(t.sliderBehaviours, [
          ar.config({
            mode: "special",
            focusIn: jt
          }),
          Pn.config({
            store: {
              mode: "manual",
              getValue: (Dt) => Y.value.get(),
              setValue: pe
            }
          }),
          vu.config({ channels: { [R_()]: { onReceive: Xe } } })
        ]),
        events: ls([
          Pt(ET(), (Dt, Nt) => {
            _e(Dt, Nt.event.value);
          }),
          us((Dt, Nt) => {
            const hn = Y.getInitialValue();
            Y.value.set(hn);
            const En = y(Dt);
            le(Dt, En);
            const zr = x(Dt);
            t.onInit(Dt, En, zr, Y.value.get());
          }),
          Pt(du(), Ze),
          Pt(Lp(), mt),
          Pt(oo(), (Dt, Nt) => {
            jt(Dt), Ze(Dt, Nt);
          }),
          Pt(tb(), mt)
        ]),
        apis: {
          resetToMin: ze,
          resetToMax: ft,
          setValue: pe,
          refresh: le
        },
        domModification: { styles: { position: "relative" } }
      };
    },
    apis: {
      setValue: (t, a, u) => {
        t.setValue(a, u);
      },
      resetToMin: (t, a) => {
        t.resetToMin(a);
      },
      resetToMax: (t, a) => {
        t.resetToMax(a);
      },
      refresh: (t, a) => {
        t.refresh(a);
      }
    }
  }), UO = Hn("rgb-hex-update"), b3 = Hn("slider-update"), WO = Hn("palette-update"), y3 = (t, a) => {
    const u = Zl.parts.spectrum({
      dom: {
        tag: "div",
        classes: [a("hue-slider-spectrum")],
        attributes: { role: "presentation" }
      }
    }), p = Zl.parts.thumb({
      dom: {
        tag: "div",
        classes: [a("hue-slider-thumb")],
        attributes: { role: "presentation" }
      }
    });
    return Zl.sketch({
      dom: {
        tag: "div",
        classes: [a("hue-slider")],
        attributes: {
          role: "slider",
          "aria-valuemin": 0,
          "aria-valuemax": 360,
          "aria-valuenow": 120
        }
      },
      rounded: !1,
      model: {
        mode: "y",
        getInitialValue: q(0)
      },
      components: [
        u,
        p
      ],
      sliderBehaviours: mn([Er.config({})]),
      onChange: (y, x, k) => {
        kn(y.element, "aria-valuenow", Math.floor(360 - k * 3.6)), nr(y, b3, { value: k });
      }
    });
  }, m7 = "form", cQ = [ac("formBehaviours", [Pn])], p7 = (t) => "<alloy.field." + t + ">", lQ = (t) => {
    const a = (() => {
      const x = [];
      return {
        field: ($, B) => (x.push($), L_(m7, p7($), B)),
        record: q(x)
      };
    })(), u = t(a), p = a.record(), y = He(p, (x) => jl({
      name: x,
      pname: p7(x)
    }));
    return j_(m7, cQ, y, dQ, u);
  }, uQ = (t, a) => t.fold(() => Rr.error(a), Rr.value), dQ = (t, a) => ({
    uid: t.uid,
    dom: t.dom,
    components: a,
    behaviours: _i(t.formBehaviours, [Pn.config({
      store: {
        mode: "manual",
        getValue: (u) => {
          const p = H_(u, t);
          return uo(p, (y, x) => y().bind((k) => {
            const $ = ho.getCurrent(k);
            return uQ($, new Error(`Cannot find a current component to extract the value from for form part '${x}': ` + Wm(k.element)));
          }).map(Pn.getValue));
        },
        setValue: (u, p) => {
          Eo(p, (y, x) => {
            Fs(u, t, x).each((k) => {
              ho.getCurrent(k).each(($) => {
                Pn.setValue($, y);
              });
            });
          });
        }
      }
    })]),
    apis: {
      getField: (u, p) => Fs(u, t, p).bind(ho.getCurrent)
    }
  }), _T = {
    getField: Xp((t, a, u) => t.getField(a, u)),
    sketch: lQ
  }, S3 = Hn("valid-input"), h7 = Hn("invalid-input"), Ov = Hn("validating-input"), OT = "colorcustom.rgb.", fQ = (t, a, u, p) => {
    const y = (le, pe) => cp.config({
      invalidClass: a("invalid"),
      notify: {
        onValidate: (_e) => {
          nr(_e, Ov, { type: le });
        },
        onValid: (_e) => {
          nr(_e, S3, {
            type: le,
            value: Pn.getValue(_e)
          });
        },
        onInvalid: (_e) => {
          nr(_e, h7, {
            type: le,
            value: Pn.getValue(_e)
          });
        }
      },
      validator: {
        validate: (_e) => {
          const ze = Pn.getValue(_e), ft = pe(ze) ? Rr.value(!0) : Rr.error(t("aria.input.invalid"));
          return wu.pure(ft);
        },
        validateOnLoad: !1
      }
    }), x = (le, pe, _e, ze, ft) => {
      const Xe = t(OT + "range"), Ze = ps.parts.label({
        dom: {
          tag: "label",
          attributes: { "aria-label": ze }
        },
        components: [Ma(_e)]
      }), mt = ps.parts.field({
        data: ft,
        factory: TE,
        inputAttributes: {
          type: "text",
          ...pe === "hex" ? { "aria-live": "polite" } : {}
        },
        inputClasses: [a("textfield")],
        inputBehaviours: mn([
          y(pe, le),
          Ea.config({})
        ]),
        onSetValue: (hn) => {
          cp.isInvalid(hn) && cp.run(hn).get(G);
        }
      }), jt = [
        Ze,
        mt
      ], Dt = pe !== "hex" ? [ps.parts["aria-descriptor"]({ text: Xe })] : [], Nt = jt.concat(Dt);
      return {
        dom: {
          tag: "div",
          attributes: { role: "presentation" }
        },
        components: Nt
      };
    }, k = (le, pe) => {
      const _e = u1(pe);
      return _T.getField(le, "hex").each((ze) => {
        Er.isFocused(ze) || Pn.setValue(le, { hex: _e.value });
      }), _e;
    }, $ = (le, pe) => {
      const _e = pe.red, ze = pe.green, ft = pe.blue;
      Pn.setValue(le, {
        red: _e,
        green: ze,
        blue: ft
      });
    }, B = ms({
      dom: {
        tag: "div",
        classes: [a("rgba-preview")],
        styles: { "background-color": "white" },
        attributes: { role: "presentation" }
      }
    }), j = (le, pe) => {
      B.getOpt(le).each((_e) => {
        Sr(_e.element, "background-color", "#" + pe.value);
      });
    };
    return Yd({
      factory: () => {
        const le = {
          red: sr(z.some(255)),
          green: sr(z.some(255)),
          blue: sr(z.some(255)),
          hex: sr(z.some("ffffff"))
        }, pe = (Cr, ns) => {
          const dr = AO(ns);
          $(Cr, dr), Xe(dr);
        }, _e = (Cr) => le[Cr].get(), ze = (Cr, ns) => {
          le[Cr].set(ns);
        }, ft = () => _e("red").bind((Cr) => _e("green").bind((ns) => _e("blue").map((dr) => eS(Cr, ns, dr, 1)))), Xe = (Cr) => {
          const ns = Cr.red, dr = Cr.green, ko = Cr.blue;
          ze("red", z.some(ns)), ze("green", z.some(dr)), ze("blue", z.some(ko));
        }, Ze = (Cr, ns) => {
          const dr = ns.event;
          dr.type !== "hex" ? ze(dr.type, z.none()) : p(Cr);
        }, mt = (Cr, ns) => {
          u(Cr);
          const dr = $8(ns);
          ze("hex", z.some(dr.value));
          const ko = AO(dr);
          $(Cr, ko), Xe(ko), nr(Cr, UO, { hex: dr }), j(Cr, dr);
        }, jt = (Cr, ns, dr) => {
          const ko = parseInt(dr, 10);
          ze(ns, z.some(ko)), ft().each((Cn) => {
            const Zn = k(Cr, Cn);
            nr(Cr, UO, { hex: Zn }), j(Cr, Zn);
          });
        }, Dt = (Cr) => Cr.type === "hex", Nt = (Cr, ns) => {
          const dr = ns.event;
          Dt(dr) ? mt(Cr, dr.value) : jt(Cr, dr.type, dr.value);
        }, hn = (Cr) => ({
          label: t(OT + Cr + ".label"),
          description: t(OT + Cr + ".description")
        }), En = hn("red"), zr = hn("green"), Yn = hn("blue"), hr = hn("hex");
        return Vo(_T.sketch((Cr) => ({
          dom: {
            tag: "form",
            classes: [a("rgb-form")],
            attributes: { "aria-label": t("aria.color.picker") }
          },
          components: [
            Cr.field("red", ps.sketch(x(bF, "red", En.label, En.description, 255))),
            Cr.field("green", ps.sketch(x(bF, "green", zr.label, zr.description, 255))),
            Cr.field("blue", ps.sketch(x(bF, "blue", Yn.label, Yn.description, 255))),
            Cr.field("hex", ps.sketch(x(vF, "hex", hr.label, hr.description, "ffffff"))),
            B.asSpec()
          ],
          formBehaviours: mn([
            cp.config({ invalidClass: a("form-invalid") }),
            Hr("rgb-form-events", [
              Pt(S3, Nt),
              Pt(h7, Ze),
              Pt(Ov, Ze)
            ])
          ])
        })), {
          apis: {
            updateHex: (Cr, ns) => {
              Pn.setValue(Cr, { hex: ns.value }), pe(Cr, ns), j(Cr, ns);
            }
          }
        });
      },
      name: "RgbForm",
      configFields: [],
      apis: {
        updateHex: (le, pe, _e) => {
          le.updateHex(pe, _e);
        }
      },
      extraApis: {}
    });
  }, mQ = (t, a) => {
    const u = Zl.parts.spectrum({
      dom: {
        tag: "canvas",
        attributes: { role: "presentation" },
        classes: [a("sv-palette-spectrum")]
      }
    }), p = Zl.parts.thumb({
      dom: {
        tag: "div",
        attributes: { role: "presentation" },
        classes: [a("sv-palette-thumb")],
        innerHtml: `<div class=${a("sv-palette-inner-thumb")} role="presentation"></div>`
      }
    }), y = (j, Y) => {
      const { width: re, height: le } = j, pe = j.getContext("2d");
      if (pe === null)
        return;
      pe.fillStyle = Y, pe.fillRect(0, 0, re, le);
      const _e = pe.createLinearGradient(0, 0, re, 0);
      _e.addColorStop(0, "rgba(255,255,255,1)"), _e.addColorStop(1, "rgba(255,255,255,0)"), pe.fillStyle = _e, pe.fillRect(0, 0, re, le);
      const ze = pe.createLinearGradient(0, 0, 0, le);
      ze.addColorStop(0, "rgba(0,0,0,0)"), ze.addColorStop(1, "rgba(0,0,0,1)"), pe.fillStyle = ze, pe.fillRect(0, 0, re, le);
    }, x = (j, Y) => {
      const re = j.components()[0].element.dom, le = NO(Y, 100, 100), pe = U8(le);
      y(re, SF(pe));
    }, k = (j, Y) => {
      const re = AR(AO(Y));
      Zl.setValue(j, {
        x: re.saturation,
        y: 100 - re.value
      }), kn(j.element, "aria-valuetext", t([
        "Saturation {0}%, Brightness {1}%",
        re.saturation,
        re.value
      ]));
    };
    return Yd({
      factory: (j) => {
        const Y = q({
          x: 0,
          y: 0
        }), re = (_e, ze, ft) => {
          he(ft) || kn(_e.element, "aria-valuetext", t([
            "Saturation {0}%, Brightness {1}%",
            Math.floor(ft.x),
            Math.floor(100 - ft.y)
          ])), nr(_e, WO, { value: ft });
        }, le = (_e, ze, ft, Xe) => {
          y(ft.element.dom, SF(vh));
        }, pe = mn([
          ho.config({ find: z.some }),
          Er.config({})
        ]);
        return Zl.sketch({
          dom: {
            tag: "div",
            attributes: {
              role: "slider",
              "aria-valuetext": t([
                "Saturation {0}%, Brightness {1}%",
                0,
                0
              ])
            },
            classes: [a("sv-palette")]
          },
          model: {
            mode: "xy",
            getInitialValue: Y
          },
          rounded: !1,
          components: [
            u,
            p
          ],
          onChange: re,
          onInit: le,
          sliderBehaviours: pe
        });
      },
      name: "SaturationBrightnessPalette",
      configFields: [],
      apis: {
        setHue: (j, Y, re) => {
          x(Y, re);
        },
        setThumb: (j, Y, re) => {
          k(Y, re);
        }
      },
      extraApis: {}
    });
  }, g7 = (t, a) => {
    const u = (y) => {
      const x = fQ(t, a, y.onValidHex, y.onInvalidHex), k = mQ(t, a), $ = (Nt) => (100 - Nt) / 100 * 360, B = (Nt) => 100 - Nt / 360 * 100, j = {
        paletteRgba: sr(vh),
        paletteHue: sr(0)
      }, Y = ms(y3(t, a)), re = ms(k.sketch({})), le = ms(x.sketch({})), pe = (Nt, hn, En) => {
        re.getOpt(Nt).each((zr) => {
          k.setHue(zr, En);
        });
      }, _e = (Nt, hn) => {
        le.getOpt(Nt).each((En) => {
          x.updateHex(En, hn);
        });
      }, ze = (Nt, hn, En) => {
        Y.getOpt(Nt).each((zr) => {
          Zl.setValue(zr, B(En));
        });
      }, ft = (Nt, hn) => {
        re.getOpt(Nt).each((En) => {
          k.setThumb(En, hn);
        });
      }, Xe = (Nt, hn) => {
        const En = AO(Nt);
        j.paletteRgba.set(En), j.paletteHue.set(hn);
      }, Ze = (Nt, hn, En, zr) => {
        Xe(hn, En), ut(zr, (Yn) => {
          Yn(Nt, hn, En);
        });
      }, mt = () => {
        const Nt = [_e];
        return (hn, En) => {
          const zr = En.event.value, Yn = j.paletteHue.get(), hr = NO(Yn, zr.x, 100 - zr.y), Cr = Q8(hr);
          Ze(hn, Cr, Yn, Nt);
        };
      }, jt = () => {
        const Nt = [
          pe,
          _e
        ];
        return (hn, En) => {
          const zr = $(En.event.value), Yn = j.paletteRgba.get(), hr = AR(Yn), Cr = NO(zr, hr.saturation, hr.value), ns = Q8(Cr);
          Ze(hn, ns, zr, Nt);
        };
      }, Dt = () => {
        const Nt = [
          pe,
          ze,
          ft
        ];
        return (hn, En) => {
          const zr = En.event.hex, Yn = GZ(zr);
          Ze(hn, zr, Yn.hue, Nt);
        };
      };
      return {
        uid: y.uid,
        dom: y.dom,
        components: [
          re.asSpec(),
          Y.asSpec(),
          le.asSpec()
        ],
        behaviours: mn([
          Hr("colour-picker-events", [
            Pt(UO, Dt()),
            Pt(WO, mt()),
            Pt(b3, jt())
          ]),
          ho.config({ find: (Nt) => le.getOpt(Nt) }),
          ar.config({ mode: "acyclic" })
        ])
      };
    };
    return Yd({
      name: "ColourPicker",
      configFields: [
        Mt("dom"),
        lt("onValidHex", G),
        lt("onInvalidHex", G)
      ],
      factory: u
    });
  }, zf = {
    self: () => ho.config({ find: z.some }),
    memento: (t) => ho.config({ find: t.getOpt }),
    childAt: (t) => ho.config({ find: (a) => ku(a.element, t).bind((u) => a.getSystem().getByDom(u).toOptional()) })
  }, jO = jn([
    lt("preprocess", Te),
    lt("postprocess", Te)
  ]), b7 = (t, a) => {
    const u = ya("RepresentingConfigs.memento processors", jO, a);
    return Pn.config({
      store: {
        mode: "manual",
        getValue: (p) => {
          const y = t.get(p), x = Pn.getValue(y);
          return u.postprocess(x);
        },
        setValue: (p, y) => {
          const x = u.preprocess(y), k = t.get(p);
          Pn.setValue(k, x);
        }
      }
    });
  }, iS = (t, a, u) => Pn.config({
    store: {
      mode: "manual",
      ...t.map((p) => ({ initialValue: p })).getOr({}),
      getValue: a,
      setValue: u
    }
  }), E3 = (t, a, u) => iS(t, (p) => a(p.element), (p, y) => u(p.element, y)), y7 = (t) => E3(t, lb, Kp), rP = (t) => Pn.config({
    store: {
      mode: "memory",
      initialValue: t
    }
  }), hQ = {
    "colorcustom.rgb.red.label": "R",
    "colorcustom.rgb.red.description": "Red component",
    "colorcustom.rgb.green.label": "G",
    "colorcustom.rgb.green.description": "Green component",
    "colorcustom.rgb.blue.label": "B",
    "colorcustom.rgb.blue.description": "Blue component",
    "colorcustom.rgb.hex.label": "#",
    "colorcustom.rgb.hex.description": "Hex color code",
    "colorcustom.rgb.range": "Range 0 to 255",
    "aria.color.picker": "Color Picker",
    "aria.input.invalid": "Invalid input"
  }, gQ = (t) => (a) => g(a) ? t.translate(hQ[a]) : t.translate(a), vQ = (t, a, u) => {
    const p = (B) => "tox-" + B, y = g7(gQ(a), p), x = (B) => {
      nr(B, Xb, {
        name: "hex-valid",
        value: !0
      });
    }, k = (B) => {
      nr(B, Xb, {
        name: "hex-valid",
        value: !1
      });
    }, $ = ms(y.sketch({
      dom: {
        tag: "div",
        classes: [p("color-picker-container")],
        attributes: { role: "presentation" }
      },
      onValidHex: x,
      onInvalidHex: k
    }));
    return {
      dom: { tag: "div" },
      components: [$.asSpec()],
      behaviours: mn([
        iS(u, (B) => {
          const j = $.get(B);
          return ho.getCurrent(j).bind((le) => Pn.getValue(le).hex).map((le) => "#" + Xf(le, "#")).getOr("");
        }, (B, j) => {
          const Y = /^#([a-fA-F0-9]{3}(?:[a-fA-F0-9]{3})?)/, re = z.from(Y.exec(j)).bind((_e) => Bt(_e, 1)), le = $.get(B);
          ho.getCurrent(le).fold(() => {
            console.log("Can not find form");
          }, (_e) => {
            Pn.setValue(_e, { hex: re.getOr("") }), _T.getField(_e, "hex").each((ze) => {
              Jr(ze, Vm());
            });
          });
        }),
        zf.self()
      ])
    };
  };
  var bQ = tinymce.util.Tools.resolve("tinymce.Resource");
  const S7 = (t) => Yr(t, "init"), w7 = (t) => {
    const a = Gr(), u = ms({ dom: { tag: t.tag } }), p = Gr();
    return {
      dom: {
        tag: "div",
        classes: ["tox-custom-editor"]
      },
      behaviours: mn([
        Hr("custom-editor-events", [us((y) => {
          u.getOpt(y).each((x) => {
            (S7(t) ? t.init(x.element.dom) : bQ.load(t.scriptId, t.scriptUrl).then((k) => k(x.element.dom, t.settings))).then((k) => {
              p.on(($) => {
                k.setValue($);
              }), p.clear(), a.set(k);
            });
          });
        })]),
        iS(z.none(), () => a.get().fold(() => p.get().getOr(""), (y) => y.getValue()), (y, x) => {
          a.get().fold(() => p.set(x), (k) => k.setValue(x));
        }),
        zf.self()
      ]),
      components: [u.asSpec()]
    };
  };
  var p1 = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const E7 = (t, a) => {
    const u = p1.explode(a.getOption("images_file_types")), p = (y) => Gt(u, (x) => Nl(y.name.toLowerCase(), `.${x.toLowerCase()}`));
    return Rn(gr(t), p);
  }, yQ = (t, a, u) => {
    const p = (le, pe) => {
      pe.stop();
    }, y = (le) => (pe, _e) => {
      ut(le, (ze) => {
        ze(pe, _e);
      });
    }, x = (le, pe) => {
      var _e;
      if (!yr.isDisabled(le)) {
        const ze = pe.event.raw;
        $(le, (_e = ze.dataTransfer) === null || _e === void 0 ? void 0 : _e.files);
      }
    }, k = (le, pe) => {
      const _e = pe.event.raw.target;
      $(le, _e.files);
    }, $ = (le, pe) => {
      pe && (Pn.setValue(le, E7(pe, a)), nr(le, Bf, { name: t.name }));
    }, B = ms({
      dom: {
        tag: "input",
        attributes: {
          type: "file",
          accept: "image/*"
        },
        styles: { display: "none" }
      },
      behaviours: mn([Hr("input-file-events", [
        Gp(um()),
        Gp(wf())
      ])])
    }), j = (le) => ({
      uid: le.uid,
      dom: {
        tag: "div",
        classes: ["tox-dropzone-container"]
      },
      behaviours: mn([
        rP(u.getOr([])),
        zf.self(),
        yr.config({}),
        Zr.config({
          toggleClass: "dragenter",
          toggleOnExecute: !1
        }),
        Hr("dropzone-events", [
          Pt("dragenter", y([
            p,
            Zr.toggle
          ])),
          Pt("dragleave", y([
            p,
            Zr.toggle
          ])),
          Pt("dragover", p),
          Pt("drop", y([
            p,
            x
          ])),
          Pt(Gg(), k)
        ])
      ]),
      components: [{
        dom: {
          tag: "div",
          classes: ["tox-dropzone"],
          styles: {}
        },
        components: [
          {
            dom: { tag: "p" },
            components: [Ma(a.translate("Drop an image here"))]
          },
          cl.sketch({
            dom: {
              tag: "button",
              styles: { position: "relative" },
              classes: [
                "tox-button",
                "tox-button--secondary"
              ]
            },
            components: [
              Ma(a.translate("Browse for an image")),
              B.asSpec()
            ],
            action: (pe) => {
              B.get(pe).element.dom.click();
            },
            buttonBehaviours: mn([
              Ea.config({}),
              ip.button(a.isDisabled),
              Bc()
            ])
          })
        ]
      }]
    }), Y = t.label.map((le) => yh(le, a)), re = ps.parts.field({ factory: { sketch: j } });
    return IO(Y, re, ["tox-form__group--stretched"], []);
  }, C7 = (t, a) => ({
    dom: {
      tag: "div",
      classes: [
        "tox-form__grid",
        `tox-form__grid--${t.columns}col`
      ]
    },
    components: He(t.items, a.interpreter)
  }), qO = (t, a) => {
    let u = null, p = null;
    return {
      cancel: () => {
        I(u) || (clearTimeout(u), u = null, p = null);
      },
      throttle: (...k) => {
        p = k, I(u) && (u = setTimeout(() => {
          const $ = p;
          u = null, p = null, t.apply(null, $);
        }, a));
      }
    };
  }, SQ = (t, a) => {
    let u = null;
    return {
      cancel: () => {
        I(u) || (clearTimeout(u), u = null);
      },
      throttle: (...x) => {
        I(u) && (u = setTimeout(() => {
          u = null, t.apply(null, x);
        }, a));
      }
    };
  }, oP = (t, a) => {
    let u = null;
    const p = () => {
      I(u) || (clearTimeout(u), u = null);
    };
    return {
      cancel: p,
      throttle: (...x) => {
        p(), u = setTimeout(() => {
          u = null, t.apply(null, x);
        }, a);
      }
    };
  }, C3 = Hn("alloy-fake-before-tabstop"), x3 = Hn("alloy-fake-after-tabstop"), x7 = (t) => ({
    dom: {
      tag: "div",
      styles: {
        width: "1px",
        height: "1px",
        outline: "none"
      },
      attributes: { tabindex: "0" },
      classes: t
    },
    behaviours: mn([
      Er.config({ ignore: !0 }),
      Ea.config({})
    ])
  }), T7 = (t, a) => ({
    dom: {
      tag: "div",
      classes: [
        "tox-navobj",
        ...t.getOr([])
      ]
    },
    components: [
      x7([C3]),
      a,
      x7([x3])
    ],
    behaviours: mn([zf.childAt(1)])
  }), T3 = (t, a) => {
    nr(t, ud(), {
      raw: {
        which: 9,
        shiftKey: a
      }
    });
  }, wQ = (t, a) => {
    const u = a.element;
    Ti(u, C3) ? T3(t, !0) : Ti(u, x3) && T3(t, !1);
  }, AT = (t) => DO(t, [
    "." + C3,
    "." + x3
  ].join(","), sn), kT = Hn("update-dialog"), ty = Hn("update-title"), sP = Hn("update-body"), _3 = Hn("update-footer"), O3 = Hn("body-send-message"), NT = Hn("dialog-focus-shifted"), aP = Ft().browser, cS = aP.isSafari(), _7 = aP.isFirefox(), A3 = cS || _7, EQ = aP.isChromium(), CQ = ({ scrollTop: t, scrollHeight: a, clientHeight: u }) => Math.ceil(t) + u >= a, O7 = (t, a) => t.scrollTo(0, a === "bottom" ? 99999999 : a), xQ = (t, a) => {
    const u = t.body;
    return z.from(!/^<!DOCTYPE (html|HTML)/.test(a) && (!EQ && !cS || se(u) && (u.scrollTop !== 0 || Math.abs(u.scrollHeight - u.clientHeight) > 1)) ? u : t.documentElement);
  }, A7 = (t, a, u) => {
    const p = t.dom;
    z.from(p.contentDocument).fold(u, (y) => {
      let x = 0;
      const k = xQ(y, a).map((B) => (x = B.scrollTop, B)).forall(CQ), $ = () => {
        const B = p.contentWindow;
        se(B) && (k ? O7(B, "bottom") : !k && A3 && x !== 0 && O7(B, x));
      };
      cS && p.addEventListener("load", $, { once: !0 }), y.open(), y.write(a), y.close(), cS || $();
    });
  }, k7 = lr(A3, cS ? 500 : 200).map((t) => qO(A7, t)), _Q = (t, a) => {
    const u = sr(t.getOr(""));
    return {
      getValue: (p) => u.get(),
      setValue: (p, y) => {
        if (u.get() !== y) {
          const x = p.element, k = () => kn(x, "srcdoc", y);
          a ? k7.fold(q(A7), ($) => $.throttle)(x, y, k) : k();
        }
        u.set(y);
      }
    };
  }, OQ = (t, a, u) => {
    const p = "tox-dialog__iframe", y = t.transparent ? [] : [`${p}--opaque`], x = t.border ? ["tox-navobj-bordered"] : [], k = {
      ...t.label.map((re) => ({ title: re })).getOr({}),
      ...u.map((re) => ({ srcdoc: re })).getOr({}),
      ...t.sandboxed ? { sandbox: "allow-scripts allow-same-origin" } : {}
    }, $ = _Q(u, t.streamContent), B = t.label.map((re) => yh(re, a)), j = (re) => T7(z.from(x), {
      uid: re.uid,
      dom: {
        tag: "iframe",
        attributes: k,
        classes: [
          p,
          ...y
        ]
      },
      behaviours: mn([
        Ea.config({}),
        Er.config({}),
        iS(u, $.getValue, $.setValue),
        vu.config({
          channels: {
            [NT]: {
              onReceive: (le, pe) => {
                pe.newFocus.each((_e) => {
                  $l(le.element).each((ze) => {
                    (Io(le.element, _e) ? ja : ua)(ze, "tox-navobj-bordered-focus");
                  });
                });
              }
            }
          }
        })
      ])
    }), Y = ps.parts.field({ factory: { sketch: j } });
    return IO(B, Y, ["tox-form__group--stretched"], []);
  }, AQ = (t) => new Promise((a, u) => {
    const p = () => {
      x(), a(t);
    }, y = [
      Cl(t, "load", p),
      Cl(t, "error", () => {
        x(), u("Unable to load data from image: " + t.dom.src);
      })
    ], x = () => ut(y, (k) => k.unbind());
    t.dom.complete && p();
  }), iP = (t, a, u, p, y) => {
    const x = u * y, k = p * y, $ = Math.max(0, t / 2 - x / 2), B = Math.max(0, a / 2 - k / 2);
    return {
      left: $.toString() + "px",
      top: B.toString() + "px",
      width: x.toString() + "px",
      height: k.toString() + "px"
    };
  }, kQ = (t, a, u) => {
    const p = Oa(t), y = Ds(t);
    return Math.min(p / a, y / u, 1);
  }, NQ = (t, a) => {
    const u = sr(a.getOr({ url: "" })), p = ms({
      dom: {
        tag: "img",
        classes: ["tox-imagepreview__image"],
        attributes: a.map((B) => ({ src: B.url })).getOr({})
      }
    }), y = ms({
      dom: {
        tag: "div",
        classes: ["tox-imagepreview__container"],
        attributes: { role: "presentation" }
      },
      components: [p.asSpec()]
    }), x = (B, j) => {
      const Y = { url: j.url };
      j.zoom.each((le) => Y.zoom = le), j.cachedWidth.each((le) => Y.cachedWidth = le), j.cachedHeight.each((le) => Y.cachedHeight = le), u.set(Y);
      const re = () => {
        const { cachedWidth: le, cachedHeight: pe, zoom: _e } = Y;
        if (!Z(le) && !Z(pe)) {
          if (Z(_e)) {
            const ft = kQ(B.element, le, pe);
            Y.zoom = ft;
          }
          const ze = iP(Oa(B.element), Ds(B.element), le, pe, Y.zoom);
          y.getOpt(B).each((ft) => {
            Rc(ft.element, ze);
          });
        }
      };
      p.getOpt(B).each((le) => {
        const pe = le.element;
        j.url !== ca(pe, "src") && (kn(pe, "src", j.url), ua(B.element, "tox-imagepreview__loaded")), re(), AQ(pe).then((_e) => {
          B.getSystem().isConnected() && (ja(B.element, "tox-imagepreview__loaded"), Y.cachedWidth = _e.dom.naturalWidth, Y.cachedHeight = _e.dom.naturalHeight, re());
        });
      });
    }, k = {};
    t.height.each((B) => k.height = B);
    const $ = a.map((B) => ({
      url: B.url,
      zoom: z.from(B.zoom),
      cachedWidth: z.from(B.cachedWidth),
      cachedHeight: z.from(B.cachedHeight)
    }));
    return {
      dom: {
        tag: "div",
        classes: ["tox-imagepreview"],
        styles: k,
        attributes: { role: "presentation" }
      },
      components: [y.asSpec()],
      behaviours: mn([
        zf.self(),
        iS($, () => u.get(), x)
      ])
    };
  }, N7 = (t, a) => {
    const u = "tox-label", p = t.align === "center" ? [`${u}--center`] : [], y = t.align === "end" ? [`${u}--end`] : [], x = {
      dom: {
        tag: "label",
        classes: [
          u,
          ...p,
          ...y
        ]
      },
      components: [Ma(a.providers.translate(t.label))]
    }, k = He(t.items, a.interpreter);
    return {
      dom: {
        tag: "div",
        classes: ["tox-form__group"]
      },
      components: [
        x,
        ...k
      ],
      behaviours: mn([
        zf.self(),
        $r.config({}),
        y7(z.none()),
        ar.config({ mode: "acyclic" })
      ])
    };
  }, k3 = Hn("toolbar.button.execute"), RQ = (t) => Ul((a, u) => {
    AE(t, a)((p) => {
      nr(a, k3, { buttonApi: p }), t.onAction(p);
    });
  }), ME = Hn("common-button-display-events"), cP = {
    [Lu()]: [
      "disabling",
      "alloy.base.behaviour",
      "toggling",
      "toolbar-button-events"
    ],
    [Vl()]: [
      "toolbar-button-events",
      ME
    ],
    [oo()]: [
      "focusing",
      "alloy.base.behaviour",
      ME
    ]
  }, N3 = (t) => Sr(t.element, "width", na(t.element, "width")), R3 = (t, a, u) => mg(t, {
    tag: "span",
    classes: [
      "tox-icon",
      "tox-tbtn__icon-wrap"
    ],
    behaviours: u
  }, a), P3 = (t, a) => R3(t, a, []), lS = (t, a) => R3(t, a, [$r.config({})]), R7 = (t, a, u) => ({
    dom: {
      tag: "span",
      classes: [`${a}__select-label`]
    },
    components: [Ma(u.translate(t))],
    behaviours: mn([$r.config({})])
  }), lp = Hn("update-menu-text"), uS = Hn("update-menu-icon"), D3 = (t, a, u) => {
    const p = sr(G), y = t.text.map((le) => ms(R7(le, a, u.providers))), x = t.icon.map((le) => ms(lS(le, u.providers.icons))), k = (le, pe) => {
      const _e = Pn.getValue(le);
      return Er.focus(_e), nr(_e, "keydown", { raw: pe.event.raw }), bh.close(_e), z.some(!0);
    }, $ = t.role.fold(() => ({}), (le) => ({ role: le })), B = t.tooltip.fold(() => ({}), (le) => {
      const pe = u.providers.translate(le);
      return {
        title: pe,
        "aria-label": pe
      };
    }), j = mg("chevron-down", {
      tag: "div",
      classes: [`${a}__select-chevron`]
    }, u.providers.icons), Y = Hn("common-button-display-events");
    return ms(bh.sketch({
      ...t.uid ? { uid: t.uid } : {},
      ...$,
      dom: {
        tag: "button",
        classes: [
          a,
          `${a}--select`
        ].concat(He(t.classes, (le) => `${a}--${le}`)),
        attributes: { ...B }
      },
      components: kE([
        x.map((le) => le.asSpec()),
        y.map((le) => le.asSpec()),
        z.some(j)
      ]),
      matchWidth: !0,
      useMinWidth: !0,
      onOpen: (le, pe, _e) => {
        t.searchable && $K(_e);
      },
      dropdownBehaviours: mn([
        ...t.dropdownBehaviours,
        ip.button(() => t.disabled || u.providers.isDisabled()),
        Bc(),
        LO.config({}),
        $r.config({}),
        Hr("dropdown-events", [
          l1(t, p),
          pg(t, p)
        ]),
        Hr(Y, [us((le, pe) => N3(le))]),
        Hr("menubutton-update-display-text", [
          Pt(lp, (le, pe) => {
            y.bind((_e) => _e.getOpt(le)).each((_e) => {
              $r.set(_e, [Ma(u.providers.translate(pe.event.text))]);
            });
          }),
          Pt(uS, (le, pe) => {
            x.bind((_e) => _e.getOpt(le)).each((_e) => {
              $r.set(_e, [lS(pe.event.icon, u.providers.icons)]);
            });
          })
        ])
      ]),
      eventOrder: Vo(cP, {
        mousedown: [
          "focusing",
          "alloy.base.behaviour",
          "item-type-events",
          "normal-dropdown-events"
        ],
        [Vl()]: [
          "toolbar-button-events",
          "dropdown-events",
          Y
        ]
      }),
      sandboxBehaviours: mn([
        ar.config({
          mode: "special",
          onLeft: k,
          onRight: k
        }),
        Hr("dropdown-sandbox-events", [
          Pt(ZM, (le, pe) => {
            kK(le), pe.stop();
          }),
          Pt(sR, (le, pe) => {
            NK(le, pe), pe.stop();
          })
        ])
      ]),
      lazySink: u.getSink,
      toggleClass: `${a}--active`,
      parts: {
        menu: {
          ...pT(!1, t.columns, t.presets),
          fakeFocus: t.searchable,
          onHighlightItem: qF,
          onCollapseMenu: (le, pe, _e) => {
            Wo.getHighlighted(_e).each((ze) => {
              qF(le, _e, ze);
            });
          },
          onDehighlightItem: DK
        }
      },
      getAnchorOverrides: () => ({
        maxHeightFunction: (le, pe) => {
          bx()(le, pe - 10);
        }
      }),
      fetch: (le) => wu.nu(je(t.fetch, le))
    })).asSpec();
  }, PQ = (t) => g(t), P7 = (t) => t.type === "separator", DQ = (t) => Yr(t, "getSubmenuItems"), D7 = { type: "separator" }, $Q = (t, a) => {
    const u = Jt(t, (p, y) => PQ(y) ? y === "" ? p : y === "|" ? p.length > 0 && !P7(p[p.length - 1]) ? p.concat([D7]) : p : Yr(a, y.toLowerCase()) ? p.concat([a[y.toLowerCase()]]) : p : p.concat([y]), []);
    return u.length > 0 && P7(u[u.length - 1]) && u.pop(), u;
  }, $7 = (t, a) => {
    const u = t.getSubmenuItems(), p = I7(u, a), y = Vo(p.menus, { [t.value]: p.items }), x = Vo(p.expansions, { [t.value]: t.value });
    return {
      item: t,
      menus: y,
      expansions: x
    };
  }, IQ = (t) => {
    const a = fn(t, "value").getOrThunk(() => Hn("generated-menu-item"));
    return Vo({ value: a }, t);
  }, I7 = (t, a) => {
    const u = $Q(g(t) ? t.split(" ") : t, a);
    return Zt(u, (p, y) => {
      if (DQ(y)) {
        const x = IQ(y), k = $7(x, a);
        return {
          menus: Vo(p.menus, k.menus),
          items: [
            k.item,
            ...p.items
          ],
          expansions: Vo(p.expansions, k.expansions)
        };
      } else
        return {
          ...p,
          items: [
            y,
            ...p.items
          ]
        };
    }, {
      menus: {},
      expansions: {},
      items: []
    });
  }, MQ = (t) => t.search.fold(() => ({ searchMode: "no-search" }), (a) => ({
    searchMode: "search-with-field",
    placeholder: a.placeholder
  })), FQ = (t) => t.search.fold(() => ({ searchMode: "no-search" }), (a) => ({ searchMode: "search-with-results" })), RT = (t, a, u, p) => {
    const y = Hn("primary-menu"), x = I7(t, u.shared.providers.menuItems());
    if (x.items.length === 0)
      return z.none();
    const k = MQ(p), $ = yH(y, x.items, a, u, p.isHorizontalMenu, k), B = FQ(p), j = uo(x.menus, (re, le) => yH(le, re, a, u, !1, B)), Y = Vo(j, Sn(y, $));
    return z.from(q0.tieredData(y, Y, x.expansions));
  }, $3 = (t) => !Yr(t, "items"), M7 = "data-value", F7 = (t, a, u, p) => He(u, (y) => $3(y) ? {
    type: "togglemenuitem",
    text: y.text,
    value: y.value,
    active: y.value === p,
    onAction: () => {
      Pn.setValue(t, y.value), nr(t, Bf, { name: a }), Er.focus(t);
    }
  } : {
    type: "nestedmenuitem",
    text: y.text,
    getSubmenuItems: () => F7(t, a, y.items, p)
  }), I3 = (t, a) => Vr(t, (u) => $3(u) ? lr(u.value === a, u) : I3(u.items, a)), M3 = (t, a, u) => {
    const p = a.shared.providers, y = u.bind((B) => I3(t.items, B)).orThunk(() => $n(t.items).filter($3)), x = t.label.map((B) => yh(B, p)), k = ps.parts.field({
      dom: {},
      factory: {
        sketch: (B) => D3({
          uid: B.uid,
          text: y.map((j) => j.text),
          icon: z.none(),
          tooltip: t.label,
          role: z.none(),
          fetch: (j, Y) => {
            const re = F7(j, t.name, t.items, Pn.getValue(j));
            Y(RT(re, Cv.CLOSE_ON_EXECUTE, a, {
              isHorizontalMenu: !1,
              search: z.none()
            }));
          },
          onSetup: q(G),
          getApi: q({}),
          columns: 1,
          presets: "normal",
          classes: [],
          dropdownBehaviours: [
            Ea.config({}),
            iS(y.map((j) => j.value), (j) => ca(j.element, M7), (j, Y) => {
              I3(t.items, Y).each((re) => {
                kn(j.element, M7, re.value), nr(j, lp, { text: re.text });
              });
            })
          ]
        }, "tox-listbox", a.shared)
      }
    }), $ = {
      dom: {
        tag: "div",
        classes: ["tox-listboxfield"]
      },
      components: [k]
    };
    return ps.sketch({
      dom: {
        tag: "div",
        classes: ["tox-form__group"]
      },
      components: St([
        x.toArray(),
        [$]
      ]),
      fieldBehaviours: mn([yr.config({
        disabled: q(!t.enabled),
        onDisabled: (B) => {
          ps.getField(B).each(yr.disable);
        },
        onEnabled: (B) => {
          ps.getField(B).each(yr.enable);
        }
      })])
    });
  }, LQ = (t, a) => ({
    dom: {
      tag: "div",
      classes: t.classes
    },
    components: He(t.items, a.shared.interpreter)
  }), BQ = (t, a) => {
    const u = He(t.options, (y) => ({
      dom: {
        tag: "option",
        value: y.value,
        innerHtml: y.text
      }
    })), p = t.data.map((y) => Sn("initialValue", y)).getOr({});
    return {
      uid: t.uid,
      dom: {
        tag: "select",
        classes: t.selectClasses,
        attributes: t.selectAttributes
      },
      components: u,
      behaviours: _i(t.selectBehaviours, [
        Er.config({}),
        Pn.config({
          store: {
            mode: "manual",
            getValue: (y) => Zm(y.element),
            setValue: (y, x) => {
              const k = $n(t.options);
              Ge(t.options, (B) => B.value === x).isSome() ? wb(y.element, x) : y.element.dom.selectedIndex === -1 && x === "" && k.each((B) => wb(y.element, B.value));
            },
            ...p
          }
        })
      ])
    };
  }, HQ = Yd({
    name: "HtmlSelect",
    configFields: [
      Mt("options"),
      ac("selectBehaviours", [
        Er,
        Pn
      ]),
      lt("selectClasses", []),
      lt("selectAttributes", {}),
      Fo("data")
    ],
    factory: BQ
  }), GO = (t, a, u) => {
    const p = He(t.items, (B) => ({
      text: a.translate(B.text),
      value: B.value
    })), y = t.label.map((B) => yh(B, a)), x = ps.parts.field({
      dom: {},
      ...u.map((B) => ({ data: B })).getOr({}),
      selectAttributes: { size: t.size },
      options: p,
      factory: HQ,
      selectBehaviours: mn([
        yr.config({ disabled: () => !t.enabled || a.isDisabled() }),
        Ea.config({}),
        Hr("selectbox-change", [Pt(Gg(), (B, j) => {
          nr(B, Bf, { name: t.name });
        })])
      ])
    }), k = t.size > 1 ? z.none() : z.some(mg("chevron-down", {
      tag: "div",
      classes: ["tox-selectfield__icon-js"]
    }, a.icons)), $ = {
      dom: {
        tag: "div",
        classes: ["tox-selectfield"]
      },
      components: St([
        [x],
        k.toArray()
      ])
    };
    return ps.sketch({
      dom: {
        tag: "div",
        classes: ["tox-form__group"]
      },
      components: St([
        y.toArray(),
        [$]
      ]),
      fieldBehaviours: mn([
        yr.config({
          disabled: () => !t.enabled || a.isDisabled(),
          onDisabled: (B) => {
            ps.getField(B).each(yr.disable);
          },
          onEnabled: (B) => {
            ps.getField(B).each(yr.enable);
          }
        }),
        Bc()
      ])
    });
  }, F3 = q([
    lt("field1Name", "field1"),
    lt("field2Name", "field2"),
    mm("onLockedChange"),
    eg(["lockClass"]),
    lt("locked", !1),
    bm.field("coupledFieldBehaviours", [
      ho,
      Pn
    ])
  ]), zQ = (t, a, u) => Fs(t, a, u).bind(ho.getCurrent), L7 = (t, a) => jl({
    factory: ps,
    name: t,
    overrides: (u) => ({
      fieldBehaviours: mn([Hr("coupled-input-behaviour", [Pt(Vm(), (p) => {
        zQ(p, u, a).each((y) => {
          Fs(p, u, "lock").each((x) => {
            Zr.isOn(x) && u.onLockedChange(p, y, x);
          });
        });
      })])])
    })
  }), L3 = q([
    L7("field1", "field2"),
    L7("field2", "field1"),
    jl({
      factory: cl,
      schema: [Mt("dom")],
      name: "lock",
      overrides: (t) => ({
        buttonBehaviours: mn([Zr.config({
          selected: t.locked,
          toggleClass: t.markers.lockClass,
          aria: { mode: "pressed" }
        })])
      })
    })
  ]), VQ = (t, a, u, p) => ({
    uid: t.uid,
    dom: t.dom,
    components: a,
    behaviours: bm.augment(t.coupledFieldBehaviours, [
      ho.config({ find: z.some }),
      Pn.config({
        store: {
          mode: "manual",
          getValue: (y) => {
            const x = Xy(y, t, [
              "field1",
              "field2"
            ]);
            return {
              [t.field1Name]: Pn.getValue(x.field1()),
              [t.field2Name]: Pn.getValue(x.field2())
            };
          },
          setValue: (y, x) => {
            const k = Xy(y, t, [
              "field1",
              "field2"
            ]);
            xa(x, t.field1Name) && Pn.setValue(k.field1(), x[t.field1Name]), xa(x, t.field2Name) && Pn.setValue(k.field2(), x[t.field2Name]);
          }
        }
      })
    ]),
    apis: {
      getField1: (y) => Fs(y, t, "field1"),
      getField2: (y) => Fs(y, t, "field2"),
      getLock: (y) => Fs(y, t, "lock")
    }
  }), Vf = ql({
    name: "FormCoupledInputs",
    configFields: F3(),
    partFields: L3(),
    factory: VQ,
    apis: {
      getField1: (t, a) => t.getField1(a),
      getField2: (t, a) => t.getField2(a),
      getLock: (t, a) => t.getLock(a)
    }
  }), B7 = (t) => {
    const a = {
      "": 0,
      px: 0,
      pt: 1,
      mm: 1,
      pc: 2,
      ex: 2,
      em: 2,
      ch: 2,
      rem: 2,
      cm: 3,
      in: 4,
      "%": 4
    }, u = (y) => y in a ? a[y] : 1;
    let p = t.value.toFixed(u(t.unit));
    return p.indexOf(".") !== -1 && (p = p.replace(/\.?0*$/, "")), p + t.unit;
  }, B3 = (t) => {
    const u = /^\s*(\d+(?:\.\d+)?)\s*(|cm|mm|in|px|pt|pc|em|ex|ch|rem|vw|vh|vmin|vmax|%)\s*$/.exec(t);
    if (u !== null) {
      const p = parseFloat(u[1]), y = u[2];
      return Rr.value({
        value: p,
        unit: y
      });
    } else
      return Rr.error(t);
  }, H7 = (t, a) => {
    const u = {
      "": 96,
      px: 96,
      pt: 72,
      cm: 2.54,
      pc: 12,
      mm: 25.4,
      in: 1
    }, p = (y) => Yr(u, y);
    return t.unit === a ? z.some(t.value) : p(t.unit) && p(a) ? u[t.unit] === u[a] ? z.some(t.value) : z.some(t.value / u[t.unit] * u[a]) : z.none();
  }, lP = (t) => z.none(), z7 = (t, a) => (u) => H7(u, a).map((p) => ({
    value: p * t,
    unit: a
  })), UQ = (t, a) => {
    const u = B3(t).toOptional(), p = B3(a).toOptional();
    return gc(u, p, (y, x) => H7(y, x.unit).map((k) => x.value / k).map((k) => z7(k, x.unit)).getOr(lP)).getOr(lP);
  }, V7 = (t, a) => {
    let u = lP;
    const p = Hn("ratio-event"), y = (re) => mg(re, {
      tag: "span",
      classes: [
        "tox-icon",
        "tox-lock-icon__" + re
      ]
    }, a.icons), x = Vf.parts.lock({
      dom: {
        tag: "button",
        classes: [
          "tox-lock",
          "tox-button",
          "tox-button--naked",
          "tox-button--icon"
        ],
        attributes: { title: a.translate(t.label.getOr("Constrain proportions")) }
      },
      components: [
        y("lock"),
        y("unlock")
      ],
      buttonBehaviours: mn([
        yr.config({ disabled: () => !t.enabled || a.isDisabled() }),
        Bc(),
        Ea.config({})
      ])
    }), k = (re) => ({
      dom: {
        tag: "div",
        classes: ["tox-form__group"]
      },
      components: re
    }), $ = (re) => ps.parts.field({
      factory: TE,
      inputClasses: ["tox-textfield"],
      inputBehaviours: mn([
        yr.config({ disabled: () => !t.enabled || a.isDisabled() }),
        Bc(),
        Ea.config({}),
        Hr("size-input-events", [
          Pt(oa(), (le, pe) => {
            nr(le, p, { isField1: re });
          }),
          Pt(Gg(), (le, pe) => {
            nr(le, Bf, { name: t.name });
          })
        ])
      ]),
      selectOnFocus: !1
    }), B = (re) => ({
      dom: {
        tag: "label",
        classes: ["tox-label"]
      },
      components: [Ma(a.translate(re))]
    }), j = Vf.parts.field1(k([
      ps.parts.label(B("Width")),
      $(!0)
    ])), Y = Vf.parts.field2(k([
      ps.parts.label(B("Height")),
      $(!1)
    ]));
    return Vf.sketch({
      dom: {
        tag: "div",
        classes: ["tox-form__group"]
      },
      components: [{
        dom: {
          tag: "div",
          classes: ["tox-form__controls-h-stack"]
        },
        components: [
          j,
          Y,
          k([
            B(E0),
            x
          ])
        ]
      }],
      field1Name: "width",
      field2Name: "height",
      locked: !0,
      markers: { lockClass: "tox-locked" },
      onLockedChange: (re, le, pe) => {
        B3(Pn.getValue(re)).each((_e) => {
          u(_e).each((ze) => {
            Pn.setValue(le, B7(ze));
          });
        });
      },
      coupledFieldBehaviours: mn([
        yr.config({
          disabled: () => !t.enabled || a.isDisabled(),
          onDisabled: (re) => {
            Vf.getField1(re).bind(ps.getField).each(yr.disable), Vf.getField2(re).bind(ps.getField).each(yr.disable), Vf.getLock(re).each(yr.disable);
          },
          onEnabled: (re) => {
            Vf.getField1(re).bind(ps.getField).each(yr.enable), Vf.getField2(re).bind(ps.getField).each(yr.enable), Vf.getLock(re).each(yr.enable);
          }
        }),
        Bc(),
        Hr("size-input-events2", [Pt(p, (re, le) => {
          const pe = le.event.isField1, _e = pe ? Vf.getField1(re) : Vf.getField2(re), ze = pe ? Vf.getField2(re) : Vf.getField1(re), ft = _e.map(Pn.getValue).getOr(""), Xe = ze.map(Pn.getValue).getOr("");
          u = UQ(ft, Xe);
        })])
      ])
    });
  }, U7 = (t, a, u) => {
    const p = Zl.parts.label({
      dom: {
        tag: "label",
        classes: ["tox-label"]
      },
      components: [Ma(a.translate(t.label))]
    }), y = Zl.parts.spectrum({
      dom: {
        tag: "div",
        classes: ["tox-slider__rail"],
        attributes: { role: "presentation" }
      }
    }), x = Zl.parts.thumb({
      dom: {
        tag: "div",
        classes: ["tox-slider__handle"],
        attributes: { role: "presentation" }
      }
    });
    return Zl.sketch({
      dom: {
        tag: "div",
        classes: ["tox-slider"],
        attributes: { role: "presentation" }
      },
      model: {
        mode: "x",
        minX: t.min,
        maxX: t.max,
        getInitialValue: q(u.getOrThunk(() => (Math.abs(t.max) - Math.abs(t.min)) / 2))
      },
      components: [
        p,
        y,
        x
      ],
      sliderBehaviours: mn([
        zf.self(),
        Er.config({})
      ]),
      onChoose: (k, $, B) => {
        nr(k, Bf, {
          name: t.name,
          value: B
        });
      }
    });
  }, WQ = (t, a) => {
    const u = ($) => ({
      dom: {
        tag: "th",
        innerHtml: a.translate($)
      }
    }), p = ($) => ({
      dom: { tag: "thead" },
      components: [{
        dom: { tag: "tr" },
        components: He($, u)
      }]
    }), y = ($) => ({
      dom: {
        tag: "td",
        innerHtml: a.translate($)
      }
    }), x = ($) => ({
      dom: { tag: "tr" },
      components: He($, y)
    }), k = ($) => ({
      dom: { tag: "tbody" },
      components: He($, x)
    });
    return {
      dom: {
        tag: "table",
        classes: ["tox-dialog__table"]
      },
      components: [
        p(t.header),
        k(t.cells)
      ],
      behaviours: mn([
        Ea.config({}),
        Er.config({})
      ])
    };
  }, H3 = (t, a) => {
    const u = t.label.map((pe) => yh(pe, a)), p = [
      yr.config({ disabled: () => t.disabled || a.isDisabled() }),
      Bc(),
      ar.config({
        mode: "execution",
        useEnter: t.multiline !== !0,
        useControlEnter: t.multiline === !0,
        execute: (pe) => (Jr(pe, FO), z.some(!0))
      }),
      Hr("textfield-change", [
        Pt(Vm(), (pe, _e) => {
          nr(pe, Bf, { name: t.name });
        }),
        Pt(Up(), (pe, _e) => {
          nr(pe, Bf, { name: t.name });
        })
      ]),
      Ea.config({})
    ], y = t.validation.map((pe) => cp.config({
      getRoot: (_e) => $l(_e.element),
      invalidClass: "tox-invalid",
      validator: {
        validate: (_e) => {
          const ze = Pn.getValue(_e), ft = pe.validator(ze);
          return wu.pure(ft === !0 ? Rr.value(ze) : Rr.error(ft));
        },
        validateOnLoad: pe.validateOnLoad
      }
    })).toArray(), x = t.placeholder.fold(q({}), (pe) => ({ placeholder: a.translate(pe) })), k = t.inputMode.fold(q({}), (pe) => ({ inputmode: pe })), $ = {
      ...x,
      ...k
    }, B = ps.parts.field({
      tag: t.multiline === !0 ? "textarea" : "input",
      ...t.data.map((pe) => ({ data: pe })).getOr({}),
      inputAttributes: $,
      inputClasses: [t.classname],
      inputBehaviours: mn(St([
        p,
        y
      ])),
      selectOnFocus: !1,
      factory: TE
    }), j = t.multiline ? {
      dom: {
        tag: "div",
        classes: ["tox-textarea-wrap"]
      },
      components: [B]
    } : B, re = (t.flex ? ["tox-form__group--stretched"] : []).concat(t.maximized ? ["tox-form-group--maximize"] : []), le = [
      yr.config({
        disabled: () => t.disabled || a.isDisabled(),
        onDisabled: (pe) => {
          ps.getField(pe).each(yr.disable);
        },
        onEnabled: (pe) => {
          ps.getField(pe).each(yr.enable);
        }
      }),
      Bc()
    ];
    return IO(u, j, re, le);
  }, W7 = (t, a, u) => H3({
    name: t.name,
    multiline: !1,
    label: t.label,
    inputMode: t.inputMode,
    placeholder: t.placeholder,
    flex: !1,
    disabled: !t.enabled,
    classname: "tox-textfield",
    validation: z.none(),
    maximized: t.maximized,
    data: u
  }, a), j7 = (t, a, u) => H3({
    name: t.name,
    multiline: !0,
    label: t.label,
    inputMode: z.none(),
    placeholder: t.placeholder,
    flex: !0,
    disabled: !t.enabled,
    classname: "tox-textarea",
    validation: z.none(),
    maximized: t.maximized,
    data: u
  }, a), ZO = (t, a) => a.getAnimationRoot.fold(() => t.element, (u) => u(t)), h1 = (t) => t.dimension.property, FE = (t, a) => t.dimension.getDimension(a), KO = (t, a) => {
    const u = ZO(t, a);
    dd(u, [
      a.shrinkingClass,
      a.growingClass
    ]);
  }, z3 = (t, a) => {
    ua(t.element, a.openClass), ja(t.element, a.closedClass), Sr(t.element, h1(a), "0px"), Qc(t.element);
  }, uP = (t, a) => {
    ua(t.element, a.closedClass), ja(t.element, a.openClass), Ur(t.element, h1(a));
  }, q7 = (t, a, u, p) => {
    u.setCollapsed(), Sr(t.element, h1(a), FE(a, t.element)), KO(t, a), z3(t, a), a.onStartShrink(t), a.onShrunk(t);
  }, jQ = (t, a, u, p) => {
    const y = p.getOrThunk(() => FE(a, t.element));
    u.setCollapsed(), Sr(t.element, h1(a), y), Qc(t.element);
    const x = ZO(t, a);
    ua(x, a.growingClass), ja(x, a.shrinkingClass), z3(t, a), a.onStartShrink(t);
  }, dP = (t, a, u) => {
    const p = FE(a, t.element);
    (p === "0px" ? q7 : jQ)(t, a, u, z.some(p));
  }, G7 = (t, a, u) => {
    const p = ZO(t, a), y = Ti(p, a.shrinkingClass), x = FE(a, t.element);
    uP(t, a);
    const k = FE(a, t.element);
    (y ? () => {
      Sr(t.element, h1(a), x), Qc(t.element);
    } : () => {
      z3(t, a);
    })(), ua(p, a.shrinkingClass), ja(p, a.growingClass), uP(t, a), Sr(t.element, h1(a), k), u.setExpanded(), a.onStartGrow(t);
  }, qQ = (t, a, u) => {
    if (u.isExpanded()) {
      Ur(t.element, h1(a));
      const p = FE(a, t.element);
      Sr(t.element, h1(a), p);
    }
  }, GQ = (t, a, u) => {
    u.isExpanded() || G7(t, a, u);
  }, Z7 = (t, a, u) => {
    u.isExpanded() && dP(t, a, u);
  }, ZQ = (t, a, u) => {
    u.isExpanded() && q7(t, a, u);
  }, K7 = (t, a, u) => u.isExpanded(), KQ = (t, a, u) => u.isCollapsed(), V3 = (t, a, u) => {
    const p = ZO(t, a);
    return Ti(p, a.growingClass) === !0;
  }, Y7 = (t, a, u) => {
    const p = ZO(t, a);
    return Ti(p, a.shrinkingClass) === !0;
  };
  var YQ = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    refresh: qQ,
    grow: GQ,
    shrink: Z7,
    immediateShrink: ZQ,
    hasGrown: K7,
    hasShrunk: KQ,
    isGrowing: V3,
    isShrinking: Y7,
    isTransitioning: (t, a, u) => V3(t, a) || Y7(t, a),
    toggleGrow: (t, a, u) => {
      (u.isExpanded() ? dP : G7)(t, a, u);
    },
    disableTransitions: KO,
    immediateGrow: (t, a, u) => {
      u.isExpanded() || (uP(t, a), Sr(t.element, h1(a), FE(a, t.element)), KO(t, a), u.setExpanded(), a.onStartGrow(t), a.onGrown(t));
    }
  }), XQ = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    exhibit: (t, a, u) => {
      const p = a.expanded;
      return pu(p ? {
        classes: [a.openClass],
        styles: {}
      } : {
        classes: [a.closedClass],
        styles: Sn(a.dimension.property, "0px")
      });
    },
    events: (t, a) => ls([xf(Hp(), (u, p) => {
      p.event.raw.propertyName === t.dimension.property && (KO(u, t), a.isExpanded() && Ur(u.element, t.dimension.property), (a.isExpanded() ? t.onGrown : t.onShrunk)(u));
    })])
  }), Q7 = [
    Mt("closedClass"),
    Mt("openClass"),
    Mt("shrinkingClass"),
    Mt("growingClass"),
    Fo("getAnimationRoot"),
    po("onShrunk"),
    po("onStartShrink"),
    po("onGrown"),
    po("onStartGrow"),
    lt("expanded", !1),
    $c("dimension", ro("property", {
      width: [
        ds("property", "width"),
        ds("getDimension", (t) => Oa(t) + "px")
      ],
      height: [
        ds("property", "height"),
        ds("getDimension", (t) => Ds(t) + "px")
      ]
    }))
  ], JQ = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: (t) => {
      const a = sr(t.expanded), u = () => "expanded: " + a.get();
      return ol({
        isExpanded: () => a.get() === !0,
        isCollapsed: () => a.get() === !1,
        setCollapsed: je(a.set, !1),
        setExpanded: je(a.set, !0),
        readState: u
      });
    }
  });
  const Cm = Zi({
    fields: Q7,
    name: "sliding",
    active: XQ,
    apis: YQ,
    state: JQ
  }), U3 = (t) => ({
    isEnabled: () => !yr.isDisabled(t),
    setEnabled: (a) => yr.set(t, !a),
    setActive: (a) => {
      const u = t.element;
      a ? (ja(u, "tox-tbtn--enabled"), kn(u, "aria-pressed", !0)) : (ua(u, "tox-tbtn--enabled"), vs(u, "aria-pressed"));
    },
    isActive: () => Ti(t.element, "tox-tbtn--enabled"),
    setText: (a) => {
      nr(t, lp, { text: a });
    },
    setIcon: (a) => nr(t, uS, { icon: a })
  }), YO = (t, a, u, p, y = !0) => D3({
    text: t.text,
    icon: t.icon,
    tooltip: t.tooltip,
    searchable: t.search.isSome(),
    role: p,
    fetch: (x, k) => {
      const $ = { pattern: t.search.isSome() ? IK(x) : "" };
      t.fetch((B) => {
        k(RT(B, Cv.CLOSE_ON_EXECUTE, u, {
          isHorizontalMenu: !1,
          search: t.search
        }));
      }, $, U3(x));
    },
    onSetup: t.onSetup,
    getApi: U3,
    columns: 1,
    presets: "normal",
    classes: [],
    dropdownBehaviours: [...y ? [Ea.config({})] : []]
  }, a, u.shared), eX = (t, a, u) => {
    const p = (x) => (k) => {
      const $ = !k.isActive();
      k.setActive($), x.storage.set($), u.shared.getSink().each((B) => {
        a().getOpt(B).each((j) => {
          Fa(j.element), nr(j, Xb, {
            name: x.name,
            value: x.storage.get()
          });
        });
      });
    }, y = (x) => (k) => {
      k.setActive(x.storage.get());
    };
    return (x) => {
      x(He(t, (k) => {
        const $ = k.text.fold(() => ({}), (B) => ({ text: B }));
        return {
          type: k.type,
          active: !1,
          ...$,
          onAction: p(k),
          onSetup: y(k)
        };
      }));
    };
  }, X7 = (t) => ({
    dom: {
      tag: "span",
      classes: ["tox-tree__label"],
      attributes: {
        title: t,
        "aria-label": t
      }
    },
    components: [Ma(t)]
  }), W3 = Hn("leaf-label-event-id"), fP = ({ leaf: t, onLeafAction: a, visible: u, treeId: p, selectedId: y, backstage: x }) => {
    const k = t.menu.map((B) => YO(B, "tox-mbtn", x, z.none(), u)), $ = [X7(t.title)];
    return k.each((B) => $.push(B)), cl.sketch({
      dom: {
        tag: "div",
        classes: [
          "tox-tree--leaf__label",
          "tox-trbtn"
        ].concat(u ? ["tox-tree--leaf__label--visible"] : [])
      },
      components: $,
      role: "treeitem",
      action: (B) => {
        a(t.id), B.getSystem().broadcastOn([`update-active-item-${p}`], { value: t.id });
      },
      eventOrder: {
        [ud()]: [
          W3,
          "keying"
        ]
      },
      buttonBehaviours: mn([
        ...u ? [Ea.config({})] : [],
        Zr.config({
          toggleClass: "tox-trbtn--enabled",
          toggleOnExecute: !1,
          aria: { mode: "selected" }
        }),
        vu.config({
          channels: {
            [`update-active-item-${p}`]: {
              onReceive: (B, j) => {
                (j.value === t.id ? Zr.on : Zr.off)(B);
              }
            }
          }
        }),
        Hr(W3, [
          us((B, j) => {
            y.each((Y) => {
              (Y === t.id ? Zr.on : Zr.off)(B);
            });
          }),
          Pt(ud(), (B, j) => {
            const Y = j.event.raw.code === "ArrowLeft", re = j.event.raw.code === "ArrowRight";
            Y ? (zu(B.element, ".tox-tree--directory").each((le) => {
              B.getSystem().getByDom(le).each((pe) => {
                s0(le, ".tox-tree--directory__label").each((_e) => {
                  pe.getSystem().getByDom(_e).each(Er.focus);
                });
              });
            }), j.stop()) : re && j.stop();
          })
        ])
      ])
    });
  }, J7 = (t, a, u) => mg(t, {
    tag: "span",
    classes: [
      "tox-tree__icon-wrap",
      "tox-icon"
    ],
    behaviours: u
  }, a), mP = (t, a) => J7(t, a, []), ez = Hn("directory-label-event-id"), tX = ({ directory: t, visible: a, noChildren: u, backstage: p }) => {
    const y = t.menu.map(($) => YO($, "tox-mbtn", p, z.none())), x = [
      {
        dom: {
          tag: "div",
          classes: ["tox-chevron"]
        },
        components: [mP("chevron-right", p.shared.providers.icons)]
      },
      X7(t.title)
    ];
    y.each(($) => {
      x.push($);
    });
    const k = ($) => {
      zu($.element, ".tox-tree--directory").each((B) => {
        $.getSystem().getByDom(B).each((j) => {
          const Y = !Zr.isOn(j);
          Zr.toggle(j), nr($, "expand-tree-node", {
            expanded: Y,
            node: t.id
          });
        });
      });
    };
    return cl.sketch({
      dom: {
        tag: "div",
        classes: [
          "tox-tree--directory__label",
          "tox-trbtn"
        ].concat(a ? ["tox-tree--directory__label--visible"] : [])
      },
      components: x,
      action: k,
      eventOrder: {
        [ud()]: [
          ez,
          "keying"
        ]
      },
      buttonBehaviours: mn([
        ...a ? [Ea.config({})] : [],
        Hr(ez, [Pt(ud(), ($, B) => {
          const j = B.event.raw.code === "ArrowRight", Y = B.event.raw.code === "ArrowLeft";
          j && u && B.stop(), (j || Y) && zu($.element, ".tox-tree--directory").each((re) => {
            $.getSystem().getByDom(re).each((le) => {
              !Zr.isOn(le) && j || Zr.isOn(le) && Y ? (k($), B.stop()) : Y && !Zr.isOn(le) && (zu(le.element, ".tox-tree--directory").each((pe) => {
                s0(pe, ".tox-tree--directory__label").each((_e) => {
                  le.getSystem().getByDom(_e).each(Er.focus);
                });
              }), B.stop());
            });
          });
        })])
      ])
    });
  }, nX = ({ children: t, onLeafAction: a, visible: u, treeId: p, expandedIds: y, selectedId: x, backstage: k }) => ({
    dom: {
      tag: "div",
      classes: ["tox-tree--directory__children"]
    },
    components: t.map(($) => $.type === "leaf" ? fP({
      leaf: $,
      selectedId: x,
      onLeafAction: a,
      visible: u,
      treeId: p,
      backstage: k
    }) : pP({
      directory: $,
      expandedIds: y,
      selectedId: x,
      onLeafAction: a,
      labelTabstopping: u,
      treeId: p,
      backstage: k
    })),
    behaviours: mn([
      Cm.config({
        dimension: { property: "height" },
        closedClass: "tox-tree--directory__children--closed",
        openClass: "tox-tree--directory__children--open",
        growingClass: "tox-tree--directory__children--growing",
        shrinkingClass: "tox-tree--directory__children--shrinking",
        expanded: u
      }),
      $r.config({})
    ])
  }), rX = Hn("directory-event-id"), pP = ({ directory: t, onLeafAction: a, labelTabstopping: u, treeId: p, backstage: y, expandedIds: x, selectedId: k }) => {
    const { children: $ } = t, B = sr(x), j = (re) => $.map((le) => le.type === "leaf" ? fP({
      leaf: le,
      selectedId: k,
      onLeafAction: a,
      visible: re,
      treeId: p,
      backstage: y
    }) : pP({
      directory: le,
      expandedIds: B.get(),
      selectedId: k,
      onLeafAction: a,
      labelTabstopping: re,
      treeId: p,
      backstage: y
    })), Y = x.includes(t.id);
    return {
      dom: {
        tag: "div",
        classes: ["tox-tree--directory"],
        attributes: { role: "treeitem" }
      },
      components: [
        tX({
          directory: t,
          visible: u,
          noChildren: t.children.length === 0,
          backstage: y
        }),
        nX({
          children: $,
          expandedIds: x,
          selectedId: k,
          onLeafAction: a,
          visible: Y,
          treeId: p,
          backstage: y
        })
      ],
      behaviours: mn([
        Hr(rX, [
          us((re, le) => {
            Zr.set(re, Y);
          }),
          Pt("expand-tree-node", (re, le) => {
            const { expanded: pe, node: _e } = le.event;
            B.set(pe ? [
              ...B.get(),
              _e
            ] : B.get().filter((ze) => ze !== _e));
          })
        ]),
        Zr.config({
          ...t.children.length > 0 ? { aria: { mode: "expanded" } } : {},
          toggleClass: "tox-tree--directory--expanded",
          onToggled: (re, le) => {
            const pe = re.components()[1], _e = j(le);
            le ? Cm.grow(pe) : Cm.shrink(pe), $r.set(pe, _e);
          }
        })
      ])
    };
  }, oX = Hn("tree-event-id"), sX = (t, a) => {
    const u = t.onLeafAction.getOr(G), p = t.onToggleExpand.getOr(G), y = t.defaultExpandedIds, x = sr(y), k = sr(t.defaultSelectedId), $ = Hn("tree-id"), B = (j, Y) => t.items.map((re) => re.type === "leaf" ? fP({
      leaf: re,
      selectedId: j,
      onLeafAction: u,
      visible: !0,
      treeId: $,
      backstage: a
    }) : pP({
      directory: re,
      selectedId: j,
      onLeafAction: u,
      expandedIds: Y,
      labelTabstopping: !0,
      treeId: $,
      backstage: a
    }));
    return {
      dom: {
        tag: "div",
        classes: ["tox-tree"],
        attributes: { role: "tree" }
      },
      components: B(k.get(), x.get()),
      behaviours: mn([
        ar.config({
          mode: "flow",
          selector: ".tox-tree--leaf__label--visible, .tox-tree--directory__label--visible",
          cycles: !1
        }),
        Hr(oX, [Pt("expand-tree-node", (j, Y) => {
          const { expanded: re, node: le } = Y.event;
          x.set(re ? [
            ...x.get(),
            le
          ] : x.get().filter((pe) => pe !== le)), p(x.get(), {
            expanded: re,
            node: le
          });
        })]),
        vu.config({
          channels: {
            [`update-active-item-${$}`]: {
              onReceive: (j, Y) => {
                k.set(z.some(Y.value)), $r.set(j, B(z.some(Y.value), x.get()));
              }
            }
          }
        }),
        $r.config({})
      ])
    };
  };
  var tz = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: (t, a) => {
      const p = t.stream.streams.setup(t, a);
      return ls([
        Pt(t.event, p),
        Tf(() => a.cancel())
      ].concat(t.cancelEvent.map((y) => [Pt(y, () => a.cancel())]).getOr([])));
    }
  });
  const j3 = (t) => {
    const a = sr(null);
    return ol({
      readState: () => ({ timer: a.get() !== null ? "set" : "unset" }),
      setTimer: (x) => {
        a.set(x);
      },
      cancel: () => {
        const x = a.get();
        x !== null && x.cancel();
      }
    });
  };
  var aX = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    throttle: j3,
    init: (t) => t.stream.streams.state(t)
  });
  const nz = (t, a) => {
    const u = t.stream, p = oP(t.onStream, u.delay);
    return a.setTimer(p), (y, x) => {
      p.throttle(y, x), u.stopEvent && x.stop();
    };
  };
  var iX = [
    $c("stream", ro("mode", {
      throttle: [
        Mt("delay"),
        lt("stopEvent", !0),
        ds("streams", {
          setup: nz,
          state: j3
        })
      ]
    })),
    lt("event", "input"),
    Fo("cancelEvent"),
    mm("onStream")
  ];
  const q3 = Zi({
    fields: iX,
    name: "streaming",
    active: tz,
    state: aX
  }), Tr = (t, a, u) => {
    const p = Pn.getValue(u);
    Pn.setValue(a, p), G3(a);
  }, PT = (t, a) => {
    const u = t.element, p = Zm(u), y = u.dom;
    ca(u, "type") !== "number" && a(y, p);
  }, G3 = (t) => {
    PT(t, (a, u) => a.setSelectionRange(u.length, u.length));
  }, rz = (t, a) => {
    PT(t, (u, p) => u.setSelectionRange(a, p.length));
  }, oz = (t, a, u) => {
    if (t.selectsOver) {
      const p = Pn.getValue(a), y = t.getDisplayText(p), x = Pn.getValue(u);
      return t.getDisplayText(x).indexOf(y) === 0 ? z.some(() => {
        Tr(t, a, u), rz(a, y.length);
      }) : z.none();
    } else
      return z.none();
  }, hP = q("alloy.typeahead.itemexecute"), sz = (t, a, u, p) => {
    const y = (re, le, pe) => {
      t.previewing.set(!1);
      const _e = yi.getCoupled(re, "sandbox");
      if (bo.isOpen(_e))
        ho.getCurrent(_e).each((ze) => {
          Wo.getHighlighted(ze).fold(() => {
            pe(ze);
          }, () => {
            W1(_e, ze.element, "keydown", le);
          });
        });
      else {
        const ze = (ft) => {
          ho.getCurrent(ft).each(pe);
        };
        MR(t, k(re), re, _e, p, ze, Sd.HighlightMenuAndItem).get(G);
      }
    }, x = Y6(t), k = (re) => (le) => le.map((pe) => {
      const _e = fl(pe.menus), ze = ke(_e, (Xe) => Rn(Xe.items, (Ze) => Ze.type === "item"));
      return Pn.getState(re).update(He(ze, (Xe) => Xe.data)), pe;
    }), $ = (re) => ho.getCurrent(re), B = "typeaheadevents", j = [
      Er.config({}),
      Pn.config({
        onSetValue: t.onSetValue,
        store: {
          mode: "dataset",
          getDataKey: (re) => Zm(re.element),
          getFallbackEntry: (re) => ({
            value: re,
            meta: {}
          }),
          setValue: (re, le) => {
            wb(re.element, t.model.getDisplayText(le));
          },
          ...t.initialData.map((re) => Sn("initialValue", re)).getOr({})
        }
      }),
      q3.config({
        stream: {
          mode: "throttle",
          delay: t.responseTime,
          stopEvent: !1
        },
        onStream: (re, le) => {
          const pe = yi.getCoupled(re, "sandbox");
          if (Er.isFocused(re) && Zm(re.element).length >= t.minChars) {
            const ze = $(pe).bind((Xe) => Wo.getHighlighted(Xe).map(Pn.getValue));
            t.previewing.set(!0);
            const ft = (Xe) => {
              $(pe).each((Ze) => {
                ze.fold(() => {
                  t.model.selectsOver && Wo.highlightFirst(Ze);
                }, (mt) => {
                  Wo.highlightBy(Ze, (jt) => Pn.getValue(jt).value === mt.value), Wo.getHighlighted(Ze).orThunk(() => (Wo.highlightFirst(Ze), z.none()));
                });
              });
            };
            MR(t, k(re), re, pe, p, ft, Sd.HighlightJustMenu).get(G);
          }
        },
        cancelEvent: _y()
      }),
      ar.config({
        mode: "special",
        onDown: (re, le) => (y(re, le, Wo.highlightFirst), z.some(!0)),
        onEscape: (re) => {
          const le = yi.getCoupled(re, "sandbox");
          return bo.isOpen(le) ? (bo.close(le), z.some(!0)) : z.none();
        },
        onUp: (re, le) => (y(re, le, Wo.highlightLast), z.some(!0)),
        onEnter: (re) => {
          const le = yi.getCoupled(re, "sandbox"), pe = bo.isOpen(le);
          if (pe && !t.previewing.get())
            return $(le).bind((_e) => Wo.getHighlighted(_e)).map((_e) => (nr(re, hP(), { item: _e }), !0));
          {
            const _e = Pn.getValue(re);
            return Jr(re, _y()), t.onExecute(le, re, _e), pe && bo.close(le), z.some(!0);
          }
        }
      }),
      Zr.config({
        toggleClass: t.markers.openClass,
        aria: { mode: "expanded" }
      }),
      yi.config({
        others: {
          sandbox: (re) => WF(t, re, {
            onOpen: () => Zr.on(re),
            onClose: () => {
              t.lazyTypeaheadComp.get().each((le) => vs(le.element, "aria-activedescendant")), Zr.off(re);
            }
          })
        }
      }),
      Hr(B, [
        us((re) => {
          t.lazyTypeaheadComp.set(z.some(re));
        }),
        Tf((re) => {
          t.lazyTypeaheadComp.set(z.none());
        }),
        Ul((re) => {
          const le = G;
          UF(t, k(re), re, p, le, Sd.HighlightMenuAndItem).get(G);
        }),
        Pt(hP(), (re, le) => {
          const pe = yi.getCoupled(re, "sandbox");
          Tr(t.model, re, le.event.item), Jr(re, _y()), t.onItemExecute(re, pe, le.event.item, Pn.getValue(re)), bo.close(pe), G3(re);
        })
      ].concat(t.dismissOnBlur ? [Pt(Vp(), (re) => {
        const le = yi.getCoupled(re, "sandbox");
        Nf(le.element).isNone() && bo.close(le);
      })] : []))
    ], Y = {
      [Vd()]: [
        Pn.name(),
        q3.name(),
        B
      ],
      ...t.eventOrder
    };
    return {
      uid: t.uid,
      dom: Q6(Vo(t, {
        inputAttributes: {
          role: "combobox",
          "aria-autocomplete": "list",
          "aria-haspopup": "true"
        }
      })),
      behaviours: {
        ...x,
        ..._i(t.typeaheadBehaviours, j)
      },
      eventOrder: Y
    };
  }, Kce = q([
    Fo("lazySink"),
    Mt("fetch"),
    lt("minChars", 5),
    lt("responseTime", 1e3),
    po("onOpen"),
    lt("getHotspot", z.some),
    lt("getAnchorOverrides", q({})),
    lt("layouts", z.none()),
    lt("eventOrder", {}),
    vf("model", {}, [
      lt("getDisplayText", (t) => t.meta !== void 0 && t.meta.text !== void 0 ? t.meta.text : t.value),
      lt("selectsOver", !0),
      lt("populateFromBrowse", !0)
    ]),
    po("onSetValue"),
    Uu("onExecute"),
    po("onItemExecute"),
    lt("inputClasses", []),
    lt("inputAttributes", {}),
    lt("inputStyles", {}),
    lt("matchWidth", !0),
    lt("useMinWidth", !1),
    lt("dismissOnBlur", !0),
    eg(["openClass"]),
    Fo("initialData"),
    ac("typeaheadBehaviours", [
      Er,
      Pn,
      q3,
      ar,
      Zr,
      yi
    ]),
    Ts("lazyTypeaheadComp", () => sr(z.none)),
    Ts("previewing", () => sr(!0))
  ].concat(K6()).concat(jF())), QO = q([rp({
    schema: [Dy()],
    name: "menu",
    overrides: (t) => ({
      fakeFocus: !0,
      onHighlightItem: (a, u, p) => {
        t.previewing.get() ? t.lazyTypeaheadComp.get().each((y) => {
          oz(t.model, y, p).fold(() => {
            t.model.selectsOver ? (Wo.dehighlight(u, p), t.previewing.set(!0)) : t.previewing.set(!1);
          }, (x) => {
            x(), t.previewing.set(!1);
          });
        }) : t.lazyTypeaheadComp.get().each((y) => {
          t.model.populateFromBrowse && Tr(t.model, y, p), as(p.element, "id").each((x) => kn(y.element, "aria-activedescendant", x));
        });
      },
      onExecute: (a, u) => t.lazyTypeaheadComp.get().map((p) => (nr(p, hP(), { item: u }), !0)),
      onHover: (a, u) => {
        t.previewing.set(!1), t.lazyTypeaheadComp.get().each((p) => {
          t.model.populateFromBrowse && Tr(t.model, p, u);
        });
      }
    })
  })]), cX = ql({
    name: "Typeahead",
    configFields: Kce(),
    partFields: QO(),
    factory: sz
  }), Sh = (t) => ({
    ...t,
    toCached: () => Sh(t.toCached()),
    bindFuture: (B) => Sh(t.bind((j) => j.fold((Y) => wu.pure(Rr.error(Y)), (Y) => B(Y)))),
    bindResult: (B) => Sh(t.map((j) => j.bind(B))),
    mapResult: (B) => Sh(t.map((j) => j.map(B))),
    mapError: (B) => Sh(t.map((j) => j.mapError(B))),
    foldResult: (B, j) => t.map((Y) => Y.fold(B, j)),
    withTimeout: (B, j) => Sh(wu.nu((Y) => {
      let re = !1;
      const le = setTimeout(() => {
        re = !0, Y(Rr.error(j()));
      }, B);
      t.get((pe) => {
        re || (clearTimeout(le), Y(pe));
      });
    }))
  }), az = (t) => Sh(wu.nu(t)), iz = (t) => Sh(wu.pure(Rr.value(t))), dX = {
    nu: az,
    wrap: Sh,
    pure: iz,
    value: iz,
    error: (t) => Sh(wu.pure(Rr.error(t))),
    fromResult: (t) => Sh(wu.pure(t)),
    fromFuture: (t) => Sh(t.map(Rr.value)),
    fromPromise: (t) => az((a) => {
      t.then((u) => {
        a(Rr.value(u));
      }, (u) => {
        a(Rr.error(u));
      });
    })
  }, gP = (t, a, u = [], p, y, x) => {
    const k = a.fold(() => ({}), (j) => ({ action: j })), $ = {
      buttonBehaviours: mn([
        ip.button(() => !t.enabled || x.isDisabled()),
        Bc(),
        Ea.config({}),
        Hr("button press", [
          sw("click"),
          sw("mousedown")
        ])
      ].concat(u)),
      eventOrder: {
        click: [
          "button press",
          "alloy.base.behaviour"
        ],
        mousedown: [
          "button press",
          "alloy.base.behaviour"
        ]
      },
      ...k
    }, B = Vo($, { dom: p });
    return Vo(B, { components: y });
  }, fX = (t, a, u, p = []) => {
    const y = t.tooltip.map((B) => ({
      "aria-label": u.translate(B),
      title: u.translate(B)
    })).getOr({}), x = {
      tag: "button",
      classes: ["tox-tbtn"],
      attributes: y
    }, k = t.icon.map((B) => P3(B, u.icons)), $ = kE([k]);
    return gP(t, a, p, x, $, u);
  }, Z3 = (t) => {
    switch (t) {
      case "primary":
        return ["tox-button"];
      case "toolbar":
        return ["tox-tbtn"];
      case "secondary":
      default:
        return [
          "tox-button",
          "tox-button--secondary"
        ];
    }
  }, lz = (t, a, u, p = [], y = []) => {
    const x = u.translate(t.text), k = t.icon.map((le) => P3(le, u.icons)), $ = [k.getOrThunk(() => Ma(x))], B = t.buttonType.getOr(!t.primary && !t.borderless ? "secondary" : "primary"), re = {
      tag: "button",
      classes: [
        ...Z3(B),
        ...k.isSome() ? ["tox-button--icon"] : [],
        ...t.borderless ? ["tox-button--naked"] : [],
        ...y
      ],
      attributes: { title: x }
    };
    return gP(t, a, p, re, $, u);
  }, K3 = (t, a, u, p = [], y = []) => {
    const x = lz(t, z.some(a), u, p, y);
    return cl.sketch(x);
  }, uz = (t, a) => (u) => {
    a === "custom" ? nr(u, Xb, {
      name: t,
      value: {}
    }) : a === "submit" ? Jr(u, FO) : a === "cancel" ? Jr(u, oS) : console.error("Unknown button type: ", a);
  }, mX = (t, a) => a === "menu", pX = (t, a) => a === "custom" || a === "cancel" || a === "submit", hX = (t, a) => a === "togglebutton", gX = (t, a) => {
    var u, p;
    const y = t.icon.map((Ze) => lS(Ze, a.icons)).map(ms), x = (Ze) => {
      nr(Ze, Xb, {
        name: t.name,
        value: {
          setIcon: (mt) => {
            y.map((jt) => jt.getOpt(Ze).each((Dt) => {
              $r.set(Dt, [lS(mt, a.icons)]);
            }));
          }
        }
      });
    }, k = t.buttonType.getOr(t.primary ? "primary" : "secondary"), $ = {
      ...t,
      name: (u = t.name) !== null && u !== void 0 ? u : "",
      primary: k === "primary",
      tooltip: z.from(t.tooltip),
      enabled: (p = t.enabled) !== null && p !== void 0 ? p : !1,
      borderless: !1
    }, B = $.tooltip.map((Ze) => ({
      "aria-label": a.translate(Ze),
      title: a.translate(Ze)
    })).getOr({}), j = Z3(k ?? "secondary"), Y = t.icon.isSome() && t.text.isSome(), re = {
      tag: "button",
      classes: [
        ...j.concat(t.icon.isSome() ? ["tox-button--icon"] : []),
        ...t.active ? ["tox-button--enabled"] : [],
        ...Y ? ["tox-button--icon-and-text"] : []
      ],
      attributes: B
    }, le = [], pe = a.translate(t.text.getOr("")), _e = Ma(pe), ft = [
      ...kE([y.map((Ze) => Ze.asSpec())]),
      ...t.text.isSome() ? [_e] : []
    ], Xe = gP($, z.some(x), le, re, ft, a);
    return cl.sketch(Xe);
  }, vP = (t, a, u) => {
    if (mX(t, a)) {
      const p = () => k, y = t, x = {
        ...t,
        type: "menubutton",
        search: z.none(),
        onSetup: ($) => ($.setEnabled(t.enabled), G),
        fetch: eX(y.items, p, u)
      }, k = ms(YO(x, "tox-tbtn", u, z.none()));
      return k.asSpec();
    } else if (pX(t, a)) {
      const p = uz(t.name, a), y = {
        ...t,
        borderless: !1
      };
      return K3(y, p, u.shared.providers, []);
    } else {
      if (hX(t, a))
        return gX(t, u.shared.providers);
      throw console.error("Unknown footer button type: ", a), new Error("Unknown footer button type");
    }
  }, vX = (t, a) => {
    const u = uz(t.name, "custom");
    return oY(z.none(), ps.parts.field({
      factory: cl,
      ...lz(t, z.some(u), a, [
        rP(""),
        zf.self()
      ])
    }));
  }, bX = { type: "separator" }, yX = (t) => ({
    type: "menuitem",
    value: t.url,
    text: t.title,
    meta: { attach: t.attach },
    onAction: G
  }), Y3 = (t, a) => ({
    type: "menuitem",
    value: a,
    text: t,
    meta: { attach: void 0 },
    onAction: G
  }), SX = (t) => He(t, yX), dz = (t, a) => Rn(a, (u) => u.type === t), fz = (t, a) => SX(dz(t, a)), wX = (t) => fz("header", t.targets), EX = (t) => fz("anchor", t.targets), CX = (t) => z.from(t.anchorTop).map((a) => Y3("<top>", a)).toArray(), xX = (t) => z.from(t.anchorBottom).map((a) => Y3("<bottom>", a)).toArray(), TX = (t) => He(t, (a) => Y3(a, a)), mz = (t) => Jt(t, (a, u) => a.length === 0 || u.length === 0 ? a.concat(u) : a.concat(bX, u), []), Q3 = (t, a) => {
    const u = t.toLowerCase();
    return Rn(a, (p) => {
      var y;
      const x = p.meta !== void 0 && p.meta.text !== void 0 ? p.meta.text : p.text, k = (y = p.value) !== null && y !== void 0 ? y : "";
      return Xa(x.toLowerCase(), u) || Xa(k.toLowerCase(), u);
    });
  }, pz = (t, a, u) => {
    var p, y;
    const x = Pn.getValue(a), k = (y = (p = x == null ? void 0 : x.meta) === null || p === void 0 ? void 0 : p.text) !== null && y !== void 0 ? y : x.value;
    return u.getLinkInformation().fold(() => [], (B) => {
      const j = Q3(k, TX(u.getHistory(t)));
      return t === "file" ? mz([
        j,
        Q3(k, wX(B)),
        Q3(k, St([
          CX(B),
          EX(B),
          xX(B)
        ]))
      ]) : j;
    });
  }, hz = Hn("aria-invalid"), gz = (t, a, u, p) => {
    const y = a.shared.providers, x = (Ze) => {
      const mt = Pn.getValue(Ze);
      u.addToHistory(mt.value, t.filetype);
    }, k = {
      ...p.map((Ze) => ({ initialData: Ze })).getOr({}),
      dismissOnBlur: !0,
      inputClasses: ["tox-textfield"],
      sandboxClasses: ["tox-dialog__popups"],
      inputAttributes: {
        "aria-errormessage": hz,
        type: "url"
      },
      minChars: 0,
      responseTime: 0,
      fetch: (Ze) => {
        const mt = pz(t.filetype, Ze, u), jt = RT(mt, Cv.BUBBLE_TO_SANDBOX, a, {
          isHorizontalMenu: !1,
          search: z.none()
        });
        return wu.pure(jt);
      },
      getHotspot: (Ze) => _e.getOpt(Ze),
      onSetValue: (Ze, mt) => {
        Ze.hasConfigured(cp) && cp.run(Ze).get(G);
      },
      typeaheadBehaviours: mn([
        ...u.getValidationHandler().map((Ze) => cp.config({
          getRoot: (mt) => $l(mt.element),
          invalidClass: "tox-control-wrap--status-invalid",
          notify: {
            onInvalid: (mt, jt) => {
              Y.getOpt(mt).each((Dt) => {
                kn(Dt.element, "title", y.translate(jt));
              });
            }
          },
          validator: {
            validate: (mt) => {
              const jt = Pn.getValue(mt);
              return dX.nu((Dt) => {
                Ze({
                  type: t.filetype,
                  url: jt.value
                }, (Nt) => {
                  if (Nt.status === "invalid") {
                    const hn = Rr.error(Nt.message);
                    Dt(hn);
                  } else {
                    const hn = Rr.value(Nt.message);
                    Dt(hn);
                  }
                });
              });
            },
            validateOnLoad: !1
          }
        })).toArray(),
        yr.config({ disabled: () => !t.enabled || y.isDisabled() }),
        Ea.config({}),
        Hr("urlinput-events", [
          Pt(Vm(), (Ze) => {
            const mt = Zm(Ze.element), jt = mt.trim();
            jt !== mt && wb(Ze.element, jt), t.filetype === "file" && nr(Ze, Bf, { name: t.name });
          }),
          Pt(Gg(), (Ze) => {
            nr(Ze, Bf, { name: t.name }), x(Ze);
          }),
          Pt(Up(), (Ze) => {
            nr(Ze, Bf, { name: t.name }), x(Ze);
          })
        ])
      ]),
      eventOrder: {
        [Vm()]: [
          "streaming",
          "urlinput-events",
          "invalidating"
        ]
      },
      model: {
        getDisplayText: (Ze) => Ze.value,
        selectsOver: !1,
        populateFromBrowse: !1
      },
      markers: { openClass: "tox-textfield--popup-open" },
      lazySink: a.shared.getSink,
      parts: { menu: pT(!1, 1, "normal") },
      onExecute: (Ze, mt, jt) => {
        nr(mt, FO, {});
      },
      onItemExecute: (Ze, mt, jt, Dt) => {
        x(Ze), nr(Ze, Bf, { name: t.name });
      }
    }, $ = ps.parts.field({
      ...k,
      factory: cX
    }), B = t.label.map((Ze) => yh(Ze, y)), Y = ms(((Ze, mt, jt = Ze, Dt = Ze) => mg(jt, {
      tag: "div",
      classes: [
        "tox-icon",
        "tox-control-wrap__status-icon-" + Ze
      ],
      attributes: {
        title: y.translate(Dt),
        "aria-live": "polite",
        ...mt.fold(() => ({}), (Nt) => ({ id: Nt }))
      }
    }, y.icons))("invalid", z.some(hz), "warning")), re = ms({
      dom: {
        tag: "div",
        classes: ["tox-control-wrap__status-icon-wrap"]
      },
      components: [Y.asSpec()]
    }), le = u.getUrlPicker(t.filetype), pe = Hn("browser.url.event"), _e = ms({
      dom: {
        tag: "div",
        classes: ["tox-control-wrap"]
      },
      components: [
        $,
        re.asSpec()
      ],
      behaviours: mn([yr.config({ disabled: () => !t.enabled || y.isDisabled() })])
    }), ze = ms(K3({
      name: t.name,
      icon: z.some("browse"),
      text: t.picker_text.or(t.label).getOr(""),
      enabled: t.enabled,
      primary: !1,
      buttonType: z.none(),
      borderless: !0
    }, (Ze) => Jr(Ze, pe), y, [], ["tox-browse-url"])), ft = () => ({
      dom: {
        tag: "div",
        classes: ["tox-form__controls-h-stack"]
      },
      components: St([
        [_e.asSpec()],
        le.map(() => ze.asSpec()).toArray()
      ])
    }), Xe = (Ze) => {
      ho.getCurrent(Ze).each((mt) => {
        const jt = Pn.getValue(mt), Dt = {
          fieldname: t.name,
          ...jt
        };
        le.each((Nt) => {
          Nt(Dt).get((hn) => {
            Pn.setValue(mt, hn), nr(Ze, Bf, { name: t.name });
          });
        });
      });
    };
    return ps.sketch({
      dom: Bce(),
      components: B.toArray().concat([ft()]),
      fieldBehaviours: mn([
        yr.config({
          disabled: () => !t.enabled || y.isDisabled(),
          onDisabled: (Ze) => {
            ps.getField(Ze).each(yr.disable), ze.getOpt(Ze).each(yr.disable);
          },
          onEnabled: (Ze) => {
            ps.getField(Ze).each(yr.enable), ze.getOpt(Ze).each(yr.enable);
          }
        }),
        Bc(),
        Hr("url-input-events", [Pt(pe, Xe)])
      ])
    });
  }, vz = (t, a) => {
    const u = b6(t.icon, a.icons);
    return Tv.sketch({
      dom: {
        tag: "div",
        attributes: { role: "alert" },
        classes: [
          "tox-notification",
          "tox-notification--in",
          `tox-notification--${t.level}`
        ]
      },
      components: [
        {
          dom: {
            tag: "div",
            classes: ["tox-notification__icon"],
            innerHtml: t.url ? void 0 : u
          },
          components: t.url ? [cl.sketch({
            dom: {
              tag: "button",
              classes: [
                "tox-button",
                "tox-button--naked",
                "tox-button--icon"
              ],
              innerHtml: u,
              attributes: { title: a.translate(t.iconTooltip) }
            },
            action: (p) => nr(p, Xb, {
              name: "alert-banner",
              value: t.url
            }),
            buttonBehaviours: mn([jN()])
          })] : void 0
        },
        {
          dom: {
            tag: "div",
            classes: ["tox-notification__body"],
            innerHtml: a.translate(t.text)
          }
        }
      ]
    });
  }, X3 = (t, a) => {
    t.dom.checked = a;
  }, _X = (t) => t.dom.checked, bz = (t, a, u) => {
    const p = (B) => (B.element.dom.click(), z.some(!0)), y = ps.parts.field({
      factory: { sketch: Te },
      dom: {
        tag: "input",
        classes: ["tox-checkbox__input"],
        attributes: { type: "checkbox" }
      },
      behaviours: mn([
        zf.self(),
        yr.config({
          disabled: () => !t.enabled || a.isDisabled(),
          onDisabled: (B) => {
            $l(B.element).each((j) => ja(j, "tox-checkbox--disabled"));
          },
          onEnabled: (B) => {
            $l(B.element).each((j) => ua(j, "tox-checkbox--disabled"));
          }
        }),
        Ea.config({}),
        Er.config({}),
        E3(u, _X, X3),
        ar.config({
          mode: "special",
          onEnter: p,
          onSpace: p,
          stopSpaceKeyup: !0
        }),
        Hr("checkbox-events", [Pt(Gg(), (B, j) => {
          nr(B, Bf, { name: t.name });
        })])
      ])
    }), x = ps.parts.label({
      dom: {
        tag: "span",
        classes: ["tox-checkbox__label"]
      },
      components: [Ma(a.translate(t.label))],
      behaviours: mn([LO.config({})])
    }), k = (B) => mg(B === "checked" ? "selected" : "unselected", {
      tag: "span",
      classes: [
        "tox-icon",
        "tox-checkbox-icon__" + B
      ]
    }, a.icons), $ = ms({
      dom: {
        tag: "div",
        classes: ["tox-checkbox__icons"]
      },
      components: [
        k("checked"),
        k("unchecked")
      ]
    });
    return ps.sketch({
      dom: {
        tag: "label",
        classes: ["tox-checkbox"]
      },
      components: [
        y,
        $.asSpec(),
        x
      ],
      fieldBehaviours: mn([
        yr.config({ disabled: () => !t.enabled || a.isDisabled() }),
        Bc()
      ])
    });
  }, yz = (t) => t.presets === "presentation" ? Tv.sketch({
    dom: {
      tag: "div",
      classes: ["tox-form__group"],
      innerHtml: t.html
    }
  }) : Tv.sketch({
    dom: {
      tag: "div",
      classes: ["tox-form__group"],
      innerHtml: t.html,
      attributes: { role: "document" }
    },
    containerBehaviours: mn([
      Ea.config({}),
      Er.config({})
    ])
  }), zc = (t) => (a, u, p, y) => fn(u, "name").fold(() => t(u, y, z.none()), (x) => a.field(x, t(u, y, fn(p, x)))), Sz = (t) => (a, u, p, y) => {
    const x = Vo(u, { source: "dynamic" });
    return zc(t)(a, x, p, y);
  }, OX = {
    bar: zc((t, a) => XK(t, a.shared)),
    collection: zc((t, a, u) => aY(t, a.shared.providers, u)),
    alertbanner: zc((t, a) => vz(t, a.shared.providers)),
    input: zc((t, a, u) => W7(t, a.shared.providers, u)),
    textarea: zc((t, a, u) => j7(t, a.shared.providers, u)),
    label: zc((t, a) => N7(t, a.shared)),
    iframe: Sz((t, a, u) => OQ(t, a.shared.providers, u)),
    button: zc((t, a) => vX(t, a.shared.providers)),
    checkbox: zc((t, a, u) => bz(t, a.shared.providers, u)),
    colorinput: zc((t, a, u) => fY(t, a.shared, a.colorinput, u)),
    colorpicker: zc((t, a, u) => vQ(t, a.shared.providers, u)),
    dropzone: zc((t, a, u) => yQ(t, a.shared.providers, u)),
    grid: zc((t, a) => C7(t, a.shared)),
    listbox: zc((t, a, u) => M3(t, a, u)),
    selectbox: zc((t, a, u) => GO(t, a.shared.providers, u)),
    sizeinput: zc((t, a) => V7(t, a.shared.providers)),
    slider: zc((t, a, u) => U7(t, a.shared.providers, u)),
    urlinput: zc((t, a, u) => gz(t, a, a.urlinput, u)),
    customeditor: zc(w7),
    htmlpanel: zc(yz),
    imagepreview: zc((t, a, u) => NQ(t, u)),
    table: zc((t, a) => WQ(t, a.shared.providers)),
    tree: zc((t, a) => sX(t, a)),
    panel: zc((t, a) => LQ(t, a))
  }, AX = {
    field: (t, a) => a,
    record: q([])
  }, yg = (t, a, u, p) => {
    const y = Vo(p, { shared: { interpreter: (x) => DT(t, x, u, y) } });
    return DT(t, a, u, y);
  }, DT = (t, a, u, p) => fn(OX, a.type).fold(() => (console.error(`Unknown factory type "${a.type}", defaulting to container: `, a), a), (y) => y(t, a, u, p)), XO = (t, a, u) => DT(AX, t, a, u), dS = "layout-inset", JO = (t) => t.x, wz = (t, a) => t.x + t.width / 2 - a.width / 2, eA = (t, a) => t.x + t.width - a.width, bP = (t) => t.y, tA = (t, a) => t.y + t.height - a.height, Ez = (t, a) => t.y + t.height / 2 - a.height / 2, nA = (t, a, u) => bi(eA(t, a), tA(t, a), u.insetSouthwest(), qd(), "southwest", sa(t, {
    right: 0,
    bottom: 3
  }), dS), rA = (t, a, u) => bi(JO(t), tA(t, a), u.insetSoutheast(), u0(), "southeast", sa(t, {
    left: 1,
    bottom: 3
  }), dS), LE = (t, a, u) => bi(eA(t, a), bP(t), u.insetNorthwest(), yw(), "northwest", sa(t, {
    right: 0,
    top: 2
  }), dS), oA = (t, a, u) => bi(JO(t), bP(t), u.insetNortheast(), Iy(), "northeast", sa(t, {
    left: 1,
    top: 2
  }), dS), Sg = (t, a, u) => bi(wz(t, a), bP(t), u.insetNorth(), kf(), "north", sa(t, { top: 2 }), dS), $T = (t, a, u) => bi(wz(t, a), tA(t, a), u.insetSouth(), Z2(), "south", sa(t, { bottom: 3 }), dS), Cz = (t, a, u) => bi(eA(t, a), Ez(t, a), u.insetEast(), av(), "east", sa(t, { right: 0 }), dS), xz = (t, a, u) => bi(JO(t), Ez(t, a), u.insetWest(), yt(), "west", sa(t, { left: 1 }), dS), Tz = (t) => {
    switch (t) {
      case "north":
        return Sg;
      case "northeast":
        return oA;
      case "northwest":
        return LE;
      case "south":
        return $T;
      case "southeast":
        return rA;
      case "southwest":
        return nA;
      case "east":
        return Cz;
      case "west":
        return xz;
    }
  }, J3 = (t, a, u, p, y) => dx(p).map(Tz).getOr(Sg)(t, a, u, p, y), kX = (t) => {
    switch (t) {
      case "north":
        return $T;
      case "northeast":
        return rA;
      case "northwest":
        return nA;
      case "south":
        return Sg;
      case "southeast":
        return oA;
      case "southwest":
        return LE;
      case "east":
        return xz;
      case "west":
        return Cz;
    }
  }, NX = (t, a, u, p, y) => dx(p).map(kX).getOr(Sg)(t, a, u, p, y), sA = {
    valignCentre: [],
    alignCentre: [],
    alignLeft: [],
    alignRight: [],
    right: [],
    left: [],
    bottom: [],
    top: []
  }, RX = (t, a, u) => {
    const y = { maxHeightFunction: vm() }, x = () => ({
      type: "node",
      root: en(wt(t())),
      node: z.from(t()),
      bubble: ep(12, 12, sA),
      layouts: {
        onRtl: () => [oA],
        onLtr: () => [LE]
      },
      overrides: y
    }), k = () => ({
      type: "hotspot",
      hotspot: a(),
      bubble: ep(-12, 12, sA),
      layouts: {
        onRtl: () => [
          Wi,
          Mc,
          Os
        ],
        onLtr: () => [
          Mc,
          Wi,
          Os
        ]
      },
      overrides: y
    });
    return () => u() ? x() : k();
  }, _z = (t, a, u, p) => {
    const x = { maxHeightFunction: vm() }, k = () => ({
      type: "node",
      root: en(wt(a())),
      node: z.from(a()),
      bubble: ep(12, 12, sA),
      layouts: {
        onRtl: () => [Sg],
        onLtr: () => [Sg]
      },
      overrides: x
    }), $ = () => t ? {
      type: "node",
      root: en(wt(a())),
      node: z.from(a()),
      bubble: ep(0, -af(a()), sA),
      layouts: {
        onRtl: () => [El],
        onLtr: () => [El]
      },
      overrides: x
    } : {
      type: "hotspot",
      hotspot: u(),
      bubble: ep(0, 0, sA),
      layouts: {
        onRtl: () => [El],
        onLtr: () => [El]
      },
      overrides: x
    };
    return () => p() ? k() : $();
  }, Av = (t, a, u) => {
    const p = () => ({
      type: "node",
      root: en(wt(t())),
      node: z.from(t()),
      layouts: {
        onRtl: () => [Sg],
        onLtr: () => [Sg]
      }
    }), y = () => ({
      type: "hotspot",
      hotspot: a(),
      layouts: {
        onRtl: () => [Os],
        onLtr: () => [Os]
      }
    });
    return () => u() ? p() : y();
  }, e4 = (t, a) => () => ({
    type: "selection",
    root: a(),
    getSelection: () => {
      const u = t.selection.getRng(), p = t.model.table.getSelectedCells();
      if (p.length > 1) {
        const y = p[0], x = p[p.length - 1], k = {
          firstCell: nt.fromDom(y),
          lastCell: nt.fromDom(x)
        };
        return z.some(k);
      }
      return z.some(Tc.range(nt.fromDom(u.startContainer), u.startOffset, nt.fromDom(u.endContainer), u.endOffset));
    }
  }), PX = (t) => (a) => ({
    type: "node",
    root: t(),
    node: a
  }), DX = (t, a, u, p) => {
    const y = K0(t), x = () => nt.fromDom(t.getBody()), k = () => nt.fromDom(t.getContentAreaContainer()), $ = () => y || !p();
    return {
      inlineDialog: RX(k, a, $),
      inlineBottomDialog: _z(t.inline, k, u, $),
      banner: Av(k, a, $),
      cursor: e4(t, x),
      node: PX(x)
    };
  }, $X = (t) => (a, u) => {
    iH(t)(a, u);
  }, IX = (t) => () => tH(t), MX = (t) => (a) => RR(t, a), Oz = (t) => (a) => eH(t, a), Az = (t) => ({
    colorPicker: $X(t),
    hasCustomColors: IX(t),
    getColors: MX(t),
    getColorCols: Oz(t)
  }), Qce = (t) => () => R6(t), Xce = (t) => ({ isDraggableModal: Qce(t) }), Eu = (t) => {
    const a = sr(LM(t) ? "bottom" : "top");
    return {
      isPositionedAtTop: () => a.get() === "top",
      getDockingMode: a.get,
      setDockingMode: a.set
    };
  }, yP = (t) => xa(t, "items"), kz = (t) => xa(t, "format"), aA = [
    {
      title: "Headings",
      items: [
        {
          title: "Heading 1",
          format: "h1"
        },
        {
          title: "Heading 2",
          format: "h2"
        },
        {
          title: "Heading 3",
          format: "h3"
        },
        {
          title: "Heading 4",
          format: "h4"
        },
        {
          title: "Heading 5",
          format: "h5"
        },
        {
          title: "Heading 6",
          format: "h6"
        }
      ]
    },
    {
      title: "Inline",
      items: [
        {
          title: "Bold",
          format: "bold"
        },
        {
          title: "Italic",
          format: "italic"
        },
        {
          title: "Underline",
          format: "underline"
        },
        {
          title: "Strikethrough",
          format: "strikethrough"
        },
        {
          title: "Superscript",
          format: "superscript"
        },
        {
          title: "Subscript",
          format: "subscript"
        },
        {
          title: "Code",
          format: "code"
        }
      ]
    },
    {
      title: "Blocks",
      items: [
        {
          title: "Paragraph",
          format: "p"
        },
        {
          title: "Blockquote",
          format: "blockquote"
        },
        {
          title: "Div",
          format: "div"
        },
        {
          title: "Pre",
          format: "pre"
        }
      ]
    },
    {
      title: "Align",
      items: [
        {
          title: "Left",
          format: "alignleft"
        },
        {
          title: "Center",
          format: "aligncenter"
        },
        {
          title: "Right",
          format: "alignright"
        },
        {
          title: "Justify",
          format: "alignjustify"
        }
      ]
    }
  ], FX = (t) => Yr(t, "items"), LX = (t) => Yr(t, "block"), BX = (t) => Yr(t, "inline"), HX = (t) => Yr(t, "selector"), Nz = (t) => Jt(t, (a, u) => {
    if (FX(u)) {
      const p = Nz(u.items);
      return {
        customFormats: a.customFormats.concat(p.customFormats),
        formats: a.formats.concat([{
          title: u.title,
          items: p.formats
        }])
      };
    } else if (BX(u) || LX(u) || HX(u)) {
      const y = `custom-${g(u.name) ? u.name : u.title.toLowerCase()}`;
      return {
        customFormats: a.customFormats.concat([{
          name: y,
          format: u
        }]),
        formats: a.formats.concat([{
          title: u.title,
          format: y,
          icon: u.icon
        }])
      };
    } else
      return {
        ...a,
        formats: a.formats.concat(u)
      };
  }, {
    customFormats: [],
    formats: []
  }), zX = (t, a) => {
    const u = Nz(a), p = (y) => {
      ut(y, (x) => {
        t.formatter.has(x.name) || t.formatter.register(x.name, x.format);
      });
    };
    return t.formatter ? p(u.customFormats) : t.on("init", () => {
      p(u.customFormats);
    }), u.formats;
  }, Rz = (t) => RM(t).map((a) => {
    const u = zX(t, a);
    return E6(t) ? aA.concat(u) : u;
  }).getOr(aA), VX = (t) => {
    const a = Xr(t);
    return a.length === 1 && vt(a, "title");
  }, t4 = (t, a, u) => ({
    ...t,
    type: "formatter",
    isSelected: a(t.format),
    getStylePreview: u(t.format)
  }), iA = (t, a, u, p) => {
    const y = (B) => t4(B, u, p), x = (B) => {
      const j = $(B.items);
      return {
        ...B,
        type: "submenu",
        getStyleItems: q(j)
      };
    }, k = (B) => {
      const j = g(B.name) ? B.name : Hn(B.title), Y = `custom-${j}`, re = {
        ...B,
        type: "formatter",
        format: Y,
        isSelected: u(Y),
        getStylePreview: p(Y)
      };
      return t.formatter.register(j, re), re;
    }, $ = (B) => He(B, (j) => yP(j) ? x(j) : kz(j) ? y(j) : VX(j) ? {
      ...j,
      type: "separator"
    } : k(j));
    return $(a);
  }, UX = (t) => {
    const a = ($) => () => t.formatter.match($), u = ($) => () => {
      const B = t.formatter.get($);
      return B !== void 0 ? z.some({
        tag: B.length > 0 && (B[0].inline || B[0].block) || "div",
        styles: t.dom.parseStyle(t.formatter.getCssText($))
      }) : z.none();
    }, p = sr([]), y = sr([]), x = sr(!1);
    return t.on("PreInit", ($) => {
      const B = Rz(t), j = iA(t, B, a, u);
      p.set(j);
    }), t.on("addStyleModifications", ($) => {
      const B = iA(t, $.items, a, u);
      y.set(B), x.set($.replace);
    }), { getData: () => {
      const $ = x.get() ? [] : p.get(), B = y.get();
      return $.concat(B);
    } };
  }, Pz = (t) => se(t) && t.nodeType === 1, WX = p1.trim, n4 = (t) => (a) => !!(Pz(a) && (a.contentEditable === t || a.getAttribute("data-mce-contenteditable") === t)), jX = n4("true"), qX = n4("false"), r4 = (t, a, u, p, y) => ({
    type: t,
    title: a,
    url: u,
    level: p,
    attach: y
  }), Jce = (t) => {
    let a = t;
    for (; a = a.parentNode; ) {
      const u = a.contentEditable;
      if (u && u !== "inherit")
        return jX(a);
    }
    return !1;
  }, ele = (t, a) => He(Ki(nt.fromDom(a), t), (u) => u.dom), Dz = (t) => t.innerText || t.textContent, GX = (t) => t.id ? t.id : Hn("h"), ZX = (t) => t && t.nodeName === "A" && (t.id || t.name) !== void 0, $z = (t) => ZX(t) && Iz(t), SP = (t) => t && /^(H[1-6])$/.test(t.nodeName), Iz = (t) => Jce(t) && !qX(t), KX = (t) => SP(t) && Iz(t), Mz = (t) => SP(t) ? parseInt(t.nodeName.substr(1), 10) : 0, YX = (t) => {
    var a;
    const u = GX(t), p = () => {
      t.id = u;
    };
    return r4("header", (a = Dz(t)) !== null && a !== void 0 ? a : "", "#" + u, Mz(t), p);
  }, QX = (t) => {
    const a = t.id || t.name, u = Dz(t);
    return r4("anchor", u || "#" + a, "#" + a, 0, G);
  }, XX = (t) => He(Rn(t, KX), YX), JX = (t) => He(Rn(t, $z), QX), o4 = (t) => ele("h1,h2,h3,h4,h5,h6,a:not([href])", t), Fz = (t) => WX(t.title).length > 0, eJ = { find: (t) => {
    const a = o4(t);
    return Rn(XX(a).concat(JX(a)), Fz);
  } }, wP = "tinymce-url-history", Lz = 5, s4 = (t) => g(t) && /^https?/.test(t), tJ = (t) => R(t) && t.length <= Lz && Ct(t, s4), cA = (t) => C(t) && Co(t, (a) => !tJ(a)).isNone(), Bz = () => {
    const t = tS.getItem(wP);
    if (t === null)
      return {};
    let a;
    try {
      a = JSON.parse(t);
    } catch (u) {
      if (u instanceof SyntaxError)
        return console.log("Local storage " + wP + " was not valid JSON", u), {};
      throw u;
    }
    return cA(a) ? a : (console.log("Local storage " + wP + " was not valid format", a), {});
  }, EP = (t) => {
    if (!cA(t))
      throw new Error(`Bad format for history:
` + JSON.stringify(t));
    tS.setItem(wP, JSON.stringify(t));
  }, nJ = (t) => {
    const a = Bz();
    return fn(a, t).getOr([]);
  }, a4 = (t, a) => {
    if (!s4(t))
      return;
    const u = Bz(), p = fn(u, a).getOr([]), y = Rn(p, (x) => x !== t);
    u[a] = [t].concat(y).slice(0, Lz), EP(u);
  }, IT = (t) => !!t, Hz = (t) => uo(p1.makeMap(t, /[, ]/), IT), i4 = (t) => z.from(DM(t)), zz = (t) => {
    const a = z.from($M(t)).filter(IT).map(Hz);
    return i4(t).fold(sn, (u) => a.fold(Lt, (p) => Xr(p).length > 0 ? p : !1));
  }, Vz = (t, a) => {
    const u = zz(t);
    return L(u) ? u ? i4(t) : z.none() : u[a] ? i4(t) : z.none();
  }, Uz = (t, a) => Vz(t, a).map((u) => (p) => wu.nu((y) => {
    const x = ($, B) => {
      if (!g($))
        throw new Error("Expected value to be string");
      if (B !== void 0 && !C(B))
        throw new Error("Expected meta to be a object");
      y({
        value: $,
        meta: B
      });
    }, k = {
      filetype: a,
      fieldname: p.fieldname,
      ...z.from(p.meta).getOr({})
    };
    u.call(t, x, p.value, k);
  })), Wz = (t) => z.from(t).filter(g).getOrUndefined(), c4 = (t) => k6(t) ? z.some({
    targets: eJ.find(t.getBody()),
    anchorTop: Wz(mT(t)),
    anchorBottom: Wz(N6(t))
  }) : z.none(), CP = (t) => z.from(ZN(t)), rJ = (t) => ({
    getHistory: nJ,
    addToHistory: a4,
    getLinkInformation: () => c4(t),
    getValidationHandler: () => CP(t),
    getUrlPicker: (a) => Uz(t, a)
  }), oJ = (t, a, u, p) => {
    const y = sr(!1), x = Eu(a), k = {
      icons: () => a.ui.registry.getAll().icons,
      menuItems: () => a.ui.registry.getAll().menuItems,
      translate: Mf.translate,
      isDisabled: () => a.mode.isReadOnly() || !a.ui.isEnabled(),
      getOption: a.options.get
    }, $ = rJ(a), B = UX(a), j = Az(a), Y = Xce(a), re = () => y.get(), le = (ft) => y.set(ft), pe = {
      shared: {
        providers: k,
        anchors: DX(a, u, p, x.isPositionedAtTop),
        header: x
      },
      urlinput: $,
      styles: B,
      colorinput: j,
      dialog: Y,
      isContextMenuOpen: re,
      setContextMenuState: le
    }, _e = {
      ...pe,
      shared: {
        ...pe.shared,
        interpreter: (ft) => XO(ft, {}, _e),
        getSink: t.popup
      }
    }, ze = {
      ...pe,
      shared: {
        ...pe.shared,
        interpreter: (ft) => XO(ft, {}, ze),
        getSink: t.dialog
      }
    };
    return {
      popup: _e,
      dialog: ze
    };
  }, MT = (t, a, u) => {
    const p = (Nt, hn) => {
      ut([
        a,
        ...u
      ], (En) => {
        En.broadcastEvent(Nt, hn);
      });
    }, y = (Nt, hn) => {
      ut([
        a,
        ...u
      ], (En) => {
        En.broadcastOn([Nt], hn);
      });
    }, x = (Nt) => y(lh(), { target: Nt.target }), k = Md(), $ = Cl(k, "touchstart", x), B = Cl(k, "touchmove", (Nt) => p(yl(), Nt)), j = Cl(k, "touchend", (Nt) => p(zd(), Nt)), Y = Cl(k, "mousedown", x), re = Cl(k, "mouseup", (Nt) => {
      Nt.raw.button === 0 && y(R_(), { target: Nt.target });
    }), le = (Nt) => y(lh(), { target: nt.fromDom(Nt.target) }), pe = (Nt) => {
      Nt.button === 0 && y(R_(), { target: nt.fromDom(Nt.target) });
    }, _e = () => {
      ut(t.editorManager.get(), (Nt) => {
        t !== Nt && Nt.dispatch("DismissPopups", { relatedTarget: t });
      });
    }, ze = (Nt) => p(Um(), Fc(Nt)), ft = (Nt) => {
      y(Yy(), {}), p(dm(), Fc(Nt));
    }, Xe = wt(nt.fromDom(t.getElement())), Ze = h0(Xe, "scroll", (Nt) => {
      requestAnimationFrame(() => {
        const hn = t.getContainer();
        if (hn != null) {
          const zr = rS(t, a.element).map((Yn) => [
            Yn.element,
            ...Yn.others
          ]).getOr([]);
          Gt(zr, (Yn) => Io(Yn, Nt.target)) && (t.dispatch("ElementScroll", { target: Nt.target.dom }), p(qp(), Nt));
        }
      });
    }), mt = () => y(Yy(), {}), jt = (Nt) => {
      Nt.state && y(lh(), { target: nt.fromDom(t.getContainer()) });
    }, Dt = (Nt) => {
      y(lh(), { target: nt.fromDom(Nt.relatedTarget.getContainer()) });
    };
    t.on("PostRender", () => {
      t.on("click", le), t.on("tap", le), t.on("mouseup", pe), t.on("mousedown", _e), t.on("ScrollWindow", ze), t.on("ResizeWindow", ft), t.on("ResizeEditor", mt), t.on("AfterProgressState", jt), t.on("DismissPopups", Dt);
    }), t.on("remove", () => {
      t.off("click", le), t.off("tap", le), t.off("mouseup", pe), t.off("mousedown", _e), t.off("ScrollWindow", ze), t.off("ResizeWindow", ft), t.off("ResizeEditor", mt), t.off("AfterProgressState", jt), t.off("DismissPopups", Dt), Y.unbind(), $.unbind(), B.unbind(), j.unbind(), re.unbind(), Ze.unbind();
    }), t.on("detach", () => {
      ut([
        a,
        ...u
      ], R0), ut([
        a,
        ...u
      ], (Nt) => Nt.destroy());
    });
  }, Vc = NI, ny = uN, jz = q([
    lt("shell", !1),
    Mt("makeItem"),
    lt("setupItem", G),
    bm.field("listBehaviours", [$r])
  ]), l4 = vd({
    name: "items",
    overrides: () => ({ behaviours: mn([$r.config({})]) })
  }), sJ = q([l4]), aJ = q("CustomList"), iJ = (t, a, u, p) => {
    const y = ($, B) => {
      k($).fold(() => {
        throw console.error("Custom List was defined to not be a shell, but no item container was specified in components"), new Error("Custom List was defined to not be a shell, but no item container was specified in components");
      }, (j) => {
        const Y = $r.contents(j), re = B.length, le = re - Y.length, pe = le > 0 ? xt(le, () => t.makeItem()) : [], _e = Y.slice(re);
        ut(_e, (ft) => $r.remove(j, ft)), ut(pe, (ft) => $r.append(j, ft));
        const ze = $r.contents(j);
        ut(ze, (ft, Xe) => {
          t.setupItem($, ft, B[Xe], Xe);
        });
      });
    }, x = t.shell ? {
      behaviours: [$r.config({})],
      components: []
    } : {
      behaviours: [],
      components: a
    }, k = ($) => t.shell ? z.some($) : Fs($, t, "items");
    return {
      uid: t.uid,
      dom: t.dom,
      components: x.components,
      behaviours: _i(t.listBehaviours, x.behaviours),
      apis: { setItems: y }
    };
  }, xP = ql({
    name: aJ(),
    configFields: jz(),
    partFields: sJ(),
    factory: iJ,
    apis: {
      setItems: (t, a, u) => {
        t.setItems(a, u);
      }
    }
  }), FT = q([
    Mt("dom"),
    lt("shell", !0),
    ac("toolbarBehaviours", [$r])
  ]), cJ = q([vd({
    name: "groups",
    overrides: () => ({ behaviours: mn([$r.config({})]) })
  })]), lJ = (t, a, u, p) => {
    const y = ($, B) => {
      x($).fold(() => {
        throw console.error("Toolbar was defined to not be a shell, but no groups container was specified in components"), new Error("Toolbar was defined to not be a shell, but no groups container was specified in components");
      }, (j) => {
        $r.set(j, B);
      });
    }, x = ($) => t.shell ? z.some($) : Fs($, t, "groups"), k = t.shell ? {
      behaviours: [$r.config({})],
      components: []
    } : {
      behaviours: [],
      components: a
    };
    return {
      uid: t.uid,
      dom: t.dom,
      components: k.components,
      behaviours: _i(t.toolbarBehaviours, k.behaviours),
      apis: {
        setGroups: y,
        refresh: G
      },
      domModification: { attributes: { role: "group" } }
    };
  }, kv = ql({
    name: "Toolbar",
    configFields: FT(),
    partFields: cJ(),
    factory: lJ,
    apis: {
      setGroups: (t, a, u) => {
        t.setGroups(a, u);
      }
    }
  }), uJ = G, dJ = sn, u4 = q([]);
  var fJ = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    setup: uJ,
    isDocked: dJ,
    getBehaviours: u4
  });
  const BE = (t) => ($i(Ta(t, "position"), "fixed") ? z.none() : Il(t)).orThunk(() => {
    const p = nt.fromTag("span");
    return Ii(t).bind((y) => {
      oi(y, p);
      const x = Il(p);
      return ou(p), x;
    });
  }), Gz = (t) => BE(t).map(Jc).getOrThunk(() => Oo(0, 0)), mJ = (t, a) => {
    const u = t.element;
    ja(u, a.transitionClass), ua(u, a.fadeOutClass), ja(u, a.fadeInClass), a.onShow(t);
  }, d4 = (t, a) => {
    const u = t.element;
    ja(u, a.transitionClass), ua(u, a.fadeInClass), ja(u, a.fadeOutClass), a.onHide(t);
  }, Zz = (t, a) => t.y < a.bottom && t.bottom > a.y, Kz = (t, a) => t.y >= a.y, Yz = (t, a) => t.bottom <= a.bottom, f4 = (t, a, u) => ({
    location: "top",
    leftX: a,
    topY: u.bounds.y - t.y
  }), m4 = (t, a, u) => ({
    location: "bottom",
    leftX: a,
    bottomY: t.bottom - u.bounds.bottom
  }), p4 = (t) => t.box.x - t.win.x, pJ = (t, a, u) => {
    const p = a.win, y = a.box, x = p4(a);
    return Vr(t, (k) => {
      switch (k) {
        case "bottom":
          return Yz(y, u.bounds) ? z.none() : z.some(m4(p, x, u));
        case "top":
          return Kz(y, u.bounds) ? z.none() : z.some(f4(p, x, u));
        default:
          return z.none();
      }
    }).getOr({ location: "no-dock" });
  }, hJ = (t, a, u) => Ct(t, (p) => {
    switch (p) {
      case "bottom":
        return Yz(a, u.bounds);
      case "top":
        return Kz(a, u.bounds);
    }
  }), gJ = (t, a) => {
    const u = a.optScrollEnv.fold(q(t.bounds.y), (p) => p.scrollElmTop + (t.bounds.y - p.currentScrollTop));
    return Oo(t.bounds.x, u);
  }, vJ = (t, a) => {
    const u = a.optScrollEnv.fold(q(t.y), (p) => t.y + p.currentScrollTop - p.scrollElmTop);
    return Oo(t.x, u);
  }, Qz = (t, a, u) => u.getInitialPos().map((p) => {
    const y = gJ(p, a);
    return {
      box: cs(y.left, y.top, Oa(t), Ds(t)),
      location: p.location
    };
  }), Xz = (t, a, u, p, y) => {
    const x = vJ(a, u), k = cs(x.left, x.top, a.width, a.height);
    p.setInitialPos({
      style: bs(t),
      position: na(t, "position") || "static",
      bounds: k,
      location: y.location
    });
  }, Jz = (t, a, u, p, y) => {
    p.getInitialPos().fold(() => Xz(t, a, u, p, y), () => G);
  }, h4 = (t, a, u) => u.getInitialPos().bind((p) => {
    var y;
    switch (u.clearInitialPos(), p.position) {
      case "static":
        return z.some({ morph: "static" });
      case "absolute":
        const x = BE(t).getOr(ta()), k = Ss(x), $ = (y = x.dom.scrollTop) !== null && y !== void 0 ? y : 0;
        return z.some({
          morph: "absolute",
          positionCss: md("absolute", fn(p.style, "left").map((B) => a.x - k.x), fn(p.style, "top").map((B) => a.y - k.y + $), fn(p.style, "right").map((B) => k.right - a.right), fn(p.style, "bottom").map((B) => k.bottom - a.bottom))
        });
      default:
        return z.none();
    }
  }), TP = (t, a, u) => Qz(t, a, u).filter(({ box: p }) => hJ(u.getModes(), p, a)).bind(({ box: p }) => h4(t, p, u)), _P = (t) => {
    switch (t.location) {
      case "top":
        return z.some({
          morph: "fixed",
          positionCss: md("fixed", z.some(t.leftX), z.some(t.topY), z.none(), z.none())
        });
      case "bottom":
        return z.some({
          morph: "fixed",
          positionCss: md("fixed", z.some(t.leftX), z.none(), z.none(), z.some(t.bottomY))
        });
      default:
        return z.none();
    }
  }, bJ = (t, a, u) => {
    const p = Ss(t), y = Ci(), x = pJ(u.getModes(), {
      win: y,
      box: p
    }, a);
    return x.location === "top" || x.location === "bottom" ? (Xz(t, p, a, u, x), _P(x)) : z.none();
  }, yJ = (t, a, u) => TP(t, a, u).orThunk(() => a.optScrollEnv.bind((p) => Qz(t, a, u)).bind(({ box: p, location: y }) => {
    const x = Ci(), k = p4({
      win: x,
      box: p
    }), $ = y === "top" ? f4(x, k, a) : m4(x, k, a);
    return _P($);
  })), SJ = (t, a, u) => {
    const p = t.element;
    return $i(Ta(p, "position"), "fixed") ? yJ(p, a, u) : bJ(p, a, u);
  }, wJ = (t, a, u) => {
    const p = t.element;
    return Qz(p, a, u).bind(({ box: y }) => h4(p, y, u));
  }, EJ = (t, a, u, p) => {
    const y = Ss(t), x = Ci(), k = p4({
      win: x,
      box: y
    }), $ = p(x, k, a);
    return $.location === "bottom" || $.location === "top" ? (Jz(t, y, a, u, $), _P($)) : z.none();
  }, eV = (t, a, u) => {
    u.setDocked(!1), ut([
      "left",
      "right",
      "top",
      "bottom",
      "position"
    ], (p) => Ur(t.element, p)), a.onUndocked(t);
  }, g4 = (t, a, u, p) => {
    const y = p.position === "fixed";
    u.setDocked(y), Jm(t.element, p), (y ? a.onDocked : a.onUndocked)(t);
  }, v4 = (t, a, u, p, y = !1) => {
    a.contextual.each((x) => {
      x.lazyContext(t).each((k) => {
        const $ = Zz(k, p.bounds);
        $ !== u.isVisible() && (u.setVisible($), y && !$ ? (wa(t.element, [x.fadeOutClass]), x.onHide(t)) : ($ ? mJ : d4)(t, x));
      });
    });
  }, b4 = (t, a, u, p, y) => {
    v4(t, a, u, p, !0), g4(t, a, u, y.positionCss);
  }, CJ = (t, a, u, p, y) => {
    switch (y.morph) {
      case "static":
        return eV(t, a, u);
      case "absolute":
        return g4(t, a, u, y.positionCss);
      case "fixed":
        return b4(t, a, u, p, y);
    }
  }, tV = (t, a, u) => {
    const p = a.lazyViewport(t);
    v4(t, a, u, p), SJ(t, p, u).each((y) => {
      CJ(t, a, u, p, y);
    });
  }, xJ = (t, a, u) => {
    const p = t.element;
    u.setDocked(!1);
    const y = a.lazyViewport(t);
    wJ(t, y, u).each((x) => {
      switch (x.morph) {
        case "static": {
          eV(t, a, u);
          break;
        }
        case "absolute": {
          g4(t, a, u, x.positionCss);
          break;
        }
      }
    }), u.setVisible(!0), a.contextual.each((x) => {
      dd(p, [
        x.fadeInClass,
        x.fadeOutClass,
        x.transitionClass
      ]), x.onShow(t);
    }), OP(t, a, u);
  }, OP = (t, a, u) => {
    t.getSystem().isConnected() && tV(t, a, u);
  }, nV = (t, a, u) => {
    u.isDocked() && xJ(t, a, u);
  }, fS = (t) => (a, u, p) => {
    const y = u.lazyViewport(a);
    EJ(a.element, y, p, t).each((k) => {
      b4(a, u, p, y, k);
    });
  }, rV = fS(f4), lA = fS(m4);
  var oV = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    refresh: OP,
    reset: nV,
    isDocked: (t, a, u) => u.isDocked(),
    getModes: (t, a, u) => u.getModes(),
    setModes: (t, a, u, p) => u.setModes(p),
    forceDockToTop: rV,
    forceDockToBottom: lA
  }), OJ = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: (t, a) => ls([
      xf(Hp(), (u, p) => {
        t.contextual.each((y) => {
          Ti(u.element, y.transitionClass) && (dd(u.element, [
            y.transitionClass,
            y.fadeInClass
          ]), (a.isVisible() ? y.onShown : y.onHidden)(u)), p.stop();
        });
      }),
      Pt(Um(), (u, p) => {
        OP(u, t, a);
      }),
      Pt(qp(), (u, p) => {
        OP(u, t, a);
      }),
      Pt(dm(), (u, p) => {
        nV(u, t, a);
      })
    ])
  }), AJ = [
    nl("contextual", [
      xo("fadeInClass"),
      xo("fadeOutClass"),
      xo("transitionClass"),
      id("lazyContext"),
      po("onShow"),
      po("onShown"),
      po("onHide"),
      po("onHidden")
    ]),
    ii("lazyViewport", () => ({
      bounds: Ci(),
      optScrollEnv: z.none()
    })),
    bl("modes", [
      "top",
      "bottom"
    ], xi),
    po("onDocked"),
    po("onUndocked")
  ], kJ = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: (t) => {
      const a = sr(!1), u = sr(!0), p = Gr(), y = sr(t.modes), x = () => `docked:  ${a.get()}, visible: ${u.get()}, modes: ${y.get().join(",")}`;
      return ol({
        isDocked: a.get,
        setDocked: a.set,
        getInitialPos: p.get,
        setInitialPos: p.set,
        clearInitialPos: p.clear,
        isVisible: u.get,
        setVisible: u.set,
        getModes: y.get,
        setModes: y.set,
        readState: x
      });
    }
  });
  const Oi = Zi({
    fields: AJ,
    name: "docking",
    active: OJ,
    apis: oV,
    state: kJ
  }), mS = q(Hn("toolbar-height-change")), up = {
    fadeInClass: "tox-editor-dock-fadein",
    fadeOutClass: "tox-editor-dock-fadeout",
    transitionClass: "tox-editor-dock-transition"
  }, AP = "tox-tinymce--toolbar-sticky-on", sV = "tox-tinymce--toolbar-sticky-off", NJ = (t, a) => {
    const u = ti(a), y = nu(a).dom.innerHeight, x = ec(u), k = nt.fromDom(t.elm), $ = Fi(k), B = Ds(k), j = $.y, Y = j + B, re = Jc(a), le = Ds(a), pe = re.top, _e = pe + le, ze = Math.abs(pe - x.top) < 2, ft = Math.abs(_e - (x.top + y)) < 2;
    if (ze && j < _e)
      Bm(x.left, j - le, u);
    else if (ft && Y > pe) {
      const Xe = j - y + B + le;
      Bm(x.left, Xe, u);
    }
  }, LT = (t, a) => vt(Oi.getModes(t), a), S4 = (t) => {
    const a = (p) => af(p) + (parseInt(na(p, "margin-top"), 10) || 0) + (parseInt(na(p, "margin-bottom"), 10) || 0), u = t.element;
    $l(u).each((p) => {
      const y = "padding-" + Oi.getModes(t)[0];
      if (Oi.isDocked(t)) {
        const x = Oa(p);
        Sr(u, "width", x + "px"), Sr(p, y, a(u) + "px");
      } else
        Ur(u, "width"), Ur(p, y);
    });
  }, BT = (t, a) => {
    a ? (ua(t, up.fadeOutClass), wa(t, [
      up.transitionClass,
      up.fadeInClass
    ])) : (ua(t, up.fadeInClass), wa(t, [
      up.fadeOutClass,
      up.transitionClass
    ]));
  }, w4 = (t, a) => {
    const u = nt.fromDom(t.getContainer());
    a ? (ja(u, AP), ua(u, sV)) : (ja(u, sV), ua(u, AP));
  }, RJ = (t, a) => {
    const u = ti(a);
    Xm(u).filter((p) => !Io(a, p)).filter((p) => Io(p, nt.fromDom(u.dom.body)) || za(t, p)).each(() => Fa(a));
  }, PJ = (t, a) => Nf(t).orThunk(() => a().toOptional().bind((u) => Nf(u.element))), DJ = (t, a, u) => {
    t.inline || (a.header.isPositionedAtTop() || t.on("ResizeEditor", () => {
      u().each(Oi.reset);
    }), t.on("ResizeWindow ResizeEditor", () => {
      u().each(S4);
    }), t.on("SkinLoaded", () => {
      u().each((p) => {
        Oi.isDocked(p) ? Oi.reset(p) : Oi.refresh(p);
      });
    }), t.on("FullscreenStateChanged", () => {
      u().each(Oi.reset);
    })), t.on("AfterScrollIntoView", (p) => {
      u().each((y) => {
        Oi.refresh(y);
        const x = y.element;
        nT(x) && NJ(p, x);
      });
    }), t.on("PostRender", () => {
      w4(t, !1);
    });
  }, $J = (t) => t().map(Oi.isDocked).getOr(!1), IJ = () => [vu.config({ channels: { [mS()]: { onReceive: S4 } } })], aV = (t, a) => {
    const u = Gr(), p = a.getSink, y = ($) => {
      p().each((B) => $(B.element));
    }, x = ($) => {
      t.inline || S4($), w4(t, Oi.isDocked($)), $.getSystem().broadcastOn([Yy()], {}), p().each((B) => B.getSystem().broadcastOn([Yy()], {}));
    }, k = t.inline ? [] : IJ();
    return [
      Er.config({}),
      Oi.config({
        contextual: {
          lazyContext: ($) => {
            const B = af($.element), j = t.inline ? t.getContentAreaContainer() : t.getContainer();
            return z.from(j).map((Y) => {
              const re = Ss(nt.fromDom(Y));
              return rS(t, $.element).fold(() => {
                const pe = re.height - B, _e = re.y + (LT($, "top") ? 0 : B);
                return cs(re.x, _e, re.width, pe);
              }, (pe) => {
                const _e = Hg(re, ST(pe)), ze = LT($, "top") ? _e.y : _e.y + B;
                return cs(_e.x, ze, _e.width, _e.height - B);
              });
            });
          },
          onShow: () => {
            y(($) => BT($, !0));
          },
          onShown: ($) => {
            y((B) => dd(B, [
              up.transitionClass,
              up.fadeInClass
            ])), u.get().each((B) => {
              RJ($.element, B), u.clear();
            });
          },
          onHide: ($) => {
            PJ($.element, p).fold(u.clear, u.set), y((B) => BT(B, !1));
          },
          onHidden: () => {
            y(($) => dd($, [up.transitionClass]));
          },
          ...up
        },
        lazyViewport: ($) => rS(t, $.element).fold(() => {
          const j = Ci(), Y = PM(t), re = j.y + (LT($, "top") ? Y : 0), le = j.height - (LT($, "bottom") ? Y : 0);
          return {
            bounds: cs(j.x, re, j.width, le),
            optScrollEnv: z.none()
          };
        }, (j) => ({
          bounds: ST(j),
          optScrollEnv: z.some({
            currentScrollTop: j.element.dom.scrollTop,
            scrollElmTop: Jc(j.element).top
          })
        })),
        modes: [a.header.getDockingMode()],
        onDocked: x,
        onUndocked: x
      }),
      ...k
    ];
  };
  var iV = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    setup: DJ,
    isDocked: $J,
    getBehaviours: aV
  });
  const cV = (t) => {
    const a = t.editor, u = t.sticky ? aV : u4;
    return {
      uid: t.uid,
      dom: t.dom,
      components: t.components,
      behaviours: mn(u(a, t.sharedBackstage))
    };
  }, E4 = jn([
    Qi,
    $c("items", Un([
      hf([
        uR,
        tc("items", xi)
      ]),
      xi
    ]))
  ].concat(gT)), MJ = (t) => Ws("GroupToolbarButton", E4, t), kP = [
    nc("text"),
    nc("tooltip"),
    nc("icon"),
    gl("search", !1, Un([
      ad,
      jn([nc("placeholder")])
    ], (t) => L(t) ? t ? z.some({ placeholder: z.none() }) : z.none() : z.some(t))),
    id("fetch"),
    ii("onSetup", () => G)
  ], uA = jn([
    Qi,
    ...kP
  ]), C4 = (t) => Ws("menubutton", uA, t), FJ = jn([
    Qi,
    fR,
    wm,
    J0,
    _E,
    a8,
    X0,
    vl("presets", "normal", [
      "normal",
      "color",
      "listpreview"
    ]),
    nF(1),
    Q0,
    i8
  ]), LJ = (t) => Ws("SplitButton", FJ, t);
  var x4 = Yd({
    factory: (t, a) => {
      const u = (y, x) => {
        const k = He(x, ($) => {
          const B = {
            type: "menubutton",
            text: $.text,
            fetch: (Y) => {
              Y($.getItems());
            }
          }, j = C4(B).mapError((Y) => Dc(Y)).getOrDie();
          return YO(j, "tox-mbtn", a.backstage, z.some("menuitem"));
        });
        $r.set(y, k);
      }, p = {
        focus: ar.focusIn,
        setMenus: u
      };
      return {
        uid: t.uid,
        dom: t.dom,
        components: [],
        behaviours: mn([
          $r.config({}),
          Hr("menubar-events", [
            us((y) => {
              t.onSetup(y);
            }),
            Pt(yf(), (y, x) => {
              qa(y.element, ".tox-mbtn--active").each((k) => {
                fm(x.event.target, ".tox-mbtn").each(($) => {
                  Io(k, $) || y.getSystem().getByDom(k).each((B) => {
                    y.getSystem().getByDom($).each((j) => {
                      bh.expand(j), bh.close(B), Er.focus(j);
                    });
                  });
                });
              });
            }),
            Pt(V1(), (y, x) => {
              x.event.prevFocus.bind((k) => y.getSystem().getByDom(k).toOptional()).each((k) => {
                x.event.newFocus.bind(($) => y.getSystem().getByDom($).toOptional()).each(($) => {
                  bh.isOpen(k) && (bh.expand($), bh.close(k));
                });
              });
            })
          ]),
          ar.config({
            mode: "flow",
            selector: ".tox-mbtn",
            onEscape: (y) => (t.onEscape(y), z.some(!0))
          }),
          Ea.config({})
        ]),
        apis: p,
        domModification: { attributes: { role: "menubar" } }
      };
    },
    name: "silver.Menubar",
    configFields: [
      Mt("dom"),
      Mt("uid"),
      Mt("onEscape"),
      Mt("backstage"),
      lt("onSetup", G)
    ],
    apis: {
      focus: (t, a) => {
        t.focus(a);
      },
      setMenus: (t, a, u) => {
        t.setMenus(a, u);
      }
    }
  });
  const T4 = "Upgrade", _4 = "https://www.tiny.cloud/tinymce-self-hosted-premium-features/?utm_campaign=self_hosted_upgrade_promo&utm_source=tiny&utm_medium=referral", BJ = (t) => ({
    uid: t.uid,
    dom: t.dom,
    components: [{
      dom: {
        tag: "a",
        attributes: {
          href: _4,
          rel: "noopener",
          target: "_blank",
          "aria-hidden": "true"
        },
        classes: ["tox-promotion-link"],
        innerHtml: T4
      }
    }]
  }), NP = "container", HJ = [ac("slotBehaviours", [])], lV = (t) => "<alloy.field." + t + ">", zJ = (t) => {
    const a = (() => {
      const x = [];
      return {
        slot: ($, B) => (x.push($), L_(NP, lV($), B)),
        record: q(x)
      };
    })(), u = t(a), p = a.record(), y = He(p, (x) => jl({
      name: x,
      pname: lV(x)
    }));
    return j_(NP, HJ, y, VJ, u);
  }, VJ = (t, a) => {
    const u = (ze) => z_(t), p = (ze, ft) => Fs(ze, t, ft), y = (ze, ft) => (Xe, Ze) => Fs(Xe, t, Ze).map((mt) => ze(mt, Ze)).getOr(ft), x = (ze) => (ft, Xe) => {
      ut(Xe, (Ze) => ze(ft, Ze));
    }, k = (ze, ft) => ca(ze.element, "aria-hidden") !== "true", $ = (ze, ft) => {
      if (!k(ze)) {
        const Xe = ze.element;
        Ur(Xe, "display"), vs(Xe, "aria-hidden"), nr(ze, nb(), {
          name: ft,
          visible: !0
        });
      }
    }, B = (ze, ft) => {
      if (k(ze)) {
        const Xe = ze.element;
        Sr(Xe, "display", "none"), kn(Xe, "aria-hidden", "true"), nr(ze, nb(), {
          name: ft,
          visible: !1
        });
      }
    }, j = y(k, !1), Y = y(B), re = x(Y), le = (ze) => re(ze, u()), pe = y($), _e = {
      getSlotNames: u,
      getSlot: p,
      isShowing: j,
      hideSlot: Y,
      hideAllSlots: le,
      showSlot: pe
    };
    return {
      uid: t.uid,
      dom: t.dom,
      components: a,
      behaviours: pv(t.slotBehaviours),
      apis: _e
    };
  }, Ed = {
    ...uo({
      getSlotNames: (t, a) => t.getSlotNames(a),
      getSlot: (t, a, u) => t.getSlot(a, u),
      isShowing: (t, a, u) => t.isShowing(a, u),
      hideSlot: (t, a, u) => t.hideSlot(a, u),
      hideAllSlots: (t, a) => t.hideAllSlots(a),
      showSlot: (t, a, u) => t.showSlot(a, u)
    }, (t) => Xp(t)),
    sketch: zJ
  }, ale = jn([
    wm,
    fR,
    ii("onShow", G),
    ii("onHide", G),
    X0
  ]), uV = (t) => Ws("sidebar", ale, t), UJ = (t) => {
    const { sidebars: a } = t.ui.registry.getAll();
    ut(Xr(a), (u) => {
      const p = a[u], y = () => $i(z.from(t.queryCommandValue("ToggleSidebar")), u);
      t.ui.registry.addToggleButton(u, {
        icon: p.icon,
        tooltip: p.tooltip,
        onAction: (x) => {
          t.execCommand("ToggleSidebar", !1, u), x.setActive(y());
        },
        onSetup: (x) => {
          x.setActive(y());
          const k = () => x.setActive(y());
          return t.on("ToggleSidebar", k), () => {
            t.off("ToggleSidebar", k);
          };
        }
      });
    });
  }, dV = (t) => ({ element: () => t.element.dom }), WJ = (t, a) => {
    const u = He(Xr(a), (p) => {
      const y = a[p], x = Mo(uV(y));
      return {
        name: p,
        getApi: dV,
        onSetup: x.onSetup,
        onShow: x.onShow,
        onHide: x.onHide
      };
    });
    return He(u, (p) => {
      const y = sr(G);
      return t.slot(p.name, {
        dom: {
          tag: "div",
          classes: ["tox-sidebar__pane"]
        },
        behaviours: CO.unnamedEvents([
          l1(p, y),
          pg(p, y),
          Pt(nb(), (x, k) => {
            const $ = k.event;
            Ge(u, (j) => j.name === $.name).each((j) => {
              ($.visible ? j.onShow : j.onHide)(j.getApi(x));
            });
          })
        ])
      });
    });
  }, jJ = (t) => Ed.sketch((a) => ({
    dom: {
      tag: "div",
      classes: ["tox-sidebar__pane-container"]
    },
    components: WJ(a, t),
    slotBehaviours: CO.unnamedEvents([us((u) => Ed.hideAllSlots(u))])
  })), qJ = (t, a, u) => {
    ho.getCurrent(t).each((y) => {
      $r.set(y, [jJ(a)]);
      const x = u == null ? void 0 : u.toLowerCase();
      g(x) && Yr(a, x) && ho.getCurrent(y).each((k) => {
        Ed.showSlot(k, x), Cm.immediateGrow(y), Ur(y.element, "width"), RP(t.element, "region");
      });
    });
  }, RP = (t, a) => {
    kn(t, "role", a);
  }, GJ = (t, a) => {
    ho.getCurrent(t).each((p) => {
      ho.getCurrent(p).each((x) => {
        Cm.hasGrown(p) ? Ed.isShowing(x, a) ? (Cm.shrink(p), RP(t.element, "presentation")) : (Ed.hideAllSlots(x), Ed.showSlot(x, a), RP(t.element, "region")) : (Ed.hideAllSlots(x), Ed.showSlot(x, a), Cm.grow(p), RP(t.element, "region"));
      });
    });
  }, fV = (t) => ho.getCurrent(t).bind((u) => Cm.isGrowing(u) || Cm.hasGrown(u) ? ho.getCurrent(u).bind((x) => Ge(Ed.getSlotNames(x), (k) => Ed.isShowing(x, k))) : z.none()), O4 = Hn("FixSizeEvent"), A4 = Hn("AutoSizeEvent"), ZJ = (t) => ({
    uid: t.uid,
    dom: {
      tag: "div",
      classes: ["tox-sidebar"],
      attributes: { role: "presentation" }
    },
    components: [{
      dom: {
        tag: "div",
        classes: ["tox-sidebar__slider"]
      },
      components: [],
      behaviours: mn([
        Ea.config({}),
        Er.config({}),
        Cm.config({
          dimension: { property: "width" },
          closedClass: "tox-sidebar--sliding-closed",
          openClass: "tox-sidebar--sliding-open",
          shrinkingClass: "tox-sidebar--sliding-shrinking",
          growingClass: "tox-sidebar--sliding-growing",
          onShrunk: (a) => {
            ho.getCurrent(a).each(Ed.hideAllSlots), Jr(a, A4);
          },
          onGrown: (a) => {
            Jr(a, A4);
          },
          onStartGrow: (a) => {
            nr(a, O4, { width: Ta(a.element, "width").getOr("") });
          },
          onStartShrink: (a) => {
            nr(a, O4, { width: Oa(a.element) + "px" });
          }
        }),
        $r.config({}),
        ho.config({
          find: (a) => {
            const u = $r.contents(a);
            return $n(u);
          }
        })
      ])
    }],
    behaviours: mn([
      zf.childAt(0),
      Hr("sidebar-sliding-events", [
        Pt(O4, (a, u) => {
          Sr(a.element, "width", u.event.width);
        }),
        Pt(A4, (a, u) => {
          Ur(a.element, "width");
        })
      ])
    ])
  });
  var mV = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    block: (t, a, u, p) => {
      kn(t.element, "aria-busy", !0);
      const y = a.getRoot(t).getOr(t), x = mn([
        ar.config({
          mode: "special",
          onTab: () => z.some(!0),
          onShiftTab: () => z.some(!0)
        }),
        Er.config({})
      ]), k = p(y, x), $ = y.getSystem().build(k);
      $r.append(y, Hu($)), $.hasConfigured(ar) && a.focus && ar.focusIn($), u.isBlocked() || a.onBlock(t), u.blockWith(() => $r.remove(y, $));
    },
    unblock: (t, a, u) => {
      vs(t.element, "aria-busy"), u.isBlocked() && a.onUnblock(t), u.clear();
    },
    isBlocked: (t, a, u) => u.isBlocked()
  }), YJ = [
    ii("getRoot", z.none),
    vi("focus", !0),
    po("onBlock"),
    po("onUnblock")
  ], dp = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: () => {
      const t = $w(), a = (u) => {
        t.set({ destroy: u });
      };
      return ol({
        readState: t.isSet,
        blockWith: a,
        clear: t.clear,
        isBlocked: t.isSet
      });
    }
  });
  const Nv = Zi({
    fields: YJ,
    name: "blocking",
    apis: mV,
    state: dp
  }), pV = (t) => (a, u) => ({
    dom: {
      tag: "div",
      attributes: {
        "aria-label": t.translate("Loading..."),
        tabindex: "0"
      },
      classes: ["tox-throbber__busy-spinner"]
    },
    components: [{ dom: o1('<div class="tox-spinner"><div></div><div></div><div></div></div>') }]
  }), k4 = (t) => ho.getCurrent(t).each((a) => Fa(a.element, !0)), QJ = (t, a) => {
    const u = "tabindex", p = `data-mce-${u}`;
    z.from(t.iframeElement).map(nt.fromDom).each((y) => {
      a ? (as(y, u).each((x) => kn(y, p, x)), kn(y, u, -1)) : (vs(y, u), as(y, p).each((x) => {
        kn(y, u, x), vs(y, p);
      }));
    });
  }, dA = (t, a, u, p) => {
    const y = a.element;
    if (QJ(t, u), u)
      Nv.block(a, pV(p)), Ur(y, "display"), vs(y, "aria-hidden"), t.hasFocus() && k4(a);
    else {
      const x = ho.getCurrent(a).exists((k) => zy(k.element));
      Nv.unblock(a), Sr(y, "display", "none"), kn(y, "aria-hidden", "true"), x && t.focus();
    }
  }, XJ = (t) => ({
    uid: t.uid,
    dom: {
      tag: "div",
      attributes: { "aria-hidden": "true" },
      classes: ["tox-throbber"],
      styles: { display: "none" }
    },
    behaviours: mn([
      $r.config({}),
      Nv.config({ focus: !1 }),
      ho.config({ find: (a) => $n(a.components()) })
    ]),
    components: []
  }), PP = (t) => t.type === "focusin", JJ = (t) => PP(t) ? (t.composed ? $n(t.composedPath()) : z.from(t.target)).map(nt.fromDom).filter($o).exists((u) => Ti(u, "mce-pastebin")) : !1, DP = (t, a, u) => {
    const p = sr(!1), y = Gr(), x = ($) => {
      p.get() && !JJ($) && ($.preventDefault(), k4(a()), t.editorManager.setActive(t));
    };
    t.inline || t.on("PreInit", () => {
      t.dom.bind(t.getWin(), "focusin", x), t.on("BeforeExecCommand", ($) => {
        $.command.toLowerCase() === "mcefocus" && $.value !== !0 && x($);
      });
    });
    const k = ($) => {
      $ !== p.get() && (p.set($), dA(t, a(), $, u.providers), q8(t, $));
    };
    t.on("ProgressState", ($) => {
      if (y.on(clearTimeout), he($.time)) {
        const B = EE.setEditorTimeout(t, () => k($.state), $.time);
        y.set(B);
      } else
        k($.state), y.clear();
    });
  }, eee = (t, a) => Jt(t, (y, x) => a(x, y.len).fold(q(y), ($) => ({
    len: $.finish,
    list: y.list.concat([$])
  })), {
    len: 0,
    list: []
  }).list, N4 = (t, a, u) => ({
    within: t,
    extra: a,
    withinWidth: u
  }), fp = (t, a, u) => {
    const p = eee(t, ($, B) => {
      const j = u($);
      return z.some({
        element: $,
        start: B,
        finish: B + j,
        width: j
      });
    }), y = Rn(p, ($) => $.finish <= a), x = Zt(y, ($, B) => $ + B.width, 0), k = p.slice(y.length);
    return {
      within: y,
      extra: k,
      withinWidth: x
    };
  }, $P = (t) => He(t, (a) => a.element), IP = (t, a, u) => {
    const p = $P(t.concat(a));
    return N4(p, [], u);
  }, hV = (t, a, u, p) => {
    const y = $P(t).concat([u]);
    return N4(y, $P(a), p);
  }, gV = (t, a, u) => N4($P(t), [], u), tee = (t, a, u) => {
    const p = fp(a, t, u);
    return p.extra.length === 0 ? z.some(p) : z.none();
  }, vV = (t, a, u, p) => {
    const y = tee(t, a, u).getOrThunk(() => fp(a, t - u(p), u)), x = y.within, k = y.extra, $ = y.withinWidth;
    return k.length === 1 && k[0].width <= u(p) ? IP(x, k, $) : k.length >= 1 ? hV(x, k, p, $) : gV(x, k, $);
  }, bV = (t, a) => {
    const u = He(a, (p) => Hu(p));
    kv.setGroups(t, u);
  }, nee = (t) => Vr(t, (a) => Nf(a.element).bind((u) => a.getSystem().getByDom(u).toOptional())), yV = (t, a, u) => {
    const p = a.builtGroups.get();
    if (p.length === 0)
      return;
    const y = gv(t, a, "primary"), x = yi.getCoupled(t, "overflowGroup");
    Sr(y.element, "visibility", "hidden");
    const k = p.concat([x]), $ = nee(k);
    u([]), bV(y, k);
    const B = Oa(y.element), j = vV(B, a.builtGroups.get(), (Y) => Oa(Y.element), x);
    j.extra.length === 0 ? ($r.remove(y, x), u([])) : (bV(y, j.within), u(j.extra)), Ur(y.element, "visibility"), Qc(y.element), $.each(Er.focus);
  }, SV = q([
    ac("splitToolbarBehaviours", [yi]),
    Ts("builtGroups", () => sr([]))
  ]), ree = q([
    eg(["overflowToggledClass"]),
    Ip("getOverflowBounds"),
    Mt("lazySink"),
    Ts("overflowGroups", () => sr([])),
    po("onOpened"),
    po("onClosed")
  ].concat(SV())), oee = q([
    jl({
      factory: kv,
      schema: FT(),
      name: "primary"
    }),
    rp({
      schema: FT(),
      name: "overflow"
    }),
    rp({ name: "overflow-button" }),
    rp({ name: "overflow-group" })
  ]), R4 = q((t, a) => {
    jv(t, Math.floor(a));
  }), wV = q([
    eg(["toggledClass"]),
    Mt("lazySink"),
    id("fetch"),
    Ip("getBounds"),
    nl("fireDismissalEventInstead", [lt("event", jp())]),
    rg(),
    po("onToggled")
  ]), EV = q([
    rp({
      name: "button",
      overrides: (t) => ({
        dom: { attributes: { "aria-haspopup": "true" } },
        buttonBehaviours: mn([Zr.config({
          toggleClass: t.markers.toggledClass,
          aria: { mode: "expanded" },
          toggleOnExecute: !1,
          onToggled: t.onToggled
        })])
      })
    }),
    rp({
      factory: kv,
      schema: FT(),
      name: "toolbar",
      overrides: (t) => ({
        toolbarBehaviours: mn([ar.config({
          mode: "cyclic",
          onEscape: (a) => (Fs(a, t, "button").each(Er.focus), z.none())
        })])
      })
    })
  ]), fA = Gr(), see = (t, a) => {
    fA.set(!0), P4(t, a), fA.clear();
  }, P4 = (t, a) => {
    const u = yi.getCoupled(t, "toolbarSandbox");
    bo.isOpen(u) ? bo.close(u) : bo.open(u, a.toolbar());
  }, MP = (t, a, u, p) => {
    const y = u.getBounds.map((k) => k()), x = u.lazySink(t).getOrDie();
    Wl.positionWithinBounds(x, a, {
      anchor: {
        type: "hotspot",
        hotspot: t,
        layouts: p,
        overrides: { maxWidthFunction: R4() }
      }
    }, y);
  }, D4 = (t, a, u, p, y) => {
    kv.setGroups(a, y), MP(t, a, u, p), Zr.on(t);
  }, CV = (t, a, u) => {
    const p = rv(), y = (k, $) => {
      const B = fA.get().getOr(!1);
      u.fetch().get((j) => {
        D4(t, $, u, a.layouts, j), p.link(t.element), B || ar.focusIn($);
      });
    }, x = () => {
      Zr.off(t), fA.get().getOr(!1) || Er.focus(t), p.unlink(t.element);
    };
    return {
      dom: {
        tag: "div",
        attributes: { id: p.id }
      },
      behaviours: mn([
        ar.config({
          mode: "special",
          onEscape: (k) => (bo.close(k), z.some(!0))
        }),
        bo.config({
          onOpen: y,
          onClose: x,
          isPartOf: (k, $, B) => th($, B) || th(t, B),
          getAttachPoint: () => u.lazySink(t).getOrDie()
        }),
        vu.config({
          channels: {
            ...eE({
              isExtraPart: sn,
              ...u.fireDismissalEventInstead.map((k) => ({ fireEventInstead: { event: k.event } })).getOr({})
            }),
            ...P0({
              doReposition: () => {
                bo.getState(yi.getCoupled(t, "toolbarSandbox")).each((k) => {
                  MP(t, k, u, a.layouts);
                });
              }
            })
          }
        })
      ])
    };
  }, pS = ql({
    name: "FloatingToolbarButton",
    factory: (t, a, u, p) => ({
      ...cl.sketch({
        ...p.button(),
        action: (y) => {
          P4(y, p);
        },
        buttonBehaviours: bm.augment({ dump: p.button().buttonBehaviours }, [yi.config({
          others: {
            toolbarSandbox: (y) => CV(y, u, t)
          }
        })])
      }),
      apis: {
        setGroups: (y, x) => {
          bo.getState(yi.getCoupled(y, "toolbarSandbox")).each((k) => {
            D4(y, k, t, u.layouts, x);
          });
        },
        reposition: (y) => {
          bo.getState(yi.getCoupled(y, "toolbarSandbox")).each((x) => {
            MP(y, x, t, u.layouts);
          });
        },
        toggle: (y) => {
          P4(y, p);
        },
        toggleWithoutFocusing: (y) => {
          see(y, p);
        },
        getToolbar: (y) => bo.getState(yi.getCoupled(y, "toolbarSandbox")),
        isOpen: (y) => bo.isOpen(yi.getCoupled(y, "toolbarSandbox"))
      }
    }),
    configFields: wV(),
    partFields: EV(),
    apis: {
      setGroups: (t, a, u) => {
        t.setGroups(a, u);
      },
      reposition: (t, a) => {
        t.reposition(a);
      },
      toggle: (t, a) => {
        t.toggle(a);
      },
      toggleWithoutFocusing: (t, a) => {
        t.toggleWithoutFocusing(a);
      },
      getToolbar: (t, a) => t.getToolbar(a),
      isOpen: (t, a) => t.isOpen(a)
    }
  }), aee = q([
    Mt("items"),
    eg(["itemSelector"]),
    ac("tgroupBehaviours", [ar])
  ]), xV = q([lE({
    name: "items",
    unit: "item"
  })]), iee = (t, a, u, p) => ({
    uid: t.uid,
    dom: t.dom,
    components: a,
    behaviours: _i(t.tgroupBehaviours, [ar.config({
      mode: "flow",
      selector: t.markers.itemSelector
    })]),
    domModification: { attributes: { role: "toolbar" } }
  }), FP = ql({
    name: "ToolbarGroup",
    configFields: aee(),
    partFields: xV(),
    factory: iee
  }), TV = (t) => He(t, (a) => Hu(a)), _V = (t, a, u) => {
    yV(t, u, (p) => {
      u.overflowGroups.set(p), a.getOpt(t).each((y) => {
        pS.setGroups(y, TV(p));
      });
    });
  }, cee = (t, a, u, p) => {
    const y = ms(pS.sketch({
      fetch: () => wu.nu((x) => {
        x(TV(t.overflowGroups.get()));
      }),
      layouts: {
        onLtr: () => [
          Mc,
          Wi
        ],
        onRtl: () => [
          Wi,
          Mc
        ],
        onBottomLtr: () => [
          Br,
          ji
        ],
        onBottomRtl: () => [
          ji,
          Br
        ]
      },
      getBounds: u.getOverflowBounds,
      lazySink: t.lazySink,
      fireDismissalEventInstead: {},
      markers: { toggledClass: t.markers.overflowToggledClass },
      parts: {
        button: p["overflow-button"](),
        toolbar: p.overflow()
      },
      onToggled: (x, k) => t[k ? "onOpened" : "onClosed"](x)
    }));
    return {
      uid: t.uid,
      dom: t.dom,
      components: a,
      behaviours: _i(t.splitToolbarBehaviours, [yi.config({
        others: {
          overflowGroup: () => FP.sketch({
            ...p["overflow-group"](),
            items: [y.asSpec()]
          })
        }
      })]),
      apis: {
        setGroups: (x, k) => {
          t.builtGroups.set(He(k, x.getSystem().build)), _V(x, y, t);
        },
        refresh: (x) => _V(x, y, t),
        toggle: (x) => {
          y.getOpt(x).each((k) => {
            pS.toggle(k);
          });
        },
        toggleWithoutFocusing: (x) => {
          y.getOpt(x).each(pS.toggleWithoutFocusing);
        },
        isOpen: (x) => y.getOpt(x).map(pS.isOpen).getOr(!1),
        reposition: (x) => {
          y.getOpt(x).each((k) => {
            pS.reposition(k);
          });
        },
        getOverflow: (x) => y.getOpt(x).bind(pS.getToolbar)
      },
      domModification: { attributes: { role: "group" } }
    };
  }, OV = ql({
    name: "SplitFloatingToolbar",
    configFields: ree(),
    partFields: oee(),
    factory: cee,
    apis: {
      setGroups: (t, a, u) => {
        t.setGroups(a, u);
      },
      refresh: (t, a) => {
        t.refresh(a);
      },
      reposition: (t, a) => {
        t.reposition(a);
      },
      toggle: (t, a) => {
        t.toggle(a);
      },
      toggleWithoutFocusing: (t, a) => {
        t.toggle(a);
      },
      isOpen: (t, a) => t.isOpen(a),
      getOverflow: (t, a) => t.getOverflow(a)
    }
  }), lee = q([
    eg([
      "closedClass",
      "openClass",
      "shrinkingClass",
      "growingClass",
      "overflowToggledClass"
    ]),
    po("onOpened"),
    po("onClosed")
  ].concat(SV())), uee = q([
    jl({
      factory: kv,
      schema: FT(),
      name: "primary"
    }),
    jl({
      factory: kv,
      schema: FT(),
      name: "overflow",
      overrides: (t) => ({
        toolbarBehaviours: mn([
          Cm.config({
            dimension: { property: "height" },
            closedClass: t.markers.closedClass,
            openClass: t.markers.openClass,
            shrinkingClass: t.markers.shrinkingClass,
            growingClass: t.markers.growingClass,
            onShrunk: (a) => {
              Fs(a, t, "overflow-button").each((u) => {
                Zr.off(u), Er.focus(u);
              }), t.onClosed(a);
            },
            onGrown: (a) => {
              ar.focusIn(a), t.onOpened(a);
            },
            onStartGrow: (a) => {
              Fs(a, t, "overflow-button").each(Zr.on);
            }
          }),
          ar.config({
            mode: "acyclic",
            onEscape: (a) => (Fs(a, t, "overflow-button").each(Er.focus), z.some(!0))
          })
        ])
      })
    }),
    rp({
      name: "overflow-button",
      overrides: (t) => ({
        buttonBehaviours: mn([Zr.config({
          toggleClass: t.markers.overflowToggledClass,
          aria: { mode: "pressed" },
          toggleOnExecute: !1
        })])
      })
    }),
    rp({ name: "overflow-group" })
  ]), dee = (t, a) => Fs(t, a, "overflow").map(Cm.hasGrown).getOr(!1), AV = (t, a) => {
    Fs(t, a, "overflow-button").bind(() => Fs(t, a, "overflow")).each((u) => {
      LP(t, a), Cm.toggleGrow(u);
    });
  }, LP = (t, a) => {
    Fs(t, a, "overflow").each((u) => {
      yV(t, a, (p) => {
        const y = He(p, (x) => Hu(x));
        kv.setGroups(u, y);
      }), Fs(t, a, "overflow-button").each((p) => {
        Cm.hasGrown(u) && Zr.on(p);
      }), Cm.refresh(u);
    });
  }, fee = (t, a, u, p) => {
    const y = "alloy.toolbar.toggle", x = (k, $) => {
      const B = He($, k.getSystem().build);
      t.builtGroups.set(B);
    };
    return {
      uid: t.uid,
      dom: t.dom,
      components: a,
      behaviours: _i(t.splitToolbarBehaviours, [
        yi.config({
          others: {
            overflowGroup: (k) => FP.sketch({
              ...p["overflow-group"](),
              items: [cl.sketch({
                ...p["overflow-button"](),
                action: ($) => {
                  Jr(k, y);
                }
              })]
            })
          }
        }),
        Hr("toolbar-toggle-events", [Pt(y, (k) => {
          AV(k, t);
        })])
      ]),
      apis: {
        setGroups: (k, $) => {
          x(k, $), LP(k, t);
        },
        refresh: (k) => LP(k, t),
        toggle: (k) => AV(k, t),
        isOpen: (k) => dee(k, t)
      },
      domModification: { attributes: { role: "group" } }
    };
  }, $4 = ql({
    name: "SplitSlidingToolbar",
    configFields: lee(),
    partFields: uee(),
    factory: fee,
    apis: {
      setGroups: (t, a, u) => {
        t.setGroups(a, u);
      },
      refresh: (t, a) => {
        t.refresh(a);
      },
      toggle: (t, a) => {
        t.toggle(a);
      },
      isOpen: (t, a) => t.isOpen(a)
    }
  }), BP = (t) => {
    const a = t.title.fold(() => ({}), (u) => ({ attributes: { title: u } }));
    return {
      dom: {
        tag: "div",
        classes: ["tox-toolbar__group"],
        ...a
      },
      components: [FP.parts.items({})],
      items: t.items,
      markers: { itemSelector: "*:not(.tox-split-button) > .tox-tbtn:not([disabled]), .tox-split-button:not([disabled]), .tox-toolbar-nav-js:not([disabled]), .tox-number-input:not([disabled])" },
      tgroupBehaviours: mn([
        Ea.config({}),
        Er.config({})
      ])
    };
  }, HP = (t) => FP.sketch(BP(t)), mA = (t, a) => {
    const u = us((p) => {
      const y = He(t.initGroups, HP);
      kv.setGroups(p, y);
    });
    return mn([
      ip.toolbarButton(t.providers.isDisabled),
      Bc(),
      ar.config({
        mode: a,
        onEscape: t.onEscape,
        selector: ".tox-toolbar__group"
      }),
      Hr("toolbar-events", [u])
    ]);
  }, kV = (t) => {
    const a = t.cyclicKeying ? "cyclic" : "acyclic";
    return {
      uid: t.uid,
      dom: {
        tag: "div",
        classes: ["tox-toolbar-overlord"]
      },
      parts: {
        "overflow-group": BP({
          title: z.none(),
          items: []
        }),
        "overflow-button": fX({
          name: "more",
          icon: z.some("more-drawer"),
          enabled: !0,
          tooltip: z.some("Reveal or hide additional toolbar items"),
          primary: !1,
          buttonType: z.none(),
          borderless: !1
        }, z.none(), t.providers)
      },
      splitToolbarBehaviours: mA(t, a)
    };
  }, NV = (t) => {
    const a = kV(t), u = 4, p = OV.parts.primary({
      dom: {
        tag: "div",
        classes: ["tox-toolbar__primary"]
      }
    });
    return OV.sketch({
      ...a,
      lazySink: t.getSink,
      getOverflowBounds: () => {
        const y = t.moreDrawerData.lazyHeader().element, x = Fi(y), k = Pl(y), $ = Fi(k), B = Math.max(k.dom.scrollHeight, $.height);
        return cs(x.x + u, $.y, x.width - u * 2, B);
      },
      parts: {
        ...a.parts,
        overflow: {
          dom: {
            tag: "div",
            classes: ["tox-toolbar__overflow"],
            attributes: t.attributes
          }
        }
      },
      components: [p],
      markers: { overflowToggledClass: "tox-tbtn--enabled" },
      onOpened: (y) => t.onToggled(y, !0),
      onClosed: (y) => t.onToggled(y, !1)
    });
  }, mee = (t) => {
    const a = $4.parts.primary({
      dom: {
        tag: "div",
        classes: ["tox-toolbar__primary"]
      }
    }), u = $4.parts.overflow({
      dom: {
        tag: "div",
        classes: ["tox-toolbar__overflow"]
      }
    }), p = kV(t);
    return $4.sketch({
      ...p,
      components: [
        a,
        u
      ],
      markers: {
        openClass: "tox-toolbar__overflow--open",
        closedClass: "tox-toolbar__overflow--closed",
        growingClass: "tox-toolbar__overflow--growing",
        shrinkingClass: "tox-toolbar__overflow--shrinking",
        overflowToggledClass: "tox-tbtn--enabled"
      },
      onOpened: (y) => {
        y.getSystem().broadcastOn([mS()], { type: "opened" }), t.onToggled(y, !0);
      },
      onClosed: (y) => {
        y.getSystem().broadcastOn([mS()], { type: "closed" }), t.onToggled(y, !1);
      }
    });
  }, zP = (t) => {
    const a = t.cyclicKeying ? "cyclic" : "acyclic";
    return kv.sketch({
      uid: t.uid,
      dom: {
        tag: "div",
        classes: ["tox-toolbar"].concat(t.type === ph.scrolling ? ["tox-toolbar--scrolling"] : [])
      },
      components: [kv.parts.groups({})],
      toolbarBehaviours: mA(t, a)
    });
  }, pee = [
    J0,
    wm,
    nc("tooltip"),
    vl("buttonType", "secondary", [
      "primary",
      "secondary"
    ]),
    vi("borderless", !1),
    id("onAction")
  ], hee = [
    ...pee,
    Kb,
    ka("type", ["button"])
  ], gee = [
    ...pee,
    vi("active", !1),
    ka("type", ["togglebutton"])
  ], VP = {
    button: hee,
    togglebutton: gee
  }, vee = [
    ka("type", ["group"]),
    bl("buttons", [], ro("type", VP))
  ], UP = ro("type", {
    ...VP,
    group: vee
  }), RV = jn([
    bl("buttons", [], UP),
    id("onShow"),
    id("onHide")
  ]), PV = (t) => Ws("view", RV, t), I4 = (t, a) => {
    var u, p;
    const y = t.type === "togglebutton", x = t.icon.map((mt) => lS(mt, a.icons)).map(ms), $ = (() => (mt) => {
      const jt = (hn) => {
        x.map((En) => En.getOpt(mt).each((zr) => {
          $r.set(zr, [lS(hn, a.icons)]);
        }));
      }, Dt = (hn) => {
        const En = mt.element;
        hn ? (ja(En, "tox-button--enabled"), kn(En, "aria-pressed", !0)) : (ua(En, "tox-button--enabled"), vs(En, "aria-pressed"));
      }, Nt = () => Ti(mt.element, "tox-button--enabled");
      if (y)
        return t.onAction({
          setIcon: jt,
          setActive: Dt,
          isActive: Nt
        });
      if (t.type === "button")
        return t.onAction({ setIcon: jt });
    })(), B = {
      ...t,
      name: y ? t.text.getOr(t.icon.getOr("")) : (u = t.text) !== null && u !== void 0 ? u : t.icon.getOr(""),
      primary: t.buttonType === "primary",
      buttonType: z.from(t.buttonType),
      tooltip: t.tooltip,
      icon: t.icon,
      enabled: !0,
      borderless: t.borderless
    }, j = Z3((p = t.buttonType) !== null && p !== void 0 ? p : "secondary"), Y = y ? t.text.map(a.translate) : z.some(a.translate(t.text)), re = Y.map(Ma), le = B.tooltip.or(Y).map((mt) => ({
      "aria-label": a.translate(mt),
      title: a.translate(mt)
    })).getOr({}), pe = x.map((mt) => mt.asSpec()), _e = kE([
      pe,
      re
    ]), ze = t.icon.isSome() && re.isSome(), ft = {
      tag: "button",
      classes: j.concat(...t.icon.isSome() && !ze ? ["tox-button--icon"] : []).concat(...ze ? ["tox-button--icon-and-text"] : []).concat(...t.borderless ? ["tox-button--naked"] : []).concat(...t.type === "togglebutton" && t.active ? ["tox-button--enabled"] : []),
      attributes: le
    }, Xe = [], Ze = gP(B, z.some($), Xe, ft, _e, a);
    return cl.sketch(Ze);
  }, DV = (t, a) => I4(t, a), $V = (t, a) => ({
    dom: {
      tag: "div",
      classes: ["tox-view__toolbar__group"]
    },
    components: He(t.buttons, (u) => DV(u, a))
  }), HE = Ft().deviceType, IV = HE.isPhone(), bee = HE.isTablet(), yee = (t) => {
    let a = !1;
    const u = He(t.buttons, (p) => p.type === "group" ? (a = !0, $V(p, t.providers)) : DV(p, t.providers));
    return {
      uid: t.uid,
      dom: {
        tag: "div",
        classes: [
          a ? "tox-view__toolbar" : "tox-view__header",
          ...IV || bee ? [
            "tox-view--mobile",
            "tox-view--scrolling"
          ] : []
        ]
      },
      behaviours: mn([
        Er.config({}),
        ar.config({
          mode: "flow",
          selector: "button, .tox-button",
          focusInside: A.OnEnterOrSpaceMode
        })
      ]),
      components: a ? u : [
        Tv.sketch({
          dom: {
            tag: "div",
            classes: ["tox-view__header-start"]
          },
          components: []
        }),
        Tv.sketch({
          dom: {
            tag: "div",
            classes: ["tox-view__header-end"]
          },
          components: u
        })
      ]
    };
  }, See = (t) => ({
    uid: t.uid,
    dom: {
      tag: "div",
      classes: ["tox-view__pane"]
    }
  }), M4 = (t, a, u, p) => {
    const y = {
      getPane: (x) => Vc.getPart(x, t, "pane"),
      getOnShow: (x) => t.viewConfig.onShow,
      getOnHide: (x) => t.viewConfig.onHide
    };
    return {
      uid: t.uid,
      dom: t.dom,
      components: a,
      apis: y
    };
  };
  var HT = ql({
    name: "silver.View",
    configFields: [Mt("viewConfig")],
    partFields: [
      vd({
        factory: { sketch: yee },
        schema: [
          Mt("buttons"),
          Mt("providers")
        ],
        name: "header"
      }),
      vd({
        factory: { sketch: See },
        schema: [],
        name: "pane"
      })
    ],
    factory: M4,
    apis: {
      getPane: (t, a) => t.getPane(a),
      getOnShow: (t, a) => t.getOnShow(a),
      getOnHide: (t, a) => t.getOnHide(a)
    }
  });
  const wee = (t, a, u) => hc(a, (p, y) => {
    const x = Mo(PV(p));
    return t.slot(y, HT.sketch({
      dom: {
        tag: "div",
        classes: ["tox-view"]
      },
      viewConfig: x,
      components: [
        ...x.buttons.length > 0 ? [HT.parts.header({
          buttons: x.buttons,
          providers: u
        })] : [],
        HT.parts.pane({})
      ]
    }));
  }), MV = (t, a) => Ed.sketch((u) => ({
    dom: {
      tag: "div",
      classes: ["tox-view-wrap__slot-container"]
    },
    components: wee(u, t, a),
    slotBehaviours: CO.unnamedEvents([us((p) => Ed.hideAllSlots(p))])
  })), F4 = (t) => Ge(Ed.getSlotNames(t), (a) => Ed.isShowing(t, a)), WP = (t) => {
    const a = t.element;
    Sr(a, "display", "none"), kn(a, "aria-hidden", "true");
  }, L4 = (t) => {
    const a = t.element;
    Ur(a, "display"), vs(a, "aria-hidden");
  }, Eee = (t) => ({ getContainer: q(t) }), FV = (t, a, u) => {
    Ed.getSlot(t, a).each((p) => {
      HT.getPane(p).each((y) => {
        u(p)(Eee(y.element.dom));
      });
    });
  }, LV = (t, a) => FV(t, a, HT.getOnShow), Cee = (t, a) => FV(t, a, HT.getOnHide);
  var jP = Yd({
    factory: (t, a) => {
      const x = {
        setViews: (k, $) => {
          $r.set(k, [MV($, a.backstage.shared.providers)]);
        },
        whichView: (k) => ho.getCurrent(k).bind(F4),
        toggleView: (k, $, B, j) => ho.getCurrent(k).exists((Y) => {
          const re = F4(Y), le = re.exists((_e) => j === _e), pe = Ed.getSlot(Y, j).isSome();
          return pe && (Ed.hideAllSlots(Y), le ? (WP(k), $()) : (B(), L4(k), Ed.showSlot(Y, j), LV(Y, j)), re.each((_e) => Cee(Y, _e))), pe;
        })
      };
      return {
        uid: t.uid,
        dom: {
          tag: "div",
          classes: ["tox-view-wrap"],
          attributes: { "aria-hidden": "true" },
          styles: { display: "none" }
        },
        components: [],
        behaviours: mn([
          $r.config({}),
          ho.config({
            find: (k) => {
              const $ = $r.contents(k);
              return $n($);
            }
          })
        ]),
        apis: x
      };
    },
    name: "silver.ViewWrapper",
    configFields: [Mt("backstage")],
    apis: {
      setViews: (t, a, u) => t.setViews(a, u),
      toggleView: (t, a, u, p, y) => t.toggleView(a, u, p, y),
      whichView: (t, a) => t.whichView(a)
    }
  });
  const BV = (t, a, u) => {
    let p = !1;
    const y = {
      getSocket: (x) => Vc.getPart(x, t, "socket"),
      setSidebar: (x, k, $) => {
        Vc.getPart(x, t, "sidebar").each((B) => qJ(B, k, $));
      },
      toggleSidebar: (x, k) => {
        Vc.getPart(x, t, "sidebar").each(($) => GJ($, k));
      },
      whichSidebar: (x) => Vc.getPart(x, t, "sidebar").bind(fV).getOrNull(),
      getHeader: (x) => Vc.getPart(x, t, "header"),
      getToolbar: (x) => Vc.getPart(x, t, "toolbar"),
      setToolbar: (x, k) => {
        Vc.getPart(x, t, "toolbar").each(($) => {
          const B = He(k, HP);
          $.getApis().setGroups($, B);
        });
      },
      setToolbars: (x, k) => {
        Vc.getPart(x, t, "multiple-toolbar").each(($) => {
          const B = He(k, (j) => He(j, HP));
          xP.setItems($, B);
        });
      },
      refreshToolbar: (x) => {
        Vc.getPart(x, t, "toolbar").each(($) => $.getApis().refresh($));
      },
      toggleToolbarDrawer: (x) => {
        Vc.getPart(x, t, "toolbar").each((k) => {
          gs(k.getApis().toggle, ($) => $(k));
        });
      },
      toggleToolbarDrawerWithoutFocusing: (x) => {
        Vc.getPart(x, t, "toolbar").each((k) => {
          gs(k.getApis().toggleWithoutFocusing, ($) => $(k));
        });
      },
      isToolbarDrawerToggled: (x) => Vc.getPart(x, t, "toolbar").bind((k) => z.from(k.getApis().isOpen).map(($) => $(k))).getOr(!1),
      getThrobber: (x) => Vc.getPart(x, t, "throbber"),
      focusToolbar: (x) => {
        Vc.getPart(x, t, "toolbar").orThunk(() => Vc.getPart(x, t, "multiple-toolbar")).each(($) => {
          ar.focusIn($);
        });
      },
      setMenubar: (x, k) => {
        Vc.getPart(x, t, "menubar").each(($) => {
          x4.setMenus($, k);
        });
      },
      focusMenubar: (x) => {
        Vc.getPart(x, t, "menubar").each((k) => {
          x4.focus(k);
        });
      },
      setViews: (x, k) => {
        Vc.getPart(x, t, "viewWrapper").each(($) => {
          jP.setViews($, k);
        });
      },
      toggleView: (x, k) => Vc.getPart(x, t, "viewWrapper").exists(($) => jP.toggleView($, () => y.showMainView(x), () => y.hideMainView(x), k)),
      whichView: (x) => Vc.getPart(x, t, "viewWrapper").bind(jP.whichView).getOrNull(),
      hideMainView: (x) => {
        p = y.isToolbarDrawerToggled(x), p && y.toggleToolbarDrawer(x), Vc.getPart(x, t, "editorContainer").each((k) => {
          const $ = k.element;
          Sr($, "display", "none"), kn($, "aria-hidden", "true");
        });
      },
      showMainView: (x) => {
        p && y.toggleToolbarDrawer(x), Vc.getPart(x, t, "editorContainer").each((k) => {
          const $ = k.element;
          Ur($, "display"), vs($, "aria-hidden");
        });
      }
    };
    return {
      uid: t.uid,
      dom: t.dom,
      components: a,
      apis: y,
      behaviours: t.behaviours
    };
  }, xee = ny.optional({
    factory: x4,
    name: "menubar",
    schema: [Mt("backstage")]
  }), Tee = (t) => t.type === ph.sliding ? mee : t.type === ph.floating ? NV : zP, B4 = ny.optional({
    factory: {
      sketch: (t) => xP.sketch({
        uid: t.uid,
        dom: t.dom,
        listBehaviours: mn([ar.config({
          mode: "acyclic",
          selector: ".tox-toolbar"
        })]),
        makeItem: () => zP({
          type: t.type,
          uid: Hn("multiple-toolbar-item"),
          cyclicKeying: !1,
          initGroups: [],
          providers: t.providers,
          onEscape: () => (t.onEscape(), z.some(!0))
        }),
        setupItem: (a, u, p, y) => {
          kv.setGroups(u, p);
        },
        shell: !0
      })
    },
    name: "multiple-toolbar",
    schema: [
      Mt("dom"),
      Mt("onEscape")
    ]
  }), _ee = ny.optional({
    factory: {
      sketch: (t) => {
        const a = Tee(t), u = {
          type: t.type,
          uid: t.uid,
          onEscape: () => (t.onEscape(), z.some(!0)),
          onToggled: (p, y) => t.onToolbarToggled(y),
          cyclicKeying: !1,
          initGroups: [],
          getSink: t.getSink,
          providers: t.providers,
          moreDrawerData: {
            lazyToolbar: t.lazyToolbar,
            lazyMoreButton: t.lazyMoreButton,
            lazyHeader: t.lazyHeader
          },
          attributes: t.attributes
        };
        return a(u);
      }
    },
    name: "toolbar",
    schema: [
      Mt("dom"),
      Mt("onEscape"),
      Mt("getSink")
    ]
  }), Oee = ny.optional({
    factory: { sketch: cV },
    name: "header",
    schema: [Mt("dom")]
  }), HV = ny.optional({
    factory: { sketch: BJ },
    name: "promotion",
    schema: [Mt("dom")]
  }), Aee = ny.optional({
    name: "socket",
    schema: [Mt("dom")]
  }), zV = ny.optional({
    factory: { sketch: ZJ },
    name: "sidebar",
    schema: [Mt("dom")]
  }), kee = ny.optional({
    factory: { sketch: XJ },
    name: "throbber",
    schema: [Mt("dom")]
  }), VV = ny.optional({
    factory: jP,
    name: "viewWrapper",
    schema: [Mt("backstage")]
  }), Nee = (t) => ({
    uid: t.uid,
    dom: {
      tag: "div",
      classes: ["tox-editor-container"]
    },
    components: t.components
  }), Ree = ny.optional({
    factory: { sketch: Nee },
    name: "editorContainer",
    schema: []
  });
  var Qs = ql({
    name: "OuterContainer",
    factory: BV,
    configFields: [
      Mt("dom"),
      Mt("behaviours")
    ],
    partFields: [
      Oee,
      xee,
      _ee,
      B4,
      Aee,
      zV,
      HV,
      kee,
      VV,
      Ree
    ],
    apis: {
      getSocket: (t, a) => t.getSocket(a),
      setSidebar: (t, a, u, p) => {
        t.setSidebar(a, u, p);
      },
      toggleSidebar: (t, a, u) => {
        t.toggleSidebar(a, u);
      },
      whichSidebar: (t, a) => t.whichSidebar(a),
      getHeader: (t, a) => t.getHeader(a),
      getToolbar: (t, a) => t.getToolbar(a),
      setToolbar: (t, a, u) => {
        t.setToolbar(a, u);
      },
      setToolbars: (t, a, u) => {
        t.setToolbars(a, u);
      },
      refreshToolbar: (t, a) => t.refreshToolbar(a),
      toggleToolbarDrawer: (t, a) => {
        t.toggleToolbarDrawer(a);
      },
      toggleToolbarDrawerWithoutFocusing: (t, a) => {
        t.toggleToolbarDrawerWithoutFocusing(a);
      },
      isToolbarDrawerToggled: (t, a) => t.isToolbarDrawerToggled(a),
      getThrobber: (t, a) => t.getThrobber(a),
      setMenubar: (t, a, u) => {
        t.setMenubar(a, u);
      },
      focusMenubar: (t, a) => {
        t.focusMenubar(a);
      },
      focusToolbar: (t, a) => {
        t.focusToolbar(a);
      },
      setViews: (t, a, u) => {
        t.setViews(a, u);
      },
      toggleView: (t, a, u) => t.toggleView(a, u),
      whichView: (t, a) => t.whichView(a)
    }
  });
  const UV = "file edit view insert format tools table help", WV = {
    file: {
      title: "File",
      items: "newdocument restoredraft | preview | export print | deleteallconversations"
    },
    edit: {
      title: "Edit",
      items: "undo redo | cut copy paste pastetext | selectall | searchreplace"
    },
    view: {
      title: "View",
      items: "code | visualaid visualchars visualblocks | spellchecker | preview fullscreen | showcomments"
    },
    insert: {
      title: "Insert",
      items: "image link media addcomment pageembed template inserttemplate codesample inserttable accordion | charmap emoticons hr | pagebreak nonbreaking anchor tableofcontents footnotes | mergetags | insertdatetime"
    },
    format: {
      title: "Format",
      items: "bold italic underline strikethrough superscript subscript codeformat | styles blocks fontfamily fontsize align lineheight | forecolor backcolor | language | removeformat"
    },
    tools: {
      title: "Tools",
      items: "aidialog aishortcuts | spellchecker spellcheckerlanguage | autocorrect capitalization | a11ycheck code typography wordcount addtemplate"
    },
    table: {
      title: "Table",
      items: "inserttable | cell row column | advtablesort | tableprops deletetable"
    },
    help: {
      title: "Help",
      items: "help"
    }
  }, Pee = (t, a, u) => {
    const p = Z0(u).split(/[ ,]/);
    return {
      text: t.title,
      getItems: () => ke(t.items, (y) => {
        const x = y.toLowerCase();
        return x.trim().length === 0 ? [] : Gt(p, (k) => k === x) ? [] : x === "separator" || x === "|" ? [{ type: "separator" }] : a.menuItems[x] ? [a.menuItems[x]] : [];
      })
    };
  }, H4 = (t) => t.split(" "), qP = (t, a) => {
    const u = {
      ...WV,
      ...a.menus
    }, p = Xr(a.menus).length > 0, y = a.menubar === void 0 || a.menubar === !0 ? H4(UV) : H4(a.menubar === !1 ? "" : a.menubar), x = Rn(y, ($) => {
      const B = Yr(WV, $);
      return p ? B || fn(a.menus, $).exists((j) => Yr(j, "items")) : B;
    }), k = He(x, ($) => {
      const B = u[$];
      return Pee({
        title: B.title,
        items: H4(B.items)
      }, a, t);
    });
    return Rn(k, ($) => {
      const B = (j) => g(j) || j.type !== "separator";
      return $.getItems().length > 0 && Gt($.getItems(), B);
    });
  }, z4 = (t) => {
    const a = () => {
      t._skinLoaded = !0, BZ(t);
    };
    return () => {
      t.initialized ? a() : t.on("init", a);
    };
  }, Dee = (t, a) => () => wF(t, { message: a }), jV = (t, a, u) => (t.on("remove", () => u.unload(a)), u.load(a)), V4 = (t, a, u, p) => (t.on("remove", () => p.unloadRawCss(a)), p.loadRawCss(a, u)), $ee = async (t, a) => {
    const p = "ui/" + tR(t).getOr("default") + "/skin.css", y = tinymce.Resource.get(p);
    if (g(y))
      return Promise.resolve(V4(t, p, y, t.ui.styleSheetLoader));
    {
      const x = a + "/skin.min.css";
      return jV(t, x, t.ui.styleSheetLoader);
    }
  }, Iee = async (t, a) => {
    if (ur(nt.fromDom(t.getElement()))) {
      const y = "ui/" + tR(t).getOr("default") + "/skin.shadowdom.css", x = tinymce.Resource.get(y);
      if (g(x))
        return V4(t, y, x, uT.DOM.styleSheetLoader), Promise.resolve();
      {
        const k = a + "/skin.shadowdom.min.css";
        return jV(t, k, uT.DOM.styleSheetLoader);
      }
    }
  }, Mee = async (t, a) => {
    tR(a).fold(() => {
      const p = eR(a);
      p && a.contentCSS.push(p + (t ? "/content.inline" : "/content") + ".min.css");
    }, (p) => {
      const y = "ui/" + p + (t ? "/content.inline" : "/content") + ".css", x = tinymce.Resource.get(y);
      if (g(x))
        V4(a, y, x, a.ui.styleSheetLoader);
      else {
        const k = eR(a);
        k && a.contentCSS.push(k + (t ? "/content.inline" : "/content") + ".min.css");
      }
    });
    const u = eR(a);
    if (!MM(a) && g(u))
      return Promise.all([
        $ee(a, u),
        Iee(a, u)
      ]).then();
  }, qV = (t, a) => Mee(t, a).then(z4(a), Dee(a, "Skin could not be loaded")), Fee = je(qV, !1), Lee = je(qV, !0), zE = (t, a, u) => t.translate([
    a,
    t.translate(u)
  ]), GP = (t, a) => {
    const u = (k, $, B, j) => {
      const Y = t.shared.providers.translate(k.title);
      if (k.type === "separator")
        return z.some({
          type: "separator",
          text: Y
        });
      if (k.type === "submenu") {
        const re = ke(k.getStyleItems(), (le) => p(le, $, j));
        return $ === 0 && re.length <= 0 ? z.none() : z.some({
          type: "nestedmenuitem",
          text: Y,
          enabled: re.length > 0,
          getSubmenuItems: () => ke(k.getStyleItems(), (le) => p(le, $, j))
        });
      } else
        return z.some({
          type: "togglemenuitem",
          text: Y,
          icon: k.icon,
          active: k.isSelected(j),
          enabled: !B,
          onAction: a.onAction(k),
          ...k.getStylePreview().fold(() => ({}), (re) => ({ meta: { style: re } }))
        });
    }, p = (k, $, B) => {
      const j = k.type === "formatter" && a.isInvalid(k);
      return $ === 0 ? j ? [] : u(k, $, !1, B).toArray() : u(k, $, j, B).toArray();
    }, y = (k) => {
      const $ = a.getCurrentValue(), B = a.shouldHide ? 0 : 1;
      return ke(k, (j) => p(j, B, $));
    };
    return {
      validateItems: y,
      getFetch: (k, $) => (B, j) => {
        const Y = $(), re = y(Y), le = RT(re, Cv.CLOSE_ON_EXECUTE, k, {
          isHorizontalMenu: !1,
          search: z.none()
        });
        j(le);
      }
    };
  }, hS = (t, a, u) => {
    const p = u.dataset, y = p.type === "basic" ? () => He(p.data, (x) => t4(x, u.isSelectedFor, u.getPreviewFor)) : p.getData;
    return {
      items: GP(a, u),
      getStyleItems: y
    };
  }, zT = (t, a, u, p, y) => {
    const { items: x, getStyleItems: k } = hS(t, a, u), $ = (j) => ({
      getComponent: q(j),
      setTooltip: (Y) => {
        const re = a.shared.providers.translate(Y);
        Pm(j.element, {
          "aria-label": re,
          title: re
        });
      }
    }), B = (j) => {
      const Y = (re) => j.setTooltip(zE(t, p, re.value));
      return t.on(y, Y), kO(hg(t, "NodeChange", (re) => {
        const le = re.getComponent();
        u.updateText(le), yr.set(re.getComponent(), !t.selection.isEditable());
      })(j), () => t.off(y, Y));
    };
    return D3({
      text: u.icon.isSome() ? z.none() : u.text,
      icon: u.icon,
      tooltip: z.from(u.tooltip),
      role: z.none(),
      fetch: x.getFetch(a, k),
      onSetup: B,
      getApi: $,
      columns: 1,
      presets: "normal",
      classes: u.icon.isSome() ? [] : ["bespoke"],
      dropdownBehaviours: []
    }, "tox-tbtn", a.shared);
  }, gS = (t) => He(t, (a) => {
    let u = a, p = a;
    const y = a.split("=");
    return y.length > 1 && (u = y[0], p = y[1]), {
      title: u,
      format: p
    };
  }), GV = (t) => ({
    type: "basic",
    data: t
  });
  var VT;
  (function(t) {
    t[t.SemiColon = 0] = "SemiColon", t[t.Space = 1] = "Space";
  })(VT || (VT = {}));
  const Bee = (t, a) => a === VT.SemiColon ? t.replace(/;$/, "").split(";") : t.split(" "), U4 = (t, a, u) => {
    const p = t.options.get(a);
    return {
      type: "basic",
      data: gS(Bee(p, u))
    };
  }, Hee = "Align", ZV = "Alignment {0}", KV = "left", W4 = [
    {
      title: "Left",
      icon: "align-left",
      format: "alignleft",
      command: "JustifyLeft"
    },
    {
      title: "Center",
      icon: "align-center",
      format: "aligncenter",
      command: "JustifyCenter"
    },
    {
      title: "Right",
      icon: "align-right",
      format: "alignright",
      command: "JustifyRight"
    },
    {
      title: "Justify",
      icon: "align-justify",
      format: "alignjustify",
      command: "JustifyFull"
    }
  ], j4 = (t) => {
    const a = () => Ge(W4, ($) => t.formatter.match($.format)), u = ($) => () => t.formatter.match($), p = ($) => z.none, y = ($) => {
      const j = a().fold(q(KV), (Y) => Y.title.toLowerCase());
      nr($, uS, { icon: `align-${j}` }), UZ(t, { value: j });
    }, x = GV(W4), k = ($) => () => Ge(W4, (B) => B.format === $.format).each((B) => t.execCommand(B.command));
    return {
      tooltip: zE(t, ZV, KV),
      text: z.none(),
      icon: z.some("align-left"),
      isSelectedFor: u,
      getCurrentValue: z.none,
      getPreviewFor: p,
      onAction: k,
      updateText: y,
      dataset: x,
      shouldHide: !1,
      isInvalid: ($) => !t.formatter.canApply($.format)
    };
  }, zee = (t, a) => zT(t, a, j4(t), ZV, "AlignTextUpdate"), Vee = (t, a) => {
    const u = hS(t, a, j4(t));
    t.ui.registry.addNestedMenuItem("align", {
      text: a.shared.providers.translate(Hee),
      onSetup: wd(t),
      getSubmenuItems: () => u.items.validateItems(u.getStyleItems())
    });
  }, ZP = (t, a) => {
    const u = a(), p = He(u, (y) => y.format);
    return z.from(t.formatter.closest(p)).bind((y) => Ge(u, (x) => x.format === y)).orThunk(() => lr(t.formatter.match("p"), {
      title: "Paragraph",
      format: "p"
    }));
  }, Uee = "Blocks", YV = "Block {0}", q4 = "Paragraph", QV = (t) => {
    const a = (x) => () => t.formatter.match(x), u = (x) => () => {
      const k = t.formatter.get(x);
      return k ? z.some({
        tag: k.length > 0 && (k[0].inline || k[0].block) || "div",
        styles: t.dom.parseStyle(t.formatter.getCssText(x))
      }) : z.none();
    }, p = (x) => {
      const $ = ZP(t, () => y.data).fold(q(q4), (B) => B.title);
      nr(x, lp, { text: $ }), Z8(t, { value: $ });
    }, y = U4(t, "block_formats", VT.SemiColon);
    return {
      tooltip: zE(t, YV, q4),
      text: z.some(q4),
      icon: z.none(),
      isSelectedFor: a,
      getCurrentValue: z.none,
      getPreviewFor: u,
      onAction: Y8(t),
      updateText: p,
      dataset: y,
      shouldHide: !1,
      isInvalid: (x) => !t.formatter.canApply(x.format)
    };
  }, Wee = (t, a) => zT(t, a, QV(t), YV, "BlocksTextUpdate"), jee = (t, a) => {
    const u = hS(t, a, QV(t));
    t.ui.registry.addNestedMenuItem("blocks", {
      text: Uee,
      onSetup: wd(t),
      getSubmenuItems: () => u.items.validateItems(u.getStyleItems())
    });
  }, XV = "Fonts", G4 = "Font {0}", KP = "System Font", qee = [
    "-apple-system",
    "Segoe UI",
    "Roboto",
    "Helvetica Neue",
    "sans-serif"
  ], Z4 = (t) => {
    const a = t.split(/\s*,\s*/);
    return He(a, (u) => u.replace(/^['"]+|['"]+$/g, ""));
  }, JV = (t, a) => a.length > 0 && Ct(a, (u) => t.indexOf(u.toLowerCase()) > -1), Gee = (t, a) => {
    if (t.indexOf("-apple-system") === 0 || a.length > 0) {
      const u = Z4(t.toLowerCase());
      return JV(u, qee) || JV(u, a);
    } else
      return !1;
  }, eU = (t) => {
    const a = () => {
      const B = (_e) => _e ? Z4(_e)[0] : "", j = t.queryCommandValue("FontName"), Y = $.data, re = j ? j.toLowerCase() : "", le = I6(t);
      return {
        matchOpt: Ge(Y, (_e) => {
          const ze = _e.format;
          return ze.toLowerCase() === re || B(ze).toLowerCase() === B(re).toLowerCase();
        }).orThunk(() => lr(Gee(re, le), {
          title: KP,
          format: re
        })),
        font: j
      };
    }, u = (B) => (j) => j.exists((Y) => Y.format === B), p = () => {
      const { matchOpt: B } = a();
      return B;
    }, y = (B) => () => z.some({
      tag: "div",
      styles: B.indexOf("dings") === -1 ? { "font-family": B } : {}
    }), x = (B) => () => {
      t.undoManager.transact(() => {
        t.focus(), t.execCommand("FontName", !1, B.format);
      });
    }, k = (B) => {
      const { matchOpt: j, font: Y } = a(), re = j.fold(q(Y), (le) => le.title);
      nr(B, lp, { text: re }), K8(t, { value: re });
    }, $ = U4(t, "font_family_formats", VT.SemiColon);
    return {
      tooltip: zE(t, G4, KP),
      text: z.some(KP),
      icon: z.none(),
      isSelectedFor: u,
      getCurrentValue: p,
      getPreviewFor: y,
      onAction: x,
      updateText: k,
      dataset: $,
      shouldHide: !1,
      isInvalid: sn
    };
  }, tU = (t, a) => zT(t, a, eU(t), G4, "FontFamilyTextUpdate"), Zee = (t, a) => {
    const u = hS(t, a, eU(t));
    t.ui.registry.addNestedMenuItem("fontfamily", {
      text: a.shared.providers.translate(XV),
      onSetup: wd(t),
      getSubmenuItems: () => u.items.validateItems(u.getStyleItems())
    });
  }, nU = {
    unsupportedLength: [
      "em",
      "ex",
      "cap",
      "ch",
      "ic",
      "rem",
      "lh",
      "rlh",
      "vw",
      "vh",
      "vi",
      "vb",
      "vmin",
      "vmax",
      "cm",
      "mm",
      "Q",
      "in",
      "pc",
      "pt",
      "px"
    ],
    fixed: [
      "px",
      "pt"
    ],
    relative: ["%"],
    empty: [""]
  }, Kee = (() => {
    const t = "[0-9]+", u = "[eE]" + ("[+-]?" + t), p = "\\.", y = ($) => `(?:${$})?`, k = `[+-]?(?:${[
      "Infinity",
      t + p + y(t) + y(u),
      p + t + y(u),
      t + y(u)
    ].join("|")})`;
    return new RegExp(`^(${k})(.*)$`);
  })(), Yee = (t, a) => Gt(a, (u) => Gt(nU[u], (p) => t === p)), YP = (t, a) => z.from(Kee.exec(t)).bind((p) => {
    const y = Number(p[1]), x = p[2];
    return Yee(x, a) ? z.some({
      value: y,
      unit: x
    }) : z.none();
  }), Qee = (t, a) => YP(t, a).map(({ value: u, unit: p }) => u + p), rU = {
    tab: q(9),
    escape: q(27),
    enter: q(13),
    backspace: q(8),
    delete: q(46),
    left: q(37),
    up: q(38),
    right: q(39),
    down: q(40),
    space: q(32),
    home: q(36),
    end: q(35),
    pageUp: q(33),
    pageDown: q(34)
  }, Xee = (t, a, u) => {
    let p = z.none();
    const y = (Ze) => Ze.map((mt) => Pn.getValue(mt)).getOr(""), x = hg(t, "NodeChange SwitchMode", (Ze) => {
      const mt = Ze.getComponent();
      p = z.some(mt), u.updateInputValue(mt), yr.set(mt, !t.selection.isEditable());
    }), k = (Ze) => ({ getComponent: q(Ze) }), $ = sr(G), B = Hn("custom-number-input-events"), j = (Ze, mt, jt) => {
      const Dt = y(p), Nt = u.getNewValue(Dt, Ze), hn = Dt.length - `${Nt}`.length, En = p.map((Yn) => Yn.element.dom.selectionStart - hn), zr = p.map((Yn) => Yn.element.dom.selectionEnd - hn);
      u.onAction(Nt, jt), p.each((Yn) => {
        Pn.setValue(Yn, Nt), mt && (En.each((hr) => Yn.element.dom.selectionStart = hr), zr.each((hr) => Yn.element.dom.selectionEnd = hr));
      });
    }, Y = (Ze, mt) => j((jt, Dt) => jt - Dt, Ze, mt), re = (Ze, mt) => j((jt, Dt) => jt + Dt, Ze, mt), le = (Ze) => $l(Ze.element).fold(z.none, (mt) => (Fa(mt), z.some(!0))), pe = (Ze) => zy(Ze.element) ? (sf(Ze.element).each((mt) => Fa(mt)), z.some(!0)) : z.none(), _e = (Ze, mt, jt, Dt) => {
      const Nt = sr(G), hn = a.shared.providers.translate(jt), En = Hn("altExecuting"), zr = hg(t, "NodeChange SwitchMode", (hr) => {
        yr.set(hr.getComponent(), !t.selection.isEditable());
      }), Yn = (hr) => {
        yr.isDisabled(hr) || Ze(!0);
      };
      return cl.sketch({
        dom: {
          tag: "button",
          attributes: {
            title: hn,
            "aria-label": hn
          },
          classes: Dt.concat(mt)
        },
        components: [P3(mt, a.shared.providers.icons)],
        buttonBehaviours: mn([
          yr.config({}),
          Hr(En, [
            l1({
              onSetup: zr,
              getApi: k
            }, Nt),
            pg({ getApi: k }, Nt),
            Pt(ud(), (hr, Cr) => {
              (Cr.event.raw.keyCode === rU.space() || Cr.event.raw.keyCode === rU.enter()) && (yr.isDisabled(hr) || Ze(!1));
            }),
            Pt(um(), Yn),
            Pt(Lp(), Yn)
          ])
        ]),
        eventOrder: {
          [ud()]: [
            En,
            "keying"
          ],
          [um()]: [
            En,
            "alloy.base.behaviour"
          ],
          [Lp()]: [
            En,
            "alloy.base.behaviour"
          ]
        }
      });
    }, ze = ms(_e((Ze) => Y(!1, Ze), "minus", "Decrease font size", [])), ft = ms(_e((Ze) => re(!1, Ze), "plus", "Increase font size", [])), Xe = ms({
      dom: {
        tag: "div",
        classes: ["tox-input-wrapper"]
      },
      components: [TE.sketch({
        inputBehaviours: mn([
          yr.config({}),
          Hr(B, [
            l1({
              onSetup: x,
              getApi: k
            }, $),
            pg({ getApi: k }, $)
          ]),
          Hr("input-update-display-text", [
            Pt(lp, (Ze, mt) => {
              Pn.setValue(Ze, mt.event.text);
            }),
            Pt(fu(), (Ze) => {
              u.onAction(Pn.getValue(Ze));
            }),
            Pt(Gg(), (Ze) => {
              u.onAction(Pn.getValue(Ze));
            })
          ]),
          ar.config({
            mode: "special",
            onEnter: (Ze) => (j(Te, !0, !0), z.some(!0)),
            onEscape: le,
            onUp: (Ze) => (re(!0, !1), z.some(!0)),
            onDown: (Ze) => (Y(!0, !1), z.some(!0)),
            onLeft: (Ze, mt) => (mt.cut(), z.none()),
            onRight: (Ze, mt) => (mt.cut(), z.none())
          })
        ])
      })],
      behaviours: mn([
        Er.config({}),
        ar.config({
          mode: "special",
          onEnter: pe,
          onSpace: pe,
          onEscape: le
        }),
        Hr("input-wrapper-events", [Pt(yf(), (Ze) => {
          ut([
            ze,
            ft
          ], (mt) => {
            const jt = nt.fromDom(mt.get(Ze).element.dom);
            zy(jt) && gm(jt);
          });
        })])
      ])
    });
    return {
      dom: {
        tag: "div",
        classes: ["tox-number-input"]
      },
      components: [
        ze.asSpec(),
        Xe.asSpec(),
        ft.asSpec()
      ],
      behaviours: mn([
        Er.config({}),
        ar.config({
          mode: "flow",
          focusInside: A.OnEnterOrSpaceMode,
          cycles: !1,
          selector: "button, .tox-input-wrapper",
          onEscape: (Ze) => zy(Ze.element) ? z.none() : (Fa(Ze.element), z.some(!0))
        })
      ])
    };
  }, Jee = "Font sizes", K4 = "Font size {0}", oU = "12pt", ete = {
    "8pt": "1",
    "10pt": "2",
    "12pt": "3",
    "14pt": "4",
    "18pt": "5",
    "24pt": "6",
    "36pt": "7"
  }, tte = {
    "xx-small": "7pt",
    "x-small": "8pt",
    small: "10pt",
    medium: "12pt",
    large: "14pt",
    "x-large": "18pt",
    "xx-large": "24pt"
  }, nte = (t, a) => {
    const u = Math.pow(10, a);
    return Math.round(t * u) / u;
  }, rte = (t, a) => /[0-9.]+px$/.test(t) ? nte(parseInt(t, 10) * 72 / 96, a || 0) + "pt" : fn(tte, t).getOr(t), ote = (t) => fn(ete, t).getOr(""), sU = (t) => {
    const a = () => {
      let B = z.none();
      const j = $.data, Y = t.queryCommandValue("FontSize");
      if (Y)
        for (let re = 3; B.isNone() && re >= 0; re--) {
          const le = rte(Y, re), pe = ote(le);
          B = Ge(j, (_e) => _e.format === Y || _e.format === le || _e.format === pe);
        }
      return {
        matchOpt: B,
        size: Y
      };
    }, u = (B) => (j) => j.exists((Y) => Y.format === B), p = () => {
      const { matchOpt: B } = a();
      return B;
    }, y = q(z.none), x = (B) => () => {
      t.undoManager.transact(() => {
        t.focus(), t.execCommand("FontSize", !1, B.format);
      });
    }, k = (B) => {
      const { matchOpt: j, size: Y } = a(), re = j.fold(q(Y), (le) => le.title);
      nr(B, lp, { text: re }), WZ(t, { value: re });
    }, $ = U4(t, "font_size_formats", VT.Space);
    return {
      tooltip: zE(t, K4, oU),
      text: z.some(oU),
      icon: z.none(),
      isSelectedFor: u,
      getPreviewFor: y,
      getCurrentValue: p,
      onAction: x,
      updateText: k,
      dataset: $,
      shouldHide: !1,
      isInvalid: sn
    };
  }, aU = (t, a) => zT(t, a, sU(t), K4, "FontSizeTextUpdate"), ste = (t) => {
    var a;
    const u = { step: 1 };
    return (a = {
      em: { step: 0.1 },
      cm: { step: 0.1 },
      in: { step: 0.1 },
      pc: { step: 0.1 },
      ch: { step: 0.1 },
      rem: { step: 0.1 }
    }[t]) !== null && a !== void 0 ? a : u;
  }, ate = 16, iU = (t) => t >= 0, ite = (t) => {
    const a = () => t.queryCommandValue("FontSize");
    return {
      updateInputValue: (p) => nr(p, lp, { text: a() }),
      onAction: (p, y) => t.execCommand("FontSize", !1, p, { skip_focus: !y }),
      getNewValue: (p, y) => {
        YP(p, [
          "unsupportedLength",
          "empty"
        ]);
        const x = a(), k = YP(p, [
          "unsupportedLength",
          "empty"
        ]).or(YP(x, [
          "unsupportedLength",
          "empty"
        ])), $ = k.map((le) => le.value).getOr(ate), B = A6(t), j = k.map((le) => le.unit).filter((le) => le !== "").getOr(B), Y = y($, ste(j).step), re = `${iU(Y) ? Y : $}${j}`;
        return re !== x && jZ(t, { value: re }), re;
      }
    };
  }, cU = (t, a) => Xee(t, a, ite(t)), lU = (t, a) => {
    const u = hS(t, a, sU(t));
    t.ui.registry.addNestedMenuItem("fontsize", {
      text: Jee,
      onSetup: wd(t),
      getSubmenuItems: () => u.items.validateItems(u.getStyleItems())
    });
  }, cte = "Formats", uU = "Format {0}", dU = (t, a) => {
    const u = "Paragraph", p = (k) => () => t.formatter.match(k), y = (k) => () => {
      const $ = t.formatter.get(k);
      return $ !== void 0 ? z.some({
        tag: $.length > 0 && ($[0].inline || $[0].block) || "div",
        styles: t.dom.parseStyle(t.formatter.getCssText(k))
      }) : z.none();
    }, x = (k) => {
      const $ = (re) => yP(re) ? ke(re.items, $) : kz(re) ? [{
        title: re.title,
        format: re.format
      }] : [], B = ke(Rz(t), $), Y = ZP(t, q(B)).fold(q(u), (re) => re.title);
      nr(k, lp, { text: Y }), VZ(t, { value: Y });
    };
    return {
      tooltip: zE(t, uU, u),
      text: z.some(u),
      icon: z.none(),
      isSelectedFor: p,
      getCurrentValue: z.none,
      getPreviewFor: y,
      onAction: Y8(t),
      updateText: x,
      shouldHide: C6(t),
      isInvalid: (k) => !t.formatter.canApply(k.format),
      dataset: a
    };
  }, UT = (t, a) => {
    const u = {
      type: "advanced",
      ...a.styles
    };
    return zT(t, a, dU(t, u), uU, "StylesTextUpdate");
  }, lte = (t, a) => {
    const u = {
      type: "advanced",
      ...a.styles
    }, p = hS(t, a, dU(t, u));
    t.ui.registry.addNestedMenuItem("styles", {
      text: cte,
      onSetup: wd(t),
      getSubmenuItems: () => p.items.validateItems(p.getStyleItems())
    });
  }, ute = q([
    Mt("toggleClass"),
    Mt("fetch"),
    mm("onExecute"),
    lt("getHotspot", z.some),
    lt("getAnchorOverrides", q({})),
    rg(),
    mm("onItemExecute"),
    Fo("lazySink"),
    Mt("dom"),
    po("onOpen"),
    ac("splitDropdownBehaviours", [
      yi,
      ar,
      Er
    ]),
    lt("matchWidth", !1),
    lt("useMinWidth", !1),
    lt("eventOrder", {}),
    Fo("role")
  ].concat(jF())), dte = jl({
    factory: cl,
    schema: [Mt("dom")],
    name: "arrow",
    defaults: () => ({ buttonBehaviours: mn([Er.revoke()]) }),
    overrides: (t) => ({
      dom: {
        tag: "span",
        attributes: { role: "presentation" }
      },
      action: (a) => {
        a.getSystem().getByUid(t.uid).each(Ef);
      },
      buttonBehaviours: mn([Zr.config({
        toggleOnExecute: !1,
        toggleClass: t.toggleClass
      })])
    })
  }), fte = jl({
    factory: cl,
    schema: [Mt("dom")],
    name: "button",
    defaults: () => ({ buttonBehaviours: mn([Er.revoke()]) }),
    overrides: (t) => ({
      dom: {
        tag: "span",
        attributes: { role: "presentation" }
      },
      action: (a) => {
        a.getSystem().getByUid(t.uid).each((u) => {
          t.onExecute(u, a);
        });
      }
    })
  }), mte = q([
    dte,
    fte,
    vd({
      factory: {
        sketch: (t) => ({
          uid: t.uid,
          dom: {
            tag: "span",
            styles: { display: "none" },
            attributes: { "aria-hidden": "true" },
            innerHtml: t.text
          }
        })
      },
      schema: [Mt("text")],
      name: "aria-descriptor"
    }),
    rp({
      schema: [Dy()],
      name: "menu",
      defaults: (t) => ({
        onExecute: (a, u) => {
          a.getSystem().getByUid(t.uid).each((p) => {
            t.onItemExecute(p, a, u);
          });
        }
      })
    }),
    pH()
  ]), pte = (t, a, u, p) => {
    const y = (Y) => {
      ho.getCurrent(Y).each((re) => {
        Wo.highlightFirst(re), ar.focusIn(re);
      });
    }, x = (Y) => {
      UF(t, Te, Y, p, y, Sd.HighlightMenuAndItem).get(G);
    }, k = (Y) => (x(Y), z.some(!0)), $ = (Y) => {
      const re = gv(Y, t, "button");
      return Ef(re), z.some(!0);
    }, B = {
      ...ls([us((Y, re) => {
        Fs(Y, t, "aria-descriptor").each((pe) => {
          const _e = Hn("aria");
          kn(pe.element, "id", _e), kn(Y.element, "aria-describedby", _e);
        });
      })]),
      ...wv(z.some(x))
    }, j = {
      repositionMenus: (Y) => {
        Zr.isOn(Y) && bH(Y);
      }
    };
    return {
      uid: t.uid,
      dom: t.dom,
      components: a,
      apis: j,
      eventOrder: {
        ...t.eventOrder,
        [Lu()]: [
          "disabling",
          "toggling",
          "alloy.base.behaviour"
        ]
      },
      events: B,
      behaviours: _i(t.splitDropdownBehaviours, [
        yi.config({
          others: {
            sandbox: (Y) => {
              const re = gv(Y, t, "arrow");
              return WF(t, Y, {
                onOpen: () => {
                  Zr.on(re), Zr.on(Y);
                },
                onClose: () => {
                  Zr.off(re), Zr.off(Y);
                }
              });
            }
          }
        }),
        ar.config({
          mode: "special",
          onSpace: $,
          onEnter: $,
          onDown: k
        }),
        Er.config({}),
        Zr.config({
          toggleOnExecute: !1,
          aria: { mode: "expanded" }
        })
      ]),
      domModification: {
        attributes: {
          role: t.role.getOr("button"),
          "aria-haspopup": !0
        }
      }
    };
  }, QP = ql({
    name: "SplitDropdown",
    configFields: ute(),
    partFields: mte(),
    factory: pte,
    apis: { repositionMenus: (t, a) => t.repositionMenus(a) }
  }), fU = (t) => ({
    isEnabled: () => !yr.isDisabled(t),
    setEnabled: (a) => yr.set(t, !a),
    setText: (a) => nr(t, lp, { text: a }),
    setIcon: (a) => nr(t, uS, { icon: a })
  }), Y4 = (t) => ({
    setActive: (a) => {
      Zr.set(t, a);
    },
    isActive: () => Zr.isOn(t),
    isEnabled: () => !yr.isDisabled(t),
    setEnabled: (a) => yr.set(t, !a),
    setText: (a) => nr(t, lp, { text: a }),
    setIcon: (a) => nr(t, uS, { icon: a })
  }), mU = (t, a) => t.map((u) => ({
    "aria-label": a.translate(u),
    title: a.translate(u)
  })).getOr({}), pU = Hn("focus-button"), XP = (t, a, u, p, y) => {
    const x = a.map(($) => ms(R7($, "tox-tbtn", y))), k = t.map(($) => ms(lS($, y.icons)));
    return {
      dom: {
        tag: "button",
        classes: ["tox-tbtn"].concat(a.isSome() ? ["tox-tbtn--select"] : []),
        attributes: mU(u, y)
      },
      components: kE([
        k.map(($) => $.asSpec()),
        x.map(($) => $.asSpec())
      ]),
      eventOrder: {
        [oo()]: [
          "focusing",
          "alloy.base.behaviour",
          ME
        ],
        [Vl()]: [
          ME,
          "toolbar-group-button-events"
        ]
      },
      buttonBehaviours: mn([
        ip.toolbarButton(y.isDisabled),
        Bc(),
        Hr(ME, [
          us(($, B) => N3($)),
          Pt(lp, ($, B) => {
            x.bind((j) => j.getOpt($)).each((j) => {
              $r.set(j, [Ma(y.translate(B.event.text))]);
            });
          }),
          Pt(uS, ($, B) => {
            k.bind((j) => j.getOpt($)).each((j) => {
              $r.set(j, [lS(B.event.icon, y.icons)]);
            });
          }),
          Pt(oo(), ($, B) => {
            B.event.prevent(), Jr($, pU);
          })
        ])
      ].concat(p.getOr([])))
    };
  }, hU = (t, a, u, p) => {
    const y = a.shared, x = sr(G), k = {
      toolbarButtonBehaviours: [],
      getApi: fU,
      onSetup: t.onSetup
    }, $ = [Hr("toolbar-group-button-events", [
      l1(k, x),
      pg(k, x)
    ])];
    return pS.sketch({
      lazySink: y.getSink,
      fetch: () => wu.nu((B) => {
        B(He(u(t.items), HP));
      }),
      markers: { toggledClass: "tox-tbtn--enabled" },
      parts: {
        button: XP(t.icon, t.text, t.tooltip, z.some($), y.providers),
        toolbar: {
          dom: {
            tag: "div",
            classes: ["tox-toolbar__overflow"],
            attributes: p
          }
        }
      }
    });
  }, gU = (t, a, u) => {
    var p;
    const y = sr(G), x = XP(t.icon, t.text, t.tooltip, z.none(), u);
    return cl.sketch({
      dom: x.dom,
      components: x.components,
      eventOrder: cP,
      buttonBehaviours: {
        ...mn([
          Hr("toolbar-button-events", [
            RQ({
              onAction: t.onAction,
              getApi: a.getApi
            }),
            l1(a, y),
            pg(a, y)
          ]),
          ip.toolbarButton(() => !t.enabled || u.isDisabled()),
          Bc()
        ].concat(a.toolbarButtonBehaviours)),
        [ME]: (p = x.buttonBehaviours) === null || p === void 0 ? void 0 : p[ME]
      }
    });
  }, hte = (t, a) => vU(t, a, []), vU = (t, a, u) => gU(t, {
    toolbarButtonBehaviours: u.length > 0 ? [Hr("toolbarButtonWith", u)] : [],
    getApi: fU,
    onSetup: t.onSetup
  }, a), gte = (t, a) => bU(t, a, []), bU = (t, a, u) => gU(t, {
    toolbarButtonBehaviours: [
      $r.config({}),
      Zr.config({
        toggleClass: "tox-tbtn--enabled",
        aria: { mode: "pressed" },
        toggleOnExecute: !1
      })
    ].concat(u.length > 0 ? [Hr("toolbarToggleButtonWith", u)] : []),
    getApi: Y4,
    onSetup: t.onSetup
  }, a), vte = (t, a, u) => (p) => wu.nu((y) => a.fetch(y)).map((y) => z.from(FR(Vo(MF(Hn("menu-value"), y, (x) => {
    a.onItemAction(t(p), x);
  }, a.columns, a.presets, Cv.CLOSE_ON_EXECUTE, a.select.getOr(sn), u), {
    movement: DR(a.columns, a.presets),
    menuBehaviours: CO.unnamedEvents(a.columns !== "auto" ? [] : [us((x, k) => {
      EO(x, 4, oR(a.presets)).each(({ numRows: $, numColumns: B }) => {
        ar.setGridSize(x, $, B);
      });
    })])
  })))), yU = (t, a) => {
    const u = (x) => ({
      isEnabled: () => !yr.isDisabled(x),
      setEnabled: (k) => yr.set(x, !k),
      setIconFill: (k, $) => {
        qa(x.element, `svg path[class="${k}"], rect[class="${k}"]`).each((B) => {
          kn(B, "fill", $);
        });
      },
      setActive: (k) => {
        kn(x.element, "aria-pressed", k), qa(x.element, "span").each(($) => {
          x.getSystem().getByDom($).each((B) => Zr.set(B, k));
        });
      },
      isActive: () => qa(x.element, "span").exists((k) => x.getSystem().getByDom(k).exists(Zr.isOn)),
      setText: (k) => qa(x.element, "span").each(($) => x.getSystem().getByDom($).each((B) => nr(B, lp, { text: k }))),
      setIcon: (k) => qa(x.element, "span").each(($) => x.getSystem().getByDom($).each((B) => nr(B, uS, { icon: k }))),
      setTooltip: (k) => {
        const $ = a.providers.translate(k);
        Pm(x.element, {
          "aria-label": $,
          title: $
        });
      }
    }), p = sr(G), y = {
      getApi: u,
      onSetup: t.onSetup
    };
    return QP.sketch({
      dom: {
        tag: "div",
        classes: ["tox-split-button"],
        attributes: {
          "aria-pressed": !1,
          ...mU(t.tooltip, a.providers)
        }
      },
      onExecute: (x) => {
        const k = u(x);
        k.isEnabled() && t.onAction(k);
      },
      onItemExecute: (x, k, $) => {
      },
      splitDropdownBehaviours: mn([
        ip.splitButton(a.providers.isDisabled),
        Bc(),
        Hr("split-dropdown-events", [
          us((x, k) => N3(x)),
          Pt(pU, Er.focus),
          l1(y, p),
          pg(y, p)
        ]),
        LO.config({})
      ]),
      eventOrder: {
        [Vl()]: [
          "alloy.base.behaviour",
          "split-dropdown-events"
        ]
      },
      toggleClass: "tox-tbtn--enabled",
      lazySink: a.getSink,
      fetch: vte(u, t, a.providers),
      parts: { menu: pT(!1, t.columns, t.presets) },
      components: [
        QP.parts.button(XP(t.icon, t.text, z.none(), z.some([Zr.config({
          toggleClass: "tox-tbtn--enabled",
          toggleOnExecute: !1
        })]), a.providers)),
        QP.parts.arrow({
          dom: {
            tag: "button",
            classes: [
              "tox-tbtn",
              "tox-split-button__chevron"
            ],
            innerHtml: b6("chevron-down", a.providers.icons)
          },
          buttonBehaviours: mn([
            ip.splitButton(a.providers.isDisabled),
            Bc(),
            jN()
          ])
        }),
        QP.parts["aria-descriptor"]({ text: a.providers.translate("To open the popup, press Shift+Enter") })
      ]
    });
  }, bte = [
    {
      name: "history",
      items: [
        "undo",
        "redo"
      ]
    },
    {
      name: "ai",
      items: [
        "aidialog",
        "aishortcuts"
      ]
    },
    {
      name: "styles",
      items: ["styles"]
    },
    {
      name: "formatting",
      items: [
        "bold",
        "italic"
      ]
    },
    {
      name: "alignment",
      items: [
        "alignleft",
        "aligncenter",
        "alignright",
        "alignjustify"
      ]
    },
    {
      name: "indentation",
      items: [
        "outdent",
        "indent"
      ]
    },
    {
      name: "permanent pen",
      items: ["permanentpen"]
    },
    {
      name: "comments",
      items: ["addcomment"]
    }
  ], pA = (t, a) => (u, p, y) => {
    const x = t(u).mapError((k) => Dc(k)).getOrDie();
    return a(x, p, y);
  }, yte = {
    button: pA(m8, (t, a) => hte(t, a.shared.providers)),
    togglebutton: pA(sF, (t, a) => gte(t, a.shared.providers)),
    menubutton: pA(C4, (t, a) => YO(t, "tox-tbtn", a, z.none(), !1)),
    splitbutton: pA(LJ, (t, a) => yU(t, a.shared)),
    grouptoolbarbutton: pA(MJ, (t, a, u) => {
      const p = u.ui.registry.getAll().buttons, y = (k) => tD(u, {
        buttons: p,
        toolbar: k,
        allowToolbarGroups: !1
      }, a, z.none()), x = { [$b]: a.shared.header.isPositionedAtTop() ? Gd.TopToBottom : Gd.BottomToTop };
      switch (fT(u)) {
        case ph.floating:
          return hU(t, a, y, x);
        default:
          throw new Error("Toolbar groups are only supported when using floating toolbar mode");
      }
    })
  }, Ste = (t, a, u) => fn(yte, t.type).fold(() => (console.error("skipping button defined by", t), z.none()), (p) => z.some(p(t, a, u))), hA = {
    styles: UT,
    fontsize: aU,
    fontsizeinput: cU,
    fontfamily: tU,
    blocks: Wee,
    align: zee
  }, wte = (t) => {
    const a = He(bte, (u) => {
      const p = Rn(u.items, (y) => Yr(t, y) || Yr(hA, y));
      return {
        name: u.name,
        items: p
      };
    });
    return Rn(a, (u) => u.items.length > 0);
  }, JP = (t) => {
    const a = t.split("|");
    return He(a, (u) => ({ items: u.trim().split(" ") }));
  }, eD = (t) => ue(t, (a) => Yr(a, "name") && Yr(a, "items")), SU = (t) => {
    const a = t.toolbar, u = t.buttons;
    return a === !1 ? [] : a === void 0 || a === !0 ? wte(u) : g(a) ? JP(a) : eD(a) ? a : (console.error("Toolbar type should be string, string[], boolean or ToolbarGroup[]"), []);
  }, Ete = (t, a, u, p, y, x) => fn(a, u.toLowerCase()).orThunk(() => x.bind((k) => Vr(k, ($) => fn(a, $ + u.toLowerCase())))).fold(() => fn(hA, u.toLowerCase()).map((k) => k(t, y)), (k) => k.type === "grouptoolbarbutton" && !p ? (console.warn(`Ignoring the '${u}' toolbar button. Group toolbar buttons are only supported when using floating toolbar mode and cannot be nested.`), z.none()) : Ste(k, y, t)), tD = (t, a, u, p) => {
    const y = SU(a), x = He(y, (k) => {
      const $ = ke(k.items, (B) => B.trim().length === 0 ? [] : Ete(t, a.buttons, B, a.allowToolbarGroups, u, p).toArray());
      return {
        title: z.from(t.translate(k.name)),
        items: $
      };
    });
    return Rn(x, (k) => k.items.length > 0);
  }, wU = (t, a, u, p) => {
    const y = a.mainUi.outerContainer, x = u.toolbar, k = u.buttons;
    if (ue(x, g)) {
      const $ = x.map((B) => {
        const j = {
          toolbar: B,
          buttons: k,
          allowToolbarGroups: u.allowToolbarGroups
        };
        return tD(t, j, p, z.none());
      });
      Qs.setToolbars(y, $);
    } else
      Qs.setToolbar(y, tD(t, u, p, z.none()));
  }, EU = Ft(), Cte = EU.os.isiOS() && EU.os.version.major <= 12, nD = (t, a) => {
    const { uiMotherships: u } = a, p = t.dom;
    let y = t.getWin();
    const x = t.getDoc().documentElement, k = sr(Oo(y.innerWidth, y.innerHeight)), $ = sr(Oo(x.offsetWidth, x.offsetHeight)), B = () => {
      const le = k.get();
      (le.left !== y.innerWidth || le.top !== y.innerHeight) && (k.set(Oo(y.innerWidth, y.innerHeight)), TR(t));
    }, j = () => {
      const le = t.getDoc().documentElement, pe = $.get();
      (pe.left !== le.offsetWidth || pe.top !== le.offsetHeight) && ($.set(Oo(le.offsetWidth, le.offsetHeight)), TR(t));
    }, Y = (le) => {
      HZ(t, le);
    };
    p.bind(y, "resize", B), p.bind(y, "scroll", Y);
    const re = h0(nt.fromDom(t.getBody()), "load", j);
    t.on("hide", () => {
      ut(u, (le) => {
        Sr(le.element, "display", "none");
      });
    }), t.on("show", () => {
      ut(u, (le) => {
        Ur(le.element, "display");
      });
    }), t.on("NodeChange", j), t.on("remove", () => {
      re.unbind(), p.unbind(y, "resize", B), p.unbind(y, "scroll", Y), y = null;
    });
  }, CU = (t, a, u) => {
    a1(t) && fv(u.mainUi.mothership.element, u.popupUi.mothership), il(a, u.dialogUi.mothership);
  };
  var xU = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    render: (t, a, u, p, y) => {
      const { mainUi: x, uiMotherships: k } = a, $ = sr(0), B = x.outerContainer;
      Fee(t);
      const j = nt.fromDom(y.targetNode), Y = en(wt(j));
      fv(j, x.mothership), CU(t, Y, a), t.on("SkinLoaded", () => {
        Qs.setSidebar(B, u.sidebar, D6(t)), wU(t, a, u, p), $.set(t.getWin().innerWidth), Qs.setMenubar(B, qP(t, u)), Qs.setViews(B, u.views), nD(t, a);
      });
      const re = Qs.getSocket(B).getOrDie("Could not find expected socket element");
      if (Cte) {
        Rc(re.element, {
          overflow: "scroll",
          "-webkit-overflow-scrolling": "touch"
        });
        const ze = SQ(() => {
          t.dispatch("ScrollContent");
        }, 20), ft = Cl(re.element, "scroll", ze.throttle);
        t.on("remove", ft.unbind);
      }
      O8(t, a), t.addCommand("ToggleSidebar", (ze, ft) => {
        Qs.toggleSidebar(B, ft), t.dispatch("ToggleSidebar");
      }), t.addQueryValueHandler("ToggleSidebar", () => {
        var ze;
        return (ze = Qs.whichSidebar(B)) !== null && ze !== void 0 ? ze : "";
      }), t.addCommand("ToggleView", (ze, ft) => {
        if (Qs.toggleView(B, ft)) {
          const Xe = B.element;
          x.mothership.broadcastOn([lh()], { target: Xe }), ut(k, (Ze) => {
            Ze.broadcastOn([lh()], { target: Xe });
          }), I(Qs.whichView(B)) && (t.focus(), t.nodeChanged(), Qs.refreshToolbar(B));
        }
      }), t.addQueryValueHandler("ToggleView", () => {
        var ze;
        return (ze = Qs.whichView(B)) !== null && ze !== void 0 ? ze : "";
      });
      const le = fT(t), pe = () => {
        Qs.refreshToolbar(a.mainUi.outerContainer);
      };
      (le === ph.sliding || le === ph.floating) && t.on("ResizeWindow ResizeEditor ResizeContent", () => {
        const ze = t.getWin().innerWidth;
        ze !== $.get() && (pe(), $.set(ze));
      });
      const _e = {
        setEnabled: (ze) => {
          SR(a, !ze);
        },
        isEnabled: () => !yr.isDisabled(B)
      };
      return {
        iframeContainer: re.element.dom,
        editorContainer: B.element.dom,
        api: _e
      };
    }
  });
  const rD = (t) => /^[0-9\.]+(|px)$/i.test("" + t) ? z.some(parseInt("" + t, 10)) : z.none(), Q4 = (t) => he(t) ? t + "px" : t, gA = (t, a, u) => {
    const p = a.filter((x) => t < x), y = u.filter((x) => t > x);
    return p.or(y).getOr(t);
  }, Tte = (t) => {
    const a = _M(t), u = kM(t), p = NM(t);
    return rD(a).map((y) => gA(y, u, p));
  }, _te = (t) => Tte(t).getOr(_M(t)), TU = (t) => {
    const a = OM(t), u = AM(t), p = qN(t);
    return rD(a).map((y) => gA(y, u, p));
  }, Ote = (t) => TU(t).getOr(OM(t)), { ToolbarLocation: X4, ToolbarMode: WT } = qG, Ate = 40, kte = (t, a, u, p, y) => {
    const { mainUi: x, uiMotherships: k } = u, $ = uT.DOM, B = K0(t), j = vO(t), Y = qN(t).or(TU(t)), re = p.shared.header, le = re.isPositionedAtTop, pe = fT(t), _e = pe === WT.sliding || pe === WT.floating, ze = sr(!1), ft = () => ze.get() && !t.removed, Xe = (dr) => _e ? dr.fold(q(0), (ko) => ko.components().length > 1 ? Ds(ko.components()[1].element) : 0) : 0, Ze = (dr) => {
      switch (pO(t)) {
        case X4.auto:
          const ko = Qs.getToolbar(x.outerContainer), Cn = Xe(ko), Zn = Ds(dr.element) - Cn, Ar = Ss(a);
          if (Ar.y > Zn)
            return "top";
          {
            const vr = Pl(a), Mr = Math.max(vr.dom.scrollHeight, Ds(vr));
            return Ar.bottom < Mr - Zn || Ci().bottom < Ar.bottom - Zn ? "bottom" : "top";
          }
        case X4.bottom:
          return "bottom";
        case X4.top:
        default:
          return "top";
      }
    }, mt = (dr) => {
      y.on((ko) => {
        Oi.setModes(ko, [dr]), re.setDockingMode(dr);
        const Cn = le() ? Gd.TopToBottom : Gd.BottomToTop;
        kn(ko.element, $b, Cn);
      });
    }, jt = () => {
      y.on((dr) => {
        const ko = Y.getOrThunk(() => {
          const Cn = rD(na(ta(), "margin-left")).getOr(0);
          return Oa(ta()) - Jc(a).left + Cn;
        });
        Sr(dr.element, "max-width", ko + "px");
      });
    }, Dt = (dr) => {
      y.on((ko) => {
        const Cn = Qs.getToolbar(x.outerContainer), Zn = Xe(Cn), Ar = Ss(a), { top: go, left: vr } = Nt(t, x.outerContainer.element).fold(() => ({
          top: le() ? Math.max(Ar.y - Ds(ko.element) + Zn, 0) : Ar.bottom,
          left: Ar.x
        }), (jo) => {
          var Gu;
          const Ca = Ss(jo), Wf = (Gu = jo.dom.scrollTop) !== null && Gu !== void 0 ? Gu : 0, xg = Io(jo, ta()), xS = xg ? Math.max(Ar.y - Ds(ko.element) + Zn, 0) : Ar.y - Ca.y + Wf - Ds(ko.element) + Zn;
          return {
            top: le() ? xS : Ar.bottom,
            left: xg ? Ar.x : Ar.x - Ca.x
          };
        }), Mr = {
          position: "absolute",
          left: Math.round(vr) + "px",
          top: Math.round(go) + "px"
        }, Bs = dr.map((jo) => {
          const Gu = ec(), Ca = 150, Wf = window.innerWidth - (vr - Gu.left);
          return { width: Math.max(Math.min(jo, Wf), Ca) + "px" };
        }).getOr({});
        Rc(x.outerContainer.element, {
          ...Mr,
          ...Bs
        });
      });
    }, Nt = (dr, ko) => a1(dr) ? BE(ko) : z.none(), hn = () => {
      ut(k, (dr) => {
        dr.broadcastOn([Yy()], {});
      });
    }, En = () => {
      if (B)
        return z.none();
      if (Jc(x.outerContainer.element).left + Pa(x.outerContainer.element) >= window.innerWidth - Ate || Ta(x.outerContainer.element, "width").isSome()) {
        Sr(x.outerContainer.element, "position", "absolute"), Sr(x.outerContainer.element, "left", "0px"), Ur(x.outerContainer.element, "width");
        const ko = Pa(x.outerContainer.element);
        return z.some(ko);
      } else
        return z.none();
    }, zr = (dr) => {
      if (!ft())
        return;
      B || jt();
      const ko = B ? z.none() : En();
      _e && Qs.refreshToolbar(x.outerContainer), B || Dt(ko), j && y.on(dr), hn();
    }, Yn = () => B || !j || !ft() ? !1 : y.get().exists((dr) => {
      const ko = re.getDockingMode(), Cn = Ze(dr);
      return Cn !== ko ? (mt(Cn), !0) : !1;
    });
    return {
      isVisible: ft,
      isPositionedAtTop: le,
      show: () => {
        ze.set(!0), Sr(x.outerContainer.element, "display", "flex"), $.addClass(t.getBody(), "mce-edit-focus"), ut(k, (dr) => {
          Ur(dr.element, "display");
        }), Yn(), a1(t) ? zr((dr) => Oi.isDocked(dr) ? Oi.reset(dr) : Oi.refresh(dr)) : zr(Oi.refresh);
      },
      hide: () => {
        ze.set(!1), Sr(x.outerContainer.element, "display", "none"), $.removeClass(t.getBody(), "mce-edit-focus"), ut(k, (dr) => {
          Sr(dr.element, "display", "none");
        });
      },
      update: zr,
      updateMode: () => {
        Yn() && zr(Oi.reset);
      },
      repositionPopups: hn
    };
  }, _U = (t, a) => {
    const u = Ss(t);
    return {
      pos: a ? u.y : u.bottom,
      bounds: u
    };
  }, OU = (t, a, u, p) => {
    const y = sr(_U(a, u.isPositionedAtTop())), x = (j) => {
      const { pos: Y, bounds: re } = _U(a, u.isPositionedAtTop()), {
        pos: le,
        bounds: pe
      } = y.get(), _e = re.height !== pe.height || re.width !== pe.width;
      y.set({
        pos: Y,
        bounds: re
      }), _e && TR(t, j), u.isVisible() && (le !== Y ? u.update(Oi.reset) : _e && (u.updateMode(), u.repositionPopups()));
    };
    p || (t.on("activate", u.show), t.on("deactivate", u.hide)), t.on("SkinLoaded ResizeWindow", () => u.update(Oi.reset)), t.on("NodeChange keydown", (j) => {
      requestAnimationFrame(() => x(j));
    });
    let k = 0;
    const $ = oP(() => u.update(Oi.refresh), 33);
    t.on("ScrollWindow", () => {
      const j = ec().left;
      j !== k && (k = j, $.throttle()), u.updateMode();
    }), a1(t) && t.on("ElementScroll", (j) => {
      u.update(Oi.refresh);
    });
    const B = sh();
    B.set(h0(nt.fromDom(t.getBody()), "load", (j) => x(j.raw))), t.on("remove", () => {
      B.clear();
    });
  };
  var AU = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    render: (t, a, u, p, y) => {
      const { mainUi: x } = a, k = Gr(), $ = nt.fromDom(y.targetNode), B = kte(t, $, a, p, k), j = _6(t);
      Lee(t);
      const Y = () => {
        if (k.isSet()) {
          B.show();
          return;
        }
        k.set(Qs.getHeader(x.outerContainer).getOrDie());
        const le = BM(t);
        a1(t) ? (fv($, x.mothership), fv($, a.popupUi.mothership)) : il(le, x.mothership), il(le, a.dialogUi.mothership), wU(t, a, u, p), Qs.setMenubar(x.outerContainer, qP(t, u)), B.show(), OU(t, $, B, j), t.nodeChanged();
      };
      t.on("show", Y), t.on("hide", B.hide), j || (t.on("focus", Y), t.on("blur", B.hide)), t.on("init", () => {
        (t.hasFocus() || j) && Y();
      }), O8(t, a);
      const re = {
        show: Y,
        hide: B.hide,
        setEnabled: (le) => {
          SR(a, !le);
        },
        isEnabled: () => !yr.isDisabled(x.outerContainer)
      };
      return {
        editorContainer: x.outerContainer.element.dom,
        api: re
      };
    }
  });
  const Nte = () => {
    const t = Gr(), a = Gr(), u = Gr();
    return {
      dialogUi: t,
      popupUi: a,
      mainUi: u,
      getUiMotherships: () => {
        const x = t.get().map(($) => $.mothership), k = a.get().map(($) => $.mothership);
        return x.fold(() => k.toArray(), ($) => k.fold(() => [$], (B) => Io($.element, B.element) ? [$] : [
          $,
          B
        ]));
      },
      lazyGetInOuterOrDie: (x, k) => () => u.get().bind(($) => k($.outerContainer)).getOrDie(`Could not find ${x} element in OuterContainer`)
    };
  }, Rte = "contexttoolbar-show", kU = "contexttoolbar-hide", Pte = (t) => ({
    hide: () => Jr(t, Ty()),
    getValue: () => Pn.getValue(t)
  }), NU = (t, a) => Pt(k3, (u, p) => {
    const y = t.get(u), x = Pte(y);
    a.onAction(x, p.event.buttonApi);
  }), vA = (t, a, u) => {
    const { primary: p, ...y } = a.original, x = Mo(m8({
      ...y,
      type: "button",
      onAction: G
    }));
    return vU(x, u, [NU(t, a)]);
  }, RU = (t, a, u) => {
    const { primary: p, ...y } = a.original, x = Mo(sF({
      ...y,
      type: "togglebutton",
      onAction: G
    }));
    return bU(x, u, [NU(t, a)]);
  }, Dte = (t) => t.type === "contextformtogglebutton", $te = (t, a, u) => Dte(a) ? RU(t, a, u) : vA(t, a, u), PU = (t, a, u) => {
    const p = He(a, (k) => ms($te(t, k, u)));
    return {
      asSpecs: () => He(p, (k) => k.asSpec()),
      findPrimary: (k) => Vr(a, ($, B) => $.primary ? z.from(p[B]).bind((j) => j.getOpt(k)).filter(Ie(yr.isDisabled)) : z.none())
    };
  }, oD = (t, a) => {
    const u = t.label.fold(() => ({}), (x) => ({ "aria-label": x })), p = ms(TE.sketch({
      inputClasses: [
        "tox-toolbar-textfield",
        "tox-toolbar-nav-js"
      ],
      data: t.initValue(),
      inputAttributes: u,
      selectOnFocus: !0,
      inputBehaviours: mn([ar.config({
        mode: "special",
        onEnter: (x) => y.findPrimary(x).map((k) => (Ef(k), !0)),
        onLeft: (x, k) => (k.cut(), z.none()),
        onRight: (x, k) => (k.cut(), z.none())
      })])
    })), y = PU(p, t.commands, a);
    return [
      {
        title: z.none(),
        items: [p.asSpec()]
      },
      {
        title: z.none(),
        items: y.asSpecs()
      }
    ];
  }, DU = {
    renderContextForm: (t, a, u) => zP({
      type: t,
      uid: Hn("context-toolbar"),
      initGroups: oD(a, u),
      onEscape: z.none,
      cyclicKeying: !0,
      providers: u
    }),
    buildInitGroups: oD
  }, $U = (t, a, u) => a.bottom - t.y >= u && t.bottom - a.y >= u, jT = (t) => {
    const a = t.getBoundingClientRect();
    if (a.height <= 0 && a.width <= 0) {
      const u = Tp(nt.fromDom(t.startContainer), t.startOffset).element;
      return (ei(u) ? Ii(u) : z.some(u)).filter($o).map((y) => y.dom.getBoundingClientRect()).getOr(a);
    } else
      return a;
  }, qT = (t) => {
    const a = t.selection.getRng(), u = jT(a);
    if (t.inline) {
      const p = ec();
      return cs(p.left + u.left, p.top + u.top, u.width, u.height);
    } else {
      const p = Fi(nt.fromDom(t.getBody()));
      return cs(p.x + u.left, p.y + u.top, u.width, u.height);
    }
  }, J4 = (t, a) => a.filter((u) => fo(u) && ed(u)).map(Fi).getOrThunk(() => qT(t)), IU = (t, a, u) => {
    const p = Math.max(t.x + u, a.x), y = Math.min(t.right - u, a.right);
    return {
      x: p,
      width: y - p
    };
  }, MU = (t, a, u, p, y, x) => {
    const k = nt.fromDom(t.getContainer()), $ = qa(k, ".tox-editor-header").getOr(k), B = Ss($), j = B.y >= a.bottom, Y = p && !j;
    if (t.inline && Y)
      return {
        y: Math.max(B.bottom + x, u.y),
        bottom: u.bottom
      };
    if (t.inline && !Y)
      return {
        y: u.y,
        bottom: Math.min(B.y - x, u.bottom)
      };
    const re = y === "line" ? Ss(k) : a;
    return Y ? {
      y: Math.max(B.bottom + x, u.y),
      bottom: Math.min(re.bottom - x, u.bottom)
    } : {
      y: Math.max(re.y + x, u.y),
      bottom: Math.min(B.y - x, u.bottom)
    };
  }, FU = (t, a, u, p = 0) => {
    const y = Hh(window), x = Ss(nt.fromDom(t.getContentAreaContainer())), k = JN(t) || nR(t) || gO(t), { x: $, width: B } = IU(x, y, p);
    if (t.inline && !k)
      return cs($, y.y, B, y.height);
    {
      const j = a.header.isPositionedAtTop(), { y: Y, bottom: re } = MU(t, x, y, j, u, p);
      return cs($, Y, B, re - Y);
    }
  }, bA = 12, LU = {
    valignCentre: [],
    alignCentre: [],
    alignLeft: ["tox-pop--align-left"],
    alignRight: ["tox-pop--align-right"],
    right: ["tox-pop--right"],
    left: ["tox-pop--left"],
    bottom: ["tox-pop--bottom"],
    top: ["tox-pop--top"],
    inset: ["tox-pop--inset"]
  }, BU = {
    maxHeightFunction: vm(),
    maxWidthFunction: R4()
  }, Mte = (t, a) => {
    const u = t.selection.getRng(), p = Tp(nt.fromDom(u.startContainer), u.startOffset);
    return u.startContainer === u.endContainer && u.startOffset === u.endOffset - 1 && Io(p.element, a);
  }, Fte = (t, a, u) => {
    const p = Ta(t, "position");
    Sr(t, "position", a);
    const y = u(t);
    return p.each((x) => Sr(t, "position", x)), y;
  }, HU = (t) => t === "node", zU = (t, a, u, p, y) => {
    const x = qT(t), k = p.lastElement().exists(($) => Io(u, $));
    if (Mte(t, u))
      return k ? J3 : Sg;
    if (k)
      return Fte(a, p.getMode(), () => $U(x, Ss(a), -20) && !p.isReposition() ? NX : J3);
    {
      const $ = p.getMode() === "fixed" ? y.y + ec().top : y.y, B = Ds(a) + bA;
      return $ + B <= x.y ? Sg : $T;
    }
  }, sD = (t, a, u, p) => {
    const y = (B) => (j, Y, re, le, pe) => {
      const _e = zU(t, le, B, u, pe), ze = {
        ...j,
        y: pe.y,
        height: pe.height
      };
      return {
        ..._e(ze, Y, re, le, pe),
        alwaysFit: !0
      };
    }, x = (B) => HU(p) ? [y(B)] : [];
    return a ? {
      onLtr: (B) => [
        Os,
        Wi,
        Mc,
        ji,
        Br,
        El
      ].concat(x(B)),
      onRtl: (B) => [
        Os,
        Mc,
        Wi,
        Br,
        ji,
        El
      ].concat(x(B))
    } : {
      onLtr: (B) => [
        El,
        Os,
        ji,
        Wi,
        Br,
        Mc
      ].concat(x(B)),
      onRtl: (B) => [
        El,
        Os,
        Br,
        Mc,
        ji,
        Wi
      ].concat(x(B))
    };
  }, VU = (t, a, u, p) => a === "line" ? {
    bubble: ep(bA, 0, LU),
    layouts: {
      onLtr: () => [qi],
      onRtl: () => [Fy]
    },
    overrides: BU
  } : {
    bubble: ep(0, bA, LU, 1 / bA),
    layouts: sD(t, u, p, a),
    overrides: BU
  }, aD = (t, a) => {
    const u = Rn(a, (x) => x.predicate(t.dom)), { pass: p, fail: y } = qn(u, (x) => x.type === "contexttoolbar");
    return {
      contextToolbars: p,
      contextForms: y
    };
  }, eL = (t) => {
    if (t.length <= 1)
      return t;
    {
      const a = (x) => Gt(t, (k) => k.position === x), u = (x) => Rn(t, (k) => k.position === x), p = a("selection"), y = a("node");
      if (p || y)
        if (y && p) {
          const x = u("node"), k = He(u("selection"), ($) => ({
            ...$,
            position: "node"
          }));
          return x.concat(k);
        } else
          return u(p ? "selection" : "node");
      else
        return u("line");
    }
  }, Lte = (t) => {
    if (t.length <= 1)
      return t;
    {
      const a = (p) => Ge(t, (y) => y.position === p);
      return a("selection").orThunk(() => a("node")).orThunk(() => a("line")).map((p) => p.position).fold(() => [], (p) => Rn(t, (y) => y.position === p));
    }
  }, UU = (t, a, u) => {
    const p = aD(t, a);
    if (p.contextForms.length > 0)
      return z.some({
        elem: t,
        toolbars: [p.contextForms[0]]
      });
    {
      const y = aD(t, u);
      if (y.contextForms.length > 0)
        return z.some({
          elem: t,
          toolbars: [y.contextForms[0]]
        });
      if (p.contextToolbars.length > 0 || y.contextToolbars.length > 0) {
        const x = eL(p.contextToolbars.concat(y.contextToolbars));
        return z.some({
          elem: t,
          toolbars: x
        });
      } else
        return z.none();
    }
  }, Bte = (t, a, u) => t(a) ? z.none() : zl(a, (p) => {
    if ($o(p)) {
      const { contextToolbars: y, contextForms: x } = aD(p, u.inNodeScope), k = x.length > 0 ? x : Lte(y);
      return k.length > 0 ? z.some({
        elem: p,
        toolbars: k
      }) : z.none();
    } else
      return z.none();
  }, t), Hte = (t, a) => {
    const u = nt.fromDom(a.getBody()), p = (k) => Io(k, u), y = (k) => !p(k) && !za(u, k), x = nt.fromDom(a.selection.getNode());
    return y(x) ? z.none() : UU(x, t.inNodeScope, t.inEditorScope).orThunk(() => Bte(p, x, t));
  }, iD = (t, a) => {
    const u = {}, p = [], y = [], x = {}, k = {}, $ = (Y, re) => {
      const le = Mo(yR(re));
      u[Y] = le, le.launch.map((pe) => {
        x["form:" + Y] = {
          ...re.launch,
          type: pe.type === "contextformtogglebutton" ? "togglebutton" : "button",
          onAction: () => {
            a(le);
          }
        };
      }), le.scope === "editor" ? y.push(le) : p.push(le), k[Y] = le;
    }, B = (Y, re) => {
      h8(re).each((le) => {
        re.scope === "editor" ? y.push(le) : p.push(le), k[Y] = le;
      });
    }, j = Xr(t);
    return ut(j, (Y) => {
      const re = t[Y];
      re.type === "contextform" ? $(Y, re) : re.type === "contexttoolbar" && B(Y, re);
    }), {
      forms: u,
      inNodeScope: p,
      inEditorScope: y,
      lookupTable: k,
      formNavigators: x
    };
  }, tL = Hn("forward-slide"), WU = Hn("backward-slide"), nL = Hn("change-slide-event"), rL = "tox-pop--resizing", zte = (t) => {
    const a = sr([]);
    return La.sketch({
      dom: {
        tag: "div",
        classes: ["tox-pop"]
      },
      fireDismissalEventInstead: { event: "doNotDismissYet" },
      onShow: (u) => {
        a.set([]), La.getContent(u).each((p) => {
          Ur(p.element, "visibility");
        }), ua(u.element, rL), Ur(u.element, "width");
      },
      inlineBehaviours: mn([
        Hr("context-toolbar-events", [
          xf(Hp(), (u, p) => {
            p.event.raw.propertyName === "width" && (ua(u.element, rL), Ur(u.element, "width"));
          }),
          Pt(nL, (u, p) => {
            const y = u.element;
            Ur(y, "width");
            const x = Oa(y);
            La.setContent(u, p.event.contents), ja(y, rL);
            const k = Oa(y);
            Sr(y, "width", x + "px"), La.getContent(u).each(($) => {
              p.event.focus.bind((B) => (Fa(B), Nf(y))).orThunk(() => (ar.focusIn($), Xm(wt(y))));
            }), setTimeout(() => {
              Sr(u.element, "width", k + "px");
            }, 0);
          }),
          Pt(tL, (u, p) => {
            La.getContent(u).each((y) => {
              a.set(a.get().concat([{
                bar: y,
                focus: Xm(wt(u.element))
              }]));
            }), nr(u, nL, {
              contents: p.event.forwardContents,
              focus: z.none()
            });
          }),
          Pt(WU, (u, p) => {
            mr(a.get()).each((y) => {
              a.set(a.get().slice(0, a.get().length - 1)), nr(u, nL, {
                contents: Hu(y.bar),
                focus: y.focus
              });
            });
          })
        ]),
        ar.config({
          mode: "special",
          onEscape: (u) => mr(a.get()).fold(() => t.onEscape(), (p) => (Jr(u, WU), z.some(!0)))
        })
      ]),
      lazySink: () => Rr.value(t.sink)
    });
  }, oL = "tox-pop--transition", jU = (t, a, u, p) => {
    const y = p.backstage, x = y.shared, k = Ft().deviceType.isTouch, $ = Gr(), B = Gr(), j = Gr(), Y = sl(zte({
      sink: u,
      onEscape: () => (t.focus(), z.some(!0))
    })), re = () => {
      const Yn = j.get().getOr("node"), hr = HU(Yn) ? 1 : 0;
      return FU(t, x, Yn, hr);
    }, le = () => !t.removed && !(k() && y.isContextMenuOpen()), pe = (Yn) => $i(gc(Yn, $.get(), Io), !0), _e = () => {
      if (le()) {
        const Yn = re(), hr = $i(j.get(), "node") ? J4(t, $.get()) : qT(t);
        return Yn.height <= 0 || !$U(hr, Yn, 0.01);
      } else
        return !0;
    }, ze = () => {
      $.clear(), B.clear(), j.clear(), La.hide(Y);
    }, ft = () => {
      if (La.isOpen(Y)) {
        const Yn = Y.element;
        Ur(Yn, "display"), _e() ? Sr(Yn, "display", "none") : (B.set(0), La.reposition(Y));
      }
    }, Xe = (Yn) => ({
      dom: {
        tag: "div",
        classes: ["tox-pop__dialog"]
      },
      components: [Yn],
      behaviours: mn([
        ar.config({ mode: "acyclic" }),
        Hr("pop-dialog-wrap-events", [
          us((hr) => {
            t.shortcuts.add("ctrl+F9", "focus statusbar", () => ar.focusIn(hr));
          }),
          Tf((hr) => {
            t.shortcuts.remove("ctrl+F9");
          })
        ])
      ])
    }), Ze = zs(() => iD(a, (Yn) => {
      const hr = Dt([Yn]);
      nr(Y, tL, { forwardContents: Xe(hr) });
    })), mt = (Yn, hr) => tD(t, {
      buttons: Yn,
      toolbar: hr.items,
      allowToolbarGroups: !1
    }, p.backstage, z.some(["form:"])), jt = (Yn, hr) => DU.buildInitGroups(Yn, hr), Dt = (Yn) => {
      const { buttons: hr } = t.ui.registry.getAll(), Cr = Ze(), ns = {
        ...hr,
        ...Cr.formNavigators
      }, dr = fT(t) === ph.scrolling ? ph.scrolling : ph.default, ko = St(He(Yn, (Cn) => Cn.type === "contexttoolbar" ? mt(ns, Cn) : jt(Cn, x.providers)));
      return zP({
        type: dr,
        uid: Hn("context-toolbar"),
        initGroups: ko,
        onEscape: z.none,
        cyclicKeying: !0,
        providers: x.providers
      });
    }, Nt = (Yn, hr) => {
      const Cr = Yn === "node" ? x.anchors.node(hr) : x.anchors.cursor(), ns = VU(t, Yn, k(), {
        lastElement: $.get,
        isReposition: () => $i(B.get(), 0),
        getMode: () => Wl.getMode(u)
      });
      return Vo(Cr, ns);
    }, hn = (Yn, hr) => {
      if (zr.cancel(), !le())
        return;
      const Cr = Dt(Yn), ns = Yn[0].position, dr = Nt(ns, hr);
      j.set(ns), B.set(1);
      const ko = Y.element;
      Ur(ko, "display"), pe(hr) || (ua(ko, oL), Wl.reset(u, Y)), La.showWithinBounds(Y, Xe(Cr), {
        anchor: dr,
        transition: {
          classes: [oL],
          mode: "placement"
        }
      }, () => z.some(re())), hr.fold($.clear, $.set), _e() && Sr(ko, "display", "none");
    };
    let En = !1;
    const zr = oP(() => {
      if (!(!t.hasFocus() || t.removed || En))
        if (Ti(Y.element, oL))
          zr.throttle();
        else {
          const Yn = Ze();
          Hte(Yn, t).fold(ze, (hr) => {
            hn(hr.toolbars, z.some(hr.elem));
          });
        }
    }, 17);
    t.on("init", () => {
      t.on("remove", ze), t.on("ScrollContent ScrollWindow ObjectResized ResizeEditor longpress", ft), t.on("click keyup focus SetContent", zr.throttle), t.on(kU, ze), t.on(Rte, (Yn) => {
        const hr = Ze();
        fn(hr.lookupTable, Yn.toolbarKey).each((Cr) => {
          hn([Cr], lr(Yn.target !== t, Yn.target)), La.getContent(Y).each(ar.focusIn);
        });
      }), t.on("focusout", (Yn) => {
        EE.setEditorTimeout(t, () => {
          Nf(u.element).isNone() && Nf(Y.element).isNone() && ze();
        }, 0);
      }), t.on("SwitchMode", () => {
        t.mode.isReadOnly() && ze();
      }), t.on("AfterProgressState", (Yn) => {
        Yn.state ? ze() : t.hasFocus() && zr.throttle();
      }), t.on("dragstart", () => {
        En = !0;
      }), t.on("dragend drop", () => {
        En = !1;
      }), t.on("NodeChange", (Yn) => {
        Nf(Y.element).fold(zr.throttle, G);
      });
    });
  }, qU = (t) => {
    ut([
      {
        name: "alignleft",
        text: "Align left",
        cmd: "JustifyLeft",
        icon: "align-left"
      },
      {
        name: "aligncenter",
        text: "Align center",
        cmd: "JustifyCenter",
        icon: "align-center"
      },
      {
        name: "alignright",
        text: "Align right",
        cmd: "JustifyRight",
        icon: "align-right"
      },
      {
        name: "alignjustify",
        text: "Justify",
        cmd: "JustifyFull",
        icon: "align-justify"
      }
    ], (u) => {
      t.ui.registry.addToggleButton(u.name, {
        tooltip: u.text,
        icon: u.icon,
        onAction: Lf(t, u.cmd),
        onSetup: _R(t, u.name)
      });
    }), t.ui.registry.addButton("alignnone", {
      tooltip: "No alignment",
      icon: "align-none",
      onSetup: wd(t),
      onAction: Lf(t, "JustifyNone")
    });
  }, GU = (t, a) => {
    const u = () => {
      const p = a.getOptions(t), y = a.getCurrent(t).map(a.hash), x = Gr();
      return He(p, (k) => ({
        type: "togglemenuitem",
        text: a.display(k),
        onSetup: ($) => {
          const B = (Y) => {
            Y && (x.on((re) => re.setActive(!1)), x.set($)), $.setActive(Y);
          };
          B($i(y, a.hash(k)));
          const j = a.watcher(t, k, B);
          return () => {
            x.clear(), j();
          };
        },
        onAction: () => a.setCurrent(t, k)
      }));
    };
    t.ui.registry.addMenuButton(a.name, {
      tooltip: a.text,
      icon: a.icon,
      fetch: (p) => p(u()),
      onSetup: a.onToolbarSetup
    }), t.ui.registry.addNestedMenuItem(a.name, {
      type: "nestedmenuitem",
      text: a.text,
      getSubmenuItems: u,
      onSetup: a.onMenuSetup
    });
  }, Vte = (t) => ({
    name: "lineheight",
    text: "Line height",
    icon: "line-height",
    getOptions: M6,
    hash: (a) => Qee(a, [
      "fixed",
      "relative",
      "empty"
    ]).getOr(a),
    display: Te,
    watcher: (a, u, p) => a.formatter.formatChanged("lineheight", p, !1, { value: u }).unbind,
    getCurrent: (a) => z.from(a.queryCommandValue("LineHeight")),
    setCurrent: (a, u) => a.execCommand("LineHeight", !1, u),
    onToolbarSetup: wd(t),
    onMenuSetup: wd(t)
  }), ZU = (t) => z.from(GN(t)).map((u) => ({
    name: "language",
    text: "Language",
    icon: "language",
    getOptions: q(u),
    hash: (p) => Z(p.customCode) ? p.code : `${p.code}/${p.customCode}`,
    display: (p) => p.title,
    watcher: (p, y, x) => {
      var k;
      return p.formatter.formatChanged("lang", x, !1, {
        value: y.code,
        customValue: (k = y.customCode) !== null && k !== void 0 ? k : null
      }).unbind;
    },
    getCurrent: (p) => {
      const y = nt.fromDom(p.selection.getNode());
      return Ic(y, (x) => z.some(x).filter($o).bind((k) => as(k, "lang").map((B) => {
        const j = as(k, "data-mce-lang").getOrUndefined();
        return {
          code: B,
          customCode: j,
          title: ""
        };
      })));
    },
    setCurrent: (p, y) => p.execCommand("Lang", !1, y),
    onToolbarSetup: (p) => {
      const y = sh();
      return p.setActive(t.formatter.match("lang", {}, void 0, !0)), y.set(t.formatter.formatChanged("lang", p.setActive, !0)), kO(y.clear, wd(t)(p));
    },
    onMenuSetup: wd(t)
  })), Ute = (t) => {
    GU(t, Vte(t)), ZU(t).each((a) => GU(t, a));
  }, Wte = (t, a) => {
    Vee(t, a), Zee(t, a), lte(t, a), jee(t, a), lU(t, a);
  }, jte = (t) => hg(t, "NodeChange", (a) => {
    a.setEnabled(t.queryCommandState("outdent") && t.selection.isEditable());
  }), qte = (t) => {
    t.ui.registry.addButton("outdent", {
      tooltip: "Decrease indent",
      icon: "outdent",
      onSetup: jte(t),
      onAction: Lf(t, "outdent")
    }), t.ui.registry.addButton("indent", {
      tooltip: "Increase indent",
      icon: "indent",
      onSetup: wd(t),
      onAction: Lf(t, "indent")
    });
  }, Gte = (t) => {
    qte(t);
  }, cD = (t, a) => (u) => {
    u.setActive(a.get());
    const p = (y) => {
      a.set(y.state), u.setActive(y.state);
    };
    return t.on("PastePlainTextToggle", p), kO(() => t.off("PastePlainTextToggle", p), wd(t)(u));
  }, Zte = (t) => {
    const a = sr(P6(t)), u = () => t.execCommand("mceTogglePlainTextPaste");
    t.ui.registry.addToggleButton("pastetext", {
      active: !1,
      icon: "paste-text",
      tooltip: "Paste as text",
      onAction: u,
      onSetup: cD(t, a)
    }), t.ui.registry.addToggleMenuItem("pastetext", {
      text: "Paste as text",
      icon: "paste-text",
      onAction: u,
      onSetup: cD(t, a)
    });
  }, sL = (t, a) => () => {
    t.execCommand("mceToggleFormat", !1, a);
  }, aL = (t) => {
    p1.each([
      {
        name: "bold",
        text: "Bold",
        icon: "bold"
      },
      {
        name: "italic",
        text: "Italic",
        icon: "italic"
      },
      {
        name: "underline",
        text: "Underline",
        icon: "underline"
      },
      {
        name: "strikethrough",
        text: "Strikethrough",
        icon: "strike-through"
      },
      {
        name: "subscript",
        text: "Subscript",
        icon: "subscript"
      },
      {
        name: "superscript",
        text: "Superscript",
        icon: "superscript"
      }
    ], (a, u) => {
      t.ui.registry.addToggleButton(a.name, {
        tooltip: a.text,
        icon: a.icon,
        onSetup: _R(t, a.name),
        onAction: sL(t, a.name)
      });
    });
    for (let a = 1; a <= 6; a++) {
      const u = "h" + a;
      t.ui.registry.addToggleButton(u, {
        text: u.toUpperCase(),
        tooltip: "Heading " + a,
        onSetup: _R(t, u),
        onAction: sL(t, u)
      });
    }
  }, KU = (t) => {
    p1.each([
      {
        name: "copy",
        text: "Copy",
        action: "Copy",
        icon: "copy"
      },
      {
        name: "help",
        text: "Help",
        action: "mceHelp",
        icon: "help"
      },
      {
        name: "selectall",
        text: "Select all",
        action: "SelectAll",
        icon: "select-all"
      },
      {
        name: "newdocument",
        text: "New document",
        action: "mceNewDocument",
        icon: "new-document"
      },
      {
        name: "print",
        text: "Print",
        action: "mcePrint",
        icon: "print"
      }
    ], (a) => {
      t.ui.registry.addButton(a.name, {
        tooltip: a.text,
        icon: a.icon,
        onAction: Lf(t, a.action)
      });
    }), p1.each([
      {
        name: "cut",
        text: "Cut",
        action: "Cut",
        icon: "cut"
      },
      {
        name: "paste",
        text: "Paste",
        action: "Paste",
        icon: "paste"
      },
      {
        name: "removeformat",
        text: "Clear formatting",
        action: "RemoveFormat",
        icon: "remove-formatting"
      },
      {
        name: "remove",
        text: "Remove",
        action: "Delete",
        icon: "remove"
      },
      {
        name: "hr",
        text: "Horizontal line",
        action: "InsertHorizontalRule",
        icon: "horizontal-rule"
      }
    ], (a) => {
      t.ui.registry.addButton(a.name, {
        tooltip: a.text,
        icon: a.icon,
        onSetup: wd(t),
        onAction: Lf(t, a.action)
      });
    });
  }, YU = (t) => {
    p1.each([{
      name: "blockquote",
      text: "Blockquote",
      action: "mceBlockQuote",
      icon: "quote"
    }], (a) => {
      t.ui.registry.addToggleButton(a.name, {
        tooltip: a.text,
        icon: a.icon,
        onAction: Lf(t, a.action),
        onSetup: _R(t, a.name)
      });
    });
  }, Kte = (t) => {
    aL(t), KU(t), YU(t);
  }, Yte = (t) => {
    p1.each([
      {
        name: "newdocument",
        text: "New document",
        action: "mceNewDocument",
        icon: "new-document"
      },
      {
        name: "copy",
        text: "Copy",
        action: "Copy",
        icon: "copy",
        shortcut: "Meta+C"
      },
      {
        name: "selectall",
        text: "Select all",
        action: "SelectAll",
        icon: "select-all",
        shortcut: "Meta+A"
      },
      {
        name: "print",
        text: "Print...",
        action: "mcePrint",
        icon: "print",
        shortcut: "Meta+P"
      }
    ], (a) => {
      t.ui.registry.addMenuItem(a.name, {
        text: a.text,
        icon: a.icon,
        shortcut: a.shortcut,
        onAction: Lf(t, a.action)
      });
    }), p1.each([
      {
        name: "bold",
        text: "Bold",
        action: "Bold",
        icon: "bold",
        shortcut: "Meta+B"
      },
      {
        name: "italic",
        text: "Italic",
        action: "Italic",
        icon: "italic",
        shortcut: "Meta+I"
      },
      {
        name: "underline",
        text: "Underline",
        action: "Underline",
        icon: "underline",
        shortcut: "Meta+U"
      },
      {
        name: "strikethrough",
        text: "Strikethrough",
        action: "Strikethrough",
        icon: "strike-through"
      },
      {
        name: "subscript",
        text: "Subscript",
        action: "Subscript",
        icon: "subscript"
      },
      {
        name: "superscript",
        text: "Superscript",
        action: "Superscript",
        icon: "superscript"
      },
      {
        name: "removeformat",
        text: "Clear formatting",
        action: "RemoveFormat",
        icon: "remove-formatting"
      },
      {
        name: "cut",
        text: "Cut",
        action: "Cut",
        icon: "cut",
        shortcut: "Meta+X"
      },
      {
        name: "paste",
        text: "Paste",
        action: "Paste",
        icon: "paste",
        shortcut: "Meta+V"
      },
      {
        name: "hr",
        text: "Horizontal line",
        action: "InsertHorizontalRule",
        icon: "horizontal-rule"
      }
    ], (a) => {
      t.ui.registry.addMenuItem(a.name, {
        text: a.text,
        icon: a.icon,
        shortcut: a.shortcut,
        onSetup: wd(t),
        onAction: Lf(t, a.action)
      });
    }), t.ui.registry.addMenuItem("codeformat", {
      text: "Code",
      icon: "sourcecode",
      onSetup: wd(t),
      onAction: sL(t, "code")
    });
  }, Qte = (t) => {
    Kte(t), Yte(t);
  }, lD = (t, a) => hg(t, "Undo Redo AddUndo TypingUndo ClearUndos SwitchMode", (u) => {
    u.setEnabled(!t.mode.isReadOnly() && t.undoManager[a]());
  }), Xte = (t) => {
    t.ui.registry.addMenuItem("undo", {
      text: "Undo",
      icon: "undo",
      shortcut: "Meta+Z",
      onSetup: lD(t, "hasUndo"),
      onAction: Lf(t, "undo")
    }), t.ui.registry.addMenuItem("redo", {
      text: "Redo",
      icon: "redo",
      shortcut: "Meta+Y",
      onSetup: lD(t, "hasRedo"),
      onAction: Lf(t, "redo")
    });
  }, iL = (t) => {
    t.ui.registry.addButton("undo", {
      tooltip: "Undo",
      icon: "undo",
      enabled: !1,
      onSetup: lD(t, "hasUndo"),
      onAction: Lf(t, "undo")
    }), t.ui.registry.addButton("redo", {
      tooltip: "Redo",
      icon: "redo",
      enabled: !1,
      onSetup: lD(t, "hasRedo"),
      onAction: Lf(t, "redo")
    });
  }, Jte = (t) => {
    Xte(t), iL(t);
  }, QU = (t) => hg(t, "VisualAid", (a) => {
    a.setActive(t.hasVisual);
  }), ene = (t) => {
    t.ui.registry.addToggleMenuItem("visualaid", {
      text: "Visual aids",
      onSetup: QU(t),
      onAction: Lf(t, "mceToggleVisualAid")
    });
  }, tne = (t) => {
    t.ui.registry.addButton("visualaid", {
      tooltip: "Visual aids",
      text: "Visual aids",
      onAction: Lf(t, "mceToggleVisualAid")
    });
  }, cL = (t) => {
    tne(t), ene(t);
  }, nne = (t, a) => {
    qU(t), Qte(t), Wte(t, a), Jte(t), IF(t), cL(t), Gte(t), Ute(t), Zte(t);
  }, XU = (t) => g(t) ? t.split(/[ ,]/) : t, JU = (t) => (a) => a.options.get(t), rne = (t) => {
    const a = t.options.register;
    a("contextmenu_avoid_overlap", {
      processor: "string",
      default: ""
    }), a("contextmenu_never_use_native", {
      processor: "boolean",
      default: !1
    }), a("contextmenu", {
      processor: (u) => u === !1 ? {
        value: [],
        valid: !0
      } : g(u) || ue(u, g) ? {
        value: XU(u),
        valid: !0
      } : {
        valid: !1,
        message: "Must be false or a string."
      },
      default: "link linkchecker image editimage table spellchecker configurepermanentpen"
    });
  }, uD = JU("contextmenu_never_use_native"), one = JU("contextmenu_avoid_overlap"), sne = (t) => e9(t).length === 0, e9 = (t) => {
    const a = t.ui.registry.getAll().contextMenus, u = t.options.get("contextmenu");
    return t.options.isSet("contextmenu") ? u : Rn(u, (p) => Yr(a, p));
  }, yA = (t, a) => ({
    type: "makeshift",
    x: t,
    y: a
  }), ane = (t, a, u) => yA(t.x + a, t.y + u), lL = (t) => t.type === "longpress" || t.type.indexOf("touch") === 0, ine = (t) => {
    if (lL(t)) {
      const a = t.touches[0];
      return yA(a.pageX, a.pageY);
    } else
      return yA(t.pageX, t.pageY);
  }, cne = (t) => {
    if (lL(t)) {
      const a = t.touches[0];
      return yA(a.clientX, a.clientY);
    } else
      return yA(t.clientX, t.clientY);
  }, lne = (t, a) => {
    const u = uT.DOM.getPos(t);
    return ane(a, u.x, u.y);
  }, une = (t, a) => a.type === "contextmenu" || a.type === "longpress" ? t.inline ? ine(a) : lne(t.getContentAreaContainer(), cne(a)) : t9(t), t9 = (t) => ({
    type: "selection",
    root: nt.fromDom(t.selection.getNode())
  }), dne = (t) => ({
    type: "node",
    node: z.some(nt.fromDom(t.selection.getNode())),
    root: nt.fromDom(t.getBody())
  }), n9 = (t, a, u) => {
    switch (u) {
      case "node":
        return dne(t);
      case "point":
        return une(t, a);
      case "selection":
        return t9(t);
    }
  }, fne = (t, a, u, p, y, x) => {
    const k = u(), $ = n9(t, a, x);
    RT(k, Cv.CLOSE_ON_EXECUTE, p, {
      isHorizontalMenu: !1,
      search: z.none()
    }).map((B) => {
      a.preventDefault(), La.showMenuAt(y, { anchor: $ }, {
        menu: { markers: Gb("normal") },
        data: B
      });
    });
  }, r9 = {
    onLtr: () => [
      Os,
      Wi,
      Mc,
      ji,
      Br,
      El,
      Sg,
      $T,
      oA,
      rA,
      LE,
      nA
    ],
    onRtl: () => [
      Os,
      Mc,
      Wi,
      Br,
      ji,
      El,
      Sg,
      $T,
      LE,
      nA,
      oA,
      rA
    ]
  }, mne = 12, o9 = {
    valignCentre: [],
    alignCentre: [],
    alignLeft: ["tox-pop--align-left"],
    alignRight: ["tox-pop--align-right"],
    right: ["tox-pop--right"],
    left: ["tox-pop--left"],
    bottom: ["tox-pop--bottom"],
    top: ["tox-pop--top"]
  }, pne = (t, a) => {
    const u = t.selection;
    if (u.isCollapsed() || a.touches.length < 1)
      return !1;
    {
      const p = a.touches[0], y = u.getRng();
      return Yw(t.getWin(), Tc.domRange(y)).exists((k) => k.left <= p.clientX && k.right >= p.clientX && k.top <= p.clientY && k.bottom >= p.clientY);
    }
  }, hne = (t) => {
    const a = t.selection.getRng(), u = () => {
      EE.setEditorTimeout(t, () => {
        t.selection.setRng(a);
      }, 10), x();
    };
    t.once("touchend", u);
    const p = (k) => {
      k.preventDefault(), k.stopImmediatePropagation();
    };
    t.on("mousedown", p, !0);
    const y = () => x();
    t.once("longpresscancel", y);
    const x = () => {
      t.off("touchend", u), t.off("longpresscancel", y), t.off("mousedown", p);
    };
  }, gne = (t, a, u) => {
    const p = n9(t, a, u);
    return {
      bubble: ep(0, u === "point" ? mne : 0, o9),
      layouts: r9,
      overrides: {
        maxWidthFunction: R4(),
        maxHeightFunction: vm()
      },
      ...p
    };
  }, VE = (t, a, u, p, y, x, k) => {
    const $ = gne(t, a, x);
    RT(u, Cv.CLOSE_ON_EXECUTE, p, {
      isHorizontalMenu: !0,
      search: z.none()
    }).map((B) => {
      a.preventDefault();
      const j = k ? Sd.HighlightMenuAndItem : Sd.HighlightNone;
      La.showMenuWithinBounds(y, { anchor: $ }, {
        menu: {
          markers: Gb("normal"),
          highlightOnOpen: j
        },
        data: B,
        type: "horizontal"
      }, () => z.some(FU(t, p.shared, x === "node" ? "node" : "selection"))), t.dispatch(kU);
    });
  }, s9 = (t, a, u, p, y, x) => {
    const k = Ft(), $ = k.os.isiOS(), B = k.os.isMacOS(), j = k.os.isAndroid(), Y = k.deviceType.isTouch(), re = () => !(j || $ || B && Y), le = () => {
      const pe = u();
      VE(t, a, pe, p, y, x, re());
    };
    if ((B || $) && x !== "node") {
      const pe = () => {
        hne(t), le();
      };
      pne(t, a) ? pe() : (t.once("selectionchange", pe), t.once("touchend", () => t.off("selectionchange", pe)));
    } else
      le();
  }, a9 = (t) => g(t) ? t === "|" : t.type === "separator", uL = { type: "separator" }, i9 = (t) => {
    const a = (u) => ({
      text: u.text,
      icon: u.icon,
      enabled: u.enabled,
      shortcut: u.shortcut
    });
    if (g(t))
      return t;
    switch (t.type) {
      case "separator":
        return uL;
      case "submenu":
        return {
          type: "nestedmenuitem",
          ...a(t),
          getSubmenuItems: () => {
            const p = t.getSubmenuItems();
            return g(p) ? p : He(p, i9);
          }
        };
      default:
        const u = t;
        return {
          type: "menuitem",
          ...a(u),
          onAction: me(u.onAction)
        };
    }
  }, c9 = (t, a) => {
    if (a.length === 0)
      return t;
    const p = mr(t).filter((y) => !a9(y)).fold(() => [], (y) => [uL]);
    return t.concat(p).concat(a).concat([uL]);
  }, l9 = (t, a, u) => {
    const p = Jt(a, (y, x) => fn(t, x.toLowerCase()).map((k) => {
      const $ = k.update(u);
      if (g($) && vc(Yu($)))
        return c9(y, $.split(" "));
      if (R($) && $.length > 0) {
        const B = He($, i9);
        return c9(y, B);
      } else
        return y;
    }).getOrThunk(() => y.concat([x])), []);
    return p.length > 0 && a9(p[p.length - 1]) && p.pop(), p;
  }, vne = (t, a) => a.ctrlKey && !uD(t), bne = (t) => t.type === "longpress" || Yr(t, "touches"), u9 = (t, a) => !bne(a) && (a.button !== 2 || a.target === t.getBody() && a.pointerType === ""), d9 = (t, a) => u9(t, a) ? t.selection.getStart(!0) : a.target, yne = (t, a) => {
    const u = one(t), p = u9(t, a) ? "selection" : "point";
    if (vc(u)) {
      const y = d9(t, a);
      return DO(nt.fromDom(y), u) ? "node" : p;
    } else
      return p;
  }, Sne = (t, a, u) => {
    const y = Ft().deviceType.isTouch, x = sl(La.sketch({
      dom: { tag: "div" },
      lazySink: a,
      onEscape: () => t.focus(),
      onShow: () => u.setContextMenuState(!0),
      onHide: () => u.setContextMenuState(!1),
      fireDismissalEventInstead: {},
      inlineBehaviours: mn([Hr("dismissContextMenu", [Pt(jp(), (B, j) => {
        bo.close(B), t.focus();
      })])])
    })), k = () => La.hide(x), $ = (B) => {
      if (uD(t) && B.preventDefault(), vne(t, B) || sne(t))
        return;
      const j = yne(t, B), Y = () => {
        const le = d9(t, B), pe = t.ui.registry.getAll(), _e = e9(t);
        return l9(pe.contextMenus, _e, le);
      };
      (y() ? s9 : fne)(t, B, Y, u, x, j);
    };
    t.on("init", () => {
      const B = "ResizeEditor ScrollContent ScrollWindow longpresscancel" + (y() ? "" : " ResizeWindow");
      t.on(B, k), t.on("longpress contextmenu", $);
    });
  }, dL = W.generate([
    {
      offset: [
        "x",
        "y"
      ]
    },
    {
      absolute: [
        "x",
        "y"
      ]
    },
    {
      fixed: [
        "x",
        "y"
      ]
    }
  ]), dD = (t) => (a) => a.translate(-t.left, -t.top), fD = (t) => (a) => a.translate(t.left, t.top), g1 = (t) => (a, u) => Jt(t, (p, y) => y(p), Oo(a, u)), SA = (t, a, u) => t.fold(g1([
    fD(u),
    dD(a)
  ]), g1([dD(a)]), g1([])), UE = (t, a, u) => t.fold(g1([fD(u)]), g1([]), g1([fD(a)])), f9 = (t, a, u) => t.fold(g1([]), g1([dD(u)]), g1([
    fD(a),
    dD(u)
  ])), wA = (t, a, u, p, y, x) => {
    const k = UE(t, y, x), $ = UE(a, y, x);
    return Math.abs(k.left - $.left) <= u && Math.abs(k.top - $.top) <= p;
  }, wne = (t, a, u, p, y, x) => {
    const k = UE(t, y, x), $ = UE(a, y, x), B = Math.abs(k.left - $.left), j = Math.abs(k.top - $.top);
    return Oo(B, j);
  }, m9 = (t, a, u) => {
    const p = t.fold((y, x) => ({
      position: z.some("absolute"),
      left: z.some(y + "px"),
      top: z.some(x + "px")
    }), (y, x) => ({
      position: z.some("absolute"),
      left: z.some(y - u.left + "px"),
      top: z.some(x - u.top + "px")
    }), (y, x) => ({
      position: z.some("fixed"),
      left: z.some(y + "px"),
      top: z.some(x + "px")
    }));
    return {
      right: z.none(),
      bottom: z.none(),
      ...p
    };
  }, fL = (t, a, u) => t.fold((p, y) => mD(p + a, y + u), (p, y) => vS(p + a, y + u), (p, y) => WE(p + a, y + u)), mL = (t, a, u, p) => {
    const y = (x, k) => ($, B) => {
      const j = x(a, u, p);
      return k($.getOr(j.left), B.getOr(j.top));
    };
    return t.fold(y(f9, mD), y(UE, vS), y(SA, WE));
  }, mD = dL.offset, vS = dL.absolute, WE = dL.fixed, p9 = (t, a) => {
    const u = ca(t, a);
    return Z(u) ? NaN : parseInt(u, 10);
  }, Ene = (t, a) => {
    const u = t.element, p = p9(u, a.leftAttr), y = p9(u, a.topAttr);
    return isNaN(p) || isNaN(y) ? z.none() : z.some(Oo(p, y));
  }, Cne = (t, a, u) => {
    const p = t.element;
    kn(p, a.leftAttr, u.left + "px"), kn(p, a.topAttr, u.top + "px");
  }, xne = (t, a) => {
    const u = t.element;
    vs(u, a.leftAttr), vs(u, a.topAttr);
  }, Tne = (t, a, u, p) => Ene(t, a).fold(() => u, (y) => WE(y.left + p.left, y.top + p.top)), _ne = (t, a, u, p, y, x) => {
    const k = Tne(t, a, u, p), $ = a.mustSnap ? Ane(t, a, k, y, x) : kne(t, a, k, y, x), B = SA(k, y, x);
    return Cne(t, a, B), $.fold(() => ({
      coord: WE(B.left, B.top),
      extra: z.none()
    }), (j) => ({
      coord: j.output,
      extra: j.extra
    }));
  }, One = (t, a) => {
    xne(t, a);
  }, h9 = (t, a, u, p) => Vr(t, (y) => {
    const x = y.sensor;
    return wA(a, x, y.range.left, y.range.top, u, p) ? z.some({
      output: mL(y.output, a, u, p),
      extra: y.extra
    }) : z.none();
  }), Ane = (t, a, u, p, y) => {
    const x = a.getSnapPoints(t);
    return h9(x, u, p, y).orThunk(() => Jt(x, (B, j) => {
      const Y = j.sensor, re = wne(u, Y, j.range.left, j.range.top, p, y);
      return B.deltas.fold(() => ({
        deltas: z.some(re),
        snap: z.some(j)
      }), (le) => {
        const pe = (re.left + re.top) / 2, _e = (le.left + le.top) / 2;
        return pe <= _e ? {
          deltas: z.some(re),
          snap: z.some(j)
        } : B;
      });
    }, {
      deltas: z.none(),
      snap: z.none()
    }).snap.map((B) => ({
      output: mL(B.output, u, p, y),
      extra: B.extra
    })));
  }, kne = (t, a, u, p, y) => {
    const x = a.getSnapPoints(t);
    return h9(x, u, p, y);
  }, Nne = (t, a, u) => ({
    coord: mL(t.output, t.output, a, u),
    extra: t.extra
  });
  var Rne = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    snapTo: (t, a, u, p) => {
      const y = a.getTarget(t.element);
      if (a.repositionTarget) {
        const x = ti(t.element), k = ec(x), $ = Gz(y), B = Nne(p, k, $), j = m9(B.coord, k, $);
        rn(y, j);
      }
    }
  });
  const GT = "data-initial-z-index", Pne = (t) => {
    Ii(t.element).filter($o).each((a) => {
      as(a, GT).fold(() => Ur(a, "z-index"), (u) => Sr(a, "z-index", u)), vs(a, GT);
    });
  }, Dne = (t) => {
    Ii(t.element).filter($o).each((a) => {
      Ta(a, "z-index").each((u) => {
        kn(a, GT, u);
      }), Sr(a, "z-index", na(t.element, "z-index"));
    });
  }, g9 = (t, a) => {
    t.getSystem().addToGui(a), Dne(a);
  }, $ne = (t) => {
    Pne(t), t.getSystem().removeFromGui(t);
  }, v9 = (t, a, u) => t.getSystem().build(Tv.sketch({
    dom: {
      styles: {
        left: "0px",
        top: "0px",
        width: "100%",
        height: "100%",
        position: "fixed",
        "z-index": "1000000000000000"
      },
      classes: [a]
    },
    events: u
  }));
  var Ine = nl("snaps", [
    Mt("getSnapPoints"),
    po("onSensor"),
    Mt("leftAttr"),
    Mt("topAttr"),
    lt("lazyViewport", Ci),
    lt("mustSnap", !1)
  ]);
  const pD = [
    lt("useFixed", sn),
    Mt("blockerClass"),
    lt("getTarget", Te),
    lt("onDrag", G),
    lt("repositionTarget", !0),
    lt("onDrop", G),
    ii("getBounds", Ci),
    Ine
  ], Mne = (t) => Xl(Ta(t, "left"), Ta(t, "top"), Ta(t, "position"), (a, u, p) => (p === "fixed" ? WE : mD)(parseInt(a, 10), parseInt(u, 10))).getOrThunk(() => {
    const a = Jc(t);
    return vS(a.left, a.top);
  }), Fne = (t, a, u, p, y) => {
    const x = y.bounds, k = UE(a, u, p), $ = fd(k.left, x.x, x.x + x.width - y.width), B = fd(k.top, x.y, x.y + x.height - y.height), j = vS($, B);
    return a.fold(() => {
      const Y = f9(j, u, p);
      return mD(Y.left, Y.top);
    }, q(j), () => {
      const Y = SA(j, u, p);
      return WE(Y.left, Y.top);
    });
  }, Lne = (t, a, u, p, y, x, k) => {
    const $ = a.fold(() => {
      const B = fL(u, x.left, x.top), j = SA(B, p, y);
      return WE(j.left, j.top);
    }, (B) => {
      const j = _ne(t, B, u, x, p, y);
      return j.extra.each((Y) => {
        B.onSensor(t, Y);
      }), j.coord;
    });
    return Fne(t, $, p, y, k);
  }, Bne = (t, a, u, p) => {
    const y = a.getTarget(t.element);
    if (a.repositionTarget) {
      const x = ti(t.element), k = ec(x), $ = Gz(y), B = Mne(y), j = Lne(t, a.snaps, B, k, $, p, u), Y = m9(j, k, $);
      rn(y, Y);
    }
    a.onDrag(t, y, p);
  }, b9 = (t, a) => ({
    bounds: t.getBounds(),
    height: af(a.element),
    width: Pa(a.element)
  }), EA = (t, a, u, p, y) => {
    const x = u.update(p, y), k = u.getStartData().getOrThunk(() => b9(a, t));
    x.each(($) => {
      Bne(t, a, k, $);
    });
  }, pL = (t, a, u, p) => {
    a.each($ne), u.snaps.each((x) => {
      One(t, x);
    });
    const y = u.getTarget(t.element);
    p.reset(), u.onDrop(t, y);
  }, hL = (t) => (a, u) => {
    const p = (y) => {
      u.setStartData(b9(a, y));
    };
    return ls([
      Pt(Um(), (y) => {
        u.getStartData().each(() => p(y));
      }),
      ...t(a, u, p)
    ]);
  }, Hne = (t) => ls([
    Pt(oo(), t.forceDrop),
    Pt(tb(), t.drop),
    Pt(ci(), (a, u) => {
      t.move(u.event);
    }),
    Pt(rc(), t.delayDrop)
  ]);
  var zne = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    getData: (t) => z.from(Oo(t.x, t.y)),
    getDelta: (t, a) => Oo(a.left - t.left, a.top - t.top)
  });
  const y9 = (t, a, u) => [Pt(oo(), (p, y) => {
    if (y.event.raw.button !== 0)
      return;
    y.stop();
    const k = () => pL(p, z.some(j), t, a), $ = EH(k, 200), B = {
      drop: k,
      delayDrop: $.schedule,
      forceDrop: k,
      move: (re) => {
        $.cancel(), EA(p, t, a, zne, re);
      }
    }, j = v9(p, t.blockerClass, Hne(B));
    (() => {
      u(p), g9(p, j);
    })();
  })], Vne = [
    ...pD,
    ds("dragger", { handlers: hL(y9) })
  ], Une = (t) => ls([
    Pt(du(), t.forceDrop),
    Pt(Lp(), t.drop),
    Pt(qr(), t.drop),
    Pt(jh(), (a, u) => {
      t.move(u.event);
    })
  ]), Wne = (t) => {
    const a = t[0];
    return z.some(Oo(a.clientX, a.clientY));
  };
  var S9 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    getData: (t) => {
      const u = t.raw.touches;
      return u.length === 1 ? Wne(u) : z.none();
    },
    getDelta: (t, a) => Oo(a.left - t.left, a.top - t.top)
  });
  const w9 = (t, a, u) => {
    const p = Gr(), y = (x) => {
      pL(x, p.get(), t, a), p.clear();
    };
    return [
      Pt(du(), (x, k) => {
        k.stop();
        const $ = () => y(x), B = {
          drop: $,
          delayDrop: G,
          forceDrop: $,
          move: (re) => {
            EA(x, t, a, S9, re);
          }
        }, j = v9(x, t.blockerClass, Une(B));
        p.set(j), (() => {
          u(x), g9(x, j);
        })();
      }),
      Pt(jh(), (x, k) => {
        k.stop(), EA(x, t, a, S9, k.event);
      }),
      Pt(Lp(), (x, k) => {
        k.stop(), y(x);
      }),
      Pt(qr(), y)
    ];
  }, jne = [
    ...pD,
    ds("dragger", { handlers: hL(w9) })
  ], qne = (t, a, u) => [
    ...y9(t, a, u),
    ...w9(t, a, u)
  ], Gne = [
    ...pD,
    ds("dragger", { handlers: hL(qne) })
  ];
  var Kne = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    mouse: Vne,
    touch: jne,
    mouseOrTouch: Gne
  }), Yne = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: () => {
      let t = z.none(), a = z.none();
      const u = () => {
        t = z.none(), a = z.none();
      }, p = (B, j) => {
        const Y = t.map((re) => B.getDelta(re, j));
        return t = z.some(j), Y;
      }, y = (B, j) => B.getData(j).bind((Y) => p(B, Y)), x = (B) => {
        a = z.some(B);
      }, k = () => a, $ = q({});
      return ol({
        readState: $,
        reset: u,
        update: y,
        getStartData: k,
        setStartData: x
      });
    }
  });
  const jE = tg({
    branchKey: "mode",
    branches: Kne,
    name: "dragging",
    active: {
      events: (t, a) => t.dragger.handlers(t, a)
    },
    extra: {
      snap: (t) => ({
        sensor: t.sensor,
        range: t.range,
        output: t.output,
        extra: z.from(t.extra)
      })
    },
    state: Yne,
    apis: Rne
  }), gL = 40, hD = gL / 2, E9 = (t, a, u, p, y, x) => t.fold(() => jE.snap({
    sensor: vS(u - hD, p - hD),
    range: Oo(y, x),
    output: vS(z.some(u), z.some(p)),
    extra: { td: a }
  }), (k) => {
    const $ = u - hD, B = p - hD, j = gL, Y = gL, re = k.element.dom.getBoundingClientRect();
    return jE.snap({
      sensor: vS($, B),
      range: Oo(j, Y),
      output: vS(z.some(u - re.width / 2), z.some(p - re.height / 2)),
      extra: { td: a }
    });
  }), vL = (t, a, u) => {
    const p = (y, x) => y.exists((k) => Io(k, x));
    return {
      getSnapPoints: t,
      leftAttr: "data-drag-left",
      topAttr: "data-drag-top",
      onSensor: (y, x) => {
        const k = x.td;
        p(a.get(), k) || (a.set(k), u(k));
      },
      mustSnap: !0
    };
  }, bL = (t) => ms(cl.sketch({
    dom: {
      tag: "div",
      classes: ["tox-selector"]
    },
    buttonBehaviours: mn([
      jE.config({
        mode: "mouseOrTouch",
        blockerClass: "blocker",
        snaps: t
      }),
      LO.config({})
    ]),
    eventOrder: {
      mousedown: [
        "dragging",
        "alloy.base.behaviour"
      ],
      touchstart: [
        "dragging",
        "alloy.base.behaviour"
      ]
    }
  })), qE = (t, a) => {
    const u = sr([]), p = sr([]), y = sr(!1), x = Gr(), k = Gr(), $ = (hn) => {
      const En = Fi(hn);
      return E9(pe.getOpt(a), hn, En.x, En.y, En.width, En.height);
    }, B = () => He(u.get(), (hn) => $(hn)), j = (hn) => {
      const En = Fi(hn);
      return E9(_e.getOpt(a), hn, En.right, En.bottom, En.width, En.height);
    }, Y = () => He(p.get(), (hn) => j(hn)), re = vL(B, x, (hn) => {
      k.get().each((En) => {
        t.dispatch("TableSelectorChange", {
          start: hn,
          finish: En
        });
      });
    }), le = vL(Y, k, (hn) => {
      x.get().each((En) => {
        t.dispatch("TableSelectorChange", {
          start: En,
          finish: hn
        });
      });
    }), pe = bL(re), _e = bL(le), ze = sl(pe.asSpec()), ft = sl(_e.asSpec()), Xe = (hn, En, zr, Yn) => {
      const hr = En.dom.getBoundingClientRect();
      Ur(hn.element, "display");
      const Cr = nu(nt.fromDom(t.getBody())).dom.innerHeight, ns = zr(hr), dr = Yn(hr, Cr);
      (ns || dr) && Sr(hn.element, "display", "none");
    }, Ze = (hn, En, zr, Yn) => {
      const hr = zr(En);
      jE.snapTo(hn, hr), Xe(hn, En, (dr) => dr[Yn] < 0, (dr, ko) => dr[Yn] > ko);
    }, mt = (hn) => Ze(ze, hn, $, "top"), jt = () => x.get().each(mt), Dt = (hn) => Ze(ft, hn, j, "bottom"), Nt = () => k.get().each(Dt);
    Ft().deviceType.isTouch() && (t.on("TableSelectionChange", (hn) => {
      y.get() || (Hb(a, ze), Hb(a, ft), y.set(!0)), x.set(hn.start), k.set(hn.finish), hn.otherCells.each((En) => {
        u.set(En.upOrLeftCells), p.set(En.downOrRightCells), mt(hn.start), Dt(hn.finish);
      });
    }), t.on("ResizeEditor ResizeWindow ScrollContent", () => {
      jt(), Nt();
    }), t.on("TableSelectionClear", () => {
      y.get() && (cg(ze), cg(ft), y.set(!1)), x.clear(), k.clear();
    }));
  };
  var Qne = `<svg width="50px" height="16px" viewBox="0 0 50 16" xmlns="http://www.w3.org/2000/svg">
  <path fill-rule="evenodd" clip-rule="evenodd" d="M10.143 0c2.608.015 5.186 2.178 5.186 5.331 0 0 .077 3.812-.084 4.87-.361 2.41-2.164 4.074-4.65 4.496-1.453.284-2.523.49-3.212.623-.373.071-.634.122-.785.152-.184.038-.997.145-1.35.145-2.732 0-5.21-2.04-5.248-5.33 0 0 0-3.514.03-4.442.093-2.4 1.758-4.342 4.926-4.963 0 0 3.875-.752 4.036-.782.368-.07.775-.1 1.15-.1Zm1.826 2.8L5.83 3.989v2.393l-2.455.475v5.968l6.137-1.189V9.243l2.456-.476V2.8ZM5.83 6.382l3.682-.713v3.574l-3.682.713V6.382Zm27.173-1.64-.084-1.066h-2.226v9.132h2.456V7.743c-.008-1.151.998-2.064 2.149-2.072 1.15-.008 1.987.92 1.995 2.072v5.065h2.455V7.359c-.015-2.18-1.657-3.929-3.837-3.913a3.993 3.993 0 0 0-2.908 1.296Zm-6.3-4.266L29.16 0v2.387l-2.456.475V.476Zm0 3.2v9.132h2.456V3.676h-2.456Zm18.179 11.787L49.11 3.676H46.58l-1.612 4.527-.46 1.382-.384-1.382-1.611-4.527H39.98l3.3 9.132L42.15 16l2.732-.537ZM22.867 9.738c0 .752.568 1.075.921 1.075.353 0 .668-.047.998-.154l.537 1.765c-.23.154-.92.537-2.225.537-1.305 0-2.655-.997-2.686-2.686a136.877 136.877 0 0 1 0-4.374H18.8V3.676h1.612v-1.98l2.455-.476v2.456h2.302V5.9h-2.302v3.837Z"/>
</svg>
`;
  const yL = (t) => t.nodeName === "BR" || !!t.getAttribute("data-mce-bogus") || t.getAttribute("data-mce-type") === "bookmark", gD = (t, a, u) => {
    var p;
    const y = (p = a.delimiter) !== null && p !== void 0 ? p : "", x = (j, Y, re) => cl.sketch({
      dom: {
        tag: "div",
        classes: ["tox-statusbar__path-item"],
        attributes: {
          "data-index": re,
          "aria-level": re + 1
        }
      },
      components: [Ma(j)],
      action: (le) => {
        t.focus(), t.selection.select(Y), t.nodeChanged();
      },
      buttonBehaviours: mn([
        ip.button(u.isDisabled),
        Bc()
      ])
    }), k = () => ({
      dom: {
        tag: "div",
        classes: ["tox-statusbar__path-divider"],
        attributes: { "aria-hidden": !0 }
      },
      components: [Ma(` ${y} `)]
    }), $ = (j) => Jt(j, (Y, re, le) => {
      const pe = x(re.name, re.element, le);
      return le === 0 ? Y.concat([pe]) : Y.concat([
        k(),
        pe
      ]);
    }, []), B = (j) => {
      const Y = [];
      let re = j.length;
      for (; re-- > 0; ) {
        const le = j[re];
        if (le.nodeType === 1 && !yL(le)) {
          const pe = G8(t, le);
          if (pe.isDefaultPrevented() || Y.push({
            name: pe.name,
            element: le
          }), pe.isPropagationStopped())
            break;
        }
      }
      return Y;
    };
    return {
      dom: {
        tag: "div",
        classes: ["tox-statusbar__path"],
        attributes: { role: "navigation" }
      },
      behaviours: mn([
        ar.config({
          mode: "flow",
          selector: "div[role=button]"
        }),
        yr.config({ disabled: u.isDisabled }),
        Bc(),
        Ea.config({}),
        $r.config({}),
        Hr("elementPathEvents", [us((j, Y) => {
          t.shortcuts.add("alt+F11", "focus statusbar elementpath", () => ar.focusIn(j)), t.on("NodeChange", (re) => {
            const le = B(re.parents), pe = le.length > 0 ? $(le) : [];
            $r.set(j, pe);
          });
        })])
      ]),
      components: []
    };
  };
  var bS;
  (function(t) {
    t[t.None = 0] = "None", t[t.Both = 1] = "Both", t[t.Vertical = 2] = "Vertical";
  })(bS || (bS = {}));
  const Xne = (t, a, u, p, y) => {
    const x = { height: gA(p + a.top, kM(t), NM(t)) };
    return u === bS.Both && (x.width = gA(y + a.left, AM(t), qN(t))), x;
  }, C9 = (t, a, u) => {
    const p = nt.fromDom(t.getContainer()), y = Xne(t, a, u, Ds(p), Oa(p));
    Eo(y, (x, k) => {
      he(x) && Sr(p, k, Q4(x));
    }), j8(t);
  }, Jne = (t) => {
    const a = QN(t);
    return a === !1 ? bS.None : a === "both" ? bS.Both : bS.Vertical;
  }, vD = (t, a, u, p) => {
    const x = Oo(u * 20, p * 20);
    return C9(t, x, a), z.some(!0);
  }, GE = (t, a) => {
    const u = Jne(t);
    if (u === bS.None)
      return z.none();
    const p = u === bS.Both ? "Press the arrow keys to resize the editor." : "Press the Up and Down arrow keys to resize the editor.";
    return z.some(mg("resize-handle", {
      tag: "div",
      classes: ["tox-statusbar__resize-handle"],
      attributes: {
        title: a.translate("Resize"),
        "aria-label": a.translate(p)
      },
      behaviours: [
        jE.config({
          mode: "mouse",
          repositionTarget: !1,
          onDrag: (y, x, k) => C9(t, k, u),
          blockerClass: "tox-blocker"
        }),
        ar.config({
          mode: "special",
          onLeft: () => vD(t, u, -1, 0),
          onRight: () => vD(t, u, 1, 0),
          onUp: () => vD(t, u, 0, -1),
          onDown: () => vD(t, u, 0, 1)
        }),
        Ea.config({}),
        Er.config({})
      ]
    }, a.icons));
  }, x9 = (t, a) => {
    const u = (p, y, x) => $r.set(p, [Ma(a.translate([
      "{0} " + x,
      y[x]
    ]))]);
    return cl.sketch({
      dom: {
        tag: "button",
        classes: ["tox-statusbar__wordcount"]
      },
      components: [],
      buttonBehaviours: mn([
        ip.button(a.isDisabled),
        Bc(),
        Ea.config({}),
        $r.config({}),
        Pn.config({
          store: {
            mode: "memory",
            initialValue: {
              mode: "words",
              count: {
                words: 0,
                characters: 0
              }
            }
          }
        }),
        Hr("wordcount-events", [
          Ul((p) => {
            const y = Pn.getValue(p), x = y.mode === "words" ? "characters" : "words";
            Pn.setValue(p, {
              mode: x,
              count: y.count
            }), u(p, y.count, x);
          }),
          us((p) => {
            t.on("wordCountUpdate", (y) => {
              const { mode: x } = Pn.getValue(p);
              Pn.setValue(p, {
                mode: x,
                count: y.wordCount
              }), u(p, y.wordCount, x);
            });
          })
        ])
      ]),
      eventOrder: {
        [Lu()]: [
          "disabling",
          "alloy.base.behaviour",
          "wordcount-events"
        ]
      }
    });
  }, ere = (t, a) => {
    const u = () => ({
      dom: {
        tag: "span",
        classes: ["tox-statusbar__branding"]
      },
      components: [{
        dom: {
          tag: "a",
          attributes: {
            href: "https://www.tiny.cloud/powered-by-tiny?utm_campaign=poweredby&utm_source=tiny&utm_medium=referral&utm_content=v6",
            rel: "noopener",
            target: "_blank",
            "aria-label": Mf.translate([
              "Powered by {0}",
              "Tiny"
            ])
          },
          innerHtml: Qne.trim()
        },
        behaviours: mn([Er.config({})])
      }]
    }), p = () => {
      const $ = k8("Alt+0"), B = "Press {0} for help";
      return {
        dom: {
          tag: "div",
          classes: ["tox-statusbar__help-text"]
        },
        components: [Ma(Mf.translate([
          B,
          $
        ]))]
      };
    }, y = () => {
      const $ = [];
      return t.hasPlugin("wordcount") && $.push(x9(t, a)), IM(t) && $.push(u()), {
        dom: {
          tag: "div",
          classes: ["tox-statusbar__right-container"]
        },
        components: $
      };
    }, x = () => {
      const $ = [], B = $6(t), j = YN(t), Y = IM(t) || t.hasPlugin("wordcount"), re = () => {
        const le = "tox-statusbar__text-container--flex-start", pe = "tox-statusbar__text-container--flex-end", _e = "tox-statusbar__text-container--space-around";
        if (B) {
          const ze = "tox-statusbar__text-container-3-cols";
          return !Y && !j ? [
            ze,
            _e
          ] : Y && !j ? [
            ze,
            pe
          ] : [
            ze,
            le
          ];
        }
        return [Y && !j ? pe : le];
      };
      return j && $.push(gD(t, {}, a)), B && $.push(p()), Y && $.push(y()), $.length > 0 ? [{
        dom: {
          tag: "div",
          classes: [
            "tox-statusbar__text-container",
            ...re()
          ]
        },
        components: $
      }] : [];
    };
    return {
      dom: {
        tag: "div",
        classes: ["tox-statusbar"]
      },
      components: (() => {
        const $ = x(), B = GE(t, a);
        return $.concat(B.toArray());
      })()
    };
  }, T9 = (t, a) => a.get().getOrDie(`UI for ${t} has not been rendered`), tre = (t, a) => {
    const u = t.inline, p = u ? AU : xU, y = vO(t) ? iV : fJ, x = Nte(), k = Gr(), $ = Gr(), B = Gr(), le = Ft().deviceType.isTouch() ? ["tox-platform-touch"] : [], pe = LM(t), _e = fT(t), ze = ms({
      dom: {
        tag: "div",
        classes: ["tox-anchorbar"]
      }
    }), ft = ms({
      dom: {
        tag: "div",
        classes: ["tox-bottom-anchorbar"]
      }
    }), Xe = () => x.mainUi.get().map((vr) => vr.outerContainer).bind(Qs.getHeader), Ze = () => Rr.fromOption(x.dialogUi.get().map((vr) => vr.sink), "UI has not been rendered"), mt = () => Rr.fromOption(x.popupUi.get().map((vr) => vr.sink), "(popup) UI has not been rendered"), jt = x.lazyGetInOuterOrDie("anchor bar", ze.getOpt), Dt = x.lazyGetInOuterOrDie("bottom anchor bar", ft.getOpt), Nt = x.lazyGetInOuterOrDie("toolbar", Qs.getToolbar), hn = x.lazyGetInOuterOrDie("throbber", Qs.getThrobber), En = oJ({
      popup: mt,
      dialog: Ze
    }, t, jt, Dt), zr = () => {
      const vr = { attributes: { [$b]: pe ? Gd.BottomToTop : Gd.TopToBottom } }, Mr = Qs.parts.menubar({
        dom: {
          tag: "div",
          classes: ["tox-menubar"]
        },
        backstage: En.popup,
        onEscape: () => {
          t.focus();
        }
      }), Bs = Qs.parts.toolbar({
        dom: {
          tag: "div",
          classes: ["tox-toolbar"]
        },
        getSink: En.popup.shared.getSink,
        providers: En.popup.shared.providers,
        onEscape: () => {
          t.focus();
        },
        onToolbarToggled: (_S) => {
          zZ(t, _S);
        },
        type: _e,
        lazyToolbar: Nt,
        lazyHeader: () => Xe().getOrDie("Could not find header element"),
        ...vr
      }), jo = Qs.parts["multiple-toolbar"]({
        dom: {
          tag: "div",
          classes: ["tox-toolbar-overlord"]
        },
        providers: En.popup.shared.providers,
        onEscape: () => {
          t.focus();
        },
        type: _e
      }), Gu = gO(t), Ca = nR(t), Wf = JN(t), xg = XN(t), xS = Yn(), TS = Gu || Ca || Wf, QE = () => Gu ? [jo] : Ca ? [Bs] : [], OD = xg ? [
        xS,
        Mr
      ] : [Mr];
      return Qs.parts.header({
        dom: {
          tag: "div",
          classes: ["tox-editor-header"].concat(TS ? [] : ["tox-editor-header--empty"]),
          ...vr
        },
        components: St([
          Wf ? OD : [],
          QE(),
          K0(t) ? [] : [ze.asSpec()]
        ]),
        sticky: vO(t),
        editor: t,
        sharedBackstage: En.popup.shared
      });
    }, Yn = () => Qs.parts.promotion({
      dom: {
        tag: "div",
        classes: ["tox-promotion"]
      }
    }), hr = () => {
      const vr = Qs.parts.socket({
        dom: {
          tag: "div",
          classes: ["tox-edit-area"]
        }
      }), Mr = Qs.parts.sidebar({
        dom: {
          tag: "div",
          classes: ["tox-sidebar"]
        }
      });
      return {
        dom: {
          tag: "div",
          classes: ["tox-sidebar-wrap"]
        },
        components: [
          vr,
          Mr
        ]
      };
    }, Cr = () => {
      const vr = BM(t), Mr = Io(ta(), vr) && na(vr, "display") === "grid", Bs = {
        dom: {
          tag: "div",
          classes: [
            "tox",
            "tox-silver-sink",
            "tox-tinymce-aux"
          ].concat(le),
          attributes: { ...Mf.isRtl() ? { dir: "rtl" } : {} }
        },
        behaviours: mn([Wl.config({ useFixed: () => y.isDocked(Xe) })])
      }, jo = {
        dom: { styles: { width: document.body.clientWidth + "px" } },
        events: ls([Pt(dm(), (Wf) => {
          Sr(Wf.element, "width", document.body.clientWidth + "px");
        })])
      }, Gu = sl(Vo(Bs, Mr ? jo : {})), Ca = LR(Gu);
      return $.set(Ca), {
        sink: Gu,
        mothership: Ca
      };
    }, ns = () => {
      const vr = {
        dom: {
          tag: "div",
          classes: [
            "tox",
            "tox-silver-sink",
            "tox-silver-popup-sink",
            "tox-tinymce-aux"
          ].concat(le),
          attributes: { ...Mf.isRtl() ? { dir: "rtl" } : {} }
        },
        behaviours: mn([Wl.config({
          useFixed: () => y.isDocked(Xe),
          getBounds: () => a.getPopupSinkBounds()
        })])
      }, Mr = sl(vr), Bs = LR(Mr);
      return B.set(Bs), {
        sink: Mr,
        mothership: Bs
      };
    }, dr = () => {
      const vr = zr(), Mr = hr(), Bs = Qs.parts.throbber({
        dom: {
          tag: "div",
          classes: ["tox-throbber"]
        },
        backstage: En.popup
      }), jo = Qs.parts.viewWrapper({ backstage: En.popup }), Gu = KN(t) && !u ? z.some(ere(t, En.popup.shared.providers)) : z.none(), Ca = St([
        pe ? [] : [vr],
        u ? [] : [Mr],
        pe ? [vr] : []
      ]), Wf = Qs.parts.editorContainer({
        components: St([
          Ca,
          u ? [] : [
            ft.asSpec(),
            ...Gu.toArray()
          ]
        ])
      }), xg = HM(t), xS = {
        role: "application",
        ...Mf.isRtl() ? { dir: "rtl" } : {},
        ...xg ? { "aria-hidden": "true" } : {}
      }, TS = sl(Qs.sketch({
        dom: {
          tag: "div",
          classes: [
            "tox",
            "tox-tinymce"
          ].concat(u ? ["tox-tinymce-inline"] : []).concat(pe ? ["tox-tinymce--toolbar-bottom"] : []).concat(le),
          styles: {
            visibility: "hidden",
            ...xg ? {
              opacity: "0",
              border: "0"
            } : {}
          },
          attributes: xS
        },
        components: [
          Wf,
          ...u ? [] : [jo],
          Bs
        ],
        behaviours: mn([
          Bc(),
          yr.config({ disableClass: "tox-tinymce--disabled" }),
          ar.config({
            mode: "cyclic",
            selector: ".tox-menubar, .tox-toolbar, .tox-toolbar__primary, .tox-toolbar__overflow--open, .tox-sidebar__overflow--open, .tox-statusbar__path, .tox-statusbar__wordcount, .tox-statusbar__branding a, .tox-statusbar__resize-handle"
          })
        ])
      })), QE = LR(TS);
      return k.set(QE), {
        mothership: QE,
        outerContainer: TS
      };
    }, ko = (vr) => {
      const Mr = Q4(_te(t)), Bs = Q4(Ote(t));
      return t.inline || (Dd("div", "width", Bs) && Sr(vr.element, "width", Bs), Dd("div", "height", Mr) ? Sr(vr.element, "height", Mr) : Sr(vr.element, "height", "400px")), Mr;
    }, Cn = (vr) => {
      t.addShortcut("alt+F9", "focus menubar", () => {
        Qs.focusMenubar(vr);
      }), t.addShortcut("alt+F10", "focus toolbar", () => {
        Qs.focusToolbar(vr);
      }), t.addCommand("ToggleToolbarDrawer", (Mr, Bs) => {
        Bs != null && Bs.skipFocus ? Qs.toggleToolbarDrawerWithoutFocusing(vr) : Qs.toggleToolbarDrawer(vr);
      }), t.addQueryStateHandler("ToggleToolbarDrawer", () => Qs.isToolbarDrawerToggled(vr));
    }, Zn = (vr) => {
      const { mainUi: Mr, popupUi: Bs, uiMotherships: jo } = vr;
      uo(x6(t), (XE, NL) => {
        t.ui.registry.addGroupToolbarButton(NL, XE);
      });
      const { buttons: Gu, menuItems: Ca, contextToolbars: Wf, sidebars: xg, views: xS } = t.ui.registry.getAll(), TS = FM(t), QE = {
        menuItems: Ca,
        menus: L6(t),
        menubar: O6(t),
        toolbar: TS.getOrThunk(() => hO(t)),
        allowToolbarGroups: _e === ph.floating,
        buttons: Gu,
        sidebar: xg,
        views: xS
      };
      Cn(Mr.outerContainer), MT(t, Mr.mothership, jo), y.setup(t, En.popup.shared, Xe), nne(t, En.popup), Sne(t, En.popup.shared.getSink, En.popup), UJ(t), DP(t, hn, En.popup.shared), jU(t, Wf, Bs.sink, { backstage: En.popup }), qE(t, Bs.sink);
      const OD = t.getElement(), _S = ko(Mr.outerContainer), kL = {
        targetNode: OD,
        height: _S
      };
      return p.render(t, vr, QE, En.popup, kL);
    }, Ar = (vr) => (B.set(vr.mothership), vr), go = () => {
      const vr = dr(), Mr = Cr(), Bs = a1(t) ? ns() : Ar(Mr);
      x.dialogUi.set(Mr), x.popupUi.set(Bs), x.mainUi.set(vr);
      const jo = {
        popupUi: Bs,
        dialogUi: Mr,
        mainUi: vr,
        uiMotherships: x.getUiMotherships()
      };
      return Zn(jo);
    };
    return {
      popups: {
        backstage: En.popup,
        getMothership: () => T9("popups", B)
      },
      dialogs: {
        backstage: En.dialog,
        getMothership: () => T9("dialogs", $)
      },
      renderUI: go
    };
  }, nre = (t, a) => {
    const u = as(t, "id").fold(() => {
      const p = Hn("dialog-label");
      return kn(a, "id", p), p;
    }, Te);
    kn(t, "aria-labelledby", u);
  }, rre = q([
    Mt("lazySink"),
    Fo("dragBlockClass"),
    ii("getBounds", Ci),
    lt("useTabstopAt", Lt),
    lt("firstTabstop", 0),
    lt("eventOrder", {}),
    ac("modalBehaviours", [ar]),
    Uu("onExecute"),
    Ob("onEscape")
  ]), SL = { sketch: Te }, ore = q([
    vd({
      name: "draghandle",
      overrides: (t, a) => ({
        behaviours: mn([jE.config({
          mode: "mouse",
          getTarget: (u) => zu(u, '[role="dialog"]').getOr(u),
          blockerClass: t.dragBlockClass.getOrDie(new Error(`The drag blocker class was not specified for a dialog with a drag handle: 
` + JSON.stringify(a, null, 2)).message),
          getBounds: t.getDragBounds
        })])
      })
    }),
    jl({
      schema: [Mt("dom")],
      name: "title"
    }),
    jl({
      factory: SL,
      schema: [Mt("dom")],
      name: "close"
    }),
    jl({
      factory: SL,
      schema: [Mt("dom")],
      name: "body"
    }),
    vd({
      factory: SL,
      schema: [Mt("dom")],
      name: "footer"
    }),
    rp({
      factory: {
        sketch: (t, a) => ({
          ...t,
          dom: a.dom,
          components: a.components
        })
      },
      schema: [
        lt("dom", {
          tag: "div",
          styles: {
            position: "fixed",
            left: "0px",
            top: "0px",
            right: "0px",
            bottom: "0px"
          }
        }),
        lt("components", [])
      ],
      name: "blocker"
    })
  ]), sre = (t, a, u, p) => {
    const y = Gr(), x = (pe) => {
      y.set(pe);
      const _e = t.lazySink(pe).getOrDie(), ze = p.blocker(), ft = _e.getSystem().build({
        ...ze,
        components: ze.components.concat([Hu(pe)]),
        behaviours: mn([
          Er.config({}),
          Hr("dialog-blocker-events", [xf(oa(), () => {
            Nv.isBlocked(pe) ? G() : ar.focusIn(pe);
          })])
        ])
      });
      Hb(_e, ft), ar.focusIn(pe);
    }, k = (pe) => {
      y.clear(), Ii(pe.element).each((_e) => {
        pe.getSystem().getByDom(_e).each((ze) => {
          cg(ze);
        });
      });
    }, $ = (pe) => gv(pe, t, "body"), B = (pe) => Fs(pe, t, "footer"), j = (pe, _e) => {
      Nv.block(pe, _e);
    }, Y = (pe) => {
      Nv.unblock(pe);
    }, re = Hn("modal-events"), le = {
      ...t.eventOrder,
      [Vl()]: [re].concat(t.eventOrder["alloy.system.attached"] || [])
    };
    return {
      uid: t.uid,
      dom: t.dom,
      components: a,
      apis: {
        show: x,
        hide: k,
        getBody: $,
        getFooter: B,
        setIdle: Y,
        setBusy: j
      },
      eventOrder: le,
      domModification: {
        attributes: {
          role: "dialog",
          "aria-modal": "true"
        }
      },
      behaviours: _i(t.modalBehaviours, [
        $r.config({}),
        ar.config({
          mode: "cyclic",
          onEnter: t.onExecute,
          onEscape: t.onEscape,
          useTabstopAt: t.useTabstopAt,
          firstTabstop: t.firstTabstop
        }),
        Nv.config({ getRoot: y.get }),
        Hr(re, [us((pe) => {
          nre(pe.element, gv(pe, t, "title").element);
        })])
      ])
    };
  }, ic = ql({
    name: "ModalDialog",
    configFields: rre(),
    partFields: ore(),
    factory: sre,
    apis: {
      show: (t, a) => {
        t.show(a);
      },
      hide: (t, a) => {
        t.hide(a);
      },
      getBody: (t, a) => t.getBody(a),
      getFooter: (t, a) => t.getFooter(a),
      setBusy: (t, a, u) => {
        t.setBusy(a, u);
      },
      setIdle: (t, a) => {
        t.setIdle(a);
      }
    }
  }), CA = jn([
    Qi,
    uR
  ].concat(OE)), wL = ad, ZT = [
    bR("button"),
    wm,
    vl("align", "end", [
      "start",
      "end"
    ]),
    hR,
    Em,
    Ey("buttonType", [
      "primary",
      "secondary"
    ])
  ], yS = [
    ...ZT,
    Kb
  ], KT = [
    ka("type", [
      "submit",
      "cancel",
      "custom"
    ]),
    ...yS
  ], are = [
    ka("type", ["menu"]),
    J0,
    fR,
    wm,
    tc("items", CA),
    ...ZT
  ], _9 = [
    ...ZT,
    ka("type", ["togglebutton"]),
    xo("tooltip"),
    wm,
    J0,
    vi("active", !1)
  ], O9 = ro("type", {
    submit: KT,
    cancel: KT,
    custom: KT,
    menu: are,
    togglebutton: _9
  }), A9 = [
    Qi,
    Kb,
    ka("level", [
      "info",
      "warn",
      "error",
      "success"
    ]),
    s8,
    lt("url", "")
  ], ire = jn(A9), cre = (t) => [
    Qi,
    t
  ], lre = [
    Qi,
    Kb,
    Em,
    bR("button"),
    wm,
    tF,
    Ey("buttonType", [
      "primary",
      "secondary",
      "toolbar"
    ]),
    hR
  ], k9 = jn(lre), ZE = [
    Qi,
    uR
  ], wh = ZE.concat([mR]), ure = ZE.concat([
    dR,
    Em
  ]), dre = jn(ure), fre = ad, N9 = wh.concat([nF("auto")]), mre = jn(N9), pre = hf([
    wO,
    Kb,
    s8
  ]), hre = wh.concat([rl("storageKey", "default")]), EL = jn(hre), CL = xi, R9 = jn(wh), gre = xi, vre = ZE.concat([
    rl("tag", "textarea"),
    xo("scriptId"),
    xo("scriptUrl"),
    Cy("settings", void 0)
  ]), P9 = ZE.concat([
    rl("tag", "textarea"),
    id("init")
  ]), bre = am((t) => Ws("customeditor.old", xs(P9), t).orThunk(() => Ws("customeditor.new", xs(vre), t))), yre = xi, D9 = jn(wh), Sre = H1(), bD = (t) => [
    Qi,
    jg("columns"),
    t
  ], QT = [
    Qi,
    xo("html"),
    vl("presets", "presentation", [
      "presentation",
      "document"
    ])
  ], yD = jn(QT), $9 = wh.concat([
    vi("border", !1),
    vi("sandboxed", !0),
    vi("streamContent", !1),
    vi("transparent", !0)
  ]), SD = jn($9), Uf = xi, wD = jn(ZE.concat([nc("height")])), I9 = jn([
    xo("url"),
    cm("zoom"),
    cm("cachedWidth"),
    cm("cachedHeight")
  ]), M9 = wh.concat([
    nc("inputMode"),
    nc("placeholder"),
    vi("maximized", !1),
    Em
  ]), wre = jn(M9), Ere = xi, SS = (t) => [
    Qi,
    dR,
    t,
    vl("align", "start", [
      "start",
      "center",
      "end"
    ])
  ], Sle = [
    Kb,
    wO
  ], Cre = [
    Kb,
    tc("items", $p("items", () => xL))
  ], xL = Un([
    jn(Sle),
    jn(Cre)
  ]), XT = wh.concat([
    tc("items", xL),
    Em
  ]), ED = jn(XT), F9 = xi, xre = wh.concat([
    Wh("items", [
      Kb,
      wO
    ]),
    Fu("size", 1),
    Em
  ]), Tre = jn(xre), _re = xi, Ore = wh.concat([
    vi("constrain", !0),
    Em
  ]), JT = jn(Ore), Are = jn([
    xo("width"),
    xo("height")
  ]), kre = ZE.concat([
    dR,
    Fu("min", 0),
    Fu("max", 0)
  ]), Nre = jn(kre), wle = Ug, Rre = [
    Qi,
    tc("header", xi),
    tc("cells", pf(xi))
  ], Pre = jn(Rre), xA = wh.concat([
    nc("placeholder"),
    vi("maximized", !1),
    Em
  ]), Dre = jn(xA), $re = xi, TL = [
    ka("type", [
      "directory",
      "leaf"
    ]),
    JM,
    xo("id"),
    ai("menu", uA)
  ], Ire = jn(TL), e = TL.concat([tc("children", $p("children", () => Qt("type", {
    directory: n,
    leaf: Ire
  })))]), n = jn(e), s = Qt("type", {
    directory: n,
    leaf: Ire
  }), l = [
    Qi,
    tc("items", s),
    Ip("onLeafAction"),
    Ip("onToggleExpand"),
    bl("defaultExpandedIds", [], xi),
    nc("defaultSelectedId")
  ], f = jn(l), b = wh.concat([
    vl("filetype", "file", [
      "image",
      "media",
      "file"
    ]),
    Em,
    nc("picker_text")
  ]), E = jn(b), N = jn([
    wO,
    gR
  ]), D = (t) => si("items", "items", mo(), pf(am((a) => Ws(`Checking item of ${t}`, U, a).fold((u) => Rr.error(Dc(u)), (u) => Rr.value(u))))), U = Vi(() => Qt("type", {
    alertbanner: ire,
    bar: jn(cre(D("bar"))),
    button: k9,
    checkbox: dre,
    colorinput: EL,
    colorpicker: R9,
    dropzone: D9,
    grid: jn(bD(D("grid"))),
    iframe: SD,
    input: wre,
    listbox: ED,
    selectbox: Tre,
    sizeinput: JT,
    slider: Nre,
    textarea: Dre,
    urlinput: E,
    customeditor: bre,
    htmlpanel: yD,
    imagepreview: wD,
    collection: mre,
    label: jn(SS(D("label"))),
    table: Pre,
    tree: f,
    panel: te
  })), J = [
    Qi,
    lt("classes", []),
    tc("items", U)
  ], te = jn(J), ce = [
    bR("tab"),
    JM,
    tc("items", U)
  ], Oe = [
    Qi,
    Wh("tabs", ce)
  ], Re = jn(Oe), xe = yS, Pe = O9, Ke = jn([
    xo("title"),
    $c("body", Qt("type", {
      panel: te,
      tabpanel: Re
    })),
    rl("size", "normal"),
    bl("buttons", [], Pe),
    lt("initialData", {}),
    ii("onAction", G),
    ii("onChange", G),
    ii("onSubmit", G),
    ii("onClose", G),
    ii("onCancel", G),
    ii("onTabChange", G)
  ]), et = (t) => Ws("dialog", Ke, t), rt = jn([
    ka("type", [
      "cancel",
      "custom"
    ]),
    ...xe
  ]), dt = jn([
    xo("title"),
    xo("url"),
    cm("height"),
    cm("width"),
    lm("buttons", rt),
    ii("onAction", G),
    ii("onCancel", G),
    ii("onClose", G),
    ii("onMessage", G)
  ]), Ht = (t) => Ws("dialog", dt, t), ln = (t) => C(t) ? [t].concat(ke(fl(t), ln)) : R(t) ? ke(t, ln) : [], Dn = (t) => g(t.type) && g(t.name), Rt = {
    checkbox: fre,
    colorinput: CL,
    colorpicker: gre,
    dropzone: Sre,
    input: Ere,
    iframe: Uf,
    imagepreview: I9,
    selectbox: _re,
    sizeinput: Are,
    slider: wle,
    listbox: F9,
    size: Are,
    textarea: $re,
    urlinput: N,
    customeditor: yre,
    collection: pre,
    togglemenuitem: wL
  }, Tt = (t) => z.from(Rt[t.type]), Kt = (t) => Rn(ln(t), Dn), Mn = (t) => {
    const a = Kt(t), u = ke(a, (p) => Tt(p).fold(() => [], (y) => [$c(p.name, y)]));
    return jn(u);
  }, rr = (t) => {
    var a;
    const u = Mo(et(t)), p = Mn(t), y = (a = t.initialData) !== null && a !== void 0 ? a : {};
    return {
      internalDialog: u,
      dataValidator: p,
      initialData: y
    };
  }, Fr = {
    open: (t, a) => {
      const u = rr(a);
      return t(u.internalDialog, u.initialData, u.dataValidator);
    },
    openUrl: (t, a) => {
      const u = Mo(Ht(a));
      return t(u);
    },
    redial: (t) => rr(t)
  };
  var Cs = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: (t, a) => {
      const u = (p, y) => {
        t.updateState.each((x) => {
          const k = x(p, y);
          a.set(k);
        }), t.renderComponents.each((x) => {
          const k = x(y, a.get());
          (t.reuseDom ? k5 : yd)(p, k);
        });
      };
      return ls([
        Pt(Zg(), (p, y) => {
          const x = y;
          if (!x.universal) {
            const k = t.channel;
            vt(x.channels, k) && u(p, x.data);
          }
        }),
        us((p, y) => {
          t.initialData.each((x) => {
            u(p, x);
          });
        })
      ]);
    }
  }), Si = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    getState: (t, a, u) => u
  }), Kl = [
    Mt("channel"),
    Fo("renderComponents"),
    Fo("updateState"),
    Fo("initialData"),
    vi("reuseDom", !0)
  ], wn = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: () => {
      const t = sr(z.none()), a = () => t.set(z.none());
      return {
        readState: () => t.get().getOr("none"),
        get: t.get,
        set: t.set,
        clear: a
      };
    }
  });
  const Ln = Zi({
    fields: Kl,
    name: "reflecting",
    active: Cs,
    apis: Si,
    state: wn
  }), Ho = (t) => {
    const a = [], u = {};
    return Eo(t, (p, y) => {
      p.fold(() => {
        a.push(y);
      }, (x) => {
        u[y] = x;
      });
    }), a.length > 0 ? Rr.error(a) : Rr.value(u);
  }, Ao = (t, a, u) => {
    const p = ms(_T.sketch((y) => ({
      dom: {
        tag: "div",
        classes: ["tox-form"].concat(t.classes)
      },
      components: He(t.items, (x) => yg(y, x, a, u))
    })));
    return {
      dom: {
        tag: "div",
        classes: ["tox-dialog__body"]
      },
      components: [{
        dom: {
          tag: "div",
          classes: ["tox-dialog__body-content"]
        },
        components: [p.asSpec()]
      }],
      behaviours: mn([
        ar.config({
          mode: "acyclic",
          useTabstopAt: Ie(AT)
        }),
        zf.memento(p),
        b7(p, {
          postprocess: (y) => Ho(y).fold((x) => (console.error(x), {}), Te)
        }),
        Hr("dialog-body-panel", [Pt(oa(), (y, x) => {
          y.getSystem().broadcastOn([NT], { newFocus: z.some(x.event.target) });
        })])
      ])
    };
  }, Qn = (t, a) => ({
    uid: t.uid,
    dom: t.dom,
    components: t.components,
    events: wv(t.action),
    behaviours: _i(t.tabButtonBehaviours, [
      Er.config({}),
      ar.config({
        mode: "execution",
        useSpace: !0,
        useEnter: !0
      }),
      Pn.config({
        store: {
          mode: "memory",
          initialValue: t.value
        }
      })
    ]),
    domModification: t.domModification
  }), Jn = Yd({
    name: "TabButton",
    configFields: [
      lt("uid", void 0),
      Mt("value"),
      si("dom", "dom", ye(() => ({
        attributes: {
          role: "tab",
          id: Hn("aria"),
          "aria-selected": "false"
        }
      })), Ua()),
      Fo("action"),
      lt("domModification", {}),
      ac("tabButtonBehaviours", [
        Er,
        ar,
        Pn
      ]),
      Mt("view")
    ],
    factory: Qn
  }), pn = q([
    Mt("tabs"),
    Mt("dom"),
    lt("clickToDismiss", !1),
    ac("tabbarBehaviours", [
      Wo,
      ar
    ]),
    eg([
      "tabClass",
      "selectedClass"
    ])
  ]), kr = lE({
    factory: Jn,
    name: "tabs",
    unit: "tab",
    overrides: (t) => {
      const a = (p, y) => {
        Wo.dehighlight(p, y), nr(p, U1(), {
          tabbar: p,
          button: y
        });
      }, u = (p, y) => {
        Wo.highlight(p, y), nr(p, rb(), {
          tabbar: p,
          button: y
        });
      };
      return {
        action: (p) => {
          const y = p.getSystem().getByUid(t.uid).getOrDie(), x = Wo.isHighlighted(y, p);
          (() => x && t.clickToDismiss ? a : x ? G : u)()(y, p);
        },
        domModification: { classes: [t.markers.tabClass] }
      };
    }
  }), To = q([kr]), Ns = (t, a, u, p) => ({
    uid: t.uid,
    dom: t.dom,
    components: a,
    "debug.sketcher": "Tabbar",
    domModification: { attributes: { role: "tablist" } },
    behaviours: _i(t.tabbarBehaviours, [
      Wo.config({
        highlightClass: t.markers.selectedClass,
        itemClass: t.markers.tabClass,
        onHighlight: (y, x) => {
          kn(x.element, "aria-selected", "true");
        },
        onDehighlight: (y, x) => {
          kn(x.element, "aria-selected", "false");
        }
      }),
      ar.config({
        mode: "flow",
        getInitial: (y) => Wo.getHighlighted(y).map((x) => x.element),
        selector: "." + t.markers.tabClass,
        executeOnMove: !0
      })
    ])
  }), Js = ql({
    name: "Tabbar",
    configFields: pn(),
    partFields: To(),
    factory: Ns
  }), Cd = (t, a) => ({
    uid: t.uid,
    dom: t.dom,
    behaviours: _i(t.tabviewBehaviours, [$r.config({})]),
    domModification: { attributes: { role: "tabpanel" } }
  }), xm = Yd({
    name: "Tabview",
    configFields: [ac("tabviewBehaviours", [$r])],
    factory: Cd
  }), ry = q([
    lt("selectFirst", !0),
    po("onChangeTab"),
    po("onDismissTab"),
    lt("tabs", []),
    ac("tabSectionBehaviours", [])
  ]), xd = jl({
    factory: Js,
    schema: [
      Mt("dom"),
      lu("markers", [
        Mt("tabClass"),
        Mt("selectedClass")
      ])
    ],
    name: "tabbar",
    defaults: (t) => ({ tabs: t.tabs })
  }), wg = jl({
    factory: xm,
    name: "tabview"
  }), Ir = q([
    xd,
    wg
  ]), _o = (t, a, u, p) => {
    const y = (k) => {
      const $ = Pn.getValue(k);
      Fs(k, t, "tabview").each((B) => {
        Ge(t.tabs, (Y) => Y.value === $).each((Y) => {
          const re = Y.view();
          as(k.element, "id").each((le) => {
            kn(B.element, "aria-labelledby", le);
          }), $r.set(B, re), t.onChangeTab(B, k, re);
        });
      });
    }, x = (k, $) => {
      Fs(k, t, "tabbar").each((B) => {
        $(B).each(Ef);
      });
    };
    return {
      uid: t.uid,
      dom: t.dom,
      components: a,
      behaviours: pv(t.tabSectionBehaviours),
      events: ls(St([
        t.selectFirst ? [us((k, $) => {
          x(k, Wo.getFirst);
        })] : [],
        [
          Pt(rb(), (k, $) => {
            const B = $.event.button;
            y(B);
          }),
          Pt(U1(), (k, $) => {
            const B = $.event.button;
            t.onDismissTab(k, B);
          })
        ]
      ])),
      apis: {
        getViewItems: (k) => Fs(k, t, "tabview").map(($) => $r.contents($)).getOr([]),
        showTab: (k, $) => {
          x(k, (j) => {
            const Y = Wo.getCandidates(j);
            return Ge(Y, (le) => Pn.getValue(le) === $).filter((le) => !Wo.isHighlighted(j, le));
          });
        }
      }
    };
  }, Jo = ql({
    name: "TabSection",
    configFields: ry(),
    partFields: Ir(),
    factory: _o,
    apis: {
      getViewItems: (t, a) => t.getViewItems(a),
      showTab: (t, a, u) => {
        t.showTab(a, u);
      }
    }
  }), Ba = (t, a, u) => He(t, (p, y) => {
    $r.set(u, t[y].view());
    const x = a.dom.getBoundingClientRect();
    return $r.set(u, []), x.height;
  }), Za = (t) => $n(nn(t, (a, u) => a > u ? -1 : a < u ? 1 : 0)), Eh = (t, a, u) => {
    const p = Pl(t).dom, y = zu(t, ".tox-dialog-wrap").getOr(t), x = na(y, "position") === "fixed";
    let k;
    x ? k = Math.max(p.clientHeight, window.innerHeight) : k = Math.max(p.offsetHeight, p.scrollHeight);
    const $ = Ds(a), j = a.dom.offsetLeft >= u.dom.offsetLeft + Oa(u) ? Math.max(Ds(u), $) : $, Y = parseInt(na(t, "margin-top"), 10) || 0, re = parseInt(na(t, "margin-bottom"), 10) || 0, pe = Ds(t) + Y + re - j;
    return k - pe;
  }, e2 = (t, a) => {
    $n(t).each((u) => Jo.showTab(a, u.value));
  }, t2 = (t, a) => {
    Sr(t, "height", a + "px"), Sr(t, "flex-basis", a + "px");
  }, oy = (t, a, u) => {
    zu(t, '[role="dialog"]').each((p) => {
      qa(p, '[role="tablist"]').each((y) => {
        u.get().map((x) => (Sr(a, "height", "0"), Sr(a, "flex-basis", "0"), Math.min(x, Eh(p, a, y)))).each((x) => {
          t2(a, x);
        });
      });
    });
  }, sy = (t) => qa(t, '[role="tabpanel"]'), wS = (t) => {
    const a = Gr();
    return {
      extraEvents: [
        us((y) => {
          const x = y.element;
          sy(x).each((k) => {
            Sr(k, "visibility", "hidden"), y.getSystem().getByDom(k).toOptional().each(($) => {
              const B = Ba(t, k, $);
              Za(B).fold(a.clear, a.set);
            }), oy(x, k, a), Ur(k, "visibility"), e2(t, y), requestAnimationFrame(() => {
              oy(x, k, a);
            });
          });
        }),
        Pt(dm(), (y) => {
          const x = y.element;
          sy(x).each((k) => {
            oy(x, k, a);
          });
        }),
        Pt(DH, (y, x) => {
          const k = y.element;
          sy(k).each(($) => {
            const B = Xm(wt($));
            Sr($, "visibility", "hidden");
            const j = Ta($, "height").map((le) => parseInt(le, 10));
            Ur($, "height"), Ur($, "flex-basis");
            const Y = $.dom.getBoundingClientRect().height;
            j.forall((le) => Y > le) ? (a.set(Y), oy(k, $, a)) : j.each((le) => {
              t2($, le);
            }), Ur($, "visibility"), B.each(Fa);
          });
        })
      ],
      selectFirst: !1
    };
  }, n2 = "send-data-to-section", TA = "send-data-to-view", CD = (t, a, u) => {
    const p = sr({}), y = (j) => {
      const Y = Pn.getValue(j), re = Ho(Y).getOr({}), le = p.get(), pe = Vo(le, re);
      p.set(pe);
    }, x = (j) => {
      const Y = p.get();
      Pn.setValue(j, Y);
    }, k = sr(null), $ = He(t.tabs, (j) => ({
      value: j.name,
      dom: {
        tag: "div",
        classes: ["tox-dialog__body-nav-item"]
      },
      components: [Ma(u.shared.providers.translate(j.title))],
      view: () => [_T.sketch((Y) => ({
        dom: {
          tag: "div",
          classes: ["tox-form"]
        },
        components: He(j.items, (re) => yg(Y, re, a, u)),
        formBehaviours: mn([
          ar.config({
            mode: "acyclic",
            useTabstopAt: Ie(AT)
          }),
          Hr("TabView.form.events", [
            us(x),
            Tf(y)
          ]),
          vu.config({
            channels: Xn([
              {
                key: n2,
                value: { onReceive: y }
              },
              {
                key: TA,
                value: { onReceive: x }
              }
            ])
          })
        ])
      }))]
    })), B = wS($);
    return Jo.sketch({
      dom: {
        tag: "div",
        classes: ["tox-dialog__body"]
      },
      onChangeTab: (j, Y, re) => {
        const le = Pn.getValue(Y);
        nr(j, PH, {
          name: le,
          oldName: k.get()
        }), k.set(le);
      },
      tabs: $,
      components: [
        Jo.parts.tabbar({
          dom: {
            tag: "div",
            classes: ["tox-dialog__body-nav"]
          },
          components: [Js.parts.tabs({})],
          markers: {
            tabClass: "tox-tab",
            selectedClass: "tox-dialog__body-nav-item--active"
          },
          tabbarBehaviours: mn([Ea.config({})])
        }),
        Jo.parts.tabview({
          dom: {
            tag: "div",
            classes: ["tox-dialog__body-content"]
          }
        })
      ],
      selectFirst: B.selectFirst,
      tabSectionBehaviours: mn([
        Hr("tabpanel", B.extraEvents),
        ar.config({ mode: "acyclic" }),
        ho.config({ find: (j) => $n(Jo.getViewItems(j)) }),
        iS(z.none(), (j) => (j.getSystem().broadcastOn([n2], {}), p.get()), (j, Y) => {
          p.set(Y), j.getSystem().broadcastOn([TA], {});
        })
      ])
    });
  }, KE = (t, a, u, p, y) => {
    const x = (B) => {
      const j = B.body;
      switch (j.type) {
        case "tabpanel":
          return [CD(j, B.initialData, p)];
        default:
          return [Ao(j, B.initialData, p)];
      }
    }, k = (B, j) => z.some({ isTabPanel: () => j.body.type === "tabpanel" }), $ = { "aria-live": "polite" };
    return {
      dom: {
        tag: "div",
        classes: ["tox-dialog__content-js"],
        attributes: {
          ...u.map((B) => ({ id: B })).getOr({}),
          ...y ? $ : {}
        }
      },
      components: [],
      behaviours: mn([
        zf.childAt(0),
        Ln.config({
          channel: `${sP}-${a}`,
          updateState: k,
          renderComponents: x,
          initialData: t
        })
      ])
    };
  }, xD = (t, a, u, p, y) => KE(t, a, z.some(u), p, y), ES = (t, a, u) => {
    const p = KE(t, a, z.none(), u, !1);
    return ic.parts.body(p);
  }, r2 = (t) => {
    const a = {
      dom: {
        tag: "div",
        classes: ["tox-dialog__content-js"]
      },
      components: [{
        dom: {
          tag: "div",
          classes: ["tox-dialog__body-iframe"]
        },
        components: [T7(z.none(), {
          dom: {
            tag: "iframe",
            attributes: { src: t.url }
          },
          behaviours: mn([
            Ea.config({}),
            Er.config({})
          ])
        })]
      }],
      behaviours: mn([ar.config({
        mode: "acyclic",
        useTabstopAt: Ie(AT)
      })])
    };
    return ic.parts.body(a);
  }, Eg = dT.deviceType.isTouch(), ay = (t, a) => ({
    dom: {
      tag: "div",
      styles: { display: "none" },
      classes: ["tox-dialog__header"]
    },
    components: [
      t,
      a
    ]
  }), o2 = (t, a) => ic.parts.close(cl.sketch({
    dom: {
      tag: "button",
      classes: [
        "tox-button",
        "tox-button--icon",
        "tox-button--naked"
      ],
      attributes: {
        type: "button",
        "aria-label": a.translate("Close")
      }
    },
    action: t,
    buttonBehaviours: mn([Ea.config({})])
  })), s2 = () => ic.parts.title({
    dom: {
      tag: "div",
      classes: ["tox-dialog__title"],
      innerHtml: "",
      styles: { display: "none" }
    }
  }), _A = (t, a) => ic.parts.body({
    dom: {
      tag: "div",
      classes: ["tox-dialog__body"]
    },
    components: [{
      dom: {
        tag: "div",
        classes: ["tox-dialog__body-content"]
      },
      components: [{ dom: o1(`<p>${g6(a.translate(t))}</p>`) }]
    }]
  }), YE = (t) => ic.parts.footer({
    dom: {
      tag: "div",
      classes: ["tox-dialog__footer"]
    },
    components: t
  }), _L = (t, a) => [
    Tv.sketch({
      dom: {
        tag: "div",
        classes: ["tox-dialog__footer-start"]
      },
      components: t
    }),
    Tv.sketch({
      dom: {
        tag: "div",
        classes: ["tox-dialog__footer-end"]
      },
      components: a
    })
  ], TD = (t) => {
    const a = "tox-dialog", u = a + "-wrap", p = u + "__backdrop", y = a + "__disable-scroll";
    return ic.sketch({
      lazySink: t.lazySink,
      onEscape: (x) => (t.onEscape(x), z.some(!0)),
      useTabstopAt: (x) => !AT(x),
      firstTabstop: t.firstTabstop,
      dom: {
        tag: "div",
        classes: [a].concat(t.extraClasses),
        styles: {
          position: "relative",
          ...t.extraStyles
        }
      },
      components: [
        t.header,
        t.body,
        ...t.footer.toArray()
      ],
      parts: {
        blocker: {
          dom: o1(`<div class="${u}"></div>`),
          components: [{
            dom: {
              tag: "div",
              classes: Eg ? [
                p,
                p + "--opaque"
              ] : [p]
            }
          }]
        }
      },
      dragBlockClass: u,
      modalBehaviours: mn([
        Er.config({}),
        Hr("dialog-events", t.dialogEvents.concat([
          xf(oa(), (x, k) => {
            Nv.isBlocked(x) ? G() : ar.focusIn(x);
          }),
          Pt(V1(), (x, k) => {
            x.getSystem().broadcastOn([NT], { newFocus: k.event.newFocus });
          })
        ])),
        Hr("scroll-lock", [
          us(() => {
            ja(ta(), y);
          }),
          Tf(() => {
            ua(ta(), y);
          })
        ]),
        ...t.extraBehaviours
      ]),
      eventOrder: {
        [Lu()]: ["dialog-events"],
        [Vl()]: [
          "scroll-lock",
          "dialog-events",
          "alloy.base.behaviour"
        ],
        [Vd()]: [
          "alloy.base.behaviour",
          "dialog-events",
          "scroll-lock"
        ],
        ...t.eventOrder
      }
    });
  }, Cu = (t) => cl.sketch({
    dom: {
      tag: "button",
      classes: [
        "tox-button",
        "tox-button--icon",
        "tox-button--naked"
      ],
      attributes: {
        type: "button",
        "aria-label": t.translate("Close"),
        title: t.translate("Close")
      }
    },
    buttonBehaviours: mn([Ea.config({})]),
    components: [mg("close", {
      tag: "span",
      classes: ["tox-icon"]
    }, t.icons)],
    action: (a) => {
      Jr(a, oS);
    }
  }), CS = (t, a, u, p) => {
    const y = (x) => [Ma(p.translate(x.title))];
    return {
      dom: {
        tag: "div",
        classes: ["tox-dialog__title"],
        attributes: { ...u.map((x) => ({ id: x })).getOr({}) }
      },
      components: [],
      behaviours: mn([Ln.config({
        channel: `${ty}-${a}`,
        initialData: t,
        renderComponents: y
      })])
    };
  }, v1 = () => ({ dom: o1('<div class="tox-dialog__draghandle"></div>') }), OA = (t, a, u, p) => Tv.sketch({
    dom: o1('<div class="tox-dialog__header"></div>'),
    components: [
      CS(t, a, z.some(u), p),
      v1(),
      Cu(p)
    ],
    containerBehaviours: mn([jE.config({
      mode: "mouse",
      blockerClass: "blocker",
      getTarget: (y) => fm(y, '[role="dialog"]').getOrDie(),
      snaps: {
        getSnapPoints: () => [],
        leftAttr: "data-drag-left",
        topAttr: "data-drag-top"
      }
    })])
  }), gt = (t, a, u) => {
    const p = ic.parts.title(CS(t, a, z.none(), u)), y = ic.parts.draghandle(v1()), x = ic.parts.close(Cu(u)), k = [p].concat(t.draggable ? [y] : []).concat([x]);
    return Tv.sketch({
      dom: o1('<div class="tox-dialog__header"></div>'),
      components: k
    });
  }, Et = (t, a, u) => gt({
    title: u.shared.providers.translate(t),
    draggable: u.dialog.isDraggableModal()
  }, a, u.shared.providers), yn = (t, a, u, p) => ({
    dom: {
      tag: "div",
      classes: ["tox-dialog__busy-spinner"],
      attributes: { "aria-label": u.translate(t) },
      styles: {
        left: "0px",
        right: "0px",
        bottom: "0px",
        top: `${p.getOr(0)}px`,
        position: "absolute"
      }
    },
    behaviours: a,
    components: [{ dom: o1('<div class="tox-spinner"><div></div><div></div><div></div></div>') }]
  }), un = (t, a, u) => ({
    onClose: () => u.closeWindow(),
    onBlock: (p) => {
      const y = qa(t().element, ".tox-dialog__header").map((x) => Ds(x));
      ic.setBusy(t(), (x, k) => yn(p.message, k, a, y));
    },
    onUnblock: () => {
      ic.setIdle(t());
    }
  }), cr = "tox-dialog--fullscreen", So = "tox-dialog--width-lg", Ha = "tox-dialog--width-md", cc = (t) => {
    switch (t) {
      case "large":
        return z.some(So);
      case "medium":
        return z.some(Ha);
      default:
        return z.none();
    }
  }, Oc = (t, a) => {
    const u = nt.fromDom(a.element.dom);
    Ti(u, cr) || (dd(u, [
      So,
      Ha
    ]), cc(t).each((p) => ja(u, p)));
  }, a2 = (t, a) => {
    const u = nt.fromDom(t.element.dom), p = Sb(u), y = Ge(p, (x) => x === So || x === Ha).or(cc(a));
    hw(u, [
      cr,
      ...y.toArray()
    ]);
  }, i2 = (t, a, u) => sl(TD({
    ...t,
    firstTabstop: 1,
    lazySink: u.shared.getSink,
    extraBehaviours: [
      rP({}),
      ...t.extraBehaviours
    ],
    onEscape: (p) => {
      Jr(p, oS);
    },
    dialogEvents: a,
    eventOrder: {
      [Zg()]: [
        Ln.name(),
        vu.name()
      ],
      [Vl()]: [
        "scroll-lock",
        Ln.name(),
        "messages",
        "dialog-events",
        "alloy.base.behaviour"
      ],
      [Vd()]: [
        "alloy.base.behaviour",
        "dialog-events",
        "messages",
        Ln.name(),
        "scroll-lock"
      ]
    }
  })), _D = (t, a = {}) => {
    const u = (p) => {
      const y = He(p.items, (x) => {
        const k = fn(a, x.name).getOr(sr(!1));
        return {
          ...x,
          storage: k
        };
      });
      return {
        ...p,
        items: y
      };
    };
    return He(t, (p) => p.type === "menu" ? u(p) : p);
  }, OL = (t) => Jt(t, (a, u) => u.type === "menu" ? Jt(u.items, (y, x) => (y[x.name] = x.storage, y), a) : a, {}), iy = (t, a) => [
    aw(oa(), wQ),
    t(wT, (u, p, y, x) => {
      Xm(wt(x.element)).fold(G, gm), a.onClose(), p.onClose();
    }),
    t(oS, (u, p, y, x) => {
      p.onCancel(u), Jr(x, wT);
    }),
    Pt(YF, (u, p) => a.onUnblock()),
    Pt(KF, (u, p) => a.onBlock(p.event))
  ], L9 = (t, a) => {
    const u = (y, x) => Pt(y, (k, $) => {
      p(k, (B, j) => {
        x(t(), B, $.event, k);
      });
    }), p = (y, x) => {
      Ln.getState(y).get().each((k) => {
        x(k, y);
      });
    };
    return [
      ...iy(u, a),
      u(Xb, (y, x, k) => {
        x.onAction(y, { name: k.name });
      })
    ];
  }, AL = (t, a, u) => {
    const p = (x, k) => Pt(x, ($, B) => {
      y($, (j, Y) => {
        k(t(), j, B.event, $);
      });
    }), y = (x, k) => {
      Ln.getState(x).get().each(($) => {
        k($.internalDialog, x);
      });
    };
    return [
      ...iy(p, a),
      p(FO, (x, k) => k.onSubmit(x)),
      p(Bf, (x, k, $) => {
        k.onChange(x, { name: $.name });
      }),
      p(Xb, (x, k, $, B) => {
        const j = () => B.getSystem().isConnected() ? ar.focusIn(B) : void 0, Y = (pe) => _p(pe, "disabled") || as(pe, "aria-disabled").exists((_e) => _e === "true"), re = wt(B.element), le = Xm(re);
        k.onAction(x, {
          name: $.name,
          value: $.value
        }), Xm(re).fold(j, (pe) => {
          Y(pe) || le.exists((_e) => za(pe, _e) && Y(_e)) ? j() : u().toOptional().filter((_e) => !za(_e.element, pe)).each(j);
        });
      }),
      p(PH, (x, k, $) => {
        k.onTabChange(x, {
          newTabName: $.name,
          oldTabName: $.oldName
        });
      }),
      Tf((x) => {
        const k = t();
        Pn.setValue(x, k.getData());
      })
    ];
  }, B9 = (t, a) => vP(t, t.type, a), H9 = (t, a, u) => Ge(a, (p) => p.name === u).bind((p) => p.memento.getOpt(t)), Mre = (t, a) => {
    const u = a.map(($) => $.footerButtons).getOr([]), p = qn(u, ($) => $.align === "start"), y = ($, B) => Tv.sketch({
      dom: {
        tag: "div",
        classes: [`tox-dialog__footer-${$}`]
      },
      components: He(B, (j) => j.memento.asSpec())
    }), x = y("start", p.pass), k = y("end", p.fail);
    return [
      x,
      k
    ];
  }, ao = (t, a, u) => {
    const p = (y, x) => {
      const k = He(x.buttons, (B) => {
        const j = ms(B9(B, u));
        return {
          name: B.name,
          align: B.align,
          memento: j
        };
      }), $ = (B) => H9(y, k, B);
      return z.some({
        lookupByName: $,
        footerButtons: k
      });
    };
    return {
      dom: o1('<div class="tox-dialog__footer"></div>'),
      components: [],
      behaviours: mn([Ln.config({
        channel: `${_3}-${a}`,
        initialData: t,
        updateState: p,
        renderComponents: Mre
      })])
    };
  }, _t = (t, a, u) => ao(t, a, u), tr = (t, a, u) => ic.parts.footer(ao(t, a, u)), Kr = (t, a) => {
    if (t.getRoot().getSystem().isConnected()) {
      const p = ho.getCurrent(t.getFormWrapper()).getOr(t.getFormWrapper());
      return _T.getField(p, a).orThunk(() => t.getFooter().bind((k) => Ln.getState(k).get()).bind((k) => k.lookupByName(a)));
    } else
      return z.none();
  }, lc = (t, a) => {
    const u = t.getRoot();
    return Ln.getState(u).get().map((p) => Mo(Ws("data", p.dataValidator, a))).getOr(a);
  }, Jd = (t, a, u) => {
    const p = (_e) => {
      const ze = t.getRoot();
      ze.getSystem().isConnected() && _e(ze);
    }, pe = {
      getData: () => {
        const _e = t.getRoot(), ze = _e.getSystem().isConnected() ? t.getFormWrapper() : _e, ft = Pn.getValue(ze), Xe = uo(u, (Ze) => Ze.get());
        return {
          ...ft,
          ...Xe
        };
      },
      setData: (_e) => {
        p((ze) => {
          const ft = pe.getData(), Xe = Vo(ft, _e), Ze = lc(t, Xe), mt = t.getFormWrapper();
          Pn.setValue(mt, Ze), Eo(u, (jt, Dt) => {
            Yr(Xe, Dt) && jt.set(Xe[Dt]);
          });
        });
      },
      setEnabled: (_e, ze) => {
        Kr(t, _e).each(ze ? yr.enable : yr.disable);
      },
      focus: (_e) => {
        Kr(t, _e).each(Er.focus);
      },
      block: (_e) => {
        if (!g(_e))
          throw new Error("The dialogInstanceAPI.block function should be passed a blocking message of type string as an argument");
        p((ze) => {
          nr(ze, KF, { message: _e });
        });
      },
      unblock: () => {
        p((_e) => {
          Jr(_e, YF);
        });
      },
      showTab: (_e) => {
        p((ze) => {
          const ft = t.getBody();
          Ln.getState(ft).get().exists((Ze) => Ze.isTabPanel()) && ho.getCurrent(ft).each((Ze) => {
            Jo.showTab(Ze, _e);
          });
        });
      },
      redial: (_e) => {
        p((ze) => {
          const ft = t.getId(), Xe = a(_e), Ze = _D(Xe.internalDialog.buttons, u);
          ze.getSystem().broadcastOn([`${kT}-${ft}`], Xe), ze.getSystem().broadcastOn([`${ty}-${ft}`], Xe.internalDialog), ze.getSystem().broadcastOn([`${sP}-${ft}`], Xe.internalDialog), ze.getSystem().broadcastOn([`${_3}-${ft}`], {
            ...Xe.internalDialog,
            buttons: Ze
          }), pe.setData(Xe.initialData);
        });
      },
      close: () => {
        p((_e) => {
          Jr(_e, wT);
        });
      },
      toggleFullscreen: t.toggleFullscreen
    };
    return pe;
  }, Td = (t, a, u) => {
    const p = Hn("dialog"), y = t.internalDialog, x = Et(y.title, p, u), k = sr(y.size), $ = cc(k.get()).toArray(), B = (Ze, mt) => (k.set(mt.internalDialog.size), Oc(mt.internalDialog.size, Ze), z.some(mt)), j = ES({
      body: y.body,
      initialData: y.initialData
    }, p, u), Y = _D(y.buttons), re = OL(Y), le = lr(Y.length !== 0, tr({ buttons: Y }, p, u)), pe = AL(() => Xe, un(() => ze, u.shared.providers, a), u.shared.getSink), _e = {
      id: p,
      header: x,
      body: j,
      footer: le,
      extraClasses: $,
      extraBehaviours: [Ln.config({
        channel: `${kT}-${p}`,
        updateState: B,
        initialData: t
      })],
      extraStyles: {}
    }, ze = i2(_e, pe, u), ft = (() => {
      const Ze = () => {
        const jt = ic.getBody(ze);
        return ho.getCurrent(jt).getOr(jt);
      }, mt = () => {
        a2(ze, k.get());
      };
      return {
        getId: q(p),
        getRoot: q(ze),
        getBody: () => ic.getBody(ze),
        getFooter: () => ic.getFooter(ze),
        getFormWrapper: Ze,
        toggleFullscreen: mt
      };
    })(), Xe = Jd(ft, a.redial, re);
    return {
      dialog: ze,
      instanceApi: Xe
    };
  }, Tm = (t, a, u, p = !1, y) => {
    const x = Hn("dialog"), k = Hn("dialog-label"), $ = Hn("dialog-content"), B = t.internalDialog, j = sr(B.size), Y = cc(j.get()).toArray(), re = (Nt, hn) => (j.set(hn.internalDialog.size), Oc(hn.internalDialog.size, Nt), y(), z.some(hn)), le = ms(OA({
      title: B.title,
      draggable: !0
    }, x, k, u.shared.providers)), pe = ms(xD({
      body: B.body,
      initialData: B.initialData
    }, x, $, u, p)), _e = _D(B.buttons), ze = OL(_e), ft = lr(_e.length !== 0, ms(_t({ buttons: _e }, x, u))), Xe = AL(() => Dt, {
      onBlock: (Nt) => {
        Nv.block(mt, (hn, En) => {
          const zr = le.getOpt(mt).map((Yn) => Ds(Yn.element));
          return yn(Nt.message, En, u.shared.providers, zr);
        });
      },
      onUnblock: () => {
        Nv.unblock(mt);
      },
      onClose: () => a.closeWindow()
    }, u.shared.getSink), mt = sl({
      dom: {
        tag: "div",
        classes: [
          "tox-dialog",
          "tox-dialog-inline",
          ...Y
        ],
        attributes: {
          role: "dialog",
          "aria-labelledby": k
        }
      },
      eventOrder: {
        [Zg()]: [
          Ln.name(),
          vu.name()
        ],
        [Lu()]: ["execute-on-form"],
        [Vl()]: [
          "reflecting",
          "execute-on-form"
        ]
      },
      behaviours: mn([
        ar.config({
          mode: "cyclic",
          onEscape: (Nt) => (Jr(Nt, wT), z.some(!0)),
          useTabstopAt: (Nt) => !AT(Nt) && (kc(Nt) !== "button" || ca(Nt, "disabled") !== "disabled"),
          firstTabstop: 1
        }),
        Ln.config({
          channel: `${kT}-${x}`,
          updateState: re,
          initialData: t
        }),
        Er.config({}),
        Hr("execute-on-form", Xe.concat([
          xf(oa(), (Nt, hn) => {
            ar.focusIn(Nt);
          }),
          Pt(V1(), (Nt, hn) => {
            Nt.getSystem().broadcastOn([NT], { newFocus: hn.event.newFocus });
          })
        ])),
        Nv.config({ getRoot: () => z.some(mt) }),
        $r.config({}),
        rP({})
      ]),
      components: [
        le.asSpec(),
        pe.asSpec(),
        ...ft.map((Nt) => Nt.asSpec()).toArray()
      ]
    }), jt = () => {
      a2(mt, j.get());
    }, Dt = Jd({
      getId: q(x),
      getRoot: q(mt),
      getFooter: () => ft.map((Nt) => Nt.get(mt)),
      getBody: () => pe.get(mt),
      getFormWrapper: () => {
        const Nt = pe.get(mt);
        return ho.getCurrent(Nt).getOr(Nt);
      },
      toggleFullscreen: jt
    }, a.redial, ze);
    return {
      dialog: mt,
      instanceApi: Dt
    };
  };
  var Cg = tinymce.util.Tools.resolve("tinymce.util.URI");
  const AA = (t) => {
    const a = (k) => {
      t.getSystem().isConnected() && k(t);
    };
    return {
      block: (k) => {
        if (!g(k))
          throw new Error("The urlDialogInstanceAPI.block function should be passed a blocking message of type string as an argument");
        a(($) => {
          nr($, KF, { message: k });
        });
      },
      unblock: () => {
        a((k) => {
          Jr(k, YF);
        });
      },
      close: () => {
        a((k) => {
          Jr(k, wT);
        });
      },
      sendMessage: (k) => {
        a(($) => {
          $.getSystem().broadcastOn([O3], k);
        });
      }
    };
  }, ef = [
    "insertContent",
    "setContent",
    "execCommand",
    "close",
    "block",
    "unblock"
  ], z9 = (t) => C(t) && ef.indexOf(t.mceAction) !== -1, V9 = (t) => !z9(t) && C(t) && Yr(t, "mceAction"), U9 = (t, a, u) => {
    switch (u.mceAction) {
      case "insertContent":
        t.insertContent(u.content);
        break;
      case "setContent":
        t.setContent(u.content);
        break;
      case "execCommand":
        const p = L(u.ui) ? u.ui : !1;
        t.execCommand(u.cmd, p, u.value);
        break;
      case "close":
        a.close();
        break;
      case "block":
        a.block(u.message);
        break;
      case "unblock":
        a.unblock();
        break;
    }
  }, t0e = (t, a, u, p) => {
    const y = Hn("dialog"), x = Et(t.title, y, p), k = r2(t), $ = t.buttons.bind((mt) => mt.length === 0 ? z.none() : z.some(tr({ buttons: mt }, y, p))), B = L9(() => Ze, un(() => Xe, p.shared.providers, a)), j = {
      ...t.height.fold(() => ({}), (mt) => ({
        height: mt + "px",
        "max-height": mt + "px"
      })),
      ...t.width.fold(() => ({}), (mt) => ({
        width: mt + "px",
        "max-width": mt + "px"
      }))
    }, Y = t.width.isNone() && t.height.isNone() ? ["tox-dialog--width-lg"] : [], re = new Cg(t.url, { base_uri: new Cg(window.location.href) }), le = `${re.protocol}://${re.host}${re.port ? ":" + re.port : ""}`, pe = sh(), _e = (mt, jt) => z.some(jt), ze = [
      Ln.config({
        channel: `${kT}-${y}`,
        updateState: _e,
        initialData: t
      }),
      Hr("messages", [
        us(() => {
          const mt = Cl(nt.fromDom(window), "message", (jt) => {
            if (re.isSameOrigin(new Cg(jt.raw.origin))) {
              const Dt = jt.raw.data;
              z9(Dt) ? U9(u, Ze, Dt) : V9(Dt) && t.onMessage(Ze, Dt);
            }
          });
          pe.set(mt);
        }),
        Tf(pe.clear)
      ]),
      vu.config({
        channels: {
          [O3]: {
            onReceive: (mt, jt) => {
              qa(mt.element, "iframe").each((Dt) => {
                const Nt = Dt.dom.contentWindow;
                se(Nt) && Nt.postMessage(jt, le);
              });
            }
          }
        }
      })
    ], Xe = i2({
      id: y,
      header: x,
      body: k,
      footer: $,
      extraClasses: Y,
      extraBehaviours: ze,
      extraStyles: j
    }, B, p), Ze = AA(Xe);
    return {
      dialog: Xe,
      instanceApi: Ze
    };
  }, n0e = (t) => {
    const a = t.shared;
    return { open: (p, y) => {
      const x = () => {
        ic.hide(j), y();
      }, k = ms(vP({
        name: "close-alert",
        text: "OK",
        primary: !0,
        buttonType: z.some("primary"),
        align: "end",
        enabled: !0,
        icon: z.none()
      }, "cancel", t)), $ = s2(), B = o2(x, a.providers), j = sl(TD({
        lazySink: () => a.getSink(),
        header: ay($, B),
        body: _A(p, a.providers),
        footer: z.some(YE(_L([], [k.asSpec()]))),
        onEscape: x,
        extraClasses: ["tox-alert-dialog"],
        extraBehaviours: [],
        extraStyles: {},
        dialogEvents: [Pt(oS, x)],
        eventOrder: {}
      }));
      ic.show(j);
      const Y = k.get(j);
      Er.focus(Y);
    } };
  }, r0e = (t) => {
    const a = t.shared;
    return { open: (p, y) => {
      const x = (le) => {
        ic.hide(Y), y(le);
      }, k = ms(vP({
        name: "yes",
        text: "Yes",
        primary: !0,
        buttonType: z.some("primary"),
        align: "end",
        enabled: !0,
        icon: z.none()
      }, "submit", t)), $ = vP({
        name: "no",
        text: "No",
        primary: !1,
        buttonType: z.some("secondary"),
        align: "end",
        enabled: !0,
        icon: z.none()
      }, "cancel", t), B = s2(), j = o2(() => x(!1), a.providers), Y = sl(TD({
        lazySink: () => a.getSink(),
        header: ay(B, j),
        body: _A(p, a.providers),
        footer: z.some(YE(_L([], [
          $,
          k.asSpec()
        ]))),
        onEscape: () => x(!1),
        extraClasses: ["tox-confirm-dialog"],
        extraBehaviours: [],
        extraStyles: {},
        dialogEvents: [
          Pt(oS, () => x(!1)),
          Pt(FO, () => x(!0))
        ],
        eventOrder: {}
      }));
      ic.show(Y);
      const re = k.get(Y);
      Er.focus(re);
    } };
  }, Cle = (t, a) => Mo(Ws("data", a, t)), xle = (t) => DO(t, ".tox-alert-dialog") || DO(t, ".tox-confirm-dialog"), o0e = (t, a, u) => a && u ? [] : [Oi.config({
    contextual: {
      lazyContext: () => z.some(Ss(nt.fromDom(t.getContentAreaContainer()))),
      fadeInClass: "tox-dialog-dock-fadein",
      fadeOutClass: "tox-dialog-dock-fadeout",
      transitionClass: "tox-dialog-dock-transition"
    },
    modes: ["top"],
    lazyViewport: (p) => rS(t, p.element).map((x) => ({
      bounds: ST(x),
      optScrollEnv: z.some({
        currentScrollTop: x.element.dom.scrollTop,
        scrollElmTop: Jc(x.element).top
      })
    })).getOrThunk(() => ({
      bounds: Ci(),
      optScrollEnv: z.none()
    }))
  })], s0e = (t) => {
    const a = t.editor, u = vO(a), p = n0e(t.backstages.dialog), y = r0e(t.backstages.dialog), x = (_e, ze, ft) => {
      if (!Z(ze)) {
        if (ze.inline === "toolbar")
          return j(_e, t.backstages.popup.shared.anchors.inlineDialog(), ft, ze);
        if (ze.inline === "bottom")
          return Y(_e, t.backstages.popup.shared.anchors.inlineBottomDialog(), ft, ze);
        if (ze.inline === "cursor")
          return j(_e, t.backstages.popup.shared.anchors.cursor(), ft, ze);
      }
      return B(_e, ft);
    }, k = (_e, ze) => $(_e, ze), $ = (_e, ze) => {
      const ft = (Xe) => {
        const Ze = t0e(Xe, {
          closeWindow: () => {
            ic.hide(Ze.dialog), ze(Ze.instanceApi);
          }
        }, a, t.backstages.dialog);
        return ic.show(Ze.dialog), Ze.instanceApi;
      };
      return Fr.openUrl(ft, _e);
    }, B = (_e, ze) => {
      const ft = (Xe, Ze, mt) => {
        const jt = Ze, Nt = Td({
          dataValidator: mt,
          initialData: jt,
          internalDialog: Xe
        }, {
          redial: Fr.redial,
          closeWindow: () => {
            ic.hide(Nt.dialog), ze(Nt.instanceApi);
          }
        }, t.backstages.dialog);
        return ic.show(Nt.dialog), Nt.instanceApi.setData(jt), Nt.instanceApi;
      };
      return Fr.open(ft, _e);
    }, j = (_e, ze, ft, Xe) => {
      const Ze = (mt, jt, Dt) => {
        const Nt = Cle(jt, Dt), hn = Gr(), En = t.backstages.popup.shared.header.isPositionedAtTop(), zr = {
          dataValidator: Dt,
          initialData: Nt,
          internalDialog: mt
        }, Yn = () => hn.on((dr) => {
          La.reposition(dr), (!u || !En) && Oi.refresh(dr);
        }), hr = Tm(zr, {
          redial: Fr.redial,
          closeWindow: () => {
            hn.on(La.hide), a.off("ResizeEditor", Yn), hn.clear(), ft(hr.instanceApi);
          }
        }, t.backstages.popup, Xe.ariaAttrs, Yn), Cr = sl(La.sketch({
          lazySink: t.backstages.popup.shared.getSink,
          dom: {
            tag: "div",
            classes: []
          },
          fireDismissalEventInstead: Xe.persistent ? { event: "doNotDismissYet" } : {},
          ...En ? {} : { fireRepositionEventInstead: {} },
          inlineBehaviours: mn([
            Hr("window-manager-inline-events", [Pt(jp(), (dr, ko) => {
              Jr(hr.dialog, oS);
            })]),
            ...o0e(a, u, En)
          ]),
          isExtraPart: (dr, ko) => xle(ko)
        }));
        hn.set(Cr);
        const ns = () => {
          const dr = a.inline ? ta() : nt.fromDom(a.getContainer()), ko = Ss(dr);
          return z.some(ko);
        };
        return La.showWithinBounds(Cr, Hu(hr.dialog), { anchor: ze }, ns), (!u || !En) && (Oi.refresh(Cr), a.on("ResizeEditor", Yn)), hr.instanceApi.setData(Nt), ar.focusIn(hr.dialog), hr.instanceApi;
      };
      return Fr.open(Ze, _e);
    }, Y = (_e, ze, ft, Xe) => {
      const Ze = (mt, jt, Dt) => {
        const Nt = Cle(jt, Dt), hn = Gr(), En = t.backstages.popup.shared.header.isPositionedAtTop(), zr = {
          dataValidator: Dt,
          initialData: Nt,
          internalDialog: mt
        }, Yn = () => hn.on((dr) => {
          La.reposition(dr), Oi.refresh(dr);
        }), hr = Tm(zr, {
          redial: Fr.redial,
          closeWindow: () => {
            hn.on(La.hide), a.off("ResizeEditor ScrollWindow ElementScroll", Yn), hn.clear(), ft(hr.instanceApi);
          }
        }, t.backstages.popup, Xe.ariaAttrs, Yn), Cr = sl(La.sketch({
          lazySink: t.backstages.popup.shared.getSink,
          dom: {
            tag: "div",
            classes: []
          },
          fireDismissalEventInstead: Xe.persistent ? { event: "doNotDismissYet" } : {},
          ...En ? {} : { fireRepositionEventInstead: {} },
          inlineBehaviours: mn([
            Hr("window-manager-inline-events", [Pt(jp(), (dr, ko) => {
              Jr(hr.dialog, oS);
            })]),
            Oi.config({
              contextual: {
                lazyContext: () => z.some(Ss(nt.fromDom(a.getContentAreaContainer()))),
                fadeInClass: "tox-dialog-dock-fadein",
                fadeOutClass: "tox-dialog-dock-fadeout",
                transitionClass: "tox-dialog-dock-transition"
              },
              modes: [
                "top",
                "bottom"
              ],
              lazyViewport: (dr) => rS(a, dr.element).map((Cn) => ({
                bounds: ST(Cn),
                optScrollEnv: z.some({
                  currentScrollTop: Cn.element.dom.scrollTop,
                  scrollElmTop: Jc(Cn.element).top
                })
              })).getOrThunk(() => ({
                bounds: Ci(),
                optScrollEnv: z.none()
              }))
            })
          ]),
          isExtraPart: (dr, ko) => xle(ko)
        }));
        hn.set(Cr);
        const ns = () => t.backstages.popup.shared.getSink().toOptional().bind((dr) => {
          const ko = rS(a, dr.element), Cn = 15, Zn = ko.map((vr) => ST(vr)).getOr(Ci()), Ar = Ss(nt.fromDom(a.getContentAreaContainer())), go = Hg(Ar, Zn);
          return z.some(cs(go.x, go.y, go.width, go.height - Cn));
        });
        return La.showWithinBounds(Cr, Hu(hr.dialog), { anchor: ze }, ns), Oi.refresh(Cr), a.on("ResizeEditor ScrollWindow ElementScroll ResizeWindow", Yn), hr.instanceApi.setData(Nt), ar.focusIn(hr.dialog), hr.instanceApi;
      };
      return Fr.open(Ze, _e);
    };
    return {
      open: x,
      openUrl: k,
      alert: (_e, ze) => {
        p.open(_e, ze);
      },
      close: (_e) => {
        _e.close();
      },
      confirm: (_e, ze) => {
        y.open(_e, ze);
      }
    };
  }, a0e = (t) => {
    w6(t), YZ(t), rne(t);
  };
  var i0e = () => {
    su.add("silver", (t) => {
      a0e(t);
      let a = () => Ci();
      const {
        dialogs: u,
        popups: p,
        renderUI: y
      } = tre(t, { getPopupSinkBounds: () => a() }), x = () => {
        const B = y();
        return rS(t, p.getMothership().element).each((Y) => {
          a = () => ST(Y);
        }), B;
      };
      HK.register(t, p.backstage.shared);
      const k = s0e({
        editor: t,
        backstages: {
          popup: p.backstage,
          dialog: u.backstage
        }
      }), $ = () => TM(t, { backstage: p.backstage }, p.getMothership());
      return {
        renderUI: x,
        getWindowManagerImpl: q(k),
        getNotificationManagerImpl: $
      };
    });
  };
  i0e();
})();
tinymce.IconManager.add("default", {
  icons: {
    "accessibility-check": '<svg width="24" height="24"><path d="M12 2a2 2 0 0 1 2 2 2 2 0 0 1-2 2 2 2 0 0 1-2-2c0-1.1.9-2 2-2Zm8 7h-5v12c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-5c0-.6-.4-1-1-1a1 1 0 0 0-1 1v5c0 .6-.4 1-1 1a1 1 0 0 1-1-1V9H4a1 1 0 1 1 0-2h16c.6 0 1 .4 1 1s-.4 1-1 1Z" fill-rule="nonzero"/></svg>',
    "accordion-toggle": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M12 15c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1h-6a1 1 0 0 1-1-1Z"/><path opacity=".2" fill-rule="evenodd" clip-rule="evenodd" d="M4 15c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1-1-1Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M12 19c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1h-6a1 1 0 0 1-1-1Z"/><path opacity=".2" fill-rule="evenodd" clip-rule="evenodd" d="M4 19c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1-1-1Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M12.3 7.3a1 1 0 0 1 1.4 0L16 9.6l2.3-2.3a1 1 0 1 1 1.4 1.4L16 12.4l-3.7-3.7a1 1 0 0 1 0-1.4ZM4.3 11.7a1 1 0 0 1 0-1.4L6.6 8 4.3 5.7a1 1 0 0 1 1.4-1.4L9.4 8l-3.7 3.7a1 1 0 0 1-1.4 0Z"/></svg>',
    accordion: '<svg width="24" height="24"><rect x="12" y="7" width="10" height="2" rx="1"/><rect x="12" y="11" width="10" height="2" rx="1"/><rect x="12" y="15" width="6" height="2" rx="1"/><path fill-rule="evenodd" clip-rule="evenodd" d="M2.3 7.3a1 1 0 0 1 1.4 0L6 9.6l2.3-2.3a1 1 0 0 1 1.4 1.4L6 12.4 2.3 8.7a1 1 0 0 1 0-1.4Z"/></svg>',
    "action-next": '<svg width="24" height="24"><path fill-rule="nonzero" d="M5.7 7.3a1 1 0 0 0-1.4 1.4l7.7 7.7 7.7-7.7a1 1 0 1 0-1.4-1.4L12 13.6 5.7 7.3Z"/></svg>',
    "action-prev": '<svg width="24" height="24"><path fill-rule="nonzero" d="M18.3 15.7a1 1 0 0 0 1.4-1.4L12 6.6l-7.7 7.7a1 1 0 0 0 1.4 1.4L12 9.4l6.3 6.3Z"/></svg>',
    addtag: '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M15 5a2 2 0 0 1 1.6.8L21 12l-4.4 6.2a2 2 0 0 1-1.6.8h-3v-2h3l3.5-5L15 7H5v3H3V7c0-1.1.9-2 2-2h10Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M6 12a1 1 0 0 0-1 1v2H3a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0v-2h2a1 1 0 1 0 0-2H7v-2c0-.6-.4-1-1-1Z"/></svg>',
    "ai-prompt": '<svg width="24" height="24"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M15 6.7a1 1 0 0 0-1.4 0l-9.9 10a1 1 0 0 0 0 1.3l2.1 2.1c.4.4 1 .4 1.4 0l10-9.9c.3-.3.3-1 0-1.4l-2.2-2Zm1.4 2.8-2-2-3 2.7 2.2 2.2 2.8-2.9Z"/><path d="m18.5 7.3-.7-1.5-1.5-.8 1.5-.7.7-1.5.7 1.5 1.5.7-1.5.8-.7 1.5ZM18.5 16.5l-.7-1.6-1.5-.7 1.5-.7.7-1.6.7 1.6 1.5.7-1.5.7-.7 1.6ZM9.7 7.3 9 5.8 7.5 5 9 4.3l.7-1.5.7 1.5L12 5l-1.5.8-.7 1.5Z"/></g><defs><clipPath id="a"><path d="M0 0h24v24H0z"/></clipPath></defs></svg>',
    ai: '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M5 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3V6a3 3 0 0 0-3-3H5Zm6.8 11.5.5 1.2a68.3 68.3 0 0 0 .7 1.1l.4.1c.3 0 .5 0 .7-.3.2-.1.3-.3.3-.6l-.3-1-2.6-6.2a20.4 20.4 0 0 0-.5-1.3l-.5-.4-.7-.2c-.2 0-.5 0-.6.2-.2 0-.4.2-.5.4l-.3.6-.3.7L5.7 15l-.2.6-.1.4c0 .3 0 .5.3.7l.6.2c.3 0 .5 0 .7-.2l.4-1 .5-1.2h3.9ZM9.8 9l1.5 4h-3l1.5-4Zm5.6-.9v7.6c0 .4 0 .7.2 1l.7.2c.3 0 .6 0 .8-.3l.2-.9V8.1c0-.4 0-.7-.2-.9a1 1 0 0 0-.8-.3c-.2 0-.5.1-.7.3l-.2 1Z"/></svg>',
    "align-center": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm3 4h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 1 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm-3-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    "align-justify": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    "align-left": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Zm0-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    "align-none": '<svg width="24" height="24"><path d="M14.2 5 13 7H5a1 1 0 1 1 0-2h9.2Zm4 0h.8a1 1 0 0 1 0 2h-2l1.2-2Zm-6.4 4-1.2 2H5a1 1 0 0 1 0-2h6.8Zm4 0H19a1 1 0 0 1 0 2h-4.4l1.2-2Zm-6.4 4-1.2 2H5a1 1 0 0 1 0-2h4.4Zm4 0H19a1 1 0 0 1 0 2h-6.8l1.2-2ZM7 17l-1.2 2H5a1 1 0 0 1 0-2h2Zm4 0h8a1 1 0 0 1 0 2H9.8l1.2-2Zm5.2-13.5 1.3.7-9.7 16.3-1.3-.7 9.7-16.3Z" fill-rule="evenodd"/></svg>',
    "align-right": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm6 4h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm-6-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    "arrow-left": '<svg width="24" height="24"><path d="m5.6 13 12 6a1 1 0 0 0 1.4-1V6a1 1 0 0 0-1.4-.9l-12 6a1 1 0 0 0 0 1.8Z" fill-rule="evenodd"/></svg>',
    "arrow-right": '<svg width="24" height="24"><path d="m18.5 13-12 6A1 1 0 0 1 5 18V6a1 1 0 0 1 1.4-.9l12 6a1 1 0 0 1 0 1.8Z" fill-rule="evenodd"/></svg>',
    bold: '<svg width="24" height="24"><path d="M7.8 19c-.3 0-.5 0-.6-.2l-.2-.5V5.7c0-.2 0-.4.2-.5l.6-.2h5c1.5 0 2.7.3 3.5 1 .7.6 1.1 1.4 1.1 2.5a3 3 0 0 1-.6 1.9c-.4.6-1 1-1.6 1.2.4.1.9.3 1.3.6s.8.7 1 1.2c.4.4.5 1 .5 1.6 0 1.3-.4 2.3-1.3 3-.8.7-2.1 1-3.8 1H7.8Zm5-8.3c.6 0 1.2-.1 1.6-.5.4-.3.6-.7.6-1.3 0-1.1-.8-1.7-2.3-1.7H9.3v3.5h3.4Zm.5 6c.7 0 1.3-.1 1.7-.4.4-.4.6-.9.6-1.5s-.2-1-.7-1.4c-.4-.3-1-.4-2-.4H9.4v3.8h4Z" fill-rule="evenodd"/></svg>',
    bookmark: '<svg width="24" height="24"><path d="M6 4v17l6-4 6 4V4c0-.6-.4-1-1-1H7a1 1 0 0 0-1 1Z" fill-rule="nonzero"/></svg>',
    "border-style": '<svg width="24" height="24"><g fill-rule="evenodd"><rect width="18" height="2" x="3" y="6" rx="1"/><rect width="2.8" height="2" x="3" y="16" rx="1"/><rect width="2.8" height="2" x="6.8" y="16" rx="1"/><rect width="2.8" height="2" x="10.6" y="16" rx="1"/><rect width="2.8" height="2" x="14.4" y="16" rx="1"/><rect width="2.8" height="2" x="18.2" y="16" rx="1"/><rect width="8" height="2" x="3" y="11" rx="1"/><rect width="8" height="2" x="13" y="11" rx="1"/></g></svg>',
    "border-width": '<svg width="24" height="24"><g fill-rule="evenodd"><rect width="18" height="5" x="3" y="5" rx="1"/><rect width="18" height="3.5" x="3" y="11.5" rx="1"/><rect width="18" height="2" x="3" y="17" rx="1"/></g></svg>',
    brightness: '<svg width="24" height="24"><path d="M12 17c.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7v-1c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3Zm0-10a1 1 0 0 1-.7-.3A1 1 0 0 1 11 6V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3Zm7 4c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-1a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1ZM7 12c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3H5a1 1 0 0 1-.7-.3A1 1 0 0 1 4 12c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1c.3 0 .5.1.7.3.2.2.3.4.3.7Zm10 3.5.7.8c.2.1.3.4.3.6 0 .3-.1.6-.3.8a1 1 0 0 1-.8.3 1 1 0 0 1-.6-.3l-.8-.7a1 1 0 0 1-.3-.8c0-.2.1-.5.3-.7a1 1 0 0 1 1.4 0Zm-10-7-.7-.8a1 1 0 0 1-.3-.6c0-.3.1-.6.3-.8.2-.2.5-.3.8-.3.2 0 .5.1.7.3l.7.7c.2.2.3.5.3.8 0 .2-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.8-.3Zm10 0a1 1 0 0 1-.8.3 1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.6.3-.8l.8-.7c.1-.2.4-.3.6-.3.3 0 .6.1.8.3.2.2.3.5.3.8 0 .2-.1.5-.3.7l-.7.7Zm-10 7c.2-.2.5-.3.8-.3.2 0 .5.1.7.3a1 1 0 0 1 0 1.4l-.8.8a1 1 0 0 1-.6.3 1 1 0 0 1-.8-.3 1 1 0 0 1-.3-.8c0-.2.1-.5.3-.6l.7-.8ZM12 8a4 4 0 0 1 3.7 2.4 4 4 0 0 1 0 3.2A4 4 0 0 1 12 16a4 4 0 0 1-3.7-2.4 4 4 0 0 1 0-3.2A4 4 0 0 1 12 8Zm0 6.5c.7 0 1.3-.2 1.8-.7.5-.5.7-1.1.7-1.8s-.2-1.3-.7-1.8c-.5-.5-1.1-.7-1.8-.7s-1.3.2-1.8.7c-.5.5-.7 1.1-.7 1.8s.2 1.3.7 1.8c.5.5 1.1.7 1.8.7Z" fill-rule="evenodd"/></svg>',
    browse: '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-4v-2h4V8H5v10h4v2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9.4-2.3 2.3a1 1 0 1 1-1.4-1.4l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 0 1-1.4 1.4L13 13.4V20a1 1 0 0 1-2 0v-6.6Z" fill-rule="nonzero"/></svg>',
    cancel: '<svg width="24" height="24"><path d="M12 4.6a7.4 7.4 0 1 1 0 14.8 7.4 7.4 0 0 1 0-14.8ZM12 3a9 9 0 1 0 0 18 9 9 0 0 0 0-18Zm0 8L14.8 8l1 1.1-2.7 2.8 2.7 2.7-1.1 1.1-2.7-2.7-2.7 2.7-1-1.1 2.6-2.7-2.7-2.7 1-1.1 2.8 2.7Z" fill-rule="nonzero"/></svg>',
    "cell-background-color": '<svg width="24" height="24"><path d="m15.7 2 1.6 1.6-2.7 2.6 5.9 5.8c.7.7.7 1.7 0 2.4l-6.3 6.1a1.7 1.7 0 0 1-2.4 0l-6.3-6.1c-.7-.7-.7-1.7 0-2.4L15.7 2ZM18 12l-4.5-4L9 12h9ZM4 16s2 2.4 2 3.8C6 21 5.1 22 4 22s-2-1-2-2.2C2 18.4 4 16 4 16Z"/></svg>',
    "cell-border-color": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M5 13v5h2v2H5a2 2 0 0 1-2-2v-5h2zm8-7V4h6a2 2 0 0 1 2 2h-8z" opacity=".2"/><path fill-rule="nonzero" d="M13 4v2H5v7H3V6c0-1.1.9-2 2-2h8zm-2.6 14.1.1-.1.1.1.2.3.2.2.2.2c.4.6.8 1.2.8 1.7 0 .8-.7 1.5-1.5 1.5S9 21.3 9 20.5c0-.5.4-1.1.8-1.7l.2-.2.2-.2.2-.3z"/><path d="m13 11-2 2H5v-2h6V6h2z"/><path fill-rule="nonzero" d="m18.4 8 1 1-1.8 1.9 4 4c.5.4.5 1.1 0 1.6l-4.3 4.2a1.2 1.2 0 0 1-1.6 0l-4.4-4.2c-.4-.5-.4-1.2 0-1.7l7-6.8Zm1.6 7-3-3-3 3h6Z"/></g></svg>',
    "change-case": '<svg width="24" height="24"><path d="M18.4 18.2v-.6c-.5.8-1.3 1.2-2.4 1.2-2.2 0-3.3-1.6-3.3-4.8 0-3.1 1-4.7 3.3-4.7 1.1 0 1.8.3 2.4 1.1v-.6c0-.5.4-.8.8-.8s.8.3.8.8v8.4c0 .5-.4.8-.8.8a.8.8 0 0 1-.8-.8zm-2-7.4c-1.3 0-1.8.9-1.8 3.2 0 2.4.5 3.3 1.7 3.3 1.3 0 1.8-.9 1.8-3.2 0-2.4-.5-3.3-1.7-3.3zM10 15.7H5.5l-.8 2.6a1 1 0 0 1-1 .7h-.2a.7.7 0 0 1-.7-1l4-12a1 1 0 0 1 2 0l4 12a.7.7 0 0 1-.8 1h-.2a1 1 0 0 1-1-.7l-.8-2.6zm-.3-1.5-2-6.5-1.9 6.5h3.9z" fill-rule="evenodd"/></svg>',
    "character-count": '<svg width="24" height="24"><path d="M4 11.5h16v1H4v-1Zm4.8-6.8V10H7.7V5.8h-1v-1h2ZM11 8.3V9h2v1h-3V7.7l2-1v-.9h-2v-1h3v2.4l-2 1Zm6.3-3.4V10h-3.1V9h2.1V8h-2.1V6.8h2.1v-1h-2.1v-1h3.1ZM5.8 16.4c0-.5.2-.8.5-1 .2-.2.6-.3 1.2-.3l.8.1c.2 0 .4.2.5.3l.4.4v2.8l.2.3H8.2V18.7l-.6.3H7c-.4 0-.7 0-1-.2a1 1 0 0 1-.3-.9c0-.3 0-.6.3-.8.3-.2.7-.4 1.2-.4l.6-.2h.3v-.2l-.1-.2a.8.8 0 0 0-.5-.1 1 1 0 0 0-.4 0l-.3.4h-1Zm2.3.8h-.2l-.2.1-.4.1a1 1 0 0 0-.4.2l-.2.2.1.3.5.1h.4l.4-.4v-.6Zm2-3.4h1.2v1.7l.5-.3h.5c.5 0 .9.1 1.2.5.3.4.5.8.5 1.4 0 .6-.2 1.1-.5 1.5-.3.4-.7.6-1.3.6l-.6-.1-.4-.4v.4h-1.1v-5.4Zm1.1 3.3c0 .3 0 .6.2.8a.7.7 0 0 0 1.2 0l.2-.8c0-.4 0-.6-.2-.8a.7.7 0 0 0-.6-.3l-.6.3-.2.8Zm6.1-.5c0-.2 0-.3-.2-.4a.8.8 0 0 0-.5-.2c-.3 0-.5.1-.6.3l-.2.9c0 .3 0 .6.2.8.1.2.3.3.6.3.2 0 .4 0 .5-.2l.2-.4h1.1c0 .5-.3.8-.6 1.1a2 2 0 0 1-1.3.4c-.5 0-1-.2-1.3-.6a2 2 0 0 1-.5-1.4c0-.6.1-1.1.5-1.5.3-.4.8-.5 1.4-.5.5 0 1 0 1.2.3.4.3.5.7.5 1.2h-1v-.1Z" fill-rule="evenodd"/></svg>',
    "checklist-rtl": '<svg width="24" height="24"><path d="M5 17h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2zm14.2 11c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 8c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8z" fill-rule="evenodd"/></svg>',
    checklist: '<svg width="24" height="24"><path d="M11 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2h-8a1 1 0 0 1 0-2ZM7.2 16c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 8c-.2.3-.7.4-1 0L3.8 6.9a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Z" fill-rule="evenodd"/></svg>',
    checkmark: '<svg width="24" height="24"><path d="M18.2 5.4a1 1 0 0 1 1.6 1.2l-8 12a1 1 0 0 1-1.5.1l-5-5a1 1 0 1 1 1.4-1.4l4.1 4.1 7.4-11Z" fill-rule="nonzero"/></svg>',
    "chevron-down": '<svg width="10" height="10"><path d="M8.7 2.2c.3-.3.8-.3 1 0 .4.4.4.9 0 1.2L5.7 7.8c-.3.3-.9.3-1.2 0L.2 3.4a.8.8 0 0 1 0-1.2c.3-.3.8-.3 1.1 0L5 6l3.7-3.8Z" fill-rule="nonzero"/></svg>',
    "chevron-left": '<svg width="10" height="10"><path d="M7.8 1.3 4 5l3.8 3.7c.3.3.3.8 0 1-.4.4-.9.4-1.2 0L2.2 5.7a.8.8 0 0 1 0-1.2L6.6.2C7 0 7.4 0 7.8.2c.3.3.3.8 0 1.1Z" fill-rule="nonzero"/></svg>',
    "chevron-right": '<svg width="10" height="10"><path d="M2.2 1.3a.8.8 0 0 1 0-1c.4-.4.9-.4 1.2 0l4.4 4.1c.3.4.3.9 0 1.2L3.4 9.8c-.3.3-.8.3-1.2 0a.8.8 0 0 1 0-1.1L6 5 2.2 1.3Z" fill-rule="nonzero"/></svg>',
    "chevron-up": '<svg width="10" height="10"><path d="M8.7 7.8 5 4 1.3 7.8c-.3.3-.8.3-1 0a.8.8 0 0 1 0-1.2l4.1-4.4c.3-.3.9-.3 1.2 0l4.2 4.4c.3.3.3.9 0 1.2-.3.3-.8.3-1.1 0Z" fill-rule="nonzero"/></svg>',
    close: '<svg width="24" height="24"><path d="M17.3 8.2 13.4 12l3.9 3.8a1 1 0 0 1-1.5 1.5L12 13.4l-3.8 3.9a1 1 0 0 1-1.5-1.5l3.9-3.8-3.9-3.8a1 1 0 0 1 1.5-1.5l3.8 3.9 3.8-3.9a1 1 0 0 1 1.5 1.5Z" fill-rule="evenodd"/></svg>',
    "code-sample": '<svg width="24" height="26"><path d="M7.1 11a2.8 2.8 0 0 1-.8 2 2.8 2.8 0 0 1 .8 2v1.7c0 .3.1.6.4.8.2.3.5.4.8.4.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.7 0-1.4-.3-2-.8-.5-.6-.8-1.3-.8-2V15c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 0 1-.4-.4v-.8c0-.2.2-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V9.3c0-.7.3-1.4.8-2 .6-.5 1.3-.8 2-.8.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8V11Zm9.8 0V9.3c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 0 1-.4-.4V7c0-.2.1-.4.4-.4.7 0 1.4.3 2 .8.5.6.8 1.3.8 2V11c0 .3.1.6.4.8.2.3.5.4.8.4.2 0 .4.2.4.4v.8c0 .2-.2.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8v1.7c0 .7-.3 1.4-.8 2-.6.5-1.3.8-2 .8a.4.4 0 0 1-.4-.4v-.8c0-.2.1-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V15a2.8 2.8 0 0 1 .8-2 2.8 2.8 0 0 1-.8-2Zm-3.3-.4c0 .4-.1.8-.5 1.1-.3.3-.7.5-1.1.5-.4 0-.8-.2-1.1-.5-.4-.3-.5-.7-.5-1.1 0-.5.1-.9.5-1.2.3-.3.7-.4 1.1-.4.4 0 .8.1 1.1.4.4.3.5.7.5 1.2ZM12 13c.4 0 .8.1 1.1.5.4.3.5.7.5 1.1 0 1-.1 1.6-.5 2a3 3 0 0 1-1.1 1c-.4.3-.8.4-1.1.4a.5.5 0 0 1-.5-.5V17a3 3 0 0 0 1-.2l.6-.6c-.6 0-1-.2-1.3-.5-.2-.3-.3-.7-.3-1 0-.5.1-1 .5-1.2.3-.4.7-.5 1.1-.5Z" fill-rule="evenodd"/></svg>',
    "color-levels": '<svg width="24" height="24"><path d="M17.5 11.4A9 9 0 0 1 18 14c0 .5 0 1-.2 1.4 0 .4-.3.9-.5 1.3a6.2 6.2 0 0 1-3.7 3 5.7 5.7 0 0 1-3.2 0A5.9 5.9 0 0 1 7.6 18a6.2 6.2 0 0 1-1.4-2.6 6.7 6.7 0 0 1 0-2.8c0-.4.1-.9.3-1.3a13.6 13.6 0 0 1 2.3-4A20 20 0 0 1 12 4a26.4 26.4 0 0 1 3.2 3.4 18.2 18.2 0 0 1 2.3 4Zm-2 4.5c.4-.7.5-1.4.5-2a7.3 7.3 0 0 0-1-3.2c.2.6.2 1.2.2 1.9a4.5 4.5 0 0 1-1.3 3 5.3 5.3 0 0 1-2.3 1.5 4.9 4.9 0 0 1-2 .1 4.3 4.3 0 0 0 2.4.8 4 4 0 0 0 2-.6 4 4 0 0 0 1.5-1.5Z" fill-rule="evenodd"/></svg>',
    "color-picker": '<svg width="24" height="24"><path d="M12 3a9 9 0 0 0 0 18 1.5 1.5 0 0 0 1.1-2.5c-.2-.3-.4-.6-.4-1 0-.8.7-1.5 1.5-1.5H16a5 5 0 0 0 5-5c0-4.4-4-8-9-8Zm-5.5 9a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm3-4a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm5 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm3 4a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Z" fill-rule="nonzero"/></svg>',
    "color-swatch-remove-color": '<svg width="24" height="24"><path stroke="#000" stroke-width="2" d="M21 3 3 21" fill-rule="evenodd"/></svg>',
    "color-swatch": '<svg width="24" height="24"><rect x="3" y="3" width="18" height="18" rx="1" fill-rule="evenodd"/></svg>',
    "comment-add": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="m9 19 3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 0 0-1 1v10c0 .6.4 1 1 1h4v2Zm-2 4v-4H5a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3h-6.4L7 23Z"/><path d="M13 10h2a1 1 0 0 1 0 2h-2v2a1 1 0 0 1-2 0v-2H9a1 1 0 0 1 0-2h2V8a1 1 0 0 1 2 0v2Z"/></g></svg>',
    comment: '<svg width="24" height="24"><path fill-rule="nonzero" d="m9 19 3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 0 0-1 1v10c0 .6.4 1 1 1h4v2Zm-2 4v-4H5a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3h-6.4L7 23Z"/></svg>',
    contrast: '<svg width="24" height="24"><path d="M12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Zm-6 8a6 6 0 0 0 6 6V6a6 6 0 0 0-6 6Z" fill-rule="evenodd"/></svg>',
    copy: '<svg width="24" height="24"><path d="M16 3H6a2 2 0 0 0-2 2v11h2V5h10V3Zm1 4a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V9c0-1.2.9-2 2-2h7Zm0 12V9h-7v10h7Z" fill-rule="nonzero"/></svg>',
    crop: '<svg width="24" height="24"><path d="M17 8v7h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v2c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-2H7V9H5a1 1 0 1 1 0-2h2V5c0-.6.4-1 1-1s1 .4 1 1v2h7l3-3 1 1-3 3ZM9 9v5l5-5H9Zm1 6h5v-5l-5 5Z" fill-rule="evenodd"/></svg>',
    "cut-column": '<svg width="24" height="24"><path fill-rule="evenodd" d="M7.2 4.5c.9 0 1.6.4 2.2 1A3.7 3.7 0 0 1 10.5 8v.5l1 1 4-4 1-.5a3.3 3.3 0 0 1 2 0c.4 0 .7.3 1 .5L17 8h4v13h-6V10l-1.5 1.5.5.5v4l-2.5-2.5-1 1v.5c0 .4 0 .8-.3 1.2-.2.5-.4.9-.8 1.2-.6.7-1.3 1-2.2 1-.8.2-1.5 0-2-.6l-.5-.8-.2-1c0-.4 0-.8.3-1.2A3.9 3.9 0 0 1 7 12.7c.5-.2 1-.3 1.5-.2l1-1-1-1c-.5 0-1 0-1.5-.2-.5-.1-1-.4-1.4-.9-.4-.3-.6-.7-.8-1.2L4.5 7c0-.4 0-.7.2-1 0-.3.3-.6.5-.8.5-.5 1.2-.8 2-.7Zm12.3 5h-3v10h3v-10ZM8 13.8h-.3l-.4.2a2.8 2.8 0 0 0-.7.4v.1a2.8 2.8 0 0 0-.6.8l-.1.4v.7l.2.5.5.2h.7a2.6 2.6 0 0 0 .8-.3 2.4 2.4 0 0 0 .7-.7 2.5 2.5 0 0 0 .3-.8 1.5 1.5 0 0 0 0-.8 1 1 0 0 0-.2-.4 1 1 0 0 0-.5-.2H8Zm3.5-3.7c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4ZM7 5.8h-.4a1 1 0 0 0-.5.3 1 1 0 0 0-.2.5v.7a2.5 2.5 0 0 0 .3.8l.2.3h.1l.4.4.4.2.4.1h.7L9 9l.2-.4a1.6 1.6 0 0 0 0-.8 2.6 2.6 0 0 0-.3-.8A2.5 2.5 0 0 0 7.7 6l-.4-.1H7Z"/></svg>',
    "cut-row": '<svg width="24" height="24"><path fill-rule="evenodd" d="M22 3v5H9l3 3 2-2h4l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8.7.6 1 1.3 1 2.2.2.8 0 1.5-.6 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 0 1-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 0 1 8.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 0 1 0-2c0-.4.3-.7.5-1l2 2V3h14ZM8.5 15.3h-.3a2.6 2.6 0 0 0-.8.4 2.5 2.5 0 0 0-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 0 0 .8-.3L9 18V18l.4-.4.2-.4.1-.4v-.7a1 1 0 0 0-.2-.5 1 1 0 0 0-.4-.2h-.5Zm7 0H15a1 1 0 0 0-.4.3 1 1 0 0 0-.2.5 1.5 1.5 0 0 0 0 .7v.4a2.8 2.8 0 0 0 .5.7h.1a2.8 2.8 0 0 0 .8.6l.4.1h.7l.5-.2.2-.5v-.7a2.6 2.6 0 0 0-.3-.8 2.4 2.4 0 0 0-.7-.7 2.5 2.5 0 0 0-.8-.3h-.3ZM12 11.6c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4Zm8.5-7.1h-11v2h11v-2Z"/></svg>',
    cut: '<svg width="24" height="24"><path d="M18 15c.6.7 1 1.4 1 2.3 0 .8-.2 1.5-.7 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 0 1-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 0 1 8.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 0 1 0-2c0-.4.3-.7.5-1l6 6 6-6 .5 1a3.3 3.3 0 0 1 0 2c0 .4-.3.7-.5 1l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8Zm-8.5 2.2.1-.4v-.7a1 1 0 0 0-.2-.5 1 1 0 0 0-.4-.2 1.6 1.6 0 0 0-.8 0 2.6 2.6 0 0 0-.8.3 2.5 2.5 0 0 0-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 0 0 .8-.3 2.8 2.8 0 0 0 1-1Zm2.5-2.8c.4 0 .7-.1 1-.4.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4s-.7.1-1 .4c-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4Zm5.4 4 .2-.5v-.7a2.6 2.6 0 0 0-.3-.8 2.4 2.4 0 0 0-.7-.7 2.5 2.5 0 0 0-.8-.3 1.5 1.5 0 0 0-.8 0 1 1 0 0 0-.4.2 1 1 0 0 0-.2.5 1.5 1.5 0 0 0 0 .7v.4l.3.4.3.4a2.8 2.8 0 0 0 .8.5l.4.1h.7l.5-.2Z" fill-rule="evenodd"/></svg>',
    "document-properties": '<svg width="24" height="24"><path d="M14.4 3H7a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V7.6L14.4 3ZM17 19H7V5h6v4h4v10Z" fill-rule="nonzero"/></svg>',
    drag: '<svg width="24" height="24"><path d="M13 5h2v2h-2V5Zm0 4h2v2h-2V9ZM9 9h2v2H9V9Zm4 4h2v2h-2v-2Zm-4 0h2v2H9v-2Zm0 4h2v2H9v-2Zm4 0h2v2h-2v-2ZM9 5h2v2H9V5Z" fill-rule="evenodd"/></svg>',
    "duplicate-column": '<svg width="24" height="24"><path d="M17 6v16h-7V6h7Zm-2 2h-3v12h3V8Zm-2-6v2H8v15H6V2h7Z"/></svg>',
    "duplicate-row": '<svg width="24" height="24"><path d="M22 11v7H6v-7h16Zm-2 2H8v3h12v-3Zm-1-6v2H4v5H2V7h17Z"/></svg>',
    duplicate: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M16 3v2H6v11H4V5c0-1.1.9-2 2-2h10Zm3 8h-2V9h-7v10h9a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V9c0-1.2.9-2 2-2h7a2 2 0 0 1 2 2v2Z"/><path d="M17 14h1a1 1 0 0 1 0 2h-1v1a1 1 0 0 1-2 0v-1h-1a1 1 0 0 1 0-2h1v-1a1 1 0 0 1 2 0v1Z"/></g></svg>',
    "edit-block": '<svg width="24" height="24"><path fill-rule="nonzero" d="m19.8 8.8-9.4 9.4c-.2.2-.5.4-.9.4l-5.4 1.2 1.2-5.4.5-.8 9.4-9.4c.7-.7 1.8-.7 2.5 0l2.1 2.1c.7.7.7 1.8 0 2.5Zm-2-.2 1-.9v-.3l-2.2-2.2a.3.3 0 0 0-.3 0l-1 1L18 8.5Zm-1 1-2.5-2.4-6 6 2.5 2.5 6-6Zm-7 7.1-2.6-2.4-.3.3-.1.2-.7 3 3.1-.6h.1l.4-.5Z"/></svg>',
    "edit-image": '<svg width="24" height="24"><path d="M18 16h2V7a2 2 0 0 0-2-2H7v2h11v9ZM6 17h15a1 1 0 0 1 0 2h-1v1a1 1 0 0 1-2 0v-1H6a2 2 0 0 1-2-2V7H3a1 1 0 1 1 0-2h1V4a1 1 0 1 1 2 0v13Zm3-5.3 1.3 2 3-4.7 3.7 6H7l2-3.3Z" fill-rule="nonzero"/></svg>',
    "embed-page": '<svg width="24" height="24"><path d="M19 6V5H5v14h2A13 13 0 0 1 19 6Zm0 1.4c-.8.8-1.6 2.4-2.2 4.6H19V7.4Zm0 5.6h-2.4c-.4 1.8-.6 3.8-.6 6h3v-6Zm-4 6c0-2.2.2-4.2.6-6H13c-.7 1.8-1.1 3.8-1.1 6h3Zm-4 0c0-2.2.4-4.2 1-6H9.6A12 12 0 0 0 8 19h3ZM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm11.8 9c.4-1.9 1-3.4 1.8-4.5a9.2 9.2 0 0 0-4 4.5h2.2Zm-3.4 0a12 12 0 0 1 2.8-4 12 12 0 0 0-5 4h2.2Z" fill-rule="nonzero"/></svg>',
    embed: '<svg width="24" height="24"><path d="M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm1 2v14h14V5H5Zm4.8 2.6 5.6 4a.5.5 0 0 1 0 .8l-5.6 4A.5.5 0 0 1 9 16V8a.5.5 0 0 1 .8-.4Z" fill-rule="nonzero"/></svg>',
    emoji: '<svg width="24" height="24"><path d="M9 11c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 0 0-1 1c0 .6.4 1 1 1Zm6 0c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 0 0-1 1c0 .6.4 1 1 1Zm-3 5.5c2.1 0 4-1.5 4.4-3.5H7.6c.5 2 2.3 3.5 4.4 3.5ZM12 4a8 8 0 1 0 0 16 8 8 0 0 0 0-16Zm0 14.5a6.5 6.5 0 1 1 0-13 6.5 6.5 0 0 1 0 13Z" fill-rule="nonzero"/></svg>',
    export: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M14.4 3 18 7v1h-5V5H7v14h9a1 1 0 0 1 2 0c0 1-.8 2-1.9 2H7c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2h7.5Z"/><path d="M18.1 12c.5 0 .9.4.9 1 0 .5-.3 1-.8 1h-7.3c-.5 0-.9-.4-.9-1 0-.5.3-1 .8-1h7.3Z"/><path d="M16.4 9.2a1 1 0 0 1 1.4.2l2.4 3.6-2.4 3.6a1 1 0 0 1-1.7-1v-.2l1.7-2.4-1.6-2.4a1 1 0 0 1 .2-1.4Z"/></g></svg>',
    fill: '<svg width="24" height="26"><path d="m16.6 12-9-9-1.4 1.4 2.4 2.4-5.2 5.1c-.5.6-.5 1.6 0 2.2L9 19.6a1.5 1.5 0 0 0 2.2 0l5.5-5.5c.5-.6.5-1.6 0-2.2ZM5.2 13 10 8.2l4.8 4.8H5.2ZM19 14.5s-2 2.2-2 3.5c0 1.1.9 2 2 2a2 2 0 0 0 2-2c0-1.3-2-3.5-2-3.5Z" fill-rule="nonzero"/></svg>',
    "flip-horizontally": '<svg width="24" height="24"><path d="M14 19h2v-2h-2v2Zm4-8h2V9h-2v2ZM4 7v10c0 1.1.9 2 2 2h3v-2H6V7h3V5H6a2 2 0 0 0-2 2Zm14-2v2h2a2 2 0 0 0-2-2Zm-7 16h2V3h-2v18Zm7-6h2v-2h-2v2Zm-4-8h2V5h-2v2Zm4 12a2 2 0 0 0 2-2h-2v2Z" fill-rule="nonzero"/></svg>',
    "flip-vertically": '<svg width="24" height="24"><path d="M5 14v2h2v-2H5Zm8 4v2h2v-2h-2Zm4-14H7a2 2 0 0 0-2 2v3h2V6h10v3h2V6a2 2 0 0 0-2-2Zm2 14h-2v2a2 2 0 0 0 2-2ZM3 11v2h18v-2H3Zm6 7v2h2v-2H9Zm8-4v2h2v-2h-2ZM5 18c0 1.1.9 2 2 2v-2H5Z" fill-rule="nonzero"/></svg>',
    footnote: '<svg width="24" height="24"><path d="M19 13c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2h14Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M19 4v6h-1V5h-1.5V4h2.6Z"/><path d="M12 18c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2h7ZM14 8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2h9Z"/></svg>',
    "format-painter": '<svg width="24" height="24"><path d="M18 5V4c0-.5-.4-1-1-1H5a1 1 0 0 0-1 1v4c0 .6.5 1 1 1h12c.6 0 1-.4 1-1V7h1v4H9v9c0 .6.4 1 1 1h2c.6 0 1-.4 1-1v-7h8V5h-3Z" fill-rule="nonzero"/></svg>',
    format: '<svg width="24" height="24"><path fill-rule="evenodd" d="M17 5a1 1 0 0 1 0 2h-4v11a1 1 0 0 1-2 0V7H7a1 1 0 1 1 0-2h10Z"/></svg>',
    fullscreen: '<svg width="24" height="24"><path d="m15.3 10-1.2-1.3 2.9-3h-2.3a.9.9 0 1 1 0-1.7H19c.5 0 .9.4.9.9v4.4a.9.9 0 1 1-1.8 0V7l-2.9 3Zm0 4 3 3v-2.3a.9.9 0 1 1 1.7 0V19c0 .5-.4.9-.9.9h-4.4a.9.9 0 1 1 0-1.8H17l-3-2.9 1.3-1.2ZM10 15.4l-2.9 3h2.3a.9.9 0 1 1 0 1.7H5a.9.9 0 0 1-.9-.9v-4.4a.9.9 0 1 1 1.8 0V17l2.9-3 1.2 1.3ZM8.7 10 5.7 7v2.3a.9.9 0 0 1-1.7 0V5c0-.5.4-.9.9-.9h4.4a.9.9 0 0 1 0 1.8H7l3 2.9-1.3 1.2Z" fill-rule="nonzero"/></svg>',
    gallery: '<svg width="24" height="24"><path fill-rule="nonzero" d="m5 15.7 2.3-2.2c.3-.3.7-.3 1 0L11 16l5.1-5c.3-.4.8-.4 1 0l2 1.9V8H5v7.7ZM5 18V19h3l1.8-1.9-2-2L5 17.9Zm14-3-2.5-2.4-6.4 6.5H19v-4ZM4 6h16c.6 0 1 .4 1 1v13c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V7c0-.6.4-1 1-1Zm6 7a2 2 0 1 1 0-4 2 2 0 0 1 0 4ZM4.5 4h15a.5.5 0 1 1 0 1h-15a.5.5 0 0 1 0-1Zm2-2h11a.5.5 0 1 1 0 1h-11a.5.5 0 0 1 0-1Z"/></svg>',
    gamma: '<svg width="24" height="24"><path d="M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm1 2v14h14V5H5Zm6.5 11.8V14L9.2 8.7a5.1 5.1 0 0 0-.4-.8l-.1-.2H8v-1l.3-.1.3-.1h.7a1 1 0 0 1 .6.5l.1.3a8.5 8.5 0 0 1 .3.6l1.9 4.6 2-5.2a1 1 0 0 1 1-.6.5.5 0 0 1 .5.6L13 14v2.8a.7.7 0 0 1-1.4 0Z" fill-rule="nonzero"/></svg>',
    help: '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M12 5.5a6.5 6.5 0 0 0-6 9 6.3 6.3 0 0 0 1.4 2l1 1a6.3 6.3 0 0 0 3.6 1 6.5 6.5 0 0 0 6-9 6.3 6.3 0 0 0-1.4-2l-1-1a6.3 6.3 0 0 0-3.6-1ZM12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Z"/><path d="M9.6 9.7a.7.7 0 0 1-.7-.8c0-1.1 1.5-1.8 3.2-1.8 1.8 0 3.2.8 3.2 2.4 0 1.4-.4 2.1-1.5 2.8-.2 0-.3.1-.3.2a2 2 0 0 0-.8.8.8.8 0 0 1-1.4-.6c.3-.7.8-1 1.3-1.5l.4-.2c.7-.4.8-.6.8-1.5 0-.5-.6-.9-1.7-.9-.5 0-1 .1-1.4.3-.2 0-.3.1-.3.2v-.2c0 .4-.4.8-.8.8Z" fill-rule="nonzero"/><circle cx="12" cy="16" r="1"/></g></svg>',
    "highlight-bg-color": '<svg width="24" height="24"><g fill-rule="evenodd"><path class="tox-icon-highlight-bg-color__color" d="M3 18h18v3H3z"/><path fill-rule="nonzero" d="M7.7 16.7H3l3.3-3.3-.7-.8L10.2 8l4 4.1-4 4.2c-.2.2-.6.2-.8 0l-.6-.7-1.1 1.1zm5-7.5L11 7.4l3-2.9a2 2 0 0 1 2.6 0L18 6c.7.7.7 2 0 2.7l-2.9 2.9-1.8-1.8-.5-.6"/></g></svg>',
    home: '<svg width="24" height="24"><path fill-rule="nonzero" d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>',
    "horizontal-rule": '<svg width="24" height="24"><path d="M4 11h16v2H4z" fill-rule="evenodd"/></svg>',
    "image-options": '<svg width="24" height="24"><path d="M6 10a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm12 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm-6 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Z" fill-rule="nonzero"/></svg>',
    image: '<svg width="24" height="24"><path d="m5 15.7 3.3-3.2c.3-.3.7-.3 1 0L12 15l4.1-4c.3-.4.8-.4 1 0l2 1.9V5H5v10.7ZM5 18V19h3l2.8-2.9-2-2L5 17.9Zm14-3-2.5-2.4-6.4 6.5H19v-4ZM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm6 8a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z" fill-rule="nonzero"/></svg>',
    indent: '<svg width="24" height="24"><path d="M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 1 1 0-2Zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm-5 4h12a1 1 0 0 1 0 2H7a1 1 0 0 1 0-2Zm-2.6-3.8L6.2 12l-1.8-1.2a1 1 0 0 1 1.2-1.6l3 2a1 1 0 0 1 0 1.6l-3 2a1 1 0 1 1-1.2-1.6Z" fill-rule="evenodd"/></svg>',
    info: '<svg width="24" height="24"><path d="M12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Zm-1 3v2h2V7h-2Zm3 10v-1h-1v-5h-3v1h1v4h-1v1h4Z" fill-rule="evenodd"/></svg>',
    "insert-character": '<svg width="24" height="24"><path d="M15 18h4l1-2v4h-6v-3.3l1.4-1a6 6 0 0 0 1.8-2.9 6.3 6.3 0 0 0-.1-4.1 5.8 5.8 0 0 0-3-3.2c-.6-.3-1.3-.5-2.1-.5a5.1 5.1 0 0 0-3.9 1.8 6.3 6.3 0 0 0-1.3 6 6.2 6.2 0 0 0 1.8 3l1.4.9V20H4v-4l1 2h4v-.5l-2-1L5.4 15A6.5 6.5 0 0 1 4 11c0-1 .2-1.9.6-2.7A7 7 0 0 1 6.3 6C7.1 5.4 8 5 9 4.5c1-.3 2-.5 3.1-.5a8.8 8.8 0 0 1 5.7 2 7 7 0 0 1 1.7 2.3 6 6 0 0 1 .2 4.8c-.2.7-.6 1.3-1 1.9a7.6 7.6 0 0 1-3.6 2.5v.5Z" fill-rule="evenodd"/></svg>',
    "insert-time": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M12 19a7 7 0 1 0 0-14 7 7 0 0 0 0 14Zm0 2a9 9 0 1 1 0-18 9 9 0 0 1 0 18Z"/><path d="M16 12h-3V7c0-.6-.4-1-1-1a1 1 0 0 0-1 1v7h5c.6 0 1-.4 1-1s-.4-1-1-1Z"/></g></svg>',
    invert: '<svg width="24" height="24"><path d="M18 19.3 16.5 18a5.8 5.8 0 0 1-3.1 1.9 6.1 6.1 0 0 1-5.5-1.6A5.8 5.8 0 0 1 6 14v-.3l.1-1.2A13.9 13.9 0 0 1 7.7 9l-3-3 .7-.8 2.8 2.9 9 8.9 1.5 1.6-.7.6Zm0-5.5v.3l-.1 1.1-.4 1-1.2-1.2a4.3 4.3 0 0 0 .2-1v-.2c0-.4 0-.8-.2-1.3l-.5-1.4a14.8 14.8 0 0 0-3-4.2L12 6a26.1 26.1 0 0 0-2.2 2.5l-1-1a20.9 20.9 0 0 1 2.9-3.3L12 4l1 .8a22.2 22.2 0 0 1 4 5.4c.6 1.2 1 2.4 1 3.6Z" fill-rule="evenodd"/></svg>',
    italic: '<svg width="24" height="24"><path d="m16.7 4.7-.1.9h-.3c-.6 0-1 0-1.4.3-.3.3-.4.6-.5 1.1l-2.1 9.8v.6c0 .5.4.8 1.4.8h.2l-.2.8H8l.2-.8h.2c1.1 0 1.8-.5 2-1.5l2-9.8.1-.5c0-.6-.4-.8-1.4-.8h-.3l.2-.9h5.8Z" fill-rule="evenodd"/></svg>',
    language: '<svg width="24" height="24"><path d="M12 3a9 9 0 1 1 0 18 9 9 0 0 1 0-18Zm4.3 13.3c-.5 1-1.2 2-2 2.9a7.5 7.5 0 0 0 3.2-2.1l-.2-.2a6 6 0 0 0-1-.6Zm-8.6 0c-.5.2-.9.5-1.2.8.9 1 2 1.7 3.2 2a10 10 0 0 1-2-2.8Zm3.6-.8c-.8 0-1.6.1-2.2.3.5 1 1.2 1.9 2.1 2.7Zm1.5 0v3c.9-.8 1.6-1.7 2.1-2.7-.6-.2-1.4-.3-2.1-.3Zm-6-2.7H4.5c.2 1 .5 2.1 1 3h.3l1.3-1a10 10 0 0 1-.3-2Zm12.7 0h-2.3c0 .7-.1 1.4-.3 2l1.6 1.1c.5-1 .9-2 1-3.1Zm-3.8 0h-3V14c1 0 2 .1 2.7.4.2-.5.3-1 .3-1.6Zm-4.4 0h-3l.3 1.6c.8-.3 1.7-.4 2.7-.4v-1.3Zm-5.5-5c-.7 1-1.1 2.2-1.3 3.5h2.3c0-1 .2-1.8.5-2.6l-1.5-1Zm2.9 1.4v.1c-.2.6-.4 1.3-.4 2h3V9.4c-1 0-1.8-.1-2.6-.3Zm6.6 0h-.1l-2.4.3v1.8h3l-.5-2.1Zm3-1.4-.3.1-1.3.8c.3.8.5 1.6.5 2.6h2.3a7.5 7.5 0 0 0-1.3-3.5Zm-9 0 2 .2V5.5a9 9 0 0 0-2 2.2Zm3.5-2.3V8c.6 0 1.3 0 1.9-.2a9 9 0 0 0-2-2.3Zm-3-.7h-.1c-1.1.4-2.1 1-3 1.8l1.2.7a10 10 0 0 1 1.9-2.5Zm4.4 0 .1.1a10 10 0 0 1 1.8 2.4l1.1-.7a7.5 7.5 0 0 0-3-1.8Z"/></svg>',
    "line-height": '<svg width="24" height="24"><path d="M21 5a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zM7 3.6l3.7 3.7a1 1 0 0 1-1.3 1.5h-.1L8 7.3v9.2l1.3-1.3a1 1 0 0 1 1.3 0h.1c.4.4.4 1 0 1.3v.1L7 20.4l-3.7-3.7a1 1 0 0 1 1.3-1.5h.1L6 16.7V7.4L4.7 8.7a1 1 0 0 1-1.3 0h-.1a1 1 0 0 1 0-1.3v-.1L7 3.6z"/></svg>',
    line: '<svg width="24" height="24"><path d="m15 9-8 8H4v-3l8-8 3 3Zm1-1-3-3 1-1h1c-.2 0 0 0 0 0l2 2s0 .2 0 0v1l-1 1ZM4 18h16v2H4v-2Z" fill-rule="evenodd"/></svg>',
    link: '<svg width="24" height="24"><path d="M6.2 12.3a1 1 0 0 1 1.4 1.4l-2 2a2 2 0 1 0 2.6 2.8l4.8-4.8a1 1 0 0 0 0-1.4 1 1 0 1 1 1.4-1.3 2.9 2.9 0 0 1 0 4L9.6 20a3.9 3.9 0 0 1-5.5-5.5l2-2Zm11.6-.6a1 1 0 0 1-1.4-1.4l2-2a2 2 0 1 0-2.6-2.8L11 10.3a1 1 0 0 0 0 1.4A1 1 0 1 1 9.6 13a2.9 2.9 0 0 1 0-4L14.4 4a3.9 3.9 0 0 1 5.5 5.5l-2 2Z" fill-rule="nonzero"/></svg>',
    "list-bull-circle": '<svg width="48" height="48"><g fill-rule="evenodd"><path d="M11 16a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6ZM11 26a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6ZM11 36a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6Z" fill-rule="nonzero"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>',
    "list-bull-default": '<svg width="48" height="48"><g fill-rule="evenodd"><circle cx="11" cy="14" r="3"/><circle cx="11" cy="24" r="3"/><circle cx="11" cy="34" r="3"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>',
    "list-bull-square": '<svg width="48" height="48"><g fill-rule="evenodd"><path d="M8 11h6v6H8zM8 21h6v6H8zM8 31h6v6H8z"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>',
    "list-num-default-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M37.4 17v-4.8h-.1l-1.5 1v-1.1l1.6-1.1h1.2v6zM33.3 17.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm1.7 5.7c0-1.2 1-2 2.2-2 1.3 0 2.1.8 2.1 1.8 0 .7-.3 1.2-1.3 2.2l-1.2 1v.2h2.6v1h-4.3v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H35zm-1.7 4.3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm3.2 7.3v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H35c0-1.1 1-1.8 2.2-1.8 1.2 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.7.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .6 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7zm-3.3 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7z"/></g></svg>',
    "list-num-default": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10 17v-4.8l-1.5 1v-1.1l1.6-1h1.2V17h-1.2Zm3.6.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm-5 5.7c0-1.2.8-2 2.1-2s2.1.8 2.1 1.8c0 .7-.3 1.2-1.4 2.2l-1.1 1v.2h2.6v1H8.6v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H8.5Zm6.3 4.3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM10 34.4v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H8.6c0-1.1 1-1.8 2.2-1.8 1.3 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.8.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .7 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7Zm4.7 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7Z"/></g></svg>',
    "list-num-lower-alpha-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M36.5 16c-.9 0-1.5-.5-1.5-1.3s.6-1.3 1.8-1.4h1v-.4c0-.4-.2-.6-.7-.6-.4 0-.7.1-.8.4h-1.1c0-.8.8-1.4 2-1.4S39 12 39 13V16h-1.2v-.6c-.3.4-.8.7-1.4.7Zm.4-.8c.6 0 1-.4 1-.9V14h-1c-.5.1-.7.3-.7.6 0 .4.3.6.7.6ZM33.1 16.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7ZM37.7 26c-.7 0-1.2-.2-1.5-.7v.7H35v-6.3h1.2v2.5c.3-.5.8-.9 1.5-.9 1.1 0 1.8 1 1.8 2.4 0 1.5-.7 2.4-1.8 2.4Zm-.5-3.6c-.6 0-1 .5-1 1.3s.4 1.4 1 1.4c.7 0 1-.6 1-1.4 0-.8-.3-1.3-1-1.3ZM33.2 26.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7zm6 7h-1c-.1-.5-.4-.8-1-.8s-1 .5-1 1.4c0 1 .4 1.4 1 1.4.5 0 .9-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7zm-6.1 3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>',
    "list-num-lower-alpha": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10.3 15.2c.5 0 1-.4 1-.9V14h-1c-.5.1-.8.3-.8.6 0 .4.3.6.8.6Zm-.4.9c-1 0-1.5-.6-1.5-1.4 0-.8.6-1.3 1.7-1.4h1.1v-.4c0-.4-.2-.6-.7-.6-.5 0-.8.1-.9.4h-1c0-.8.8-1.4 2-1.4 1.1 0 1.8.6 1.8 1.6V16h-1.1v-.6h-.1c-.2.4-.7.7-1.3.7Zm4.6 0c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-3.2 10c-.6 0-1.2-.3-1.4-.8v.7H8.5v-6.3H10v2.5c.3-.5.8-.9 1.4-.9 1.2 0 1.9 1 1.9 2.4 0 1.5-.7 2.4-1.9 2.4Zm-.4-3.7c-.7 0-1 .5-1 1.3s.3 1.4 1 1.4c.6 0 1-.6 1-1.4 0-.8-.4-1.3-1-1.3Zm4 3.7c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-2.2 7h-1.2c0-.5-.4-.8-.9-.8-.6 0-1 .5-1 1.4 0 1 .4 1.4 1 1.4.5 0 .8-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7Zm1.8 3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
    "list-num-lower-greek-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M37.4 16c-1.2 0-2-.8-2-2.3 0-1.5.8-2.4 2-2.4.6 0 1 .4 1.3 1v-.9H40v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1-.7h-.2c-.2.4-.7.8-1.3.8Zm.3-1c.6 0 1-.5 1-1.3s-.4-1.3-1-1.3-1 .5-1 1.3.4 1.4 1 1.4ZM33.3 16.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM36 21.9c0-1.5.8-2.3 2.1-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.9 1.3.9.3 1.3.8 1.3 1.7 0 1.2-.7 1.9-1.8 1.9-.6 0-1.1-.3-1.4-.8v2.2H36V22Zm1.8 1.2v-1h.3c.5 0 .9-.2.9-.7 0-.5-.3-.8-.9-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1 1.3s1-.4 1-1-.4-1-1.2-1h-.3ZM33.3 26.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM37.1 34.6 34.8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.2.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2Zm.7 1a2 2 0 0 0-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1ZM33.3 36.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
    "list-num-lower-greek": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10.5 15c.7 0 1-.5 1-1.3s-.3-1.3-1-1.3c-.5 0-.9.5-.9 1.3s.4 1.4 1 1.4Zm-.3 1c-1.1 0-1.8-.8-1.8-2.3 0-1.5.7-2.4 1.8-2.4.7 0 1.1.4 1.3 1h.1v-.9h1.2v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1.1-.7h-.1c-.2.4-.7.8-1.4.8Zm5 .1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7Zm-4.9 7v-1h.3c.6 0 1-.2 1-.7 0-.5-.4-.8-1-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1.1 1.3.6 0 1-.4 1-1s-.5-1-1.3-1h-.3ZM8.6 22c0-1.5.7-2.3 2-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.8 1.3.8.3 1.3.8 1.3 1.7 0 1.2-.8 1.9-1.9 1.9-.6 0-1.1-.3-1.3-.8v2.2H8.5V22Zm6.2 4.2c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm-4.5 8.5L8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.1.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2Zm.7 1a2 2 0 0 0-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1Zm4.5.5c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
    "list-num-lower-roman-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M32.9 16v-1.2h-1.3V16H33Zm0 10v-1.2h-1.3V26H33Zm0 10v-1.2h-1.3V36H33Z"/><path fill-rule="nonzero" d="M36 21h-1.5v5H36zM36 31h-1.5v5H36zM39 21h-1.5v5H39zM39 31h-1.5v5H39zM42 31h-1.5v5H42zM36 11h-1.5v5H36zM36 19h-1.5v1H36zM36 29h-1.5v1H36zM39 19h-1.5v1H39zM39 29h-1.5v1H39zM42 29h-1.5v1H42zM36 9h-1.5v1H36z"/></g></svg>',
    "list-num-lower-roman": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M15.1 16v-1.2h1.3V16H15Zm0 10v-1.2h1.3V26H15Zm0 10v-1.2h1.3V36H15Z"/><path fill-rule="nonzero" d="M12 21h1.5v5H12zM12 31h1.5v5H12zM9 21h1.5v5H9zM9 31h1.5v5H9zM6 31h1.5v5H6zM12 11h1.5v5H12zM12 19h1.5v1H12zM12 29h1.5v1H12zM9 19h1.5v1H9zM9 29h1.5v1H9zM6 29h1.5v1H6zM12 9h1.5v1H12z"/></g></svg>',
    "list-num-upper-alpha-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="m39.3 17-.5-1.4h-2l-.5 1.4H35l2-6h1.6l2 6h-1.3Zm-1.6-4.7-.7 2.3h1.6l-.8-2.3ZM33.4 17c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm4.7 9.9h-2.7v-6H38c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7Zm-1.4-5v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1Zm0 4h1.1c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9h-1.1V26ZM33 27.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm4.9 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2Zm-4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
    "list-num-upper-alpha": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="m12.6 17-.5-1.4h-2L9.5 17H8.3l2-6H12l2 6h-1.3ZM11 12.3l-.7 2.3h1.6l-.8-2.3Zm4.7 4.8c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7ZM11.4 27H8.7v-6h2.6c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7ZM10 22v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1Zm0 4H11c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9H10V26Zm5.4 1.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-4.1 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2Zm4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
    "list-num-upper-roman-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M31.6 17v-1.2H33V17h-1.3Zm0 10v-1.2H33V27h-1.3Zm0 10v-1.2H33V37h-1.3Z"/><path fill-rule="nonzero" d="M34.5 20H36v7h-1.5zM34.5 30H36v7h-1.5zM37.5 20H39v7h-1.5zM37.5 30H39v7h-1.5zM40.5 30H42v7h-1.5zM34.5 10H36v7h-1.5z"/></g></svg>',
    "list-num-upper-roman": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M15.1 17v-1.2h1.3V17H15Zm0 10v-1.2h1.3V27H15Zm0 10v-1.2h1.3V37H15Z"/><path fill-rule="nonzero" d="M12 20h1.5v7H12zM12 30h1.5v7H12zM9 20h1.5v7H9zM9 30h1.5v7H9zM6 30h1.5v7H6zM12 10h1.5v7H12z"/></g></svg>',
    lock: '<svg width="24" height="24"><path d="M16.3 11c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H8V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h.3ZM10 8v3h4V8a1 1 0 0 0-.3-.7A1 1 0 0 0 13 7h-2a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7Z" fill-rule="evenodd"/></svg>',
    ltr: '<svg width="24" height="24"><path d="M11 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 7.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L11 5ZM4.4 16.2 6.2 15l-1.8-1.2a1 1 0 0 1 1.2-1.6l3 2a1 1 0 0 1 0 1.6l-3 2a1 1 0 1 1-1.2-1.6Z" fill-rule="evenodd"/></svg>',
    minus: '<svg width="24" height="24"><path d="M19 11a1 1 0 0 1 .1 2H5a1 1 0 0 1-.1-2H19Z"/></svg>',
    "more-drawer": '<svg width="24" height="24"><path d="M6 10a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm12 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm-6 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Z" fill-rule="nonzero"/></svg>',
    "new-document": '<svg width="24" height="24"><path d="M14.4 3H7a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V7.6L14.4 3ZM17 19H7V5h6v4h4v10Z" fill-rule="nonzero"/></svg>',
    "new-tab": '<svg width="24" height="24"><path d="m15 13 2-2v8H5V7h8l-2 2H7v8h8v-4Zm4-8v5.5l-2-2-5.6 5.5H10v-1.4L15.5 7l-2-2H19Z" fill-rule="evenodd"/></svg>',
    "non-breaking": '<svg width="24" height="24"><path d="M11 11H8a1 1 0 1 1 0-2h3V6c0-.6.4-1 1-1s1 .4 1 1v3h3c.6 0 1 .4 1 1s-.4 1-1 1h-3v3c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-3Zm10 4v5H3v-5c0-.6.4-1 1-1s1 .4 1 1v3h14v-3c0-.6.4-1 1-1s1 .4 1 1Z" fill-rule="evenodd"/></svg>',
    notice: '<svg width="24" height="24"><path d="M15.5 4 20 8.5v7L15.5 20h-7L4 15.5v-7L8.5 4h7ZM13 17v-2h-2v2h2Zm0-4V7h-2v6h2Z" fill-rule="evenodd" clip-rule="evenodd"/></svg>',
    "ordered-list-rtl": '<svg width="24" height="24"><path d="M6 17h8a1 1 0 0 1 0 2H6a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2H6a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2H6a1 1 0 1 1 0-2Zm13-1v3.5a.5.5 0 1 1-1 0V5h-.5a.5.5 0 1 1 0-1H19Zm-1 8.8.2.2h1.3a.5.5 0 1 1 0 1h-1.6a1 1 0 0 1-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 0 0-.2-.2h-1.3a.5.5 0 0 1-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3Zm2 4.2v2c0 .6-.4 1-1 1h-1.5a.5.5 0 0 1 0-1h1.2a.3.3 0 1 0 0-.6h-1.3a.4.4 0 1 1 0-.8h1.3a.3.3 0 0 0 0-.6h-1.2a.5.5 0 1 1 0-1H19c.6 0 1 .4 1 1Z" fill-rule="evenodd"/></svg>',
    "ordered-list": '<svg width="24" height="24"><path d="M10 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 1 1 0-2ZM6 4v3.5c0 .3-.2.5-.5.5a.5.5 0 0 1-.5-.5V5h-.5a.5.5 0 0 1 0-1H6Zm-1 8.8.2.2h1.3c.3 0 .5.2.5.5s-.2.5-.5.5H4.9a1 1 0 0 1-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 0 0-.2-.2H4.5a.5.5 0 0 1-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3ZM7 17v2c0 .6-.4 1-1 1H4.5a.5.5 0 0 1 0-1h1.2c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.4a.4.4 0 1 1 0-.8h1.3c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.5a.5.5 0 1 1 0-1H6c.6 0 1 .4 1 1Z" fill-rule="evenodd"/></svg>',
    orientation: '<svg width="24" height="24"><path d="M7.3 6.4 1 13l6.4 6.5 6.5-6.5-6.5-6.5ZM3.7 13l3.6-3.7L11 13l-3.7 3.7-3.6-3.7ZM12 6l2.8 2.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0L9.2 5.7a.8.8 0 0 1 0-1.2L13.6.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L12 4h1a9 9 0 1 1-4.3 16.9l1.5-1.5A7 7 0 1 0 13 6h-1Z" fill-rule="nonzero"/></svg>',
    outdent: '<svg width="24" height="24"><path d="M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 1 1 0-2Zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm-5 4h12a1 1 0 0 1 0 2H7a1 1 0 0 1 0-2Zm1.6-3.8a1 1 0 0 1-1.2 1.6l-3-2a1 1 0 0 1 0-1.6l3-2a1 1 0 0 1 1.2 1.6L6.8 12l1.8 1.2Z" fill-rule="evenodd"/></svg>',
    "page-break": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M5 11c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1h-1a1 1 0 0 1 0-2Zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2ZM7 3v5h10V3c0-.6.4-1 1-1s1 .4 1 1v7H5V3c0-.6.4-1 1-1s1 .4 1 1ZM6 22a1 1 0 0 1-1-1v-7h14v7c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-5H7v5c0 .6-.4 1-1 1Z"/></g></svg>',
    paragraph: '<svg width="24" height="24"><path fill-rule="evenodd" d="M10 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 6.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L10 5Z"/></svg>',
    "paste-column-after": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V7h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h7v2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm8 7v12h-6V8h6Zm-1.5 1.5h-3v9h3v-9ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
    "paste-column-before": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V18c0 1-.8 2-1.9 2H11v-2h7V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v2H4V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm-2 7v12H4V8h6ZM8.5 9.5h-3v9h3v-9ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
    "paste-row-after": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V11h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h14c0 1-.8 2-1.9 2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm10 11v5H8v-5h14Zm-1.5 1.5h-11v2h11v-2ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
    "paste-row-before": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V7h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h12v-4h2v4c0 1-.8 2-1.9 2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm10 7v5H8V8h14Zm-1.5 1.5h-11v2h11v-2ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
    "paste-text": '<svg width="24" height="24"><path d="M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h3V9h9ZM9 20H6a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0 1 12 1a3 3 0 0 1 2.8 2H18a2 2 0 0 1 2 2v4h1v12H9v-1Zm1.5-9.5v9h9v-9h-9ZM12 3a1 1 0 0 0-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1Zm0 9h6v2h-.5l-.5-1h-1v4h.8v1h-3.6v-1h.8v-4h-1l-.5 1H12v-2Z" fill-rule="nonzero"/></svg>',
    paste: '<svg width="24" height="24"><path d="M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h3V9h9ZM9 20H6a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0 1 12 1a3 3 0 0 1 2.8 2H18a2 2 0 0 1 2 2v4h1v12H9v-1Zm1.5-9.5v9h9v-9h-9ZM12 3a1 1 0 0 0-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1Z" fill-rule="nonzero"/></svg>',
    "permanent-pen": '<svg width="24" height="24"><path d="M10.5 17.5 8 20H3v-3l3.5-3.5a2 2 0 0 1 0-3L14 3l1 1-7.3 7.3a1 1 0 0 0 0 1.4l3.6 3.6c.4.4 1 .4 1.4 0L20 9l1 1-7.6 7.6a2 2 0 0 1-2.8 0l-.1-.1Z" fill-rule="nonzero"/></svg>',
    plus: '<svg width="24" height="24"><path d="M12 4c.5 0 1 .4 1 .9V11h6a1 1 0 0 1 .1 2H13v6a1 1 0 0 1-2 .1V13H5a1 1 0 0 1-.1-2H11V5c0-.6.4-1 1-1Z"/></svg>',
    preferences: '<svg width="24" height="24"><path d="m20.1 13.5-1.9.2a5.8 5.8 0 0 1-.6 1.5l1.2 1.5c.4.4.3 1 0 1.4l-.7.7a1 1 0 0 1-1.4 0l-1.5-1.2a6.2 6.2 0 0 1-1.5.6l-.2 1.9c0 .5-.5.9-1 .9h-1a1 1 0 0 1-1-.9l-.2-1.9a5.8 5.8 0 0 1-1.5-.6l-1.5 1.2a1 1 0 0 1-1.4 0l-.7-.7a1 1 0 0 1 0-1.4l1.2-1.5a6.2 6.2 0 0 1-.6-1.5l-1.9-.2a1 1 0 0 1-.9-1v-1c0-.5.4-1 .9-1l1.9-.2a5.8 5.8 0 0 1 .6-1.5L5.2 7.3a1 1 0 0 1 0-1.4l.7-.7a1 1 0 0 1 1.4 0l1.5 1.2a6.2 6.2 0 0 1 1.5-.6l.2-1.9c0-.5.5-.9 1-.9h1c.5 0 1 .4 1 .9l.2 1.9a5.8 5.8 0 0 1 1.5.6l1.5-1.2a1 1 0 0 1 1.4 0l.7.7c.3.4.4 1 0 1.4l-1.2 1.5a6.2 6.2 0 0 1 .6 1.5l1.9.2c.5 0 .9.5.9 1v1c0 .5-.4 1-.9 1ZM12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z" fill-rule="evenodd"/></svg>',
    preview: '<svg width="24" height="24"><path d="M3.5 12.5c.5.8 1.1 1.6 1.8 2.3 2 2 4.2 3.2 6.7 3.2s4.7-1.2 6.7-3.2a16.2 16.2 0 0 0 2.1-2.8 15.7 15.7 0 0 0-2.1-2.8c-2-2-4.2-3.2-6.7-3.2a9.3 9.3 0 0 0-6.7 3.2A16.2 16.2 0 0 0 3.2 12c0 .2.2.3.3.5Zm-2.4-1 .7-1.2L4 7.8C6.2 5.4 8.9 4 12 4c3 0 5.8 1.4 8.1 3.8a18.2 18.2 0 0 1 2.8 3.7v1l-.7 1.2-2.1 2.5c-2.3 2.4-5 3.8-8.1 3.8-3 0-5.8-1.4-8.1-3.8a18.2 18.2 0 0 1-2.8-3.7 1 1 0 0 1 0-1Zm12-3.3a2 2 0 1 0 2.7 2.6 4 4 0 1 1-2.6-2.6Z" fill-rule="nonzero"/></svg>',
    print: '<svg width="24" height="24"><path d="M18 8H6a3 3 0 0 0-3 3v6h2v3h14v-3h2v-6a3 3 0 0 0-3-3Zm-1 10H7v-4h10v4Zm.5-5c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5 1.5.7 1.5 1.5-.7 1.5-1.5 1.5Zm.5-8H6v2h12V5Z" fill-rule="nonzero"/></svg>',
    quote: '<svg width="24" height="24"><path d="M7.5 17h.9c.4 0 .7-.2.9-.6L11 13V8c0-.6-.4-1-1-1H6a1 1 0 0 0-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 0 0 .8 1.3Zm8 0h.9c.4 0 .7-.2.9-.6L19 13V8c0-.6-.4-1-1-1h-4a1 1 0 0 0-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 0 0 .8 1.3Z" fill-rule="nonzero"/></svg>',
    redo: '<svg width="24" height="24"><path d="M17.6 10H12c-2.8 0-4.4 1.4-4.9 3.5-.4 2 .3 4 1.4 4.6a1 1 0 1 1-1 1.8c-2-1.2-2.9-4.1-2.3-6.8.6-3 3-5.1 6.8-5.1h5.6l-3.3-3.3a1 1 0 1 1 1.4-1.4l5 5a1 1 0 0 1 0 1.4l-5 5a1 1 0 0 1-1.4-1.4l3.3-3.3Z" fill-rule="nonzero"/></svg>',
    reload: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="m5 22.1-1.2-4.7v-.2a1 1 0 0 1 1-1l5 .4a1 1 0 1 1-.2 2l-2.2-.2a7.8 7.8 0 0 0 8.4.2 7.5 7.5 0 0 0 3.5-6.4 1 1 0 1 1 2 0 9.5 9.5 0 0 1-4.5 8 9.9 9.9 0 0 1-10.2 0l.4 1.4a1 1 0 1 1-2 .5ZM13.6 7.4c0-.5.5-1 1-.9l2.8.2a8 8 0 0 0-9.5-1 7.5 7.5 0 0 0-3.6 7 1 1 0 0 1-2 0 9.5 9.5 0 0 1 4.5-8.6 10 10 0 0 1 10.9.3l-.3-1a1 1 0 0 1 2-.5l1.1 4.8a1 1 0 0 1-1 1.2l-5-.4a1 1 0 0 1-.9-1Z"/></g></svg>',
    "remove-formatting": '<svg width="24" height="24"><path d="M13.2 6a1 1 0 0 1 0 .2l-2.6 10a1 1 0 0 1-1 .8h-.2a.8.8 0 0 1-.8-1l2.6-10H8a1 1 0 1 1 0-2h9a1 1 0 0 1 0 2h-3.8ZM5 18h7a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2Zm13 1.5L16.5 18 15 19.5a.7.7 0 0 1-1-1l1.5-1.5-1.5-1.5a.7.7 0 0 1 1-1l1.5 1.5 1.5-1.5a.7.7 0 0 1 1 1L17.5 17l1.5 1.5a.7.7 0 0 1-1 1Z" fill-rule="evenodd"/></svg>',
    remove: '<svg width="24" height="24"><path d="M16 7h3a1 1 0 0 1 0 2h-1v9a3 3 0 0 1-3 3H9a3 3 0 0 1-3-3V9H5a1 1 0 1 1 0-2h3V6a3 3 0 0 1 3-3h2a3 3 0 0 1 3 3v1Zm-2 0V6c0-.6-.4-1-1-1h-2a1 1 0 0 0-1 1v1h4Zm2 2H8v9c0 .6.4 1 1 1h6c.6 0 1-.4 1-1V9Zm-7 3a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0v-4Zm4 0a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0v-4Z" fill-rule="nonzero"/></svg>',
    "resize-handle": '<svg width="10" height="10"><g fill-rule="nonzero"><path d="M8.1 1.1A.5.5 0 1 1 9 2l-7 7A.5.5 0 1 1 1 8l7-7ZM8.1 5.1A.5.5 0 1 1 9 6l-3 3A.5.5 0 1 1 5 8l3-3Z"/></g></svg>',
    resize: '<svg width="24" height="24"><path d="M4 5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h6c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 0 1-.7.3H7.4L18 16.6V13c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v6c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-6a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3.6L6 7.4V11c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.7-.3A1 1 0 0 1 4 11V5Z" fill-rule="evenodd"/></svg>',
    "restore-draft": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M17 13c0 .6-.4 1-1 1h-4V8c0-.6.4-1 1-1s1 .4 1 1v4h2c.6 0 1 .4 1 1Z"/><path d="M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10Z" fill-rule="nonzero"/></g></svg>',
    "rotate-left": '<svg width="24" height="24"><path d="M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10Z" fill-rule="nonzero"/></svg>',
    "rotate-right": '<svg width="24" height="24"><path d="M20 8V5a1 1 0 0 1 2 0v6c0 .6-.4 1-1 1h-6a1 1 0 0 1 0-2h4.3L16 7A7.2 7.2 0 0 0 7.7 6a7 7 0 0 0 3 13.1c1.9.1 3.7-.5 5-1.7a1 1 0 0 1 1.4 1.5A9.2 9.2 0 0 1 2.2 14c-.9-3.9 1-8 4.5-9.9 3.5-1.9 8-1.3 10.8 1.5L20 8Z" fill-rule="nonzero"/></svg>',
    rtl: '<svg width="24" height="24"><path d="M8 5h8v2h-2v12h-2V7h-2v12H8v-7c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 4.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L8 5Zm12 11.2a1 1 0 1 1-1 1.6l-3-2a1 1 0 0 1 0-1.6l3-2a1 1 0 1 1 1 1.6L18.4 15l1.8 1.2Z" fill-rule="evenodd"/></svg>',
    save: '<svg width="24" height="24"><path d="M5 16h14a2 2 0 0 1 2 2v2a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-2c0-1.1.9-2 2-2Zm0 2v2h14v-2H5Zm10 0h2v2h-2v-2Zm-4-6.4L8.7 9.3a1 1 0 1 0-1.4 1.4l4 4c.4.4 1 .4 1.4 0l4-4a1 1 0 1 0-1.4-1.4L13 11.6V4a1 1 0 0 0-2 0v7.6Z" fill-rule="nonzero"/></svg>',
    search: '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Z" fill-rule="nonzero"/></svg>',
    "select-all": '<svg width="24" height="24"><path d="M3 5h2V3a2 2 0 0 0-2 2Zm0 8h2v-2H3v2Zm4 8h2v-2H7v2ZM3 9h2V7H3v2Zm10-6h-2v2h2V3Zm6 0v2h2a2 2 0 0 0-2-2ZM5 21v-2H3c0 1.1.9 2 2 2Zm-2-4h2v-2H3v2ZM9 3H7v2h2V3Zm2 18h2v-2h-2v2Zm8-8h2v-2h-2v2Zm0 8a2 2 0 0 0 2-2h-2v2Zm0-12h2V7h-2v2Zm0 8h2v-2h-2v2Zm-4 4h2v-2h-2v2Zm0-16h2V3h-2v2ZM7 17h10V7H7v10Zm2-8h6v6H9V9Z" fill-rule="nonzero"/></svg>',
    selected: '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2Zm3.6 10.9L7 12.3a.7.7 0 0 0-1 1L9.6 17 18 8.6a.7.7 0 0 0 0-1 .7.7 0 0 0-1 0l-7.4 7.3Z"/></svg>',
    send: '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="m13.3 22 7-18.3-18.3 7L9 15l4.3 7ZM18 6.8l-.7-.7L9.4 14l.7.7L18 6.8Z"/></svg>',
    settings: '<svg width="24" height="24"><path d="M11 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V8H5a1 1 0 1 1 0-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.5V6ZM8 8h2V6H8v2Zm9 2.8v.2h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v.3c0 .2 0 .3-.2.5l-.6.2h-2.4c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V13H5a1 1 0 0 1 0-2h8v-.3c0-.2 0-.3.2-.5l.6-.2h2.4c.3 0 .4 0 .6.2l.2.6ZM14 13h2v-2h-2v2Zm-3 2.8v.2h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V18H5a1 1 0 0 1 0-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.6ZM8 18h2v-2H8v2Z" fill-rule="evenodd"/></svg>',
    sharpen: '<svg width="24" height="24"><path d="m16 6 4 4-8 9-8-9 4-4h8Zm-4 10.2 5.5-6.2-.1-.1H12v-.3h5.1l-.2-.2H12V9h4.6l-.2-.2H12v-.3h4.1l-.2-.2H12V8h3.6l-.2-.2H8.7L6.5 10l.1.1H12v.3H6.9l.2.2H12v.3H7.3l.2.2H12v.3H7.7l.3.2h4v.3H8.2l.2.2H12v.3H8.6l.3.2H12v.3H9l.3.2H12v.3H9.5l.2.2H12v.3h-2l.2.2H12v.3h-1.6l.2.2H12v.3h-1.1l.2.2h.9v.3h-.7l.2.2h.5v.3h-.3l.3.2Z" fill-rule="evenodd"/></svg>',
    sourcecode: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M9.8 15.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0l-4.4-4.1a.8.8 0 0 1 0-1.2l4.4-4.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L6 12l3.8 3.7ZM14.2 15.7c-.3.3-.3.8 0 1 .4.4.9.4 1.2 0l4.4-4.1c.3-.3.3-.9 0-1.2l-4.4-4.2a.8.8 0 0 0-1.2 0c-.3.3-.3.8 0 1.1L18 12l-3.8 3.7Z"/></g></svg>',
    "spell-check": '<svg width="24" height="24"><path d="M6 8v3H5V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h2c.3 0 .5.1.7.3.2.2.3.4.3.7v6H8V8H6Zm0-3v2h2V5H6Zm13 0h-3v5h3v1h-3a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3v1Zm-5 1.5-.1.7c-.1.2-.3.3-.6.3.3 0 .5.1.6.3l.1.7V10c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-3V4h3c.3 0 .5.1.7.3.2.2.3.4.3.7v1.5ZM13 10V8h-2v2h2Zm0-3V5h-2v2h2Zm3 5 1 1-6.5 7L7 15.5l1.3-1 2.2 2.2L16 12Z" fill-rule="evenodd"/></svg>',
    "strike-through": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M15.6 8.5c-.5-.7-1-1.1-1.3-1.3-.6-.4-1.3-.6-2-.6-2.7 0-2.8 1.7-2.8 2.1 0 1.6 1.8 2 3.2 2.3 4.4.9 4.6 2.8 4.6 3.9 0 1.4-.7 4.1-5 4.1A6.2 6.2 0 0 1 7 16.4l1.5-1.1c.4.6 1.6 2 3.7 2 1.6 0 2.5-.4 3-1.2.4-.8.3-2-.8-2.6-.7-.4-1.6-.7-2.9-1-1-.2-3.9-.8-3.9-3.6C7.6 6 10.3 5 12.4 5c2.9 0 4.2 1.6 4.7 2.4l-1.5 1.1Z"/><path d="M5 11h14a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2Z" fill-rule="nonzero"/></g></svg>',
    subscript: '<svg width="24" height="24"><path d="m10.4 10 4.6 4.6-1.4 1.4L9 11.4 4.4 16 3 14.6 7.6 10 3 5.4 4.4 4 9 8.6 13.6 4 15 5.4 10.4 10ZM21 19h-5v-1l1-.8 1.7-1.6c.3-.4.5-.8.5-1.2 0-.3 0-.6-.2-.7-.2-.2-.5-.3-.9-.3a2 2 0 0 0-.8.2l-.7.3-.4-1.1 1-.6 1.2-.2c.8 0 1.4.3 1.8.7.4.4.6.9.6 1.5s-.2 1.1-.5 1.6a8 8 0 0 1-1.3 1.3l-.6.6h2.6V19Z" fill-rule="nonzero"/></svg>',
    superscript: '<svg width="24" height="24"><path d="M15 9.4 10.4 14l4.6 4.6-1.4 1.4L9 15.4 4.4 20 3 18.6 7.6 14 3 9.4 4.4 8 9 12.6 13.6 8 15 9.4Zm5.9 1.6h-5v-1l1-.8 1.7-1.6c.3-.5.5-.9.5-1.3 0-.3 0-.5-.2-.7-.2-.2-.5-.3-.9-.3l-.8.2-.7.4-.4-1.2c.2-.2.5-.4 1-.5.3-.2.8-.2 1.2-.2.8 0 1.4.2 1.8.6.4.4.6 1 .6 1.6 0 .5-.2 1-.5 1.5l-1.3 1.4-.6.5h2.6V11Z" fill-rule="nonzero"/></svg>',
    "table-caption": '<svg width="24" height="24"><g fill-rule="nonzero"><rect width="12" height="2" x="3" y="4" rx="1"/><path d="M19 8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-8c0-1.1.9-2 2-2h14ZM5 15v3h6v-3H5Zm14 0h-6v3h6v-3Zm0-5h-6v3h6v-3ZM5 13h6v-3H5v3Z"/></g></svg>',
    "table-cell-classes": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M13 4v9H3V6c0-1.1.9-2 2-2h8Zm-2 2H5v5h6V6Z"/><path fill-rule="nonzero" d="M13 4h6a2 2 0 0 1 2 2v7h-8v-2h6V6h-6V4Z" opacity=".2"/><path d="m18 20-2.6 1.6.7-3-2.4-2 3.1-.2 1.2-2.9 1.2 2.9 3.1.2-2.4 2 .7 3z"/><path fill-rule="nonzero" d="M3 13v5c0 1.1.9 2 2 2h8v-7h-2v5H5v-5H3Z" opacity=".2"/></g></svg>',
    "table-cell-properties": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9H5v5h6v-5Zm8 0h-6v5h6v-5Zm-8-7H5v5h6V6Z"/></svg>',
    "table-cell-select-all": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v12h14V6Z"/><path d="M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2Z" opacity=".2"/></g></svg>',
    "table-cell-select-inner": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v12h14V6Z" opacity=".2"/><path d="M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2Z"/></g></svg>',
    "table-classes": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v7h-8v7H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9H5v5h6v-5Zm8-7h-6v5h6V6Zm-8 0H5v5h6V6Z"/><path d="m18 20-2.6 1.6.7-3-2.4-2 3.1-.2 1.2-2.9 1.2 2.9 3.1.2-2.4 2 .7 3z"/></g></svg>',
    "table-delete-column": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-4 4h-2V6h-2v2H9V6H5v12h4v-2h2v2h2v-2h2v2h4V6h-4v2Zm.3.5 1 1.2-3 2.3 3 2.3-1 1.2L12 13l-3.3 2.6-1-1.2 3-2.3-3-2.3 1-1.2L12 11l3.3-2.5Z"/></svg>',
    "table-delete-row": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v3h2.5v2H5v2h2.5v2H5v3h14v-3h-2.5v-2H19v-2h-2.5V9H19V6Zm-4.7 1.8 1.2 1L13 12l2.6 3.3-1.2 1-2.3-3-2.3 3-1.2-1L11 12 8.5 8.7l1.2-1 2.3 3 2.3-3Z"/></svg>',
    "table-delete-table": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 6v12h14V6H5Z"/><path d="m14.4 8.6 1.1 1-2.4 2.4 2.4 2.4-1.1 1.1-2.4-2.4-2.4 2.4-1-1.1 2.3-2.4-2.3-2.4 1-1 2.4 2.3z"/></g></svg>',
    "table-insert-column-after": '<svg width="24" height="24"><path fill-rule="nonzero" d="M20 4c.6 0 1 .4 1 1v2a1 1 0 0 1-2 0V6h-8v12h8v-1a1 1 0 0 1 2 0v2c0 .5-.4 1-.9 1H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h15ZM9 13H5v5h4v-5Zm7-5c.5 0 1 .4 1 .9V11h2a1 1 0 0 1 .1 2H17v2a1 1 0 0 1-2 .1V13h-2a1 1 0 0 1-.1-2H15V9c0-.6.4-1 1-1ZM9 6H5v5h4V6Z"/></svg>',
    "table-insert-column-before": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a1 1 0 0 1-1-1v-2a1 1 0 0 1 2 0v1h8V6H5v1a1 1 0 1 1-2 0V5c0-.6.4-1 1-1h15Zm0 9h-4v5h4v-5ZM8 8c.5 0 1 .4 1 .9V11h2a1 1 0 0 1 .1 2H9v2a1 1 0 0 1-2 .1V13H5a1 1 0 0 1-.1-2H7V9c0-.6.4-1 1-1Zm11-2h-4v5h4V6Z"/></svg>',
    "table-insert-row-above": '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4a1 1 0 1 1 0 2H5v6h14V6h-1a1 1 0 0 1 0-2h2c.6 0 1 .4 1 1v13a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5c0-.6.4-1 1-1h2Zm5 10H5v4h6v-4Zm8 0h-6v4h6v-4ZM12 3c.5 0 1 .4 1 .9V6h2a1 1 0 0 1 0 2h-2v2a1 1 0 0 1-2 .1V8H9a1 1 0 0 1 0-2h2V4c0-.6.4-1 1-1Z"/></svg>',
    "table-insert-row-after": '<svg width="24" height="24"><path fill-rule="nonzero" d="M12 13c.5 0 1 .4 1 .9V16h2a1 1 0 0 1 .1 2H13v2a1 1 0 0 1-2 .1V18H9a1 1 0 0 1-.1-2H11v-2c0-.6.4-1 1-1Zm6 7a1 1 0 0 1 0-2h1v-6H5v6h1a1 1 0 0 1 0 2H4a1 1 0 0 1-1-1V6c0-1.1.9-2 2-2h14a2 2 0 0 1 2 2v13c0 .5-.4 1-.9 1H18ZM11 6H5v4h6V6Zm8 0h-6v4h6V6Z"/></svg>',
    "table-left-header": '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 9h-4v5h4v-5Zm-6 0H9v5h4v-5Zm0-7H9v5h4V6Zm6 0h-4v5h4V6Z"/></svg>',
    "table-merge-cells": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 15.5V18h3v-2.5H5Zm14-5h-9V18h9v-7.5ZM19 6h-4v2.5h4V6ZM8 6H5v2.5h3V6Zm5 0h-3v2.5h3V6Zm-8 7.5h3v-3H5v3Z"/></svg>',
    "table-row-numbering-rtl": '<svg width="24" height="24"><path d="M6 4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2h12a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2H6Zm0 12h8v3H6v-3Zm11 0c.6 0 1 .4 1 1v1a1 1 0 0 1-2 0v-1c0-.6.4-1 1-1ZM6 11h8v3H6v-3Zm11 0c.6 0 1 .4 1 1v1a1 1 0 0 1-2 0v-1c0-.6.4-1 1-1ZM6 6h8v3H6V6Zm11 0c.6 0 1 .4 1 1v1a1 1 0 1 1-2 0V7c0-.6.4-1 1-1Z"/></svg>',
    "table-row-numbering": '<svg width="24" height="24"><path d="M18 4a2 2 0 0 1 2 2v13a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h12Zm0 12h-8v3h8v-3ZM7 16a1 1 0 0 0-1 1v1a1 1 0 0 0 2 0v-1c0-.6-.4-1-1-1Zm11-5h-8v3h8v-3ZM7 11a1 1 0 0 0-1 1v1a1 1 0 0 0 2 0v-1c0-.6-.4-1-1-1Zm11-5h-8v3h8V6ZM7 6a1 1 0 0 0-1 1v1a1 1 0 1 0 2 0V7c0-.6-.4-1-1-1Z"/></svg>',
    "table-row-properties": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 15v3h6v-3H5Zm14 0h-6v3h6v-3Zm0-9h-6v3h6V6ZM5 9h6V6H5v3Z"/></svg>',
    "table-split-cells": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM8 15.5H5V18h3v-2.5Zm11-5h-9V18h9v-7.5Zm-2.5 1 1 1-2 2 2 2-1 1-2-2-2 2-1-1 2-2-2-2 1-1 2 2 2-2Zm-8.5-1H5v3h3v-3ZM19 6h-4v2.5h4V6ZM8 6H5v2.5h3V6Zm5 0h-3v2.5h3V6Z"/></svg>',
    "table-top-header": '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 11H5v3h6v-3Zm8 0h-6v3h6v-3Zm0-5h-6v3h6v-3ZM5 13h6v-3H5v3Z"/></svg>',
    table: '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 14v4h6v-4H5Zm14 0h-6v4h6v-4Zm0-6h-6v4h6V8ZM5 12h6V8H5v4Z"/></svg>',
    "template-add": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 12v4H5a2 2 0 0 0-2 2v3h9.3a6 6 0 0 1-.3-2H5v-1h7a6 6 0 0 1 .8-2H11v-5l-.8-.6a3 3 0 1 1 3.6 0l-.8.6v4.7a6 6 0 0 1 2-1.9V12a5 5 0 1 0-6 0Z"/><path d="M18 15c.5 0 1 .4 1 .9V18h2a1 1 0 0 1 .1 2H19v2a1 1 0 0 1-2 .1V20h-2a1 1 0 0 1-.1-2H17v-2c0-.6.4-1 1-1Z"/></svg>',
    template: '<svg width="24" height="24"><path d="M19 19v-1H5v1h14ZM9 16v-4a5 5 0 1 1 6 0v4h4a2 2 0 0 1 2 2v3H3v-3c0-1.1.9-2 2-2h4Zm4 0v-5l.8-.6a3 3 0 1 0-3.6 0l.8.6v5h2Z" fill-rule="nonzero"/></svg>',
    "temporary-placeholder": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M9 7.6V6h2.5V4.5a.5.5 0 1 1 1 0V6H15v1.6a8 8 0 1 1-6 0Zm-2.6 5.3a.5.5 0 0 0 .3.6c.3 0 .6 0 .6-.3l.1-.2a5 5 0 0 1 3.3-2.8c.3-.1.4-.4.4-.6-.1-.3-.4-.5-.6-.4a6 6 0 0 0-4.1 3.7Z"/><circle cx="14" cy="4" r="1"/><circle cx="12" cy="2" r="1"/><circle cx="10" cy="4" r="1"/></g></svg>',
    "text-color": '<svg width="24" height="24"><g fill-rule="evenodd"><path class="tox-icon-text-color__color" d="M3 18h18v3H3z"/><path d="M8.7 16h-.8a.5.5 0 0 1-.5-.6l2.7-9c.1-.3.3-.4.5-.4h2.8c.2 0 .4.1.5.4l2.7 9a.5.5 0 0 1-.5.6h-.8a.5.5 0 0 1-.4-.4l-.7-2.2c0-.3-.3-.4-.5-.4h-3.4c-.2 0-.4.1-.5.4l-.7 2.2c0 .3-.2.4-.4.4Zm2.6-7.6-.6 2a.5.5 0 0 0 .5.6h1.6a.5.5 0 0 0 .5-.6l-.6-2c0-.3-.3-.4-.5-.4h-.4c-.2 0-.4.1-.5.4Z"/></g></svg>',
    "text-size-decrease": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M14 5a1 1 0 1 1 0 2h-4v11a1 1 0 1 1-2 0V7H4a1 1 0 0 1 0-2h10ZM14 12a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2h-6Z"/></svg>',
    "text-size-increase": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M14 5a1 1 0 1 1 0 2h-4v11a1 1 0 1 1-2 0V7H4a1 1 0 0 1 0-2h10ZM17 9a1 1 0 0 0-1 1v2h-2a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0v-2h2a1 1 0 1 0 0-2h-2v-2c0-.6-.4-1-1-1Z"/></svg>',
    toc: '<svg width="24" height="24"><path d="M5 5c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 1 1 0-2Zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 1 1 0-2Zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm0-4c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 1 1 0-2Zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    translate: '<svg width="24" height="24"><path d="m12.7 14.3-.3.7-.4.7-2.2-2.2-3.1 3c-.3.4-.8.4-1 0a.7.7 0 0 1 0-1l3.1-3A12.4 12.4 0 0 1 6.7 9H8a10.1 10.1 0 0 0 1.7 2.4c.5-.5 1-1.1 1.4-1.8l.9-2H4.7a.7.7 0 1 1 0-1.5h4.4v-.7c0-.4.3-.8.7-.8.4 0 .7.4.7.8v.7H15c.4 0 .8.3.8.7 0 .4-.4.8-.8.8h-1.4a12.3 12.3 0 0 1-1 2.4 13.5 13.5 0 0 1-1.7 2.3l1.9 1.8Zm4.3-3 2.7 7.3a.5.5 0 0 1-.4.7 1 1 0 0 1-1-.7l-.6-1.5h-3.4l-.6 1.5a1 1 0 0 1-1 .7.5.5 0 0 1-.4-.7l2.7-7.4a1 1 0 0 1 2 0Zm-2.2 4.4h2.4L16 12.5l-1.2 3.2Z" fill-rule="evenodd"/></svg>',
    typography: '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M17 5a1 1 0 1 1 0 2h-4v11a1 1 0 1 1-2 0V7H7a1 1 0 0 1 0-2h10Z"/><path d="m17.5 14 .8-1.7 1.7-.8-1.7-.8-.8-1.7-.8 1.7-1.7.8 1.7.8.8 1.7ZM7 14l1 2 2 1-2 1-1 2-1-2-2-1 2-1 1-2Z"/></svg>',
    underline: '<svg width="24" height="24"><path d="M16 5c.6 0 1 .4 1 1v5.5a4 4 0 0 1-.4 1.8l-1 1.4a5.3 5.3 0 0 1-5.5 1 5 5 0 0 1-1.6-1c-.5-.4-.8-.9-1.1-1.4a4 4 0 0 1-.4-1.8V6c0-.6.4-1 1-1s1 .4 1 1v5.5c0 .3 0 .6.2 1l.6.7a3.3 3.3 0 0 0 2.2.8 3.4 3.4 0 0 0 2.2-.8c.3-.2.4-.5.6-.8l.2-.9V6c0-.6.4-1 1-1ZM8 17h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    undo: '<svg width="24" height="24"><path d="M6.4 8H12c3.7 0 6.2 2 6.8 5.1.6 2.7-.4 5.6-2.3 6.8a1 1 0 0 1-1-1.8c1.1-.6 1.8-2.7 1.4-4.6-.5-2.1-2.1-3.5-4.9-3.5H6.4l3.3 3.3a1 1 0 1 1-1.4 1.4l-5-5a1 1 0 0 1 0-1.4l5-5a1 1 0 0 1 1.4 1.4L6.4 8Z" fill-rule="nonzero"/></svg>',
    unlink: '<svg width="24" height="24"><path d="M6.2 12.3a1 1 0 0 1 1.4 1.4l-2 2a2 2 0 1 0 2.6 2.8l4.8-4.8a1 1 0 0 0 0-1.4 1 1 0 1 1 1.4-1.3 2.9 2.9 0 0 1 0 4L9.6 20a3.9 3.9 0 0 1-5.5-5.5l2-2Zm11.6-.6a1 1 0 0 1-1.4-1.4l2.1-2a2 2 0 1 0-2.7-2.8L11 10.3a1 1 0 0 0 0 1.4A1 1 0 1 1 9.6 13a2.9 2.9 0 0 1 0-4L14.4 4a3.9 3.9 0 0 1 5.5 5.5l-2 2ZM7.6 6.3a.8.8 0 0 1-1 1.1L3.3 4.2a.7.7 0 1 1 1-1l3.2 3.1ZM5.1 8.6a.8.8 0 0 1 0 1.5H3a.8.8 0 0 1 0-1.5H5Zm5-3.5a.8.8 0 0 1-1.5 0V3a.8.8 0 0 1 1.5 0V5Zm6 11.8a.8.8 0 0 1 1-1l3.2 3.2a.8.8 0 0 1-1 1L16 17Zm-2.2 2a.8.8 0 0 1 1.5 0V21a.8.8 0 0 1-1.5 0V19Zm5-3.5a.7.7 0 1 1 0-1.5H21a.8.8 0 0 1 0 1.5H19Z" fill-rule="nonzero"/></svg>',
    unlock: '<svg width="24" height="24"><path d="M16 5c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h-2V8a1 1 0 0 0-.3-.7A1 1 0 0 0 16 7h-2a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7v3h.3c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H4.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H11V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2Z" fill-rule="evenodd"/></svg>',
    "unordered-list": '<svg width="24" height="24"><path d="M11 5h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2ZM4.5 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Z" fill-rule="evenodd"/></svg>',
    unselected: '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2Zm0 1a1 1 0 0 0-1 1v12c0 .6.4 1 1 1h12c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H6Z"/></svg>',
    upload: '<svg width="24" height="24"><path d="M18 19v-2a1 1 0 0 1 2 0v3c0 .6-.4 1-1 1H5a1 1 0 0 1-1-1v-3a1 1 0 0 1 2 0v2h12ZM11 6.4 8.7 8.7a1 1 0 0 1-1.4-1.4l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 1 1-1.4 1.4L13 6.4V16a1 1 0 0 1-2 0V6.4Z" fill-rule="nonzero"/></svg>',
    user: '<svg width="24" height="24"><path d="M12 24a12 12 0 1 1 0-24 12 12 0 0 1 0 24Zm-8.7-5.3a11 11 0 0 0 17.4 0C19.4 16.3 14.6 15 12 15c-2.6 0-7.4 1.3-8.7 3.7ZM12 13c2.2 0 4-2 4-4.5S14.2 4 12 4 8 6 8 8.5 9.8 13 12 13Z" fill-rule="nonzero"/></svg>',
    "vertical-align": '<svg width="24" height="24"><g fill-rule="nonzero"><rect width="18" height="2" x="3" y="11" rx="1"/><path d="M12 2c.6 0 1 .4 1 1v4l2-1.3a1 1 0 0 1 1.2 1.5l-.1.1-4.1 3-4-3a1 1 0 0 1 1-1.7l2 1.5V3c0-.6.4-1 1-1zm0 11.8 4 2.9a1 1 0 0 1-1 1.7l-2-1.5V21c0 .5-.4 1-.9 1H12a1 1 0 0 1-1-1v-4l-2 1.3a1 1 0 0 1-1.2-.1l-.1-.1a1 1 0 0 1 .1-1.3l.1-.1 4.1-3z"/></g></svg>',
    visualblocks: '<svg width="24" height="24"><path d="M9 19v2H7v-2h2Zm-4 0v2a2 2 0 0 1-2-2h2Zm8 0v2h-2v-2h2Zm8 0a2 2 0 0 1-2 2v-2h2Zm-4 0v2h-2v-2h2ZM15 7a1 1 0 0 1 0 2v7a1 1 0 0 1-2 0V9h-1v7a1 1 0 0 1-2 0v-4a2.5 2.5 0 0 1-.2-5H15ZM5 15v2H3v-2h2Zm16 0v2h-2v-2h2ZM5 11v2H3v-2h2Zm16 0v2h-2v-2h2ZM5 7v2H3V7h2Zm16 0v2h-2V7h2ZM5 3v2H3c0-1.1.9-2 2-2Zm8 0v2h-2V3h2Zm6 0a2 2 0 0 1 2 2h-2V3ZM9 3v2H7V3h2Zm8 0v2h-2V3h2Z" fill-rule="evenodd"/></svg>',
    visualchars: '<svg width="24" height="24"><path d="M10 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 6.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L10 5Z" fill-rule="evenodd"/></svg>',
    warning: '<svg width="24" height="24"><path d="M19.8 18.3c.2.5.3.9 0 1.2-.1.3-.5.5-1 .5H5.2c-.5 0-.9-.2-1-.5-.3-.3-.2-.7 0-1.2L11 4.7l.5-.5.5-.2c.2 0 .3 0 .5.2.2 0 .3.3.5.5l6.8 13.6ZM12 18c.3 0 .5-.1.7-.3.2-.2.3-.4.3-.7a1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7c0 .3.1.5.3.7.2.2.4.3.7.3Zm.7-3 .3-4a1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7l.3 4h1.4Z" fill-rule="evenodd"/></svg>',
    "zoom-in": '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Zm-1-9a1 1 0 0 1 2 0v6a1 1 0 0 1-2 0V8Zm-2 4a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2H8Z" fill-rule="nonzero"/></svg>',
    "zoom-out": '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Zm-3-5a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2H8Z" fill-rule="nonzero"/></svg>'
  }
});
(function() {
  var r = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const o = (M, W, de) => {
    var Ee;
    return de(M, W.prototype) ? !0 : ((Ee = M.constructor) === null || Ee === void 0 ? void 0 : Ee.name) === W.name;
  }, c = (M) => {
    const W = typeof M;
    return M === null ? "null" : W === "object" && Array.isArray(M) ? "array" : W === "object" && o(M, String, (de, Ee) => Ee.isPrototypeOf(de)) ? "string" : W;
  }, i = (M) => (W) => c(W) === M, d = (M) => (W) => typeof W === M, m = (M) => (W) => M === W, v = i("string"), g = i("array"), C = d("boolean"), O = m(void 0), R = (M) => M == null, I = (M) => !R(M), L = d("function"), Z = d("number"), ne = () => {
  }, se = (M, W) => (de) => M(W(de)), Q = (M) => () => M, he = (M) => M, ue = (M, W) => M === W;
  function G(M, ...W) {
    return (...de) => {
      const Ee = W.concat(de);
      return M.apply(null, Ee);
    };
  }
  const me = (M) => {
    M();
  }, we = Q(!1), be = Q(!0);
  class q {
    constructor(W, de) {
      this.tag = W, this.value = de;
    }
    static some(W) {
      return new q(!0, W);
    }
    static none() {
      return q.singletonNone;
    }
    fold(W, de) {
      return this.tag ? de(this.value) : W();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(W) {
      return this.tag ? q.some(W(this.value)) : q.none();
    }
    bind(W) {
      return this.tag ? W(this.value) : q.none();
    }
    exists(W) {
      return this.tag && W(this.value);
    }
    forall(W) {
      return !this.tag || W(this.value);
    }
    filter(W) {
      return !this.tag || W(this.value) ? this : q.none();
    }
    getOr(W) {
      return this.tag ? this.value : W;
    }
    or(W) {
      return this.tag ? this : W;
    }
    getOrThunk(W) {
      return this.tag ? this.value : W();
    }
    orThunk(W) {
      return this.tag ? this : W();
    }
    getOrDie(W) {
      if (this.tag)
        return this.value;
      throw new Error(W ?? "Called getOrDie on None");
    }
    static from(W) {
      return I(W) ? q.some(W) : q.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(W) {
      this.tag && W(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  q.singletonNone = new q(!1);
  const Te = Object.keys, Le = Object.hasOwnProperty, je = (M, W) => {
    const de = Te(M);
    for (let Ee = 0, qe = de.length; Ee < qe; Ee++) {
      const kt = de[Ee], tn = M[kt];
      W(tn, kt);
    }
  }, Ie = (M) => (W, de) => {
    M[de] = W;
  }, Ce = (M, W, de, Ee) => {
    je(M, (qe, kt) => {
      (W(qe, kt) ? de : Ee)(qe, kt);
    });
  }, pt = (M, W) => {
    const de = {};
    return Ce(M, W, Ie(de), ne), de;
  }, sn = (M, W) => {
    const de = [];
    return je(M, (Ee, qe) => {
      de.push(W(Ee, qe));
    }), de;
  }, Lt = (M) => sn(M, he), z = (M) => Te(M).length, bt = (M, W) => at(M, W) ? q.from(M[W]) : q.none(), at = (M, W) => Le.call(M, W), _n = (M, W) => at(M, W) && M[W] !== void 0 && M[W] !== null, st = (M) => {
    for (const W in M)
      if (Le.call(M, W))
        return !1;
    return !0;
  }, Ne = Array.prototype.indexOf, vt = Array.prototype.push, Gt = (M, W) => Ne.call(M, W), xt = (M, W) => Gt(M, W) > -1, cn = (M, W) => {
    for (let de = 0, Ee = M.length; de < Ee; de++) {
      const qe = M[de];
      if (W(qe, de))
        return !0;
    }
    return !1;
  }, He = (M, W) => {
    const de = [];
    for (let Ee = 0; Ee < M; Ee++)
      de.push(W(Ee));
    return de;
  }, ut = (M, W) => {
    const de = M.length, Ee = new Array(de);
    for (let qe = 0; qe < de; qe++) {
      const kt = M[qe];
      Ee[qe] = W(kt, qe);
    }
    return Ee;
  }, oe = (M, W) => {
    for (let de = 0, Ee = M.length; de < Ee; de++) {
      const qe = M[de];
      W(qe, de);
    }
  }, qn = (M, W) => {
    for (let de = M.length - 1; de >= 0; de--) {
      const Ee = M[de];
      W(Ee, de);
    }
  }, Rn = (M, W) => {
    const de = [], Ee = [];
    for (let qe = 0, kt = M.length; qe < kt; qe++) {
      const tn = M[qe];
      (W(tn, qe) ? de : Ee).push(tn);
    }
    return {
      pass: de,
      fail: Ee
    };
  }, Zt = (M, W) => {
    const de = [];
    for (let Ee = 0, qe = M.length; Ee < qe; Ee++) {
      const kt = M[Ee];
      W(kt, Ee) && de.push(kt);
    }
    return de;
  }, Jt = (M, W, de) => (qn(M, (Ee, qe) => {
    de = W(de, Ee, qe);
  }), de), wo = (M, W, de) => (oe(M, (Ee, qe) => {
    de = W(de, Ee, qe);
  }), de), Ge = (M, W, de) => {
    for (let Ee = 0, qe = M.length; Ee < qe; Ee++) {
      const kt = M[Ee];
      if (W(kt, Ee))
        return q.some(kt);
      if (de(kt, Ee))
        break;
    }
    return q.none();
  }, qt = (M, W) => Ge(M, W, we), St = (M) => {
    const W = [];
    for (let de = 0, Ee = M.length; de < Ee; ++de) {
      if (!g(M[de]))
        throw new Error("Arr.flatten item " + de + " was not an array, input: " + M);
      vt.apply(W, M[de]);
    }
    return W;
  }, ke = (M, W) => St(ut(M, W)), Ct = (M, W) => {
    for (let de = 0, Ee = M.length; de < Ee; ++de) {
      const qe = M[de];
      if (W(qe, de) !== !0)
        return !1;
    }
    return !0;
  }, an = (M, W) => {
    const de = {};
    for (let Ee = 0, qe = M.length; Ee < qe; Ee++) {
      const kt = M[Ee];
      de[String(kt)] = W(kt, Ee);
    }
    return de;
  }, ht = (M, W) => W >= 0 && W < M.length ? q.some(M[W]) : q.none(), bn = (M) => ht(M, 0), Ye = (M) => ht(M, M.length - 1), nn = (M, W) => {
    for (let de = 0; de < M.length; de++) {
      const Ee = W(M[de], de);
      if (Ee.isSome())
        return Ee;
    }
    return q.none();
  }, Bt = 8, $n = 9, mr = 11, gr = 1, Vr = 3, Xr = (M, W) => {
    const Ee = (W || document).createElement("div");
    if (Ee.innerHTML = M, !Ee.hasChildNodes() || Ee.childNodes.length > 1) {
      const qe = "HTML does not have a single root node";
      throw console.error(qe, M), new Error(qe);
    }
    return uo(Ee.childNodes[0]);
  }, pc = (M, W) => {
    const Ee = (W || document).createElement(M);
    return uo(Ee);
  }, Eo = (M, W) => {
    const Ee = (W || document).createTextNode(M);
    return uo(Ee);
  }, uo = (M) => {
    if (M == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: M };
  }, br = {
    fromHtml: Xr,
    fromTag: pc,
    fromText: Eo,
    fromDom: uo,
    fromPoint: (M, W, de) => q.from(M.dom.elementFromPoint(W, de)).map(uo)
  }, hs = (M, W) => {
    const de = M.dom;
    if (de.nodeType !== gr)
      return !1;
    {
      const Ee = de;
      if (Ee.matches !== void 0)
        return Ee.matches(W);
      if (Ee.msMatchesSelector !== void 0)
        return Ee.msMatchesSelector(W);
      if (Ee.webkitMatchesSelector !== void 0)
        return Ee.webkitMatchesSelector(W);
      if (Ee.mozMatchesSelector !== void 0)
        return Ee.mozMatchesSelector(W);
      throw new Error("Browser lacks native selectors");
    }
  }, Ps = (M) => M.nodeType !== gr && M.nodeType !== $n && M.nodeType !== mr || M.childElementCount === 0, qo = (M, W) => {
    const de = W === void 0 ? document : W.dom;
    return Ps(de) ? [] : ut(de.querySelectorAll(M), br.fromDom);
  }, hc = (M, W) => {
    const de = W === void 0 ? document : W.dom;
    return Ps(de) ? q.none() : q.from(de.querySelector(M)).map(br.fromDom);
  }, Co = (M, W) => M.dom === W.dom, fl = hs;
  typeof window < "u" || Function("return this;")();
  const fn = (M) => M.dom.nodeName.toLowerCase(), Yr = (M) => M.dom.nodeType, xa = (M) => (W) => Yr(W) === M, $i = (M) => Yr(M) === Bt || fn(M) === "#comment", Kc = xa(gr), wi = xa(Vr), es = xa($n), gc = xa(mr), Xl = (M) => (W) => Kc(W) && fn(W) === M, gs = (M) => br.fromDom(M.dom.ownerDocument), lr = (M) => es(M) ? M : gs(M), Ei = (M) => q.from(M.dom.parentNode).map(br.fromDom), Jl = (M, W) => {
    const de = L(W) ? W : we;
    let Ee = M.dom;
    const qe = [];
    for (; Ee.parentNode !== null && Ee.parentNode !== void 0; ) {
      const kt = Ee.parentNode, tn = br.fromDom(kt);
      if (qe.push(tn), de(tn) === !0)
        break;
      Ee = kt;
    }
    return qe;
  }, Pd = (M) => q.from(M.dom.previousSibling).map(br.fromDom), Xf = (M) => q.from(M.dom.nextSibling).map(br.fromDom), Qa = (M) => ut(M.dom.childNodes, br.fromDom), Xa = (M, W) => {
    const de = M.dom.childNodes;
    return q.from(de[W]).map(br.fromDom);
  }, ia = (M) => Xa(M, 0), Nl = (M) => gc(M) && I(M.dom.host), Yu = L(Element.prototype.attachShadow) && L(Node.prototype.getRootNode) ? (M) => br.fromDom(M.dom.getRootNode()) : lr, vc = (M) => {
    const W = Yu(M);
    return Nl(W) ? q.some(W) : q.none();
  }, ea = (M) => br.fromDom(M.dom.host), bc = (M) => {
    const W = wi(M) ? M.dom.parentNode : M.dom;
    if (W == null || W.ownerDocument === null)
      return !1;
    const de = W.ownerDocument;
    return vc(br.fromDom(W)).fold(() => de.body.contains(W), se(bc, ea));
  };
  var Qu = (M, W, de, Ee, qe) => M(de, Ee) ? q.some(de) : L(qe) && qe(de) ? q.none() : W(de, Ee, qe);
  const wp = (M, W, de) => {
    let Ee = M.dom;
    const qe = L(de) ? de : we;
    for (; Ee.parentNode; ) {
      Ee = Ee.parentNode;
      const kt = br.fromDom(Ee);
      if (W(kt))
        return q.some(kt);
      if (qe(kt))
        break;
    }
    return q.none();
  }, of = (M, W, de) => Qu((qe, kt) => kt(qe), wp, M, W, de), Ou = (M, W) => {
    const de = (qe) => W(br.fromDom(qe));
    return qt(M.dom.childNodes, de).map(br.fromDom);
  }, Au = (M, W, de) => wp(M, (Ee) => hs(Ee, W), de), nt = (M, W) => Ou(M, (de) => hs(de, W)), Ja = (M, W) => hc(W, M), eu = (M, W, de) => Qu((qe, kt) => hs(qe, kt), Au, M, W, de), Ep = (M) => eu(M, "[contenteditable]"), Jf = (M, W = !1) => bc(M) ? M.dom.isContentEditable : Ep(M).fold(Q(W), (de) => os(de) === "true"), os = (M) => M.dom.contentEditable, Cp = (M) => M.nodeName.toLowerCase(), Am = (M) => br.fromDom(M.getBody()), tu = (M) => (W) => Co(W, Am(M)), em = (M) => M ? M.replace(/px$/, "") : "", Hs = (M) => /^\d+(\.\d+)?$/.test(M) ? M + "px" : M, Gs = (M) => br.fromDom(M.selection.getStart()), Ac = (M) => br.fromDom(M.selection.getEnd()), kc = (M) => of(M, Xl("table")).forall(Jf), Xu = (M, W) => Zt(Qa(M), W), Ju = (M, W) => {
    let de = [];
    return oe(Qa(M), (Ee) => {
      W(Ee) && (de = de.concat([Ee])), de = de.concat(Ju(Ee, W));
    }), de;
  }, ed = (M, W) => Xu(M, (de) => hs(de, W)), $o = (M, W) => qo(W, M), ei = (M, W, de) => {
    if (v(de) || C(de) || Z(de))
      M.setAttribute(W, de + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", W, ":: Value ", de, ":: Element ", M), new Error("Attribute value was not simple");
  }, Rl = (M, W, de) => {
    ei(M.dom, W, de);
  }, td = (M, W) => {
    const de = M.dom;
    je(W, (Ee, qe) => {
      ei(de, qe, Ee);
    });
  }, Xi = (M, W) => {
    const de = M.dom.getAttribute(W);
    return de === null ? void 0 : de;
  }, Zs = (M, W) => q.from(Xi(M, W)), ss = (M, W) => {
    M.dom.removeAttribute(W);
  }, yc = (M) => wo(M.dom.attributes, (W, de) => (W[de.name] = de.value, W), {}), tm = (M, W, de = ue) => M.exists((Ee) => de(Ee, W)), Io = (M) => {
    const W = [], de = (Ee) => {
      W.push(Ee);
    };
    for (let Ee = 0; Ee < M.length; Ee++)
      M[Ee].each(de);
    return W;
  }, za = (M, W, de) => M.isSome() && W.isSome() ? q.some(de(M.getOrDie(), W.getOrDie())) : q.none(), ti = (M) => M.bind(he), Ra = (M, W) => M ? q.some(W) : q.none(), Pl = (M, W) => M.substring(W), nu = (M, W, de) => W === "" || M.length >= W.length && M.substr(de, de + W.length) === W, Ii = (M, W) => Dl(M, W) ? Pl(M, W.length) : M, Dl = (M, W) => nu(M, W, 0), km = ((M) => (W) => W.replace(M, ""))(/^\s+|\s+$/g), Il = (M) => M.length > 0, xp = (M) => !Il(M), Nc = (M, W = 10) => {
    const de = parseInt(M, W);
    return isNaN(de) ? q.none() : q.some(de);
  }, ku = (M) => {
    const W = parseFloat(M);
    return isNaN(W) ? q.none() : q.some(W);
  }, sf = (M) => M.style !== void 0 && L(M.style.getPropertyValue), Nm = (M, W, de) => {
    if (!v(de))
      throw console.error("Invalid call to CSS.set. Property ", W, ":: Value ", de, ":: Element ", M), new Error("CSS value must be a string: " + de);
    sf(M) && M.style.setProperty(W, de);
  }, Tp = (M, W) => {
    sf(M) && M.style.removeProperty(W);
  }, Se = (M, W, de) => {
    const Ee = M.dom;
    Nm(Ee, W, de);
  }, Ve = (M, W) => {
    const de = M.dom, qe = window.getComputedStyle(de).getPropertyValue(W);
    return qe === "" && !bc(M) ? tt(de, W) : qe;
  }, tt = (M, W) => sf(M) ? M.style.getPropertyValue(W) : "", wt = (M, W) => {
    const de = M.dom, Ee = tt(de, W);
    return q.from(Ee).filter((qe) => qe.length > 0);
  }, en = (M, W) => {
    const de = M.dom;
    Tp(de, W), tm(Zs(M, "style").map(km), "") && ss(M, "style");
  }, ur = (M, W, de = 0) => Zs(M, W).map((Ee) => parseInt(Ee, 10)).getOr(de), Yo = (M, W) => Lr(M, W, be), Lr = (M, W, de) => ke(Qa(M), (Ee) => hs(Ee, W) ? de(Ee) ? [Ee] : [] : Lr(Ee, W, de)), Nr = [
    "tfoot",
    "thead",
    "tbody",
    "colgroup"
  ], Ks = (M) => xt(Nr, M), fo = (M, W) => ({
    rows: M,
    columns: W
  }), ta = (M, W, de) => ({
    element: M,
    rowspan: W,
    colspan: de
  }), Yc = (M, W, de, Ee, qe, kt) => ({
    element: M,
    rowspan: W,
    colspan: de,
    row: Ee,
    column: qe,
    isLocked: kt
  }), Rm = (M, W, de) => ({
    element: M,
    cells: W,
    section: de
  }), kn = (M, W, de, Ee) => ({
    startRow: M,
    startCol: W,
    finishRow: de,
    finishCol: Ee
  }), Pm = (M, W, de) => ({
    element: M,
    colspan: W,
    column: de
  }), ca = (M, W) => ({
    element: M,
    columns: W
  }), as = (M, W, de = we) => {
    if (de(W))
      return q.none();
    if (xt(M, fn(W)))
      return q.some(W);
    const Ee = (qe) => hs(qe, "table") || de(qe);
    return Au(W, M.join(","), Ee);
  }, _p = (M, W) => as([
    "td",
    "th"
  ], M, W), vs = (M) => Yo(M, "th,td"), Wv = (M) => hs(M, "colgroup") ? ed(M, "col") : ke(Sr(M), (W) => ed(W, "col")), Va = (M, W) => eu(M, "table", W), Sc = (M) => Yo(M, "tr"), Sr = (M) => Va(M).fold(Q([]), (W) => ed(W, "colgroup")), Rc = (M, W) => ut(M, (de) => {
    if (fn(de) === "colgroup") {
      const Ee = ut(Wv(de), (qe) => {
        const kt = ur(qe, "span", 1);
        return ta(qe, 1, kt);
      });
      return Rm(de, Ee, "colgroup");
    } else {
      const Ee = ut(vs(de), (qe) => {
        const kt = ur(qe, "rowspan", 1), tn = ur(qe, "colspan", 1);
        return ta(qe, kt, tn);
      });
      return Rm(de, Ee, W(de));
    }
  }), rn = (M) => Ei(M).map((W) => {
    const de = fn(W);
    return Ks(de) ? de : "tbody";
  }).getOr("tbody"), na = (M) => {
    const W = Sc(M), Ee = [
      ...Sr(M),
      ...W
    ];
    return Rc(Ee, rn);
  }, Dm = "data-snooker-locked-cols", Ta = (M) => Zs(M, Dm).bind((W) => q.from(W.match(/\d+/g))).map((W) => an(W, be)), bs = (M, W) => M + "," + W, Dd = (M, W, de) => q.from(M.access[bs(W, de)]), Ur = (M, W, de) => {
    const Ee = Qc(M, (qe) => de(W, qe.element));
    return Ee.length > 0 ? q.some(Ee[0]) : q.none();
  }, Qc = (M, W) => {
    const de = ke(M.all, (Ee) => Ee.cells);
    return Zt(de, W);
  }, ni = (M) => {
    const W = {};
    let de = 0;
    return oe(M.cells, (Ee) => {
      const qe = Ee.colspan;
      He(qe, (kt) => {
        const tn = de + kt;
        W[tn] = Pm(Ee.element, qe, tn);
      }), de += qe;
    }), W;
  }, Xc = (M) => {
    const W = {}, de = [], qe = bn(M).map((zl) => zl.element).bind(Va).bind(Ta).getOr({});
    let kt = 0, tn = 0, Sn = 0;
    const {
      pass: Xn,
      fail: Pr
    } = Rn(M, (zl) => zl.section === "colgroup");
    oe(Pr, (zl) => {
      const Ic = [];
      oe(zl.cells, (uu) => {
        let bf = 0;
        for (; W[bs(Sn, bf)] !== void 0; )
          bf++;
        const Bd = _n(qe, bf.toString()), Mp = Yc(uu.element, uu.rowspan, uu.colspan, Sn, bf, Bd);
        for (let Ro = 0; Ro < uu.colspan; Ro++)
          for (let Fp = 0; Fp < uu.rowspan; Fp++) {
            const qg = Sn + Fp, Sa = bf + Ro, du = bs(qg, Sa);
            W[du] = Mp, tn = Math.max(tn, Sa + 1);
          }
        Ic.push(Mp);
      }), kt++, de.push(Rm(zl.element, Ic, zl.section)), Sn++;
    });
    const { columns: la, colgroups: Lo } = Ye(Xn).map((zl) => {
      const Ic = ni(zl);
      return {
        colgroups: [ca(zl.element, Lt(Ic))],
        columns: Ic
      };
    }).getOrThunk(() => ({
      colgroups: [],
      columns: {}
    }));
    return {
      grid: fo(kt, tn),
      access: W,
      all: de,
      columns: la,
      colgroups: Lo
    };
  }, Nu = {
    fromTable: (M) => {
      const W = na(M);
      return Xc(W);
    },
    generate: Xc,
    getAt: Dd,
    findItem: Ur,
    filterItems: Qc,
    justCells: (M) => ke(M.all, (W) => W.cells),
    justColumns: (M) => Lt(M.columns),
    hasColumns: (M) => Te(M.columns).length > 0,
    getColumnAt: (M, W) => q.from(M.columns[W])
  };
  var Ru = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const Jc = (M, W, de) => {
    const Ee = M.select("td,th", W);
    let qe;
    for (let kt = 0; kt < Ee.length; kt++) {
      const tn = M.getStyle(Ee[kt], de);
      if (O(qe) && (qe = tn), qe !== tn)
        return "";
    }
    return qe;
  }, Ml = (M, W, de) => {
    Ru.each("left center right".split(" "), (Ee) => {
      Ee !== de && M.formatter.remove("align" + Ee, {}, W);
    }), de && M.formatter.apply("align" + de, {}, W);
  }, Op = (M, W, de) => {
    Ru.each("top middle bottom".split(" "), (Ee) => {
      Ee !== de && M.formatter.remove("valign" + Ee, {}, W);
    }), de && M.formatter.apply("valign" + de, {}, W);
  }, no = (M, W, de) => {
    M.dispatch("TableModified", {
      ...de,
      table: W
    });
  }, Oa = (M, W) => ku(M).getOr(W), Pa = (M, W, de) => Oa(Ve(M, W), de), jv = (M, W, de, Ee) => {
    const qe = Pa(M, `padding-${de}`, 0), kt = Pa(M, `padding-${Ee}`, 0), tn = Pa(M, `border-${de}-width`, 0), Sn = Pa(M, `border-${Ee}-width`, 0);
    return W - qe - kt - tn - Sn;
  }, zs = (M, W) => {
    const de = M.dom, Ee = de.getBoundingClientRect().width || de.offsetWidth;
    return W === "border-box" ? Ee : jv(M, Ee, "left", "right");
  }, hi = (M) => zs(M, "content-box");
  var Fh = tinymce.util.Tools.resolve("tinymce.Env");
  const Lh = "tableprops tabledelete | tableinsertrowbefore tableinsertrowafter tabledeleterow | tableinsertcolbefore tableinsertcolafter tabledeletecol", Fl = He(5, (M) => {
    const W = `${M + 1}px`;
    return {
      title: W,
      value: W
    };
  }), $m = ut([
    "Solid",
    "Dotted",
    "Dashed",
    "Double",
    "Groove",
    "Ridge",
    "Inset",
    "Outset",
    "None",
    "Hidden"
  ], (M) => ({
    title: M,
    value: M.toLowerCase()
  })), is = "100%", ru = (M) => {
    var W;
    const de = M.dom, Ee = (W = de.getParent(M.selection.getStart(), de.isBlock)) !== null && W !== void 0 ? W : M.getBody();
    return hi(br.fromDom(Ee)) + "px";
  }, Ji = (M, W) => Mg(M) || !Pu(M) ? W : Ig(M) ? {
    ...W,
    width: ru(M)
  } : {
    ...W,
    width: is
  }, ri = (M, W) => Mg(M) || Pu(M) ? W : Ig(M) ? {
    ...W,
    width: ru(M)
  } : {
    ...W,
    width: is
  }, Da = (M) => (W) => W.options.get(M), Vs = (M) => {
    const W = M.options.register;
    W("table_border_widths", {
      processor: "object[]",
      default: Fl
    }), W("table_border_styles", {
      processor: "object[]",
      default: $m
    }), W("table_cell_advtab", {
      processor: "boolean",
      default: !0
    }), W("table_row_advtab", {
      processor: "boolean",
      default: !0
    }), W("table_advtab", {
      processor: "boolean",
      default: !0
    }), W("table_appearance_options", {
      processor: "boolean",
      default: !0
    }), W("table_grid", {
      processor: "boolean",
      default: !Fh.deviceType.isTouch()
    }), W("table_cell_class_list", {
      processor: "object[]",
      default: []
    }), W("table_row_class_list", {
      processor: "object[]",
      default: []
    }), W("table_class_list", {
      processor: "object[]",
      default: []
    }), W("table_toolbar", {
      processor: "string",
      default: Lh
    }), W("table_background_color_map", {
      processor: "object[]",
      default: []
    }), W("table_border_color_map", {
      processor: "object[]",
      default: []
    });
  }, Ll = Da("table_sizing_mode"), cf = Da("table_border_widths"), nm = Da("table_border_styles"), Bh = Da("table_cell_advtab"), Ap = Da("table_row_advtab"), Pc = Da("table_advtab"), kp = Da("table_appearance_options"), gi = Da("table_grid"), Pu = Da("table_style_by_css"), Np = Da("table_cell_class_list"), nd = Da("table_row_class_list"), Im = Da("table_class_list"), wc = Da("table_toolbar"), Mm = Da("table_background_color_map"), Id = Da("table_border_color_map"), Ig = (M) => Ll(M) === "fixed", Mg = (M) => Ll(M) === "responsive", lf = (M) => {
    const W = M.options, de = W.get("table_default_styles");
    return W.isSet("table_default_styles") ? de : Ji(M, de);
  }, Ec = (M) => {
    const W = M.options, de = W.get("table_default_attributes");
    return W.isSet("table_default_attributes") ? de : ri(M, de);
  }, Fg = (M, W) => W.column >= M.startCol && W.column + W.colspan - 1 <= M.finishCol && W.row >= M.startRow && W.row + W.rowspan - 1 <= M.finishRow, Fe = (M, W) => {
    let de = !0;
    const Ee = G(Fg, W);
    for (let qe = W.startRow; qe <= W.finishRow; qe++)
      for (let kt = W.startCol; kt <= W.finishCol; kt++)
        de = de && Nu.getAt(M, qe, kt).exists(Ee);
    return de ? q.some(W) : q.none();
  }, uf = (M, W) => kn(Math.min(M.row, W.row), Math.min(M.column, W.column), Math.max(M.row + M.rowspan - 1, W.row + W.rowspan - 1), Math.max(M.column + M.colspan - 1, W.column + W.colspan - 1)), Bl = (M, W, de) => {
    const Ee = Nu.findItem(M, W, Co), qe = Nu.findItem(M, de, Co);
    return Ee.bind((kt) => qe.map((tn) => uf(kt, tn)));
  }, Fm = (M, W, de) => Bl(M, W, de).bind((Ee) => Fe(M, Ee)), Lg = (M, W, de) => {
    const Ee = Lm(M);
    return Fm(Ee, W, de);
  }, Lm = Nu.fromTable, Je = (M, W) => {
    Ei(M).each((Ee) => {
      Ee.dom.insertBefore(W.dom, M.dom);
    });
  }, Wt = (M, W) => {
    Xf(M).fold(() => {
      Ei(M).each((qe) => {
        er(qe, W);
      });
    }, (Ee) => {
      Je(Ee, W);
    });
  }, Ft = (M, W) => {
    ia(M).fold(() => {
      er(M, W);
    }, (Ee) => {
      M.dom.insertBefore(W.dom, Ee.dom);
    });
  }, er = (M, W) => {
    M.dom.appendChild(W.dom);
  }, Qr = (M, W) => {
    Je(M, W), er(W, M);
  }, No = (M, W) => {
    oe(W, (de, Ee) => {
      const qe = Ee === 0 ? M : W[Ee - 1];
      Wt(qe, de);
    });
  }, Qo = (M, W) => {
    oe(W, (de) => {
      er(M, de);
    });
  }, Xo = (M) => {
    const W = M.dom;
    W.parentNode !== null && W.parentNode.removeChild(W);
  }, Rp = (M) => {
    const W = Qa(M);
    W.length > 0 && No(M, W), Xo(M);
  }, $a = ((M, W) => {
    const de = (kt) => {
      if (!M(kt))
        throw new Error("Can only get " + W + " value of a " + W + " node");
      return Ee(kt).getOr("");
    }, Ee = (kt) => M(kt) ? q.from(kt.dom.nodeValue) : q.none();
    return {
      get: de,
      getOption: Ee,
      set: (kt, tn) => {
        if (!M(kt))
          throw new Error("Can only set raw " + W + " value of a " + W + " node");
        kt.dom.nodeValue = tn;
      }
    };
  })(wi, "text"), Hl = (M) => $a.get(M), Bg = (M, W) => $a.set(M, W);
  var oi = [
    "body",
    "p",
    "div",
    "article",
    "aside",
    "figcaption",
    "figure",
    "footer",
    "header",
    "nav",
    "section",
    "ol",
    "ul",
    "li",
    "table",
    "thead",
    "tbody",
    "tfoot",
    "caption",
    "tr",
    "td",
    "th",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "blockquote",
    "pre",
    "address"
  ], ga = () => {
    const M = (Pr) => br.fromDom(Pr.dom.cloneNode(!1)), W = (Pr) => lr(Pr).dom, de = (Pr) => Kc(Pr) ? fn(Pr) === "body" ? !0 : xt(oi, fn(Pr)) : !1, Ee = (Pr) => Kc(Pr) ? xt([
      "br",
      "img",
      "hr",
      "input"
    ], fn(Pr)) : !1, qe = (Pr) => Kc(Pr) && Xi(Pr, "contenteditable") === "false", kt = (Pr, la) => Pr.dom.compareDocumentPosition(la.dom), tn = (Pr, la) => {
      const Lo = yc(Pr);
      td(la, Lo);
    }, Sn = (Pr) => {
      const la = fn(Pr);
      return xt([
        "script",
        "noscript",
        "iframe",
        "noframes",
        "noembed",
        "title",
        "style",
        "textarea",
        "xmp"
      ], la);
    }, Xn = (Pr) => Kc(Pr) ? Zs(Pr, "lang") : q.none();
    return {
      up: Q({
        selector: Au,
        closest: eu,
        predicate: wp,
        all: Jl
      }),
      down: Q({
        selector: $o,
        predicate: Ju
      }),
      styles: Q({
        get: Ve,
        getRaw: wt,
        set: Se,
        remove: en
      }),
      attrs: Q({
        get: Xi,
        set: Rl,
        remove: ss,
        copyTo: tn
      }),
      insert: Q({
        before: Je,
        after: Wt,
        afterAll: No,
        append: er,
        appendAll: Qo,
        prepend: Ft,
        wrap: Qr
      }),
      remove: Q({
        unwrap: Rp,
        remove: Xo
      }),
      create: Q({
        nu: br.fromTag,
        clone: M,
        text: br.fromText
      }),
      query: Q({
        comparePosition: kt,
        prevSibling: Pd,
        nextSibling: Xf
      }),
      property: Q({
        children: Qa,
        name: fn,
        parent: Ei,
        document: W,
        isText: wi,
        isComment: $i,
        isElement: Kc,
        isSpecial: Sn,
        getLanguage: Xn,
        getText: Hl,
        setText: Bg,
        isBoundary: de,
        isEmptyTag: Ee,
        isNonEditable: qe
      }),
      eq: Co,
      is: fl
    };
  };
  const Du = (M, W, de, Ee) => {
    const qe = de[0], kt = de.slice(1);
    return Ee(M, W, qe, kt);
  }, ys = (M, W, de) => de.length > 0 ? Du(M, W, de, ou) : q.none(), ou = (M, W, de, Ee) => {
    const qe = W(M, de);
    return Jt(Ee, (kt, tn) => {
      const Sn = W(M, tn);
      return ec(M, kt, Sn);
    }, qe);
  }, ec = (M, W, de) => W.bind((Ee) => de.filter(G(M.eq, Ee))), Bm = ys, Gv = ga(), Pp = (M, W) => Bm(Gv, (de, Ee) => M(Ee), W), Hh = (M) => Au(M, "table"), Md = (M, W) => {
    const de = $o(M, W);
    return de.length > 0 ? q.some(de) : q.none();
  }, Cc = (M, W, de) => Ja(M, W).bind((Ee) => Ja(M, de).bind((qe) => Pp(Hh, [
    Ee,
    qe
  ]).map((kt) => ({
    first: Ee,
    last: qe,
    table: kt
  })))), Dp = (M, W) => Md(M, W), wy = (M, W, de) => Cc(M, W, de).bind((Ee) => {
    const qe = (Xn) => Co(M, Xn), kt = "thead,tfoot,tbody,table", tn = Au(Ee.first, kt, qe), Sn = Au(Ee.last, kt, qe);
    return tn.bind((Xn) => Sn.bind((Pr) => Co(Xn, Pr) ? Lg(Ee.table, Ee.first, Ee.last) : q.none()));
  }), Hm = (M) => ut(M, br.fromDom), zh = "data-mce-selected", df = "td[" + zh + "],th[" + zh + "]", ff = "data-mce-first-selected", rm = "td[" + ff + "],th[" + ff + "]", cs = "data-mce-last-selected", Ss = "td[" + cs + "],th[" + cs + "]", Fi = {
    selected: zh,
    selectedSelector: df,
    firstSelected: ff,
    firstSelectedSelector: rm,
    lastSelected: cs,
    lastSelectedSelector: Ss
  }, Hg = (M) => Va(M).bind((W) => Dp(W, Fi.firstSelectedSelector)).fold(Q(M), (W) => W[0]), Zv = (M) => (W, de) => {
    const Ee = fn(W), qe = Ee === "col" || Ee === "colgroup" ? Hg(W) : W;
    return eu(qe, M, de);
  }, Ci = Zv("th,td,caption"), su = Zv("th,td"), Li = (M) => Hm(M.model.table.getSelectedCells()), au = (M, W) => {
    const de = su(M), Ee = de.bind((qe) => Va(qe)).map((qe) => Sc(qe));
    return za(de, Ee, (qe, kt) => Zt(kt, (tn) => cn(Hm(tn.dom.cells), (Sn) => Xi(Sn, W) === "1" || Co(Sn, qe)))).getOr([]);
  }, Vh = [
    {
      text: "None",
      value: ""
    },
    {
      text: "Top",
      value: "top"
    },
    {
      text: "Middle",
      value: "middle"
    },
    {
      text: "Bottom",
      value: "bottom"
    }
  ], Rr = (M) => ({ value: Bi(M) }), el = /^#?([a-f\d])([a-f\d])([a-f\d])$/i, mf = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, Ia = (M) => el.test(M) || mf.test(M), Bi = (M) => Ii(M, "#").toUpperCase(), Kv = (M) => Ia(M) ? q.some({ value: Bi(M) }) : q.none(), Hi = (M) => {
    const W = M.toString(16);
    return (W.length === 1 ? "0" + W : W).toUpperCase();
  }, va = (M) => {
    const W = Hi(M.red) + Hi(M.green) + Hi(M.blue);
    return Rr(W);
  }, ml = /^\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i, Aa = /^\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?(?:\.\d+)?)\s*\)\s*$/i, rd = (M, W, de, Ee) => ({
    red: M,
    green: W,
    blue: de,
    alpha: Ee
  }), Fd = (M, W, de, Ee) => {
    const qe = parseInt(M, 10), kt = parseInt(W, 10), tn = parseInt(de, 10), Sn = parseFloat(Ee);
    return rd(qe, kt, tn, Sn);
  }, $s = (M) => {
    if (M === "transparent")
      return q.some(rd(0, 0, 0, 0));
    const W = ml.exec(M);
    if (W !== null)
      return q.some(Fd(W[1], W[2], W[3], "1"));
    const de = Aa.exec(M);
    return de !== null ? q.some(Fd(de[1], de[2], de[3], de[4])) : q.none();
  }, ba = (M) => Kv(M).orThunk(() => $s(M).map(va)).getOrThunk(() => {
    const W = document.createElement("canvas");
    W.height = 1, W.width = 1;
    const de = W.getContext("2d");
    de.clearRect(0, 0, W.width, W.height), de.fillStyle = "#FFFFFF", de.fillStyle = M, de.fillRect(0, 0, 1, 1);
    const Ee = de.getImageData(0, 0, 1, 1).data, qe = Ee[0], kt = Ee[1], tn = Ee[2], Sn = Ee[3];
    return va(rd(qe, kt, tn, Sn));
  }), tl = (M) => $s(M).map(va).map((W) => "#" + W.value).getOr(M), od = (M) => {
    let W = M;
    return {
      get: () => W,
      set: (qe) => {
        W = qe;
      }
    };
  }, Ys = (M) => {
    const W = od(q.none()), de = () => W.get().each(M);
    return {
      clear: () => {
        de(), W.set(q.none());
      },
      isSet: () => W.get().isSome(),
      get: () => W.get(),
      set: (Sn) => {
        de(), W.set(q.some(Sn));
      }
    };
  }, zg = () => Ys((M) => M.unbind()), Yv = (M, W, de) => (Ee) => {
    const qe = zg(), kt = xp(de), tn = () => {
      const Sn = Li(M), Xn = (Pr) => M.formatter.match(W, { value: de }, Pr.dom, kt);
      kt ? (Ee.setActive(!cn(Sn, Xn)), qe.set(M.formatter.formatChanged(W, (Pr) => Ee.setActive(!Pr), !0))) : (Ee.setActive(Ct(Sn, Xn)), qe.set(M.formatter.formatChanged(W, Ee.setActive, !1, { value: de })));
    };
    return M.initialized ? tn() : M.on("init", tn), qe.clear;
  }, Vo = (M) => _n(M, "menu"), $u = (M) => ut(M, (W) => {
    const de = W.text || W.title || "";
    return Vo(W) ? {
      text: de,
      items: $u(W.menu)
    } : {
      text: de,
      value: W.value
    };
  }), mo = (M, W, de, Ee) => ut(W, (qe) => {
    const kt = qe.text || qe.title;
    return Vo(qe) ? {
      type: "nestedmenuitem",
      text: kt,
      getSubmenuItems: () => mo(M, qe.menu, de, Ee)
    } : {
      text: kt,
      type: "togglemenuitem",
      onAction: () => Ee(qe.value),
      onSetup: Yv(M, de, qe.value)
    };
  }), zi = (M, W) => (de) => {
    M.execCommand("mceTableApplyCellStyle", !1, { [W]: de });
  }, iu = (M) => ke(M, (W) => Vo(W) ? [{
    ...W,
    menu: iu(W.menu)
  }] : Il(W.value) ? [W] : []), sd = (M, W, de, Ee) => (qe) => qe(mo(M, W, de, Ee)), ye = (M, W, de) => {
    const Ee = ut(W, (qe) => ({
      text: qe.title,
      value: "#" + ba(qe.value).value,
      type: "choiceitem"
    }));
    return [{
      type: "fancymenuitem",
      fancytype: "colorswatch",
      initData: {
        colors: Ee.length > 0 ? Ee : void 0,
        allowCustomColors: !1
      },
      onAction: (qe) => {
        const kt = qe.value === "remove" ? "" : qe.value;
        M.execCommand("mceTableApplyCellStyle", !1, { [de]: kt });
      }
    }];
  }, cu = (M) => () => {
    const de = M.queryCommandValue("mceTableRowType") === "header" ? "body" : "header";
    M.execCommand("mceTableRowType", !1, { type: de });
  }, zm = (M) => () => {
    const de = M.queryCommandValue("mceTableColType") === "th" ? "td" : "th";
    M.execCommand("mceTableColType", !1, { type: de });
  }, pl = (M) => {
    const W = $u(Np(M));
    return W.length > 0 ? q.some({
      name: "class",
      type: "listbox",
      label: "Class",
      items: W
    }) : q.none();
  }, ts = [
    {
      name: "width",
      type: "input",
      label: "Width"
    },
    {
      name: "height",
      type: "input",
      label: "Height"
    },
    {
      name: "celltype",
      type: "listbox",
      label: "Cell type",
      items: [
        {
          text: "Cell",
          value: "td"
        },
        {
          text: "Header cell",
          value: "th"
        }
      ]
    },
    {
      name: "scope",
      type: "listbox",
      label: "Scope",
      items: [
        {
          text: "None",
          value: ""
        },
        {
          text: "Row",
          value: "row"
        },
        {
          text: "Column",
          value: "col"
        },
        {
          text: "Row group",
          value: "rowgroup"
        },
        {
          text: "Column group",
          value: "colgroup"
        }
      ]
    },
    {
      name: "halign",
      type: "listbox",
      label: "Horizontal align",
      items: [
        {
          text: "None",
          value: ""
        },
        {
          text: "Left",
          value: "left"
        },
        {
          text: "Center",
          value: "center"
        },
        {
          text: "Right",
          value: "right"
        }
      ]
    },
    {
      name: "valign",
      type: "listbox",
      label: "Vertical align",
      items: Vh
    }
  ], Qv = (M) => ts.concat(pl(M).toArray()), Uh = (M, W) => {
    const Ee = [
      {
        name: "borderstyle",
        type: "listbox",
        label: "Border style",
        items: [{
          text: "Select...",
          value: ""
        }].concat($u(nm(M)))
      },
      {
        name: "bordercolor",
        type: "colorinput",
        label: "Border color"
      },
      {
        name: "backgroundcolor",
        type: "colorinput",
        label: "Background color"
      }
    ];
    return {
      title: "Advanced",
      name: "advanced",
      items: W === "cell" ? [{
        name: "borderwidth",
        type: "input",
        label: "Border width"
      }].concat(Ee) : Ee
    };
  }, Iu = { normal: (M, W) => {
    const de = M.dom;
    return {
      setAttrib: (tn, Sn) => {
        de.setAttrib(W, tn, Sn);
      },
      setStyle: (tn, Sn) => {
        de.setStyle(W, tn, Sn);
      },
      setFormat: (tn, Sn) => {
        Sn === "" ? M.formatter.remove(tn, { value: null }, W, !0) : M.formatter.apply(tn, { value: Sn }, W);
      }
    };
  } }, H = Xl("th"), X = (M, W) => M && W ? "sectionCells" : M ? "section" : "cells", fe = (M) => {
    const W = M.section === "thead", de = tm(Me(M.cells), "th");
    return M.section === "tfoot" ? { type: "footer" } : W || de ? {
      type: "header",
      subType: X(W, de)
    } : { type: "body" };
  }, Me = (M) => {
    const W = Zt(M, (de) => H(de.element));
    return W.length === 0 ? q.some("td") : W.length === M.length ? q.some("th") : q.none();
  }, We = (M) => {
    const W = ut(M, (qe) => fe(qe).type), de = xt(W, "header"), Ee = xt(W, "footer");
    if (!de && !Ee)
      return q.some("body");
    {
      const qe = xt(W, "body");
      return de && !qe && !Ee ? q.some("header") : !de && !qe && Ee ? q.some("footer") : q.none();
    }
  }, Ut = (M) => {
    let W = !1, de;
    return (...Ee) => (W || (W = !0, de = M.apply(null, Ee)), de);
  }, Wn = (M, W) => nn(M.all, (de) => qt(de.cells, (Ee) => Co(W, Ee.element))), xr = (M, W, de) => {
    const Ee = ut(W.selection, (kt) => _p(kt).bind((tn) => Wn(M, tn)).filter(de)), qe = Io(Ee);
    return Ra(qe.length > 0, qe);
  }, wr = (M, W) => W.mergable, pr = (M, W) => W.unmergable, Us = (M, W) => xr(M, W, be), ra = (M, W) => Wn(M, W).exists((de) => !de.isLocked), hl = (M, W) => Ct(W, (de) => ra(M, de)), Ld = (M, W) => wr(M, W).filter((de) => hl(M, de.cells)), Vi = (M, W) => pr(M, W).filter((de) => hl(M, de));
  ({ ...{ generate: (M) => {
    if (!g(M))
      throw new Error("cases must be an array");
    if (M.length === 0)
      throw new Error("there must be at least one case");
    const W = [], de = {};
    return oe(M, (Ee, qe) => {
      const kt = Te(Ee);
      if (kt.length !== 1)
        throw new Error("one and only one name per case");
      const tn = kt[0], Sn = Ee[tn];
      if (de[tn] !== void 0)
        throw new Error("duplicate key detected:" + tn);
      if (tn === "cata")
        throw new Error("cannot have a case named cata (sorry)");
      if (!g(Sn))
        throw new Error("case arguments must be an array");
      W.push(tn), de[tn] = (...Xn) => {
        const Pr = Xn.length;
        if (Pr !== Sn.length)
          throw new Error("Wrong number of arguments to case " + tn + ". Expected " + Sn.length + " (" + Sn + "), got " + Pr);
        return {
          fold: (...Lo) => {
            if (Lo.length !== M.length)
              throw new Error("Wrong number of arguments to fold. Expected " + M.length + ", got " + Lo.length);
            return Lo[qe].apply(null, Xn);
          },
          match: (Lo) => {
            const _s = Te(Lo);
            if (W.length !== _s.length)
              throw new Error("Wrong number of arguments to match. Expected: " + W.join(",") + `
Actual: ` + _s.join(","));
            if (!Ct(W, (Ic) => xt(_s, Ic)))
              throw new Error("Not all branches were specified when using match. Specified: " + _s.join(", ") + `
Required: ` + W.join(", "));
            return Lo[tn].apply(null, Xn);
          },
          log: (Lo) => {
            console.log(Lo, {
              constructors: W,
              constructor: tn,
              params: Xn
            });
          }
        };
      };
    }), de;
  } }.generate([
    { none: [] },
    { only: ["index"] },
    {
      left: [
        "index",
        "next"
      ]
    },
    {
      middle: [
        "prev",
        "index",
        "next"
      ]
    },
    {
      right: [
        "prev",
        "index"
      ]
    }
  ]) });
  const Un = (M, W) => {
    const de = Nu.fromTable(M);
    return Us(de, W).bind((qe) => {
      const kt = qe[qe.length - 1], tn = qe[0].row, Sn = kt.row + kt.rowspan, Xn = de.all.slice(tn, Sn);
      return We(Xn);
    }).getOr("");
  }, Ui = (M) => Dl(M, "rgb") ? tl(M) : M, B1 = (M) => {
    const W = br.fromDom(M);
    return {
      borderwidth: wt(W, "border-width").getOr(""),
      borderstyle: wt(W, "border-style").getOr(""),
      bordercolor: wt(W, "border-color").map(Ui).getOr(""),
      backgroundcolor: wt(W, "background-color").map(Ui).getOr("")
    };
  }, hf = (M) => {
    const W = M[0], de = M.slice(1);
    return oe(de, (Ee) => {
      oe(Te(W), (qe) => {
        je(Ee, (kt, tn) => {
          const Sn = W[qe];
          Sn !== "" && qe === tn && Sn !== kt && (W[qe] = "");
        });
      });
    }), W;
  }, Ua = (M, W, de, Ee) => qt(M, (qe) => !O(de.formatter.matchNode(Ee, W + qe))).getOr(""), om = G(Ua, [
    "left",
    "center",
    "right"
  ], "align"), Ug = G(Ua, [
    "top",
    "middle",
    "bottom"
  ], "valign"), xi = (M, W) => {
    const de = lf(M), Ee = Ec(M), qe = () => ({
      borderstyle: bt(de, "border-style").getOr(""),
      bordercolor: Ui(bt(de, "border-color").getOr("")),
      backgroundcolor: Ui(bt(de, "background-color").getOr(""))
    }), kt = {
      height: "",
      width: "100%",
      cellspacing: "",
      cellpadding: "",
      caption: !1,
      class: "",
      align: "",
      border: ""
    }, tn = () => {
      const la = de["border-width"];
      return Pu(M) && la ? { border: la } : bt(Ee, "border").fold(() => ({}), (Lo) => ({ border: Lo }));
    }, Sn = W ? qe() : {}, Xn = () => {
      const la = bt(de, "border-spacing").or(bt(Ee, "cellspacing")).fold(() => ({}), (_s) => ({ cellspacing: _s })), Lo = bt(de, "border-padding").or(bt(Ee, "cellpadding")).fold(() => ({}), (_s) => ({ cellpadding: _s }));
      return {
        ...la,
        ...Lo
      };
    };
    return {
      ...kt,
      ...de,
      ...Ee,
      ...Sn,
      ...tn(),
      ...Xn()
    };
  }, ad = (M) => Va(br.fromDom(M)).map((W) => {
    const de = { selection: Hm(M.cells) };
    return Un(W, de);
  }).getOr(""), Xv = (M, W, de) => {
    const Ee = (Sn, Xn) => {
      const Pr = wt(br.fromDom(Xn), "border-width");
      return Pu(M) && Pr.isSome() ? Pr.getOr("") : Sn.getAttrib(Xn, "border") || Jc(M.dom, Xn, "border-width") || Jc(M.dom, Xn, "border") || "";
    }, qe = M.dom, kt = Pu(M) ? qe.getStyle(W, "border-spacing") || qe.getAttrib(W, "cellspacing") : qe.getAttrib(W, "cellspacing") || qe.getStyle(W, "border-spacing"), tn = Pu(M) ? Jc(qe, W, "padding") || qe.getAttrib(W, "cellpadding") : qe.getAttrib(W, "cellpadding") || Jc(qe, W, "padding");
    return {
      width: qe.getStyle(W, "width") || qe.getAttrib(W, "width"),
      height: qe.getStyle(W, "height") || qe.getAttrib(W, "height"),
      cellspacing: kt ?? "",
      cellpadding: tn ?? "",
      border: Ee(qe, W),
      caption: !!qe.select("caption", W)[0],
      class: qe.getAttrib(W, "class", ""),
      align: om(M, W),
      ...de ? B1(W) : {}
    };
  }, gf = (M, W, de) => {
    const Ee = M.dom;
    return {
      height: Ee.getStyle(W, "height") || Ee.getAttrib(W, "height"),
      class: Ee.getAttrib(W, "class", ""),
      type: ad(W),
      align: om(M, W),
      ...de ? B1(W) : {}
    };
  }, Jv = (M, W, de, Ee) => {
    const qe = M.dom, kt = Ee.getOr(W), tn = (Sn, Xn) => qe.getStyle(Sn, Xn) || qe.getAttrib(Sn, Xn);
    return {
      width: tn(kt, "width"),
      height: tn(W, "height"),
      scope: qe.getAttrib(W, "scope"),
      celltype: Cp(W),
      class: qe.getAttrib(W, "class", ""),
      halign: om(M, W),
      valign: Ug(M, W),
      ...de ? B1(W) : {}
    };
  }, sm = (M, W) => {
    const de = Nu.fromTable(M), Ee = Nu.justCells(de), qe = Zt(Ee, (kt) => cn(W, (tn) => Co(kt.element, tn)));
    return ut(qe, (kt) => ({
      element: kt.element.dom,
      column: Nu.getColumnAt(de, kt.column).map((tn) => tn.element.dom)
    }));
  }, Qt = (M, W, de, Ee) => {
    Ee("scope") && M.setAttrib("scope", de.scope), Ee("class") && M.setAttrib("class", de.class), Ee("height") && M.setStyle("height", Hs(de.height)), Ee("width") && W.setStyle("width", Hs(de.width));
  }, H1 = (M, W, de) => {
    de("backgroundcolor") && M.setFormat("tablecellbackgroundcolor", W.backgroundcolor), de("bordercolor") && M.setFormat("tablecellbordercolor", W.bordercolor), de("borderstyle") && M.setFormat("tablecellborderstyle", W.borderstyle), de("borderwidth") && M.setFormat("tablecellborderwidth", Hs(W.borderwidth));
  }, am = (M, W, de, Ee) => {
    const qe = W.length === 1;
    oe(W, (kt) => {
      const tn = kt.element, Sn = qe ? be : Ee, Xn = Iu.normal(M, tn), Pr = kt.column.map((la) => Iu.normal(M, la)).getOr(Xn);
      Qt(Xn, Pr, de, Sn), Bh(M) && H1(Xn, de, Sn), Ee("halign") && Ml(M, tn, de.halign), Ee("valign") && Op(M, tn, de.valign);
    });
  }, im = (M, W) => {
    M.execCommand("mceTableCellType", !1, {
      type: W.celltype,
      no_events: !0
    });
  }, Mu = (M, W, de, Ee) => {
    const qe = pt(Ee, (kt, tn) => de[tn] !== kt);
    z(qe) > 0 && W.length >= 1 && Va(W[0]).each((kt) => {
      const tn = sm(kt, W), Sn = z(pt(qe, (Pr, la) => la !== "scope" && la !== "celltype")) > 0, Xn = at(qe, "celltype");
      (Sn || at(qe, "scope")) && am(M, tn, Ee, G(at, qe)), Xn && im(M, Ee), no(M, kt.dom, {
        structure: Xn,
        style: Sn
      });
    });
  }, Ws = (M, W, de, Ee) => {
    const qe = Ee.getData();
    Ee.close(), M.undoManager.transact(() => {
      Mu(M, W, de, qe), M.focus();
    });
  }, Mo = (M, W) => {
    const de = Va(W[0]).map((Ee) => ut(sm(Ee, W), (qe) => Jv(M, qe.element, Bh(M), qe.column)));
    return hf(de.getOrDie());
  }, ya = (M) => {
    const W = Li(M);
    if (W.length === 0)
      return;
    const de = Mo(M, W), Ee = {
      type: "tabpanel",
      tabs: [
        {
          title: "General",
          name: "general",
          items: Qv(M)
        },
        Uh(M, "cell")
      ]
    }, qe = {
      type: "panel",
      items: [{
        type: "grid",
        columns: 2,
        items: Qv(M)
      }]
    };
    M.windowManager.open({
      title: "Cell Properties",
      size: "normal",
      body: Bh(M) ? Ee : qe,
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: de,
      onSubmit: G(Ws, M, W, de)
    });
  }, Dc = (M) => {
    const W = $u(nd(M));
    return W.length > 0 ? q.some({
      name: "class",
      type: "listbox",
      label: "Class",
      items: W
    }) : q.none();
  }, ro = [
    {
      type: "listbox",
      name: "type",
      label: "Row type",
      items: [
        {
          text: "Header",
          value: "header"
        },
        {
          text: "Body",
          value: "body"
        },
        {
          text: "Footer",
          value: "footer"
        }
      ]
    },
    {
      type: "listbox",
      name: "align",
      label: "Alignment",
      items: [
        {
          text: "None",
          value: ""
        },
        {
          text: "Left",
          value: "left"
        },
        {
          text: "Center",
          value: "center"
        },
        {
          text: "Right",
          value: "right"
        }
      ]
    },
    {
      label: "Height",
      name: "height",
      type: "input"
    }
  ], $p = (M) => ro.concat(Dc(M).toArray()), si = (M, W, de) => {
    de("class") && M.setAttrib("class", W.class), de("height") && M.setStyle("height", Hs(W.height));
  }, Ts = (M, W, de) => {
    de("backgroundcolor") && M.setStyle("background-color", W.backgroundcolor), de("bordercolor") && M.setStyle("border-color", W.bordercolor), de("borderstyle") && M.setStyle("border-style", W.borderstyle);
  }, Wg = (M, W, de, Ee) => {
    const kt = W.length === 1 ? be : Ee;
    oe(W, (tn) => {
      const Sn = Iu.normal(M, tn);
      si(Sn, de, kt), Ap(M) && Ts(Sn, de, kt), Ee("align") && Ml(M, tn, de.align);
    });
  }, Mt = (M, W) => {
    M.execCommand("mceTableRowType", !1, {
      type: W.type,
      no_events: !0
    });
  }, $c = (M, W, de, Ee) => {
    const qe = pt(Ee, (kt, tn) => de[tn] !== kt);
    if (z(qe) > 0) {
      const kt = at(qe, "type"), tn = kt ? z(qe) > 1 : !0;
      tn && Wg(M, W, Ee, G(at, qe)), kt && Mt(M, Ee), Va(br.fromDom(W[0])).each((Sn) => no(M, Sn.dom, {
        structure: kt,
        style: tn
      }));
    }
  }, jg = (M, W, de, Ee) => {
    const qe = Ee.getData();
    Ee.close(), M.undoManager.transact(() => {
      $c(M, W, de, qe), M.focus();
    });
  }, xo = (M) => {
    const W = au(Gs(M), Fi.selected);
    if (W.length === 0)
      return;
    const de = ut(W, (tn) => gf(M, tn.dom, Ap(M))), Ee = hf(de), qe = {
      type: "tabpanel",
      tabs: [
        {
          title: "General",
          name: "general",
          items: $p(M)
        },
        Uh(M, "row")
      ]
    }, kt = {
      type: "panel",
      items: [{
        type: "grid",
        columns: 2,
        items: $p(M)
      }]
    };
    M.windowManager.open({
      title: "Row Properties",
      size: "normal",
      body: Ap(M) ? qe : kt,
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: Ee,
      onSubmit: G(jg, M, ut(W, (tn) => tn.dom), Ee)
    });
  }, ka = (M, W, de) => {
    const Ee = de ? [
      {
        type: "input",
        name: "cols",
        label: "Cols",
        inputMode: "numeric"
      },
      {
        type: "input",
        name: "rows",
        label: "Rows",
        inputMode: "numeric"
      }
    ] : [], qe = [
      {
        type: "input",
        name: "width",
        label: "Width"
      },
      {
        type: "input",
        name: "height",
        label: "Height"
      }
    ], kt = kp(M) ? [
      {
        type: "input",
        name: "cellspacing",
        label: "Cell spacing",
        inputMode: "numeric"
      },
      {
        type: "input",
        name: "cellpadding",
        label: "Cell padding",
        inputMode: "numeric"
      },
      {
        type: "input",
        name: "border",
        label: "Border width"
      },
      {
        type: "label",
        label: "Caption",
        items: [{
          type: "checkbox",
          name: "caption",
          label: "Show caption"
        }]
      }
    ] : [], tn = [{
      type: "listbox",
      name: "align",
      label: "Alignment",
      items: [
        {
          text: "None",
          value: ""
        },
        {
          text: "Left",
          value: "left"
        },
        {
          text: "Center",
          value: "center"
        },
        {
          text: "Right",
          value: "right"
        }
      ]
    }], Sn = W.length > 0 ? [{
      type: "listbox",
      name: "class",
      label: "Class",
      items: W
    }] : [];
    return Ee.concat(qe).concat(kt).concat(tn).concat(Sn);
  }, eb = (M, W, de, Ee) => {
    if (W.tagName === "TD" || W.tagName === "TH")
      v(de) && I(Ee) ? M.setStyle(W, de, Ee) : M.setStyles(W, de);
    else if (W.children)
      for (let qe = 0; qe < W.children.length; qe++)
        eb(M, W.children[qe], de, Ee);
  }, id = (M, W, de, Ee) => {
    const qe = M.dom, kt = {}, tn = {}, Sn = Pu(M), Xn = Pc(M);
    if (O(de.class) || (kt.class = de.class), tn.height = Hs(de.height), Sn ? tn.width = Hs(de.width) : qe.getAttrib(W, "width") && (kt.width = em(de.width)), Sn ? (tn["border-width"] = Hs(de.border), tn["border-spacing"] = Hs(de.cellspacing)) : (kt.border = de.border, kt.cellpadding = de.cellpadding, kt.cellspacing = de.cellspacing), Sn && W.children) {
      const Pr = {};
      if (Ee.border && (Pr["border-width"] = Hs(de.border)), Ee.cellpadding && (Pr.padding = Hs(de.cellpadding)), Xn && Ee.bordercolor && (Pr["border-color"] = de.bordercolor), !st(Pr))
        for (let la = 0; la < W.children.length; la++)
          eb(qe, W.children[la], Pr);
    }
    if (Xn) {
      const Pr = de;
      tn["background-color"] = Pr.backgroundcolor, tn["border-color"] = Pr.bordercolor, tn["border-style"] = Pr.borderstyle;
    }
    qe.setStyles(W, {
      ...lf(M),
      ...tn
    }), qe.setAttribs(W, {
      ...Ec(M),
      ...kt
    });
  }, cd = (M, W, de, Ee) => {
    const qe = M.dom, kt = Ee.getData(), tn = pt(kt, (Sn, Xn) => de[Xn] !== Sn);
    Ee.close(), kt.class === "" && delete kt.class, M.undoManager.transact(() => {
      if (!W) {
        const Sn = Nc(kt.cols).getOr(1), Xn = Nc(kt.rows).getOr(1);
        M.execCommand("mceInsertTable", !1, {
          rows: Xn,
          columns: Sn
        }), W = su(Gs(M), tu(M)).bind((Pr) => Va(Pr, tu(M))).map((Pr) => Pr.dom).getOrDie();
      }
      if (z(tn) > 0) {
        const Sn = {
          border: at(tn, "border"),
          bordercolor: at(tn, "bordercolor"),
          cellpadding: at(tn, "cellpadding")
        };
        id(M, W, kt, Sn);
        const Xn = qe.select("caption", W)[0];
        (Xn && !kt.caption || !Xn && kt.caption) && M.execCommand("mceTableToggleCaption"), Ml(M, W, kt.align);
      }
      if (M.focus(), M.addVisual(), z(tn) > 0) {
        const Sn = at(tn, "caption"), Xn = Sn ? z(tn) > 1 : !0;
        no(M, W, {
          structure: Sn,
          style: Xn
        });
      }
    });
  }, lu = (M, W) => {
    const de = M.dom;
    let Ee, qe = xi(M, Pc(M));
    W ? (qe.cols = "1", qe.rows = "1", Pc(M) && (qe.borderstyle = "", qe.bordercolor = "", qe.backgroundcolor = "")) : (Ee = de.getParent(M.selection.getStart(), "table", M.getBody()), Ee ? qe = Xv(M, Ee, Pc(M)) : Pc(M) && (qe.borderstyle = "", qe.bordercolor = "", qe.backgroundcolor = ""));
    const kt = $u(Im(M));
    kt.length > 0 && qe.class && (qe.class = qe.class.replace(/\s*mce\-item\-table\s*/g, ""));
    const tn = {
      type: "grid",
      columns: 2,
      items: ka(M, kt, W)
    }, Sn = () => ({
      type: "panel",
      items: [tn]
    }), Xn = () => ({
      type: "tabpanel",
      tabs: [
        {
          title: "General",
          name: "general",
          items: [tn]
        },
        Uh(M, "table")
      ]
    }), Pr = Pc(M) ? Xn() : Sn();
    M.windowManager.open({
      title: "Table Properties",
      size: "normal",
      body: Pr,
      onSubmit: G(cd, M, Ee, qe),
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: qe
    });
  }, Wh = (M) => {
    const W = (de) => {
      kc(Gs(M)) && de();
    };
    je({
      mceTableProps: G(lu, M, !1),
      mceTableRowProps: G(xo, M),
      mceTableCellProps: G(ya, M),
      mceInsertTableDialog: G(lu, M, !0)
    }, (de, Ee) => M.addCommand(Ee, () => W(de)));
  }, tc = (M, W) => nt(M, W).isSome(), Fo = he, ai = (M) => {
    const W = (Ee, qe) => Zs(Ee, qe).exists((kt) => parseInt(kt, 10) > 1), de = (Ee) => W(Ee, "rowspan") || W(Ee, "colspan");
    return M.length > 0 && Ct(M, de) ? q.some(M) : q.none();
  }, cm = (M, W, de) => W.length <= 1 ? q.none() : wy(M, de.firstSelectedSelector, de.lastSelectedSelector).map((Ee) => ({
    bounds: Ee,
    cells: W
  })), nc = (M) => ({
    element: M,
    mergable: q.none(),
    unmergable: q.none(),
    selection: [M]
  }), Ey = (M, W, de) => ({
    element: de,
    mergable: cm(W, M, Fi),
    unmergable: ai(M),
    selection: Fo(M)
  }), Ip = (M) => {
    const W = od(q.none()), de = od([]);
    let Ee = q.none();
    const qe = Xl("caption"), kt = (qr) => Ee.forall((oo) => !oo[qr]), tn = () => Ci(Gs(M), tu(M)), Sn = () => Ci(Ac(M), tu(M)), Xn = () => tn().bind((qr) => ti(za(Va(qr), Sn().bind(Va), (oo, ci) => Co(oo, ci) ? qe(qr) ? q.some(nc(qr)) : q.some(Ey(Li(M), oo, qr)) : q.none()))), Pr = (qr) => Va(qr.element).map((ci) => {
      const rc = Nu.fromTable(ci), tb = Us(rc, qr).getOr([]), yf = wo(tb, (oa, fu) => (fu.isLocked && (oa.onAny = !0, fu.column === 0 ? oa.onFirst = !0 : fu.column + fu.colspan >= rc.grid.columns && (oa.onLast = !0)), oa), {
        onAny: !1,
        onFirst: !1,
        onLast: !1
      });
      return {
        mergeable: Ld(rc, qr).isSome(),
        unmergeable: Vi(rc, qr).isSome(),
        locked: yf
      };
    }), la = () => {
      W.set(Ut(Xn)()), Ee = W.get().bind(Pr), oe(de.get(), me);
    }, Lo = (qr) => (qr(), de.set(de.get().concat([qr])), () => {
      de.set(Zt(de.get(), (oo) => oo !== qr));
    }), _s = (qr, oo) => Lo(() => W.get().fold(() => {
      qr.setEnabled(!1);
    }, (ci) => {
      qr.setEnabled(!oo(ci) && M.selection.isEditable());
    })), zl = (qr, oo, ci) => Lo(() => W.get().fold(() => {
      qr.setEnabled(!1), qr.setActive(!1);
    }, (rc) => {
      qr.setEnabled(!oo(rc) && M.selection.isEditable()), qr.setActive(ci(rc));
    })), Ic = (qr) => Ee.exists((oo) => oo.locked[qr]), uu = (qr) => _s(qr, (oo) => !1), bf = (qr) => _s(qr, (oo) => qe(oo.element)), Bd = (qr) => (oo) => _s(oo, (ci) => qe(ci.element) || Ic(qr)), Mp = (qr) => (oo) => _s(oo, (ci) => qe(ci.element) || qr().isNone()), Ro = (qr, oo) => (ci) => _s(ci, (rc) => qe(rc.element) || qr().isNone() || Ic(oo)), Fp = (qr) => _s(qr, (oo) => kt("mergeable")), qg = (qr) => _s(qr, (oo) => kt("unmergeable")), Sa = (qr) => zl(qr, we, (oo) => Va(oo.element, tu(M)).exists((rc) => tc(rc, "caption"))), du = (qr, oo) => (ci) => zl(ci, (rc) => qe(rc.element), () => M.queryCommandValue(qr) === oo), jh = du("mceTableRowType", "header"), Lp = du("mceTableColType", "th");
    return M.on("NodeChange ExecCommand TableSelectorChange", la), {
      onSetupTable: uu,
      onSetupCellOrRow: bf,
      onSetupColumn: Bd,
      onSetupPasteable: Mp,
      onSetupPasteableColumn: Ro,
      onSetupMergeable: Fp,
      onSetupUnmergeable: qg,
      resetTargets: la,
      onSetupTableWithCaption: Sa,
      onSetupTableRowHeaders: jh,
      onSetupTableColumnHeaders: Lp,
      targets: W.get
    };
  };
  var lm = tinymce.util.Tools.resolve("tinymce.FakeClipboard");
  const nl = "x-tinymce/dom-table-", ld = nl + "rows", lt = nl + "columns", gl = (M) => {
    var W;
    const de = (W = lm.read()) !== null && W !== void 0 ? W : [];
    return nn(de, (Ee) => q.from(Ee.getType(M)));
  }, Fu = () => gl(ld), rl = () => gl(lt), vl = (M) => (W) => {
    const de = () => {
      W.setEnabled(M.selection.isEditable());
    };
    return M.on("NodeChange", de), de(), () => {
      M.off("NodeChange", de);
    };
  }, vi = (M, W) => {
    M.ui.registry.addMenuButton("table", {
      tooltip: "Table",
      icon: "table",
      onSetup: vl(M),
      fetch: (Sn) => Sn("inserttable | cell row column | advtablesort | tableprops deletetable")
    });
    const de = (Sn) => () => M.execCommand(Sn), Ee = (Sn, Xn) => {
      M.queryCommandSupported(Xn.command) && M.ui.registry.addButton(Sn, {
        ...Xn,
        onAction: L(Xn.onAction) ? Xn.onAction : de(Xn.command)
      });
    }, qe = (Sn, Xn) => {
      M.queryCommandSupported(Xn.command) && M.ui.registry.addToggleButton(Sn, {
        ...Xn,
        onAction: L(Xn.onAction) ? Xn.onAction : de(Xn.command)
      });
    };
    Ee("tableprops", {
      tooltip: "Table properties",
      command: "mceTableProps",
      icon: "table",
      onSetup: W.onSetupTable
    }), Ee("tabledelete", {
      tooltip: "Delete table",
      command: "mceTableDelete",
      icon: "table-delete-table",
      onSetup: W.onSetupTable
    }), Ee("tablecellprops", {
      tooltip: "Cell properties",
      command: "mceTableCellProps",
      icon: "table-cell-properties",
      onSetup: W.onSetupCellOrRow
    }), Ee("tablemergecells", {
      tooltip: "Merge cells",
      command: "mceTableMergeCells",
      icon: "table-merge-cells",
      onSetup: W.onSetupMergeable
    }), Ee("tablesplitcells", {
      tooltip: "Split cell",
      command: "mceTableSplitCells",
      icon: "table-split-cells",
      onSetup: W.onSetupUnmergeable
    }), Ee("tableinsertrowbefore", {
      tooltip: "Insert row before",
      command: "mceTableInsertRowBefore",
      icon: "table-insert-row-above",
      onSetup: W.onSetupCellOrRow
    }), Ee("tableinsertrowafter", {
      tooltip: "Insert row after",
      command: "mceTableInsertRowAfter",
      icon: "table-insert-row-after",
      onSetup: W.onSetupCellOrRow
    }), Ee("tabledeleterow", {
      tooltip: "Delete row",
      command: "mceTableDeleteRow",
      icon: "table-delete-row",
      onSetup: W.onSetupCellOrRow
    }), Ee("tablerowprops", {
      tooltip: "Row properties",
      command: "mceTableRowProps",
      icon: "table-row-properties",
      onSetup: W.onSetupCellOrRow
    }), Ee("tableinsertcolbefore", {
      tooltip: "Insert column before",
      command: "mceTableInsertColBefore",
      icon: "table-insert-column-before",
      onSetup: W.onSetupColumn("onFirst")
    }), Ee("tableinsertcolafter", {
      tooltip: "Insert column after",
      command: "mceTableInsertColAfter",
      icon: "table-insert-column-after",
      onSetup: W.onSetupColumn("onLast")
    }), Ee("tabledeletecol", {
      tooltip: "Delete column",
      command: "mceTableDeleteCol",
      icon: "table-delete-column",
      onSetup: W.onSetupColumn("onAny")
    }), Ee("tablecutrow", {
      tooltip: "Cut row",
      command: "mceTableCutRow",
      icon: "cut-row",
      onSetup: W.onSetupCellOrRow
    }), Ee("tablecopyrow", {
      tooltip: "Copy row",
      command: "mceTableCopyRow",
      icon: "duplicate-row",
      onSetup: W.onSetupCellOrRow
    }), Ee("tablepasterowbefore", {
      tooltip: "Paste row before",
      command: "mceTablePasteRowBefore",
      icon: "paste-row-before",
      onSetup: W.onSetupPasteable(Fu)
    }), Ee("tablepasterowafter", {
      tooltip: "Paste row after",
      command: "mceTablePasteRowAfter",
      icon: "paste-row-after",
      onSetup: W.onSetupPasteable(Fu)
    }), Ee("tablecutcol", {
      tooltip: "Cut column",
      command: "mceTableCutCol",
      icon: "cut-column",
      onSetup: W.onSetupColumn("onAny")
    }), Ee("tablecopycol", {
      tooltip: "Copy column",
      command: "mceTableCopyCol",
      icon: "duplicate-column",
      onSetup: W.onSetupColumn("onAny")
    }), Ee("tablepastecolbefore", {
      tooltip: "Paste column before",
      command: "mceTablePasteColBefore",
      icon: "paste-column-before",
      onSetup: W.onSetupPasteableColumn(rl, "onFirst")
    }), Ee("tablepastecolafter", {
      tooltip: "Paste column after",
      command: "mceTablePasteColAfter",
      icon: "paste-column-after",
      onSetup: W.onSetupPasteableColumn(rl, "onLast")
    }), Ee("tableinsertdialog", {
      tooltip: "Insert table",
      command: "mceInsertTableDialog",
      icon: "table",
      onSetup: vl(M)
    });
    const kt = iu(Im(M));
    kt.length !== 0 && M.queryCommandSupported("mceTableToggleClass") && M.ui.registry.addMenuButton("tableclass", {
      icon: "table-classes",
      tooltip: "Table styles",
      fetch: sd(M, kt, "tableclass", (Sn) => M.execCommand("mceTableToggleClass", !1, Sn)),
      onSetup: W.onSetupTable
    });
    const tn = iu(Np(M));
    tn.length !== 0 && M.queryCommandSupported("mceTableCellToggleClass") && M.ui.registry.addMenuButton("tablecellclass", {
      icon: "table-cell-classes",
      tooltip: "Cell styles",
      fetch: sd(M, tn, "tablecellclass", (Sn) => M.execCommand("mceTableCellToggleClass", !1, Sn)),
      onSetup: W.onSetupCellOrRow
    }), M.queryCommandSupported("mceTableApplyCellStyle") && (M.ui.registry.addMenuButton("tablecellvalign", {
      icon: "vertical-align",
      tooltip: "Vertical align",
      fetch: sd(M, Vh, "tablecellverticalalign", zi(M, "vertical-align")),
      onSetup: W.onSetupCellOrRow
    }), M.ui.registry.addMenuButton("tablecellborderwidth", {
      icon: "border-width",
      tooltip: "Border width",
      fetch: sd(M, cf(M), "tablecellborderwidth", zi(M, "border-width")),
      onSetup: W.onSetupCellOrRow
    }), M.ui.registry.addMenuButton("tablecellborderstyle", {
      icon: "border-style",
      tooltip: "Border style",
      fetch: sd(M, nm(M), "tablecellborderstyle", zi(M, "border-style")),
      onSetup: W.onSetupCellOrRow
    }), M.ui.registry.addMenuButton("tablecellbackgroundcolor", {
      icon: "cell-background-color",
      tooltip: "Background color",
      fetch: (Sn) => Sn(ye(M, Mm(M), "background-color")),
      onSetup: W.onSetupCellOrRow
    }), M.ui.registry.addMenuButton("tablecellbordercolor", {
      icon: "cell-border-color",
      tooltip: "Border color",
      fetch: (Sn) => Sn(ye(M, Id(M), "border-color")),
      onSetup: W.onSetupCellOrRow
    })), qe("tablecaption", {
      tooltip: "Table caption",
      icon: "table-caption",
      command: "mceTableToggleCaption",
      onSetup: W.onSetupTableWithCaption
    }), qe("tablerowheader", {
      tooltip: "Row header",
      icon: "table-top-header",
      command: "mceTableRowType",
      onAction: cu(M),
      onSetup: W.onSetupTableRowHeaders
    }), qe("tablecolheader", {
      tooltip: "Column header",
      icon: "table-left-header",
      command: "mceTableColType",
      onAction: zm(M),
      onSetup: W.onSetupTableColumnHeaders
    });
  }, ii = (M) => {
    const W = (Ee) => M.dom.is(Ee, "table") && M.getBody().contains(Ee) && M.dom.isEditable(Ee.parentNode), de = wc(M);
    de.length > 0 && M.ui.registry.addContextToolbar("table", {
      predicate: W,
      items: de,
      scope: "node",
      position: "node"
    });
  }, Cy = (M) => (W) => {
    const de = () => {
      W.setEnabled(M.selection.isEditable());
    };
    return M.on("NodeChange", de), de(), () => {
      M.off("NodeChange", de);
    };
  }, bl = (M, W) => {
    const de = (Lo) => () => M.execCommand(Lo), Ee = (Lo, _s) => M.queryCommandSupported(_s.command) ? (M.ui.registry.addMenuItem(Lo, {
      ..._s,
      onAction: L(_s.onAction) ? _s.onAction : de(_s.command)
    }), !0) : !1, qe = (Lo, _s) => {
      M.queryCommandSupported(_s.command) && M.ui.registry.addToggleMenuItem(Lo, {
        ..._s,
        onAction: L(_s.onAction) ? _s.onAction : de(_s.command)
      });
    }, kt = (Lo) => {
      M.execCommand("mceInsertTable", !1, {
        rows: Lo.numRows,
        columns: Lo.numColumns
      });
    }, tn = [
      Ee("tableinsertrowbefore", {
        text: "Insert row before",
        icon: "table-insert-row-above",
        command: "mceTableInsertRowBefore",
        onSetup: W.onSetupCellOrRow
      }),
      Ee("tableinsertrowafter", {
        text: "Insert row after",
        icon: "table-insert-row-after",
        command: "mceTableInsertRowAfter",
        onSetup: W.onSetupCellOrRow
      }),
      Ee("tabledeleterow", {
        text: "Delete row",
        icon: "table-delete-row",
        command: "mceTableDeleteRow",
        onSetup: W.onSetupCellOrRow
      }),
      Ee("tablerowprops", {
        text: "Row properties",
        icon: "table-row-properties",
        command: "mceTableRowProps",
        onSetup: W.onSetupCellOrRow
      }),
      Ee("tablecutrow", {
        text: "Cut row",
        icon: "cut-row",
        command: "mceTableCutRow",
        onSetup: W.onSetupCellOrRow
      }),
      Ee("tablecopyrow", {
        text: "Copy row",
        icon: "duplicate-row",
        command: "mceTableCopyRow",
        onSetup: W.onSetupCellOrRow
      }),
      Ee("tablepasterowbefore", {
        text: "Paste row before",
        icon: "paste-row-before",
        command: "mceTablePasteRowBefore",
        onSetup: W.onSetupPasteable(Fu)
      }),
      Ee("tablepasterowafter", {
        text: "Paste row after",
        icon: "paste-row-after",
        command: "mceTablePasteRowAfter",
        onSetup: W.onSetupPasteable(Fu)
      })
    ], Sn = [
      Ee("tableinsertcolumnbefore", {
        text: "Insert column before",
        icon: "table-insert-column-before",
        command: "mceTableInsertColBefore",
        onSetup: W.onSetupColumn("onFirst")
      }),
      Ee("tableinsertcolumnafter", {
        text: "Insert column after",
        icon: "table-insert-column-after",
        command: "mceTableInsertColAfter",
        onSetup: W.onSetupColumn("onLast")
      }),
      Ee("tabledeletecolumn", {
        text: "Delete column",
        icon: "table-delete-column",
        command: "mceTableDeleteCol",
        onSetup: W.onSetupColumn("onAny")
      }),
      Ee("tablecutcolumn", {
        text: "Cut column",
        icon: "cut-column",
        command: "mceTableCutCol",
        onSetup: W.onSetupColumn("onAny")
      }),
      Ee("tablecopycolumn", {
        text: "Copy column",
        icon: "duplicate-column",
        command: "mceTableCopyCol",
        onSetup: W.onSetupColumn("onAny")
      }),
      Ee("tablepastecolumnbefore", {
        text: "Paste column before",
        icon: "paste-column-before",
        command: "mceTablePasteColBefore",
        onSetup: W.onSetupPasteableColumn(rl, "onFirst")
      }),
      Ee("tablepastecolumnafter", {
        text: "Paste column after",
        icon: "paste-column-after",
        command: "mceTablePasteColAfter",
        onSetup: W.onSetupPasteableColumn(rl, "onLast")
      })
    ], Xn = [
      Ee("tablecellprops", {
        text: "Cell properties",
        icon: "table-cell-properties",
        command: "mceTableCellProps",
        onSetup: W.onSetupCellOrRow
      }),
      Ee("tablemergecells", {
        text: "Merge cells",
        icon: "table-merge-cells",
        command: "mceTableMergeCells",
        onSetup: W.onSetupMergeable
      }),
      Ee("tablesplitcells", {
        text: "Split cell",
        icon: "table-split-cells",
        command: "mceTableSplitCells",
        onSetup: W.onSetupUnmergeable
      })
    ];
    gi(M) ? M.ui.registry.addNestedMenuItem("inserttable", {
      text: "Table",
      icon: "table",
      getSubmenuItems: () => [{
        type: "fancymenuitem",
        fancytype: "inserttable",
        onAction: kt
      }],
      onSetup: Cy(M)
    }) : M.ui.registry.addMenuItem("inserttable", {
      text: "Table",
      icon: "table",
      onAction: de("mceInsertTableDialog"),
      onSetup: Cy(M)
    }), M.ui.registry.addMenuItem("inserttabledialog", {
      text: "Insert table",
      icon: "table",
      onAction: de("mceInsertTableDialog"),
      onSetup: Cy(M)
    }), Ee("tableprops", {
      text: "Table properties",
      onSetup: W.onSetupTable,
      command: "mceTableProps"
    }), Ee("deletetable", {
      text: "Delete table",
      icon: "table-delete-table",
      onSetup: W.onSetupTable,
      command: "mceTableDelete"
    }), xt(tn, !0) && M.ui.registry.addNestedMenuItem("row", {
      type: "nestedmenuitem",
      text: "Row",
      getSubmenuItems: Q("tableinsertrowbefore tableinsertrowafter tabledeleterow tablerowprops | tablecutrow tablecopyrow tablepasterowbefore tablepasterowafter")
    }), xt(Sn, !0) && M.ui.registry.addNestedMenuItem("column", {
      type: "nestedmenuitem",
      text: "Column",
      getSubmenuItems: Q("tableinsertcolumnbefore tableinsertcolumnafter tabledeletecolumn | tablecutcolumn tablecopycolumn tablepastecolumnbefore tablepastecolumnafter")
    }), xt(Xn, !0) && M.ui.registry.addNestedMenuItem("cell", {
      type: "nestedmenuitem",
      text: "Cell",
      getSubmenuItems: Q("tablecellprops tablemergecells tablesplitcells")
    }), M.ui.registry.addContextMenu("table", {
      update: () => (W.resetTargets(), W.targets().fold(Q(""), (Lo) => fn(Lo.element) === "caption" ? "tableprops deletetable" : "cell row column | advtablesort | tableprops deletetable"))
    });
    const Pr = iu(Im(M));
    Pr.length !== 0 && M.queryCommandSupported("mceTableToggleClass") && M.ui.registry.addNestedMenuItem("tableclass", {
      icon: "table-classes",
      text: "Table styles",
      getSubmenuItems: () => mo(M, Pr, "tableclass", (Lo) => M.execCommand("mceTableToggleClass", !1, Lo)),
      onSetup: W.onSetupTable
    });
    const la = iu(Np(M));
    la.length !== 0 && M.queryCommandSupported("mceTableCellToggleClass") && M.ui.registry.addNestedMenuItem("tablecellclass", {
      icon: "table-cell-classes",
      text: "Cell styles",
      getSubmenuItems: () => mo(M, la, "tablecellclass", (Lo) => M.execCommand("mceTableCellToggleClass", !1, Lo)),
      onSetup: W.onSetupCellOrRow
    }), M.queryCommandSupported("mceTableApplyCellStyle") && (M.ui.registry.addNestedMenuItem("tablecellvalign", {
      icon: "vertical-align",
      text: "Vertical align",
      getSubmenuItems: () => mo(M, Vh, "tablecellverticalalign", zi(M, "vertical-align")),
      onSetup: W.onSetupCellOrRow
    }), M.ui.registry.addNestedMenuItem("tablecellborderwidth", {
      icon: "border-width",
      text: "Border width",
      getSubmenuItems: () => mo(M, cf(M), "tablecellborderwidth", zi(M, "border-width")),
      onSetup: W.onSetupCellOrRow
    }), M.ui.registry.addNestedMenuItem("tablecellborderstyle", {
      icon: "border-style",
      text: "Border style",
      getSubmenuItems: () => mo(M, nm(M), "tablecellborderstyle", zi(M, "border-style")),
      onSetup: W.onSetupCellOrRow
    }), M.ui.registry.addNestedMenuItem("tablecellbackgroundcolor", {
      icon: "cell-background-color",
      text: "Background color",
      getSubmenuItems: () => ye(M, Mm(M), "background-color"),
      onSetup: W.onSetupCellOrRow
    }), M.ui.registry.addNestedMenuItem("tablecellbordercolor", {
      icon: "cell-border-color",
      text: "Border color",
      getSubmenuItems: () => ye(M, Id(M), "border-color"),
      onSetup: W.onSetupCellOrRow
    })), qe("tablecaption", {
      icon: "table-caption",
      text: "Table caption",
      command: "mceTableToggleCaption",
      onSetup: W.onSetupTableWithCaption
    }), qe("tablerowheader", {
      text: "Row header",
      icon: "table-top-header",
      command: "mceTableRowType",
      onAction: cu(M),
      onSetup: W.onSetupTableRowHeaders
    }), qe("tablecolheader", {
      text: "Column header",
      icon: "table-left-header",
      command: "mceTableColType",
      onAction: zm(M),
      onSetup: W.onSetupTableRowHeaders
    });
  }, vf = (M) => {
    const W = Ip(M);
    Vs(M), Wh(M), bl(M, W), vi(M, W), ii(M);
  };
  var sr = () => {
    r.add("table", vf);
  };
  sr();
})();
(function() {
  const r = (G) => {
    let me = G;
    return {
      get: () => me,
      set: (q) => {
        me = q;
      }
    };
  };
  var o = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const c = (G) => () => G;
  var i = tinymce.util.Tools.resolve("tinymce.Env");
  const d = (G) => G.dispatch("ResizeEditor"), m = (G) => (me) => me.options.get(G), v = (G) => {
    const me = G.options.register;
    me("autoresize_overflow_padding", {
      processor: "number",
      default: 1
    }), me("autoresize_bottom_margin", {
      processor: "number",
      default: 50
    });
  }, g = m("min_height"), C = m("max_height"), O = m("autoresize_overflow_padding"), R = m("autoresize_bottom_margin"), I = (G) => G.plugins.fullscreen && G.plugins.fullscreen.isFullscreen(), L = (G, me) => {
    const we = G.getBody();
    we && (we.style.overflowY = me ? "" : "hidden", me || (we.scrollTop = 0));
  }, Z = (G, me, we, be) => {
    var q;
    const Te = parseInt((q = G.getStyle(me, we, be)) !== null && q !== void 0 ? q : "", 10);
    return isNaN(Te) ? 0 : Te;
  }, ne = (G) => {
    if ((G == null ? void 0 : G.type.toLowerCase()) === "setcontent") {
      const me = G;
      return me.selection === !0 || me.paste === !0;
    } else
      return !1;
  }, se = (G, me, we, be) => {
    var q;
    const Te = G.dom, Le = G.getDoc();
    if (!Le)
      return;
    if (I(G)) {
      L(G, !0);
      return;
    }
    const je = Le.documentElement, Ie = be ? be() : O(G), Ce = (q = g(G)) !== null && q !== void 0 ? q : G.getElement().offsetHeight;
    let pt = Ce;
    const sn = Z(Te, je, "margin-top", !0), Lt = Z(Te, je, "margin-bottom", !0);
    let z = je.offsetHeight + sn + Lt + Ie;
    z < 0 && (z = 0);
    const bt = G.getContainer().offsetHeight, at = G.getContentAreaContainer().offsetHeight, _n = bt - at;
    z + _n > Ce && (pt = z + _n);
    const st = C(G);
    if (st && pt > st ? (pt = st, L(G, !0)) : L(G, !1), pt !== me.get()) {
      const Ne = pt - me.get();
      if (Te.setStyle(G.getContainer(), "height", pt + "px"), me.set(pt), d(G), i.browser.isSafari() && (i.os.isMacOS() || i.os.isiOS())) {
        const vt = G.getWin();
        vt.scrollTo(vt.pageXOffset, vt.pageYOffset);
      }
      G.hasFocus() && ne(we) && G.selection.scrollIntoView(), (i.browser.isSafari() || i.browser.isChromium()) && Ne < 0 && se(G, me, we, be);
    }
  }, Q = (G, me) => {
    let we = () => R(G), be, q;
    G.on("init", (Te) => {
      be = 0;
      const Le = O(G), je = G.dom;
      je.setStyles(G.getDoc().documentElement, { height: "auto" }), i.browser.isEdge() || i.browser.isIE() ? je.setStyles(G.getBody(), {
        paddingLeft: Le,
        paddingRight: Le,
        "min-height": 0
      }) : je.setStyles(G.getBody(), {
        paddingLeft: Le,
        paddingRight: Le
      }), se(G, me, Te, we), be += 1;
    }), G.on("NodeChange SetContent keyup FullscreenStateChanged ResizeContent", (Te) => {
      if (be === 1)
        q = G.getContainer().offsetHeight, se(G, me, Te, we), be += 1;
      else if (be === 2) {
        const Le = q < G.getContainer().offsetHeight;
        if (Le) {
          const je = G.dom, Ie = G.getDoc();
          je.setStyles(Ie.documentElement, { "min-height": 0 }), je.setStyles(G.getBody(), { "min-height": "inherit" });
        }
        we = Le ? c(0) : we, be += 1;
      } else
        se(G, me, Te, we);
    });
  }, he = (G, me) => {
    G.addCommand("mceAutoResize", () => {
      se(G, me);
    });
  };
  var ue = () => {
    o.add("autoresize", (G) => {
      if (v(G), G.options.isSet("resize") || G.options.set("resize", !1), !G.inline) {
        const me = r(0);
        he(G, me), Q(G, me);
      }
    });
  };
  ue();
})();
/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 *
 * @license MIT <https://opensource.org/licenses/MIT>
 * @author Lea Verou <https://lea.verou.me>
 * @namespace
 * @public
 */
(function() {
  var r = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const o = (z) => z == null, c = (z) => !o(z), i = () => {
  }, d = (z) => () => z;
  class m {
    constructor(bt, at) {
      this.tag = bt, this.value = at;
    }
    static some(bt) {
      return new m(!0, bt);
    }
    static none() {
      return m.singletonNone;
    }
    fold(bt, at) {
      return this.tag ? at(this.value) : bt();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(bt) {
      return this.tag ? m.some(bt(this.value)) : m.none();
    }
    bind(bt) {
      return this.tag ? bt(this.value) : m.none();
    }
    exists(bt) {
      return this.tag && bt(this.value);
    }
    forall(bt) {
      return !this.tag || bt(this.value);
    }
    filter(bt) {
      return !this.tag || bt(this.value) ? this : m.none();
    }
    getOr(bt) {
      return this.tag ? this.value : bt;
    }
    or(bt) {
      return this.tag ? this : bt;
    }
    getOrThunk(bt) {
      return this.tag ? this.value : bt();
    }
    orThunk(bt) {
      return this.tag ? this : bt();
    }
    getOrDie(bt) {
      if (this.tag)
        return this.value;
      throw new Error(bt ?? "Called getOrDie on None");
    }
    static from(bt) {
      return c(bt) ? m.some(bt) : m.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(bt) {
      this.tag && bt(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  m.singletonNone = new m(!1);
  const v = (z, bt) => bt >= 0 && bt < z.length ? m.some(z[bt]) : m.none(), g = (z) => v(z, 0);
  var C = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils");
  const O = typeof window < "u" ? window : Function("return this;")(), R = function(z, bt, at) {
    const _n = window.Prism;
    window.Prism = { manual: !0 };
    var st = typeof window < "u" ? window : typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope ? self : {}, Ne = function(vt) {
      var Gt = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i, xt = 0, cn = {}, He = {
        manual: vt.Prism && vt.Prism.manual,
        disableWorkerMessageHandler: vt.Prism && vt.Prism.disableWorkerMessageHandler,
        util: {
          encode: function ke(Ct) {
            return Ct instanceof ut ? new ut(Ct.type, ke(Ct.content), Ct.alias) : Array.isArray(Ct) ? Ct.map(ke) : Ct.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
          },
          type: function(ke) {
            return Object.prototype.toString.call(ke).slice(8, -1);
          },
          objId: function(ke) {
            return ke.__id || Object.defineProperty(ke, "__id", { value: ++xt }), ke.__id;
          },
          clone: function ke(Ct, an) {
            an = an || {};
            var ht, bn;
            switch (He.util.type(Ct)) {
              case "Object":
                if (bn = He.util.objId(Ct), an[bn])
                  return an[bn];
                ht = {}, an[bn] = ht;
                for (var Ye in Ct)
                  Ct.hasOwnProperty(Ye) && (ht[Ye] = ke(Ct[Ye], an));
                return ht;
              case "Array":
                return bn = He.util.objId(Ct), an[bn] ? an[bn] : (ht = [], an[bn] = ht, Ct.forEach(function(nn, Bt) {
                  ht[Bt] = ke(nn, an);
                }), ht);
              default:
                return Ct;
            }
          },
          getLanguage: function(ke) {
            for (; ke; ) {
              var Ct = Gt.exec(ke.className);
              if (Ct)
                return Ct[1].toLowerCase();
              ke = ke.parentElement;
            }
            return "none";
          },
          setLanguage: function(ke, Ct) {
            ke.className = ke.className.replace(RegExp(Gt, "gi"), ""), ke.classList.add("language-" + Ct);
          },
          currentScript: function() {
            if (typeof document > "u")
              return null;
            if ("currentScript" in document && 1 < 2)
              return document.currentScript;
            try {
              throw new Error();
            } catch (ht) {
              var ke = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(ht.stack) || [])[1];
              if (ke) {
                var Ct = document.getElementsByTagName("script");
                for (var an in Ct)
                  if (Ct[an].src == ke)
                    return Ct[an];
              }
              return null;
            }
          },
          isActive: function(ke, Ct, an) {
            for (var ht = "no-" + Ct; ke; ) {
              var bn = ke.classList;
              if (bn.contains(Ct))
                return !0;
              if (bn.contains(ht))
                return !1;
              ke = ke.parentElement;
            }
            return !!an;
          }
        },
        languages: {
          plain: cn,
          plaintext: cn,
          text: cn,
          txt: cn,
          extend: function(ke, Ct) {
            var an = He.util.clone(He.languages[ke]);
            for (var ht in Ct)
              an[ht] = Ct[ht];
            return an;
          },
          insertBefore: function(ke, Ct, an, ht) {
            ht = ht || He.languages;
            var bn = ht[ke], Ye = {};
            for (var nn in bn)
              if (bn.hasOwnProperty(nn)) {
                if (nn == Ct)
                  for (var Bt in an)
                    an.hasOwnProperty(Bt) && (Ye[Bt] = an[Bt]);
                an.hasOwnProperty(nn) || (Ye[nn] = bn[nn]);
              }
            var $n = ht[ke];
            return ht[ke] = Ye, He.languages.DFS(He.languages, function(mr, gr) {
              gr === $n && mr != ke && (this[mr] = Ye);
            }), Ye;
          },
          DFS: function ke(Ct, an, ht, bn) {
            bn = bn || {};
            var Ye = He.util.objId;
            for (var nn in Ct)
              if (Ct.hasOwnProperty(nn)) {
                an.call(Ct, nn, Ct[nn], ht || nn);
                var Bt = Ct[nn], $n = He.util.type(Bt);
                $n === "Object" && !bn[Ye(Bt)] ? (bn[Ye(Bt)] = !0, ke(Bt, an, null, bn)) : $n === "Array" && !bn[Ye(Bt)] && (bn[Ye(Bt)] = !0, ke(Bt, an, nn, bn));
              }
          }
        },
        plugins: {},
        highlightAll: function(ke, Ct) {
          He.highlightAllUnder(document, ke, Ct);
        },
        highlightAllUnder: function(ke, Ct, an) {
          var ht = {
            callback: an,
            container: ke,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
          };
          He.hooks.run("before-highlightall", ht), ht.elements = Array.prototype.slice.apply(ht.container.querySelectorAll(ht.selector)), He.hooks.run("before-all-elements-highlight", ht);
          for (var bn = 0, Ye; Ye = ht.elements[bn++]; )
            He.highlightElement(Ye, Ct === !0, ht.callback);
        },
        highlightElement: function(ke, Ct, an) {
          var ht = He.util.getLanguage(ke), bn = He.languages[ht];
          He.util.setLanguage(ke, ht);
          var Ye = ke.parentElement;
          Ye && Ye.nodeName.toLowerCase() === "pre" && He.util.setLanguage(Ye, ht);
          var nn = ke.textContent, Bt = {
            element: ke,
            language: ht,
            grammar: bn,
            code: nn
          };
          function $n(gr) {
            Bt.highlightedCode = gr, He.hooks.run("before-insert", Bt), Bt.element.innerHTML = Bt.highlightedCode, He.hooks.run("after-highlight", Bt), He.hooks.run("complete", Bt), an && an.call(Bt.element);
          }
          if (He.hooks.run("before-sanity-check", Bt), Ye = Bt.element.parentElement, Ye && Ye.nodeName.toLowerCase() === "pre" && !Ye.hasAttribute("tabindex") && Ye.setAttribute("tabindex", "0"), !Bt.code) {
            He.hooks.run("complete", Bt), an && an.call(Bt.element);
            return;
          }
          if (He.hooks.run("before-highlight", Bt), !Bt.grammar) {
            $n(He.util.encode(Bt.code));
            return;
          }
          if (Ct && vt.Worker) {
            var mr = new Worker(He.filename);
            mr.onmessage = function(gr) {
              $n(gr.data);
            }, mr.postMessage(JSON.stringify({
              language: Bt.language,
              code: Bt.code,
              immediateClose: !0
            }));
          } else
            $n(He.highlight(Bt.code, Bt.grammar, Bt.language));
        },
        highlight: function(ke, Ct, an) {
          var ht = {
            code: ke,
            grammar: Ct,
            language: an
          };
          if (He.hooks.run("before-tokenize", ht), !ht.grammar)
            throw new Error('The language "' + ht.language + '" has no grammar.');
          return ht.tokens = He.tokenize(ht.code, ht.grammar), He.hooks.run("after-tokenize", ht), ut.stringify(He.util.encode(ht.tokens), ht.language);
        },
        tokenize: function(ke, Ct) {
          var an = Ct.rest;
          if (an) {
            for (var ht in an)
              Ct[ht] = an[ht];
            delete Ct.rest;
          }
          var bn = new Rn();
          return Zt(bn, bn.head, ke), qn(ke, bn, Ct, bn.head, 0), wo(bn);
        },
        hooks: {
          all: {},
          add: function(ke, Ct) {
            var an = He.hooks.all;
            an[ke] = an[ke] || [], an[ke].push(Ct);
          },
          run: function(ke, Ct) {
            var an = He.hooks.all[ke];
            if (!(!an || !an.length))
              for (var ht = 0, bn; bn = an[ht++]; )
                bn(Ct);
          }
        },
        Token: ut
      };
      vt.Prism = He;
      function ut(ke, Ct, an, ht) {
        this.type = ke, this.content = Ct, this.alias = an, this.length = (ht || "").length | 0;
      }
      ut.stringify = function ke(Ct, an) {
        if (typeof Ct == "string")
          return Ct;
        if (Array.isArray(Ct)) {
          var ht = "";
          return Ct.forEach(function($n) {
            ht += ke($n, an);
          }), ht;
        }
        var bn = {
          type: Ct.type,
          content: ke(Ct.content, an),
          tag: "span",
          classes: [
            "token",
            Ct.type
          ],
          attributes: {},
          language: an
        }, Ye = Ct.alias;
        Ye && (Array.isArray(Ye) ? Array.prototype.push.apply(bn.classes, Ye) : bn.classes.push(Ye)), He.hooks.run("wrap", bn);
        var nn = "";
        for (var Bt in bn.attributes)
          nn += " " + Bt + '="' + (bn.attributes[Bt] || "").replace(/"/g, "&quot;") + '"';
        return "<" + bn.tag + ' class="' + bn.classes.join(" ") + '"' + nn + ">" + bn.content + "</" + bn.tag + ">";
      };
      function oe(ke, Ct, an, ht) {
        ke.lastIndex = Ct;
        var bn = ke.exec(an);
        if (bn && ht && bn[1]) {
          var Ye = bn[1].length;
          bn.index += Ye, bn[0] = bn[0].slice(Ye);
        }
        return bn;
      }
      function qn(ke, Ct, an, ht, bn, Ye) {
        for (var nn in an)
          if (!(!an.hasOwnProperty(nn) || !an[nn])) {
            var Bt = an[nn];
            Bt = Array.isArray(Bt) ? Bt : [Bt];
            for (var $n = 0; $n < Bt.length; ++$n) {
              if (Ye && Ye.cause == nn + "," + $n)
                return;
              var mr = Bt[$n], gr = mr.inside, Vr = !!mr.lookbehind, Xr = !!mr.greedy, pc = mr.alias;
              if (Xr && !mr.pattern.global) {
                var Eo = mr.pattern.toString().match(/[imsuy]*$/)[0];
                mr.pattern = RegExp(mr.pattern.source, Eo + "g");
              }
              for (var uo = mr.pattern || mr, Es = ht.next, br = bn; Es !== Ct.tail && !(Ye && br >= Ye.reach); br += Es.value.length, Es = Es.next) {
                var hs = Es.value;
                if (Ct.length > ke.length)
                  return;
                if (!(hs instanceof ut)) {
                  var Ps = 1, qo;
                  if (Xr) {
                    if (qo = oe(uo, br, ke, Vr), !qo || qo.index >= ke.length)
                      break;
                    var fn = qo.index, hc = qo.index + qo[0].length, Co = br;
                    for (Co += Es.value.length; fn >= Co; )
                      Es = Es.next, Co += Es.value.length;
                    if (Co -= Es.value.length, br = Co, Es.value instanceof ut)
                      continue;
                    for (var fl = Es; fl !== Ct.tail && (Co < hc || typeof fl.value == "string"); fl = fl.next)
                      Ps++, Co += fl.value.length;
                    Ps--, hs = ke.slice(br, Co), qo.index -= br;
                  } else if (qo = oe(uo, 0, hs, Vr), !qo)
                    continue;
                  var fn = qo.index, Yr = qo[0], xa = hs.slice(0, fn), $i = hs.slice(fn + Yr.length), Kc = br + hs.length;
                  Ye && Kc > Ye.reach && (Ye.reach = Kc);
                  var wi = Es.prev;
                  xa && (wi = Zt(Ct, wi, xa), br += xa.length), Jt(Ct, wi, Ps);
                  var es = new ut(nn, gr ? He.tokenize(Yr, gr) : Yr, pc, Yr);
                  if (Es = Zt(Ct, wi, es), $i && Zt(Ct, Es, $i), Ps > 1) {
                    var gc = {
                      cause: nn + "," + $n,
                      reach: Kc
                    };
                    qn(ke, Ct, an, Es.prev, br, gc), Ye && gc.reach > Ye.reach && (Ye.reach = gc.reach);
                  }
                }
              }
            }
          }
      }
      function Rn() {
        var ke = {
          value: null,
          prev: null,
          next: null
        }, Ct = {
          value: null,
          prev: ke,
          next: null
        };
        ke.next = Ct, this.head = ke, this.tail = Ct, this.length = 0;
      }
      function Zt(ke, Ct, an) {
        var ht = Ct.next, bn = {
          value: an,
          prev: Ct,
          next: ht
        };
        return Ct.next = bn, ht.prev = bn, ke.length++, bn;
      }
      function Jt(ke, Ct, an) {
        for (var ht = Ct.next, bn = 0; bn < an && ht !== ke.tail; bn++)
          ht = ht.next;
        Ct.next = ht, ht.prev = Ct, ke.length -= bn;
      }
      function wo(ke) {
        for (var Ct = [], an = ke.head.next; an !== ke.tail; )
          Ct.push(an.value), an = an.next;
        return Ct;
      }
      if (!vt.document)
        return vt.addEventListener && (He.disableWorkerMessageHandler || vt.addEventListener("message", function(ke) {
          var Ct = JSON.parse(ke.data), an = Ct.language, ht = Ct.code, bn = Ct.immediateClose;
          vt.postMessage(He.highlight(ht, He.languages[an], an)), bn && vt.close();
        }, !1)), He;
      var Ge = He.util.currentScript();
      Ge && (He.filename = Ge.src, Ge.hasAttribute("data-manual") && (He.manual = !0));
      function qt() {
        He.manual || He.highlightAll();
      }
      if (!He.manual) {
        var St = document.readyState;
        St === "loading" || St === "interactive" && Ge && Ge.defer ? document.addEventListener("DOMContentLoaded", qt) : window.requestAnimationFrame ? window.requestAnimationFrame(qt) : window.setTimeout(qt, 16);
      }
      return He;
    }(st);
    return typeof bt < "u" && bt.exports && (bt.exports = Ne), typeof z < "u" && (z.Prism = Ne), Ne.languages.clike = {
      comment: [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: !0,
          greedy: !0
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: !0,
          greedy: !0
        }
      ],
      string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: !0
      },
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: !0,
        inside: { punctuation: /[.\\]/ }
      },
      keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
      boolean: /\b(?:false|true)\b/,
      function: /\b\w+(?=\()/,
      number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
      punctuation: /[{}[\];(),.:]/
    }, function(vt) {
      function Gt(xt, cn) {
        return "___" + xt.toUpperCase() + cn + "___";
      }
      Object.defineProperties(vt.languages["markup-templating"] = {}, {
        buildPlaceholders: {
          value: function(xt, cn, He, ut) {
            if (xt.language === cn) {
              var oe = xt.tokenStack = [];
              xt.code = xt.code.replace(He, function(qn) {
                if (typeof ut == "function" && !ut(qn))
                  return qn;
                for (var Rn = oe.length, Zt; xt.code.indexOf(Zt = Gt(cn, Rn)) !== -1; )
                  ++Rn;
                return oe[Rn] = qn, Zt;
              }), xt.grammar = vt.languages.markup;
            }
          }
        },
        tokenizePlaceholders: {
          value: function(xt, cn) {
            if (xt.language !== cn || !xt.tokenStack)
              return;
            xt.grammar = vt.languages[cn];
            var He = 0, ut = Object.keys(xt.tokenStack);
            function oe(qn) {
              for (var Rn = 0; Rn < qn.length && !(He >= ut.length); Rn++) {
                var Zt = qn[Rn];
                if (typeof Zt == "string" || Zt.content && typeof Zt.content == "string") {
                  var Jt = ut[He], wo = xt.tokenStack[Jt], Ge = typeof Zt == "string" ? Zt : Zt.content, qt = Gt(cn, Jt), St = Ge.indexOf(qt);
                  if (St > -1) {
                    ++He;
                    var ke = Ge.substring(0, St), Ct = new vt.Token(cn, vt.tokenize(wo, xt.grammar), "language-" + cn, wo), an = Ge.substring(St + qt.length), ht = [];
                    ke && ht.push.apply(ht, oe([ke])), ht.push(Ct), an && ht.push.apply(ht, oe([an])), typeof Zt == "string" ? qn.splice.apply(qn, [
                      Rn,
                      1
                    ].concat(ht)) : Zt.content = ht;
                  }
                } else
                  Zt.content && oe(Zt.content);
              }
              return qn;
            }
            oe(xt.tokens);
          }
        }
      });
    }(Ne), Ne.languages.c = Ne.languages.extend("clike", {
      comment: {
        pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
        greedy: !0
      },
      string: {
        pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
        greedy: !0
      },
      "class-name": {
        pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
        lookbehind: !0
      },
      keyword: /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
      function: /\b[a-z_]\w*(?=\s*\()/i,
      number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
      operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
    }), Ne.languages.insertBefore("c", "string", {
      char: {
        pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
        greedy: !0
      }
    }), Ne.languages.insertBefore("c", "string", {
      macro: {
        pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
        lookbehind: !0,
        greedy: !0,
        alias: "property",
        inside: {
          string: [
            {
              pattern: /^(#\s*include\s*)<[^>]+>/,
              lookbehind: !0
            },
            Ne.languages.c.string
          ],
          char: Ne.languages.c.char,
          comment: Ne.languages.c.comment,
          "macro-name": [
            {
              pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
              lookbehind: !0
            },
            {
              pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
              lookbehind: !0,
              alias: "function"
            }
          ],
          directive: {
            pattern: /^(#\s*)[a-z]+/,
            lookbehind: !0,
            alias: "keyword"
          },
          "directive-hash": /^#/,
          punctuation: /##|\\(?=[\r\n])/,
          expression: {
            pattern: /\S[\s\S]*/,
            inside: Ne.languages.c
          }
        }
      }
    }), Ne.languages.insertBefore("c", "function", { constant: /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/ }), delete Ne.languages.c.boolean, function(vt) {
      var Gt = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/, xt = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
        return Gt.source;
      });
      vt.languages.cpp = vt.languages.extend("c", {
        "class-name": [
          {
            pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
              return Gt.source;
            })),
            lookbehind: !0
          },
          /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
          /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
          /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
        ],
        keyword: Gt,
        number: {
          pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
          greedy: !0
        },
        operator: />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
        boolean: /\b(?:false|true)\b/
      }), vt.languages.insertBefore("cpp", "string", {
        module: {
          pattern: RegExp(/(\b(?:import|module)\s+)/.source + "(?:" + /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
            return xt;
          }) + ")"),
          lookbehind: !0,
          greedy: !0,
          inside: {
            string: /^[<"][\s\S]+/,
            operator: /:/,
            punctuation: /\./
          }
        },
        "raw-string": {
          pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
          alias: "string",
          greedy: !0
        }
      }), vt.languages.insertBefore("cpp", "keyword", {
        "generic-function": {
          pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
          inside: {
            function: /^\w+/,
            generic: {
              pattern: /<[\s\S]+/,
              alias: "class-name",
              inside: vt.languages.cpp
            }
          }
        }
      }), vt.languages.insertBefore("cpp", "operator", {
        "double-colon": {
          pattern: /::/,
          alias: "punctuation"
        }
      }), vt.languages.insertBefore("cpp", "class-name", {
        "base-clause": {
          pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
          lookbehind: !0,
          greedy: !0,
          inside: vt.languages.extend("cpp", {})
        }
      }), vt.languages.insertBefore("inside", "double-colon", { "class-name": /\b[a-z_]\w*\b(?!\s*::)/i }, vt.languages.cpp["base-clause"]);
    }(Ne), function(vt) {
      function Gt(qo, hc) {
        return qo.replace(/<<(\d+)>>/g, function(Co, fl) {
          return "(?:" + hc[+fl] + ")";
        });
      }
      function xt(qo, hc, Co) {
        return RegExp(Gt(qo, hc), Co || "");
      }
      function cn(qo, hc) {
        for (var Co = 0; Co < hc; Co++)
          qo = qo.replace(/<<self>>/g, function() {
            return "(?:" + qo + ")";
          });
        return qo.replace(/<<self>>/g, "[^\\s\\S]");
      }
      var He = {
        type: "bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void",
        typeDeclaration: "class enum interface record struct",
        contextual: "add alias and ascending async await by descending from(?=\\s*(?:\\w|$)) get global group into init(?=\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\s*{)",
        other: "abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield"
      };
      function ut(qo) {
        return "\\b(?:" + qo.trim().replace(/ /g, "|") + ")\\b";
      }
      var oe = ut(He.typeDeclaration), qn = RegExp(ut(He.type + " " + He.typeDeclaration + " " + He.contextual + " " + He.other)), Rn = ut(He.typeDeclaration + " " + He.contextual + " " + He.other), Zt = ut(He.type + " " + He.typeDeclaration + " " + He.other), Jt = cn(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source, 2), wo = cn(/\((?:[^()]|<<self>>)*\)/.source, 2), Ge = /@?\b[A-Za-z_]\w*\b/.source, qt = Gt(/<<0>>(?:\s*<<1>>)?/.source, [
        Ge,
        Jt
      ]), St = Gt(/(?!<<0>>)<<1>>(?:\s*\.\s*<<1>>)*/.source, [
        Rn,
        qt
      ]), ke = /\[\s*(?:,\s*)*\]/.source, Ct = Gt(/<<0>>(?:\s*(?:\?\s*)?<<1>>)*(?:\s*\?)?/.source, [
        St,
        ke
      ]), an = Gt(/[^,()<>[\];=+\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source, [
        Jt,
        wo,
        ke
      ]), ht = Gt(/\(<<0>>+(?:,<<0>>+)+\)/.source, [an]), bn = Gt(/(?:<<0>>|<<1>>)(?:\s*(?:\?\s*)?<<2>>)*(?:\s*\?)?/.source, [
        ht,
        St,
        ke
      ]), Ye = {
        keyword: qn,
        punctuation: /[<>()?,.:[\]]/
      }, nn = /'(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'/.source, Bt = /"(?:\\.|[^\\"\r\n])*"/.source, $n = /@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source;
      vt.languages.csharp = vt.languages.extend("clike", {
        string: [
          {
            pattern: xt(/(^|[^$\\])<<0>>/.source, [$n]),
            lookbehind: !0,
            greedy: !0
          },
          {
            pattern: xt(/(^|[^@$\\])<<0>>/.source, [Bt]),
            lookbehind: !0,
            greedy: !0
          }
        ],
        "class-name": [
          {
            pattern: xt(/(\busing\s+static\s+)<<0>>(?=\s*;)/.source, [St]),
            lookbehind: !0,
            inside: Ye
          },
          {
            pattern: xt(/(\busing\s+<<0>>\s*=\s*)<<1>>(?=\s*;)/.source, [
              Ge,
              bn
            ]),
            lookbehind: !0,
            inside: Ye
          },
          {
            pattern: xt(/(\busing\s+)<<0>>(?=\s*=)/.source, [Ge]),
            lookbehind: !0
          },
          {
            pattern: xt(/(\b<<0>>\s+)<<1>>/.source, [
              oe,
              qt
            ]),
            lookbehind: !0,
            inside: Ye
          },
          {
            pattern: xt(/(\bcatch\s*\(\s*)<<0>>/.source, [St]),
            lookbehind: !0,
            inside: Ye
          },
          {
            pattern: xt(/(\bwhere\s+)<<0>>/.source, [Ge]),
            lookbehind: !0
          },
          {
            pattern: xt(/(\b(?:is(?:\s+not)?|as)\s+)<<0>>/.source, [Ct]),
            lookbehind: !0,
            inside: Ye
          },
          {
            pattern: xt(/\b<<0>>(?=\s+(?!<<1>>|with\s*\{)<<2>>(?:\s*[=,;:{)\]]|\s+(?:in|when)\b))/.source, [
              bn,
              Zt,
              Ge
            ]),
            inside: Ye
          }
        ],
        keyword: qn,
        number: /(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:[dflmu]|lu|ul)?\b/i,
        operator: />>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/,
        punctuation: /\?\.?|::|[{}[\];(),.:]/
      }), vt.languages.insertBefore("csharp", "number", {
        range: {
          pattern: /\.\./,
          alias: "operator"
        }
      }), vt.languages.insertBefore("csharp", "punctuation", {
        "named-parameter": {
          pattern: xt(/([(,]\s*)<<0>>(?=\s*:)/.source, [Ge]),
          lookbehind: !0,
          alias: "punctuation"
        }
      }), vt.languages.insertBefore("csharp", "class-name", {
        namespace: {
          pattern: xt(/(\b(?:namespace|using)\s+)<<0>>(?:\s*\.\s*<<0>>)*(?=\s*[;{])/.source, [Ge]),
          lookbehind: !0,
          inside: { punctuation: /\./ }
        },
        "type-expression": {
          pattern: xt(/(\b(?:default|sizeof|typeof)\s*\(\s*(?!\s))(?:[^()\s]|\s(?!\s)|<<0>>)*(?=\s*\))/.source, [wo]),
          lookbehind: !0,
          alias: "class-name",
          inside: Ye
        },
        "return-type": {
          pattern: xt(/<<0>>(?=\s+(?:<<1>>\s*(?:=>|[({]|\.\s*this\s*\[)|this\s*\[))/.source, [
            bn,
            St
          ]),
          inside: Ye,
          alias: "class-name"
        },
        "constructor-invocation": {
          pattern: xt(/(\bnew\s+)<<0>>(?=\s*[[({])/.source, [bn]),
          lookbehind: !0,
          inside: Ye,
          alias: "class-name"
        },
        "generic-method": {
          pattern: xt(/<<0>>\s*<<1>>(?=\s*\()/.source, [
            Ge,
            Jt
          ]),
          inside: {
            function: xt(/^<<0>>/.source, [Ge]),
            generic: {
              pattern: RegExp(Jt),
              alias: "class-name",
              inside: Ye
            }
          }
        },
        "type-list": {
          pattern: xt(/\b((?:<<0>>\s+<<1>>|record\s+<<1>>\s*<<5>>|where\s+<<2>>)\s*:\s*)(?:<<3>>|<<4>>|<<1>>\s*<<5>>|<<6>>)(?:\s*,\s*(?:<<3>>|<<4>>|<<6>>))*(?=\s*(?:where|[{;]|=>|$))/.source, [
            oe,
            qt,
            Ge,
            bn,
            qn.source,
            wo,
            /\bnew\s*\(\s*\)/.source
          ]),
          lookbehind: !0,
          inside: {
            "record-arguments": {
              pattern: xt(/(^(?!new\s*\()<<0>>\s*)<<1>>/.source, [
                qt,
                wo
              ]),
              lookbehind: !0,
              greedy: !0,
              inside: vt.languages.csharp
            },
            keyword: qn,
            "class-name": {
              pattern: RegExp(bn),
              greedy: !0,
              inside: Ye
            },
            punctuation: /[,()]/
          }
        },
        preprocessor: {
          pattern: /(^[\t ]*)#.*/m,
          lookbehind: !0,
          alias: "property",
          inside: {
            directive: {
              pattern: /(#)\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\b/,
              lookbehind: !0,
              alias: "keyword"
            }
          }
        }
      });
      var mr = Bt + "|" + nn, gr = Gt(/\/(?![*/])|\/\/[^\r\n]*[\r\n]|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>/.source, [mr]), Vr = cn(Gt(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [gr]), 2), Xr = /\b(?:assembly|event|field|method|module|param|property|return|type)\b/.source, pc = Gt(/<<0>>(?:\s*\(<<1>>*\))?/.source, [
        St,
        Vr
      ]);
      vt.languages.insertBefore("csharp", "class-name", {
        attribute: {
          pattern: xt(/((?:^|[^\s\w>)?])\s*\[\s*)(?:<<0>>\s*:\s*)?<<1>>(?:\s*,\s*<<1>>)*(?=\s*\])/.source, [
            Xr,
            pc
          ]),
          lookbehind: !0,
          greedy: !0,
          inside: {
            target: {
              pattern: xt(/^<<0>>(?=\s*:)/.source, [Xr]),
              alias: "keyword"
            },
            "attribute-arguments": {
              pattern: xt(/\(<<0>>*\)/.source, [Vr]),
              inside: vt.languages.csharp
            },
            "class-name": {
              pattern: RegExp(St),
              inside: { punctuation: /\./ }
            },
            punctuation: /[:,]/
          }
        }
      });
      var Eo = /:[^}\r\n]+/.source, uo = cn(Gt(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [gr]), 2), Es = Gt(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [
        uo,
        Eo
      ]), br = cn(Gt(/[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/.source, [mr]), 2), hs = Gt(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [
        br,
        Eo
      ]);
      function Ps(qo, hc) {
        return {
          interpolation: {
            pattern: xt(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [qo]),
            lookbehind: !0,
            inside: {
              "format-string": {
                pattern: xt(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source, [
                  hc,
                  Eo
                ]),
                lookbehind: !0,
                inside: { punctuation: /^:/ }
              },
              punctuation: /^\{|\}$/,
              expression: {
                pattern: /[\s\S]+/,
                alias: "language-csharp",
                inside: vt.languages.csharp
              }
            }
          },
          string: /[\s\S]+/
        };
      }
      vt.languages.insertBefore("csharp", "string", {
        "interpolation-string": [
          {
            pattern: xt(/(^|[^\\])(?:\$@|@\$)"(?:""|\\[\s\S]|\{\{|<<0>>|[^\\{"])*"/.source, [Es]),
            lookbehind: !0,
            greedy: !0,
            inside: Ps(Es, uo)
          },
          {
            pattern: xt(/(^|[^@\\])\$"(?:\\.|\{\{|<<0>>|[^\\"{])*"/.source, [hs]),
            lookbehind: !0,
            greedy: !0,
            inside: Ps(hs, br)
          }
        ],
        char: {
          pattern: RegExp(nn),
          greedy: !0
        }
      }), vt.languages.dotnet = vt.languages.cs = vt.languages.csharp;
    }(Ne), function(vt) {
      var Gt = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      vt.languages.css = {
        comment: /\/\*[\s\S]*?\*\//,
        atrule: {
          pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + Gt.source + ")*?" + /(?:;|(?=\s*\{))/.source),
          inside: {
            rule: /^@[\w-]+/,
            "selector-function-argument": {
              pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
              lookbehind: !0,
              alias: "selector"
            },
            keyword: {
              pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
              lookbehind: !0
            }
          }
        },
        url: {
          pattern: RegExp("\\burl\\((?:" + Gt.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
          greedy: !0,
          inside: {
            function: /^url/i,
            punctuation: /^\(|\)$/,
            string: {
              pattern: RegExp("^" + Gt.source + "$"),
              alias: "url"
            }
          }
        },
        selector: {
          pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + Gt.source + ")*(?=\\s*\\{)"),
          lookbehind: !0
        },
        string: {
          pattern: Gt,
          greedy: !0
        },
        property: {
          pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
          lookbehind: !0
        },
        important: /!important\b/i,
        function: {
          pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
          lookbehind: !0
        },
        punctuation: /[(){};:,]/
      }, vt.languages.css.atrule.inside.rest = vt.languages.css;
      var xt = vt.languages.markup;
      xt && (xt.tag.addInlined("style", "css"), xt.tag.addAttribute("style", "css"));
    }(Ne), function(vt) {
      var Gt = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/, xt = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source, cn = {
        pattern: RegExp(/(^|[^\w.])/.source + xt + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
        lookbehind: !0,
        inside: {
          namespace: {
            pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
            inside: { punctuation: /\./ }
          },
          punctuation: /\./
        }
      };
      vt.languages.java = vt.languages.extend("clike", {
        string: {
          pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
          lookbehind: !0,
          greedy: !0
        },
        "class-name": [
          cn,
          {
            pattern: RegExp(/(^|[^\w.])/.source + xt + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
            lookbehind: !0,
            inside: cn.inside
          },
          {
            pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + xt + /[A-Z]\w*\b/.source),
            lookbehind: !0,
            inside: cn.inside
          }
        ],
        keyword: Gt,
        function: [
          vt.languages.clike.function,
          {
            pattern: /(::\s*)[a-z_]\w*/,
            lookbehind: !0
          }
        ],
        number: /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
        operator: {
          pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
          lookbehind: !0
        },
        constant: /\b[A-Z][A-Z_\d]+\b/
      }), vt.languages.insertBefore("java", "string", {
        "triple-quoted-string": {
          pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
          greedy: !0,
          alias: "string"
        },
        char: {
          pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
          greedy: !0
        }
      }), vt.languages.insertBefore("java", "class-name", {
        annotation: {
          pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
          lookbehind: !0,
          alias: "punctuation"
        },
        generics: {
          pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
          inside: {
            "class-name": cn,
            keyword: Gt,
            punctuation: /[<>(),.:]/,
            operator: /[?&|]/
          }
        },
        import: [
          {
            pattern: RegExp(/(\bimport\s+)/.source + xt + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
            lookbehind: !0,
            inside: {
              namespace: cn.inside.namespace,
              punctuation: /\./,
              operator: /\*/,
              "class-name": /\w+/
            }
          },
          {
            pattern: RegExp(/(\bimport\s+static\s+)/.source + xt + /(?:\w+|\*)(?=\s*;)/.source),
            lookbehind: !0,
            alias: "static",
            inside: {
              namespace: cn.inside.namespace,
              static: /\b\w+$/,
              punctuation: /\./,
              operator: /\*/,
              "class-name": /\w+/
            }
          }
        ],
        namespace: {
          pattern: RegExp(/(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
            return Gt.source;
          })),
          lookbehind: !0,
          inside: { punctuation: /\./ }
        }
      });
    }(Ne), Ne.languages.javascript = Ne.languages.extend("clike", {
      "class-name": [
        Ne.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
          lookbehind: !0
        }
      ],
      keyword: [
        {
          pattern: /((?:^|\})\s*)catch\b/,
          lookbehind: !0
        },
        {
          pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: !0
        }
      ],
      function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      number: {
        pattern: RegExp(/(^|[^\w$])/.source + "(?:" + (/NaN|Infinity/.source + "|" + /0[bB][01]+(?:_[01]+)*n?/.source + "|" + /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + /\d+(?:_\d+)*n/.source + "|" + /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source),
        lookbehind: !0
      },
      operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    }), Ne.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, Ne.languages.insertBefore("javascript", "keyword", {
      regex: {
        pattern: RegExp(/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source),
        lookbehind: !0,
        greedy: !0,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: !0,
            alias: "language-regex",
            inside: Ne.languages.regex
          },
          "regex-delimiter": /^\/|\/$/,
          "regex-flags": /^[a-z]+$/
        }
      },
      "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
      },
      parameter: [
        {
          pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: !0,
          inside: Ne.languages.javascript
        },
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: !0,
          inside: Ne.languages.javascript
        },
        {
          pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
          lookbehind: !0,
          inside: Ne.languages.javascript
        },
        {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: !0,
          inside: Ne.languages.javascript
        }
      ],
      constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    }), Ne.languages.insertBefore("javascript", "string", {
      hashbang: {
        pattern: /^#!.*/,
        greedy: !0,
        alias: "comment"
      },
      "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: !0,
        inside: {
          "template-punctuation": {
            pattern: /^`|`$/,
            alias: "string"
          },
          interpolation: {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: !0,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              rest: Ne.languages.javascript
            }
          },
          string: /[\s\S]+/
        }
      },
      "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: !0,
        greedy: !0,
        alias: "property"
      }
    }), Ne.languages.insertBefore("javascript", "operator", {
      "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: !0,
        alias: "property"
      }
    }), Ne.languages.markup && (Ne.languages.markup.tag.addInlined("script", "javascript"), Ne.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript")), Ne.languages.js = Ne.languages.javascript, Ne.languages.markup = {
      comment: {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: !0
      },
      prolog: {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: !0
      },
      doctype: {
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: !0,
        inside: {
          "internal-subset": {
            pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
            lookbehind: !0,
            greedy: !0,
            inside: null
          },
          string: {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: !0
          },
          punctuation: /^<!|>$|[[\]]/,
          "doctype-tag": /^DOCTYPE/i,
          name: /[^\s<>'"]+/
        }
      },
      cdata: {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: !0
      },
      tag: {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: !0,
        inside: {
          tag: {
            pattern: /^<\/?[^\s>\/]+/,
            inside: {
              punctuation: /^<\/?/,
              namespace: /^[^\s>\/:]+:/
            }
          },
          "special-attr": [],
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
            inside: {
              punctuation: [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                {
                  pattern: /^(\s*)["']|["']$/,
                  lookbehind: !0
                }
              ]
            }
          },
          punctuation: /\/?>/,
          "attr-name": {
            pattern: /[^\s>\/]+/,
            inside: { namespace: /^[^\s>\/:]+:/ }
          }
        }
      },
      entity: [
        {
          pattern: /&[\da-z]{1,8};/i,
          alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
      ]
    }, Ne.languages.markup.tag.inside["attr-value"].inside.entity = Ne.languages.markup.entity, Ne.languages.markup.doctype.inside["internal-subset"].inside = Ne.languages.markup, Ne.hooks.add("wrap", function(vt) {
      vt.type === "entity" && (vt.attributes.title = vt.content.replace(/&amp;/, "&"));
    }), Object.defineProperty(Ne.languages.markup.tag, "addInlined", {
      value: function(Gt, xt) {
        var cn = {};
        cn["language-" + xt] = {
          pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
          lookbehind: !0,
          inside: Ne.languages[xt]
        }, cn.cdata = /^<!\[CDATA\[|\]\]>$/i;
        var He = {
          "included-cdata": {
            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
            inside: cn
          }
        };
        He["language-" + xt] = {
          pattern: /[\s\S]+/,
          inside: Ne.languages[xt]
        };
        var ut = {};
        ut[Gt] = {
          pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
            return Gt;
          }), "i"),
          lookbehind: !0,
          greedy: !0,
          inside: He
        }, Ne.languages.insertBefore("markup", "cdata", ut);
      }
    }), Object.defineProperty(Ne.languages.markup.tag, "addAttribute", {
      value: function(vt, Gt) {
        Ne.languages.markup.tag.inside["special-attr"].push({
          pattern: RegExp(/(^|["'\s])/.source + "(?:" + vt + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"),
          lookbehind: !0,
          inside: {
            "attr-name": /^[^\s=]+/,
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                value: {
                  pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                  lookbehind: !0,
                  alias: [
                    Gt,
                    "language-" + Gt
                  ],
                  inside: Ne.languages[Gt]
                },
                punctuation: [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  /"|'/
                ]
              }
            }
          }
        });
      }
    }), Ne.languages.html = Ne.languages.markup, Ne.languages.mathml = Ne.languages.markup, Ne.languages.svg = Ne.languages.markup, Ne.languages.xml = Ne.languages.extend("markup", {}), Ne.languages.ssml = Ne.languages.xml, Ne.languages.atom = Ne.languages.xml, Ne.languages.rss = Ne.languages.xml, function(vt) {
      var Gt = /\/\*[\s\S]*?\*\/|\/\/.*|#(?!\[).*/, xt = [
        {
          pattern: /\b(?:false|true)\b/i,
          alias: "boolean"
        },
        {
          pattern: /(::\s*)\b[a-z_]\w*\b(?!\s*\()/i,
          greedy: !0,
          lookbehind: !0
        },
        {
          pattern: /(\b(?:case|const)\s+)\b[a-z_]\w*(?=\s*[;=])/i,
          greedy: !0,
          lookbehind: !0
        },
        /\b(?:null)\b/i,
        /\b[A-Z_][A-Z0-9_]*\b(?!\s*\()/
      ], cn = /\b0b[01]+(?:_[01]+)*\b|\b0o[0-7]+(?:_[0-7]+)*\b|\b0x[\da-f]+(?:_[\da-f]+)*\b|(?:\b\d+(?:_\d+)*\.?(?:\d+(?:_\d+)*)?|\B\.\d+)(?:e[+-]?\d+)?/i, He = /<?=>|\?\?=?|\.{3}|\??->|[!=]=?=?|::|\*\*=?|--|\+\+|&&|\|\||<<|>>|[?~]|[/^|%*&<>.+-]=?/, ut = /[{}\[\](),:;]/;
      vt.languages.php = {
        delimiter: {
          pattern: /\?>$|^<\?(?:php(?=\s)|=)?/i,
          alias: "important"
        },
        comment: Gt,
        variable: /\$+(?:\w+\b|(?=\{))/,
        package: {
          pattern: /(namespace\s+|use\s+(?:function\s+)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
          lookbehind: !0,
          inside: { punctuation: /\\/ }
        },
        "class-name-definition": {
          pattern: /(\b(?:class|enum|interface|trait)\s+)\b[a-z_]\w*(?!\\)\b/i,
          lookbehind: !0,
          alias: "class-name"
        },
        "function-definition": {
          pattern: /(\bfunction\s+)[a-z_]\w*(?=\s*\()/i,
          lookbehind: !0,
          alias: "function"
        },
        keyword: [
          {
            pattern: /(\(\s*)\b(?:array|bool|boolean|float|int|integer|object|string)\b(?=\s*\))/i,
            alias: "type-casting",
            greedy: !0,
            lookbehind: !0
          },
          {
            pattern: /([(,?]\s*)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string)\b(?=\s*\$)/i,
            alias: "type-hint",
            greedy: !0,
            lookbehind: !0
          },
          {
            pattern: /(\)\s*:\s*(?:\?\s*)?)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|never|object|self|static|string|void)\b/i,
            alias: "return-type",
            greedy: !0,
            lookbehind: !0
          },
          {
            pattern: /\b(?:array(?!\s*\()|bool|float|int|iterable|mixed|object|string|void)\b/i,
            alias: "type-declaration",
            greedy: !0
          },
          {
            pattern: /(\|\s*)(?:false|null)\b|\b(?:false|null)(?=\s*\|)/i,
            alias: "type-declaration",
            greedy: !0,
            lookbehind: !0
          },
          {
            pattern: /\b(?:parent|self|static)(?=\s*::)/i,
            alias: "static-context",
            greedy: !0
          },
          {
            pattern: /(\byield\s+)from\b/i,
            lookbehind: !0
          },
          /\bclass\b/i,
          {
            pattern: /((?:^|[^\s>:]|(?:^|[^-])>|(?:^|[^:]):)\s*)\b(?:abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|match|namespace|never|new|or|parent|print|private|protected|public|readonly|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield|__halt_compiler)\b/i,
            lookbehind: !0
          }
        ],
        "argument-name": {
          pattern: /([(,]\s*)\b[a-z_]\w*(?=\s*:(?!:))/i,
          lookbehind: !0
        },
        "class-name": [
          {
            pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self|\s+static))\s+|\bcatch\s*\()\b[a-z_]\w*(?!\\)\b/i,
            greedy: !0,
            lookbehind: !0
          },
          {
            pattern: /(\|\s*)\b[a-z_]\w*(?!\\)\b/i,
            greedy: !0,
            lookbehind: !0
          },
          {
            pattern: /\b[a-z_]\w*(?!\\)\b(?=\s*\|)/i,
            greedy: !0
          },
          {
            pattern: /(\|\s*)(?:\\?\b[a-z_]\w*)+\b/i,
            alias: "class-name-fully-qualified",
            greedy: !0,
            lookbehind: !0,
            inside: { punctuation: /\\/ }
          },
          {
            pattern: /(?:\\?\b[a-z_]\w*)+\b(?=\s*\|)/i,
            alias: "class-name-fully-qualified",
            greedy: !0,
            inside: { punctuation: /\\/ }
          },
          {
            pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self\b|\s+static\b))\s+|\bcatch\s*\()(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
            alias: "class-name-fully-qualified",
            greedy: !0,
            lookbehind: !0,
            inside: { punctuation: /\\/ }
          },
          {
            pattern: /\b[a-z_]\w*(?=\s*\$)/i,
            alias: "type-declaration",
            greedy: !0
          },
          {
            pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
            alias: [
              "class-name-fully-qualified",
              "type-declaration"
            ],
            greedy: !0,
            inside: { punctuation: /\\/ }
          },
          {
            pattern: /\b[a-z_]\w*(?=\s*::)/i,
            alias: "static-context",
            greedy: !0
          },
          {
            pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*::)/i,
            alias: [
              "class-name-fully-qualified",
              "static-context"
            ],
            greedy: !0,
            inside: { punctuation: /\\/ }
          },
          {
            pattern: /([(,?]\s*)[a-z_]\w*(?=\s*\$)/i,
            alias: "type-hint",
            greedy: !0,
            lookbehind: !0
          },
          {
            pattern: /([(,?]\s*)(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
            alias: [
              "class-name-fully-qualified",
              "type-hint"
            ],
            greedy: !0,
            lookbehind: !0,
            inside: { punctuation: /\\/ }
          },
          {
            pattern: /(\)\s*:\s*(?:\?\s*)?)\b[a-z_]\w*(?!\\)\b/i,
            alias: "return-type",
            greedy: !0,
            lookbehind: !0
          },
          {
            pattern: /(\)\s*:\s*(?:\?\s*)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
            alias: [
              "class-name-fully-qualified",
              "return-type"
            ],
            greedy: !0,
            lookbehind: !0,
            inside: { punctuation: /\\/ }
          }
        ],
        constant: xt,
        function: {
          pattern: /(^|[^\\\w])\\?[a-z_](?:[\w\\]*\w)?(?=\s*\()/i,
          lookbehind: !0,
          inside: { punctuation: /\\/ }
        },
        property: {
          pattern: /(->\s*)\w+/,
          lookbehind: !0
        },
        number: cn,
        operator: He,
        punctuation: ut
      };
      var oe = {
        pattern: /\{\$(?:\{(?:\{[^{}]+\}|[^{}]+)\}|[^{}])+\}|(^|[^\\{])\$+(?:\w+(?:\[[^\r\n\[\]]+\]|->\w+)?)/,
        lookbehind: !0,
        inside: vt.languages.php
      }, qn = [
        {
          pattern: /<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/,
          alias: "nowdoc-string",
          greedy: !0,
          inside: {
            delimiter: {
              pattern: /^<<<'[^']+'|[a-z_]\w*;$/i,
              alias: "symbol",
              inside: { punctuation: /^<<<'?|[';]$/ }
            }
          }
        },
        {
          pattern: /<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i,
          alias: "heredoc-string",
          greedy: !0,
          inside: {
            delimiter: {
              pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i,
              alias: "symbol",
              inside: { punctuation: /^<<<"?|[";]$/ }
            },
            interpolation: oe
          }
        },
        {
          pattern: /`(?:\\[\s\S]|[^\\`])*`/,
          alias: "backtick-quoted-string",
          greedy: !0
        },
        {
          pattern: /'(?:\\[\s\S]|[^\\'])*'/,
          alias: "single-quoted-string",
          greedy: !0
        },
        {
          pattern: /"(?:\\[\s\S]|[^\\"])*"/,
          alias: "double-quoted-string",
          greedy: !0,
          inside: { interpolation: oe }
        }
      ];
      vt.languages.insertBefore("php", "variable", {
        string: qn,
        attribute: {
          pattern: /#\[(?:[^"'\/#]|\/(?![*/])|\/\/.*$|#(?!\[).*$|\/\*(?:[^*]|\*(?!\/))*\*\/|"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*')+\](?=\s*[a-z$#])/im,
          greedy: !0,
          inside: {
            "attribute-content": {
              pattern: /^(#\[)[\s\S]+(?=\]$)/,
              lookbehind: !0,
              inside: {
                comment: Gt,
                string: qn,
                "attribute-class-name": [
                  {
                    pattern: /([^:]|^)\b[a-z_]\w*(?!\\)\b/i,
                    alias: "class-name",
                    greedy: !0,
                    lookbehind: !0
                  },
                  {
                    pattern: /([^:]|^)(?:\\?\b[a-z_]\w*)+/i,
                    alias: [
                      "class-name",
                      "class-name-fully-qualified"
                    ],
                    greedy: !0,
                    lookbehind: !0,
                    inside: { punctuation: /\\/ }
                  }
                ],
                constant: xt,
                number: cn,
                operator: He,
                punctuation: ut
              }
            },
            delimiter: {
              pattern: /^#\[|\]$/,
              alias: "punctuation"
            }
          }
        }
      }), vt.hooks.add("before-tokenize", function(Rn) {
        if (/<\?/.test(Rn.code)) {
          var Zt = /<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/g;
          vt.languages["markup-templating"].buildPlaceholders(Rn, "php", Zt);
        }
      }), vt.hooks.add("after-tokenize", function(Rn) {
        vt.languages["markup-templating"].tokenizePlaceholders(Rn, "php");
      });
    }(Ne), Ne.languages.python = {
      comment: {
        pattern: /(^|[^\\])#.*/,
        lookbehind: !0,
        greedy: !0
      },
      "string-interpolation": {
        pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
        greedy: !0,
        inside: {
          interpolation: {
            pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
            lookbehind: !0,
            inside: {
              "format-spec": {
                pattern: /(:)[^:(){}]+(?=\}$)/,
                lookbehind: !0
              },
              "conversion-option": {
                pattern: /![sra](?=[:}]$)/,
                alias: "punctuation"
              },
              rest: null
            }
          },
          string: /[\s\S]+/
        }
      },
      "triple-quoted-string": {
        pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
        greedy: !0,
        alias: "string"
      },
      string: {
        pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
        greedy: !0
      },
      function: {
        pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
        lookbehind: !0
      },
      "class-name": {
        pattern: /(\bclass\s+)\w+/i,
        lookbehind: !0
      },
      decorator: {
        pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
        lookbehind: !0,
        alias: [
          "annotation",
          "punctuation"
        ],
        inside: { punctuation: /\./ }
      },
      keyword: /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
      builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
      boolean: /\b(?:False|None|True)\b/,
      number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
      operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
      punctuation: /[{}[\];(),.:]/
    }, Ne.languages.python["string-interpolation"].inside.interpolation.inside.rest = Ne.languages.python, Ne.languages.py = Ne.languages.python, function(vt) {
      vt.languages.ruby = vt.languages.extend("clike", {
        comment: {
          pattern: /#.*|^=begin\s[\s\S]*?^=end/m,
          greedy: !0
        },
        "class-name": {
          pattern: /(\b(?:class|module)\s+|\bcatch\s+\()[\w.\\]+|\b[A-Z_]\w*(?=\s*\.\s*new\b)/,
          lookbehind: !0,
          inside: { punctuation: /[.\\]/ }
        },
        keyword: /\b(?:BEGIN|END|alias|and|begin|break|case|class|def|define_method|defined|do|each|else|elsif|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|private|protected|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\b/,
        operator: /\.{2,3}|&\.|===|<?=>|[!=]?~|(?:&&|\|\||<<|>>|\*\*|[+\-*/%<>!^&|=])=?|[?:]/,
        punctuation: /[(){}[\].,;]/
      }), vt.languages.insertBefore("ruby", "operator", {
        "double-colon": {
          pattern: /::/,
          alias: "punctuation"
        }
      });
      var Gt = {
        pattern: /((?:^|[^\\])(?:\\{2})*)#\{(?:[^{}]|\{[^{}]*\})*\}/,
        lookbehind: !0,
        inside: {
          content: {
            pattern: /^(#\{)[\s\S]+(?=\}$)/,
            lookbehind: !0,
            inside: vt.languages.ruby
          },
          delimiter: {
            pattern: /^#\{|\}$/,
            alias: "punctuation"
          }
        }
      };
      delete vt.languages.ruby.function;
      var xt = "(?:" + [
        /([^a-zA-Z0-9\s{(\[<=])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
        /\((?:[^()\\]|\\[\s\S]|\((?:[^()\\]|\\[\s\S])*\))*\)/.source,
        /\{(?:[^{}\\]|\\[\s\S]|\{(?:[^{}\\]|\\[\s\S])*\})*\}/.source,
        /\[(?:[^\[\]\\]|\\[\s\S]|\[(?:[^\[\]\\]|\\[\s\S])*\])*\]/.source,
        /<(?:[^<>\\]|\\[\s\S]|<(?:[^<>\\]|\\[\s\S])*>)*>/.source
      ].join("|") + ")", cn = /(?:"(?:\\.|[^"\\\r\n])*"|(?:\b[a-zA-Z_]\w*|[^\s\0-\x7F]+)[?!]?|\$.)/.source;
      vt.languages.insertBefore("ruby", "keyword", {
        "regex-literal": [
          {
            pattern: RegExp(/%r/.source + xt + /[egimnosux]{0,6}/.source),
            greedy: !0,
            inside: {
              interpolation: Gt,
              regex: /[\s\S]+/
            }
          },
          {
            pattern: /(^|[^/])\/(?!\/)(?:\[[^\r\n\]]+\]|\\.|[^[/\\\r\n])+\/[egimnosux]{0,6}(?=\s*(?:$|[\r\n,.;})#]))/,
            lookbehind: !0,
            greedy: !0,
            inside: {
              interpolation: Gt,
              regex: /[\s\S]+/
            }
          }
        ],
        variable: /[@$]+[a-zA-Z_]\w*(?:[?!]|\b)/,
        symbol: [
          {
            pattern: RegExp(/(^|[^:]):/.source + cn),
            lookbehind: !0,
            greedy: !0
          },
          {
            pattern: RegExp(/([\r\n{(,][ \t]*)/.source + cn + /(?=:(?!:))/.source),
            lookbehind: !0,
            greedy: !0
          }
        ],
        "method-definition": {
          pattern: /(\bdef\s+)\w+(?:\s*\.\s*\w+)?/,
          lookbehind: !0,
          inside: {
            function: /\b\w+$/,
            keyword: /^self\b/,
            "class-name": /^\w+/,
            punctuation: /\./
          }
        }
      }), vt.languages.insertBefore("ruby", "string", {
        "string-literal": [
          {
            pattern: RegExp(/%[qQiIwWs]?/.source + xt),
            greedy: !0,
            inside: {
              interpolation: Gt,
              string: /[\s\S]+/
            }
          },
          {
            pattern: /("|')(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|(?!\1)[^\\#\r\n])*\1/,
            greedy: !0,
            inside: {
              interpolation: Gt,
              string: /[\s\S]+/
            }
          },
          {
            pattern: /<<[-~]?([a-z_]\w*)[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
            alias: "heredoc-string",
            greedy: !0,
            inside: {
              delimiter: {
                pattern: /^<<[-~]?[a-z_]\w*|\b[a-z_]\w*$/i,
                inside: {
                  symbol: /\b\w+/,
                  punctuation: /^<<[-~]?/
                }
              },
              interpolation: Gt,
              string: /[\s\S]+/
            }
          },
          {
            pattern: /<<[-~]?'([a-z_]\w*)'[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
            alias: "heredoc-string",
            greedy: !0,
            inside: {
              delimiter: {
                pattern: /^<<[-~]?'[a-z_]\w*'|\b[a-z_]\w*$/i,
                inside: {
                  symbol: /\b\w+/,
                  punctuation: /^<<[-~]?'|'$/
                }
              },
              string: /[\s\S]+/
            }
          }
        ],
        "command-literal": [
          {
            pattern: RegExp(/%x/.source + xt),
            greedy: !0,
            inside: {
              interpolation: Gt,
              command: {
                pattern: /[\s\S]+/,
                alias: "string"
              }
            }
          },
          {
            pattern: /`(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|[^\\`#\r\n])*`/,
            greedy: !0,
            inside: {
              interpolation: Gt,
              command: {
                pattern: /[\s\S]+/,
                alias: "string"
              }
            }
          }
        ]
      }), delete vt.languages.ruby.string, vt.languages.insertBefore("ruby", "number", {
        builtin: /\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Fixnum|Float|Hash|IO|Integer|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|Stat|String|Struct|Symbol|TMS|Thread|ThreadGroup|Time|TrueClass)\b/,
        constant: /\b[A-Z][A-Z0-9_]*(?:[?!]|\b)/
      }), vt.languages.rb = vt.languages.ruby;
    }(Ne), window.Prism = _n, Ne;
  }(void 0, void 0), I = (z) => (bt) => bt.options.get(z), L = (z) => {
    const bt = z.options.register;
    bt("codesample_languages", { processor: "object[]" }), bt("codesample_global_prismjs", {
      processor: "boolean",
      default: !1
    });
  }, Z = I("codesample_languages"), ne = I("codesample_global_prismjs"), se = (z) => O.Prism && ne(z) ? O.Prism : R, Q = (z) => c(z) && z.nodeName === "PRE" && z.className.indexOf("language-") !== -1, he = (z) => {
    const bt = z.selection ? z.selection.getNode() : null;
    return Q(bt) ? m.some(bt) : m.none();
  }, ue = (z, bt, at) => {
    const _n = z.dom;
    z.undoManager.transact(() => {
      const st = he(z);
      return at = C.DOM.encode(at), st.fold(() => {
        z.insertContent('<pre id="__new" class="language-' + bt + '">' + at + "</pre>");
        const Ne = _n.select("#__new")[0];
        _n.setAttrib(Ne, "id", null), z.selection.select(Ne);
      }, (Ne) => {
        _n.setAttrib(Ne, "class", "language-" + bt), Ne.innerHTML = at, se(z).highlightElement(Ne), z.selection.select(Ne);
      });
    });
  }, G = (z) => he(z).bind((at) => m.from(at.textContent)).getOr(""), me = (z) => {
    const bt = [
      {
        text: "HTML/XML",
        value: "markup"
      },
      {
        text: "JavaScript",
        value: "javascript"
      },
      {
        text: "CSS",
        value: "css"
      },
      {
        text: "PHP",
        value: "php"
      },
      {
        text: "Ruby",
        value: "ruby"
      },
      {
        text: "Python",
        value: "python"
      },
      {
        text: "Java",
        value: "java"
      },
      {
        text: "C",
        value: "c"
      },
      {
        text: "C#",
        value: "csharp"
      },
      {
        text: "C++",
        value: "cpp"
      }
    ], at = Z(z);
    return at || bt;
  }, we = (z, bt) => he(z).fold(() => bt, (_n) => {
    const st = _n.className.match(/language-(\w+)/);
    return st ? st[1] : bt;
  }), be = (z) => {
    const bt = me(z), at = g(bt).fold(d(""), (Ne) => Ne.value), _n = we(z, at), st = G(z);
    z.windowManager.open({
      title: "Insert/Edit Code Sample",
      size: "large",
      body: {
        type: "panel",
        items: [
          {
            type: "listbox",
            name: "language",
            label: "Language",
            items: bt
          },
          {
            type: "textarea",
            name: "code",
            label: "Code view"
          }
        ]
      },
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: {
        language: _n,
        code: st
      },
      onSubmit: (Ne) => {
        const vt = Ne.getData();
        ue(z, vt.language, vt.code), Ne.close();
      }
    });
  }, q = (z) => {
    z.addCommand("codesample", () => {
      const bt = z.selection.getNode();
      z.selection.isCollapsed() || Q(bt) ? be(z) : z.formatter.toggle("code");
    });
  }, Le = ((z) => (bt) => bt.replace(z, ""))(/^\s+|\s+$/g);
  var je = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const Ie = (z) => {
    z.on("PreProcess", (bt) => {
      const at = z.dom, _n = at.select("pre[contenteditable=false]", bt.node);
      je.each(je.grep(_n, Q), (st) => {
        const Ne = st.textContent;
        at.setAttrib(st, "class", Le(at.getAttrib(st, "class"))), at.setAttrib(st, "contentEditable", null), at.setAttrib(st, "data-mce-highlighted", null);
        let vt;
        for (; vt = st.firstChild; )
          st.removeChild(vt);
        const Gt = at.add(st, "code");
        Gt.textContent = Ne;
      });
    }), z.on("SetContent", () => {
      const bt = z.dom, at = je.grep(bt.select("pre"), (_n) => Q(_n) && bt.getAttrib(_n, "data-mce-highlighted") !== "true");
      at.length && z.undoManager.transact(() => {
        je.each(at, (_n) => {
          var st;
          je.each(bt.select("br", _n), (Ne) => {
            bt.replace(z.getDoc().createTextNode(`
`), Ne);
          }), _n.innerHTML = bt.encode((st = _n.textContent) !== null && st !== void 0 ? st : ""), se(z).highlightElement(_n), bt.setAttrib(_n, "data-mce-highlighted", !0), _n.className = Le(_n.className);
        });
      });
    }), z.on("PreInit", () => {
      z.parser.addNodeFilter("pre", (bt) => {
        var at;
        for (let _n = 0, st = bt.length; _n < st; _n++) {
          const Ne = bt[_n];
          ((at = Ne.attr("class")) !== null && at !== void 0 ? at : "").indexOf("language-") !== -1 && (Ne.attr("contenteditable", "false"), Ne.attr("data-mce-highlighted", "false"));
        }
      });
    });
  }, Ce = (z, bt = i) => (at) => {
    const _n = () => {
      at.setEnabled(z.selection.isEditable()), bt(at);
    };
    return z.on("NodeChange", _n), _n(), () => {
      z.off("NodeChange", _n);
    };
  }, pt = (z) => {
    const bt = z.selection.getStart();
    return z.dom.is(bt, 'pre[class*="language-"]');
  }, sn = (z) => {
    const bt = () => z.execCommand("codesample");
    z.ui.registry.addToggleButton("codesample", {
      icon: "code-sample",
      tooltip: "Insert/edit code sample",
      onAction: bt,
      onSetup: Ce(z, (at) => {
        at.setActive(pt(z));
      })
    }), z.ui.registry.addMenuItem("codesample", {
      text: "Code sample...",
      icon: "code-sample",
      onAction: bt,
      onSetup: Ce(z)
    });
  };
  var Lt = () => {
    r.add("codesample", (z) => {
      L(z), Ie(z), sn(z), q(z), z.on("dblclick", (bt) => {
        Q(bt.target) && be(z);
      });
    });
  };
  Lt();
})();
(function() {
  var r = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const o = (Se, Ve, tt) => {
    var wt;
    return tt(Se, Ve.prototype) ? !0 : ((wt = Se.constructor) === null || wt === void 0 ? void 0 : wt.name) === Ve.name;
  }, c = (Se) => {
    const Ve = typeof Se;
    return Se === null ? "null" : Ve === "object" && Array.isArray(Se) ? "array" : Ve === "object" && o(Se, String, (tt, wt) => wt.isPrototypeOf(tt)) ? "string" : Ve;
  }, i = (Se) => (Ve) => c(Ve) === Se, d = (Se) => (Ve) => typeof Ve === Se, m = (Se) => (Ve) => Se === Ve, v = i("string"), g = i("object"), C = i("array"), O = m(null), R = d("boolean"), I = (Se) => Se == null, L = (Se) => !I(Se), Z = d("function"), ne = (Se, Ve) => {
    if (C(Se)) {
      for (let tt = 0, wt = Se.length; tt < wt; ++tt)
        if (!Ve(Se[tt]))
          return !1;
      return !0;
    }
    return !1;
  }, se = () => {
  }, Q = (Se) => () => Se, he = (Se, Ve) => Se === Ve;
  class ue {
    constructor(Ve, tt) {
      this.tag = Ve, this.value = tt;
    }
    static some(Ve) {
      return new ue(!0, Ve);
    }
    static none() {
      return ue.singletonNone;
    }
    fold(Ve, tt) {
      return this.tag ? tt(this.value) : Ve();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(Ve) {
      return this.tag ? ue.some(Ve(this.value)) : ue.none();
    }
    bind(Ve) {
      return this.tag ? Ve(this.value) : ue.none();
    }
    exists(Ve) {
      return this.tag && Ve(this.value);
    }
    forall(Ve) {
      return !this.tag || Ve(this.value);
    }
    filter(Ve) {
      return !this.tag || Ve(this.value) ? this : ue.none();
    }
    getOr(Ve) {
      return this.tag ? this.value : Ve;
    }
    or(Ve) {
      return this.tag ? this : Ve;
    }
    getOrThunk(Ve) {
      return this.tag ? this.value : Ve();
    }
    orThunk(Ve) {
      return this.tag ? this : Ve();
    }
    getOrDie(Ve) {
      if (this.tag)
        return this.value;
      throw new Error(Ve ?? "Called getOrDie on None");
    }
    static from(Ve) {
      return L(Ve) ? ue.some(Ve) : ue.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(Ve) {
      this.tag && Ve(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  ue.singletonNone = new ue(!1);
  const G = Array.prototype.indexOf, me = Array.prototype.push, we = (Se, Ve) => G.call(Se, Ve), be = (Se, Ve) => we(Se, Ve) > -1, q = (Se, Ve) => {
    const tt = Se.length, wt = new Array(tt);
    for (let en = 0; en < tt; en++) {
      const ur = Se[en];
      wt[en] = Ve(ur, en);
    }
    return wt;
  }, Te = (Se, Ve) => {
    for (let tt = 0, wt = Se.length; tt < wt; tt++) {
      const en = Se[tt];
      Ve(en, tt);
    }
  }, Le = (Se, Ve, tt) => (Te(Se, (wt, en) => {
    tt = Ve(tt, wt, en);
  }), tt), je = (Se) => {
    const Ve = [];
    for (let tt = 0, wt = Se.length; tt < wt; ++tt) {
      if (!C(Se[tt]))
        throw new Error("Arr.flatten item " + tt + " was not an array, input: " + Se);
      me.apply(Ve, Se[tt]);
    }
    return Ve;
  }, Ie = (Se, Ve) => je(q(Se, Ve)), Ce = (Se, Ve) => {
    for (let tt = 0; tt < Se.length; tt++) {
      const wt = Ve(Se[tt], tt);
      if (wt.isSome())
        return wt;
    }
    return ue.none();
  }, pt = (Se, Ve, tt = he) => Se.exists((wt) => tt(wt, Ve)), sn = (Se) => {
    const Ve = [], tt = (wt) => {
      Ve.push(wt);
    };
    for (let wt = 0; wt < Se.length; wt++)
      Se[wt].each(tt);
    return Ve;
  }, Lt = (Se, Ve) => Se ? ue.some(Ve) : ue.none(), z = (Se) => (Ve) => Ve.options.get(Se), bt = (Se) => {
    const Ve = Se.options.register;
    Ve("link_assume_external_targets", {
      processor: (tt) => {
        const wt = v(tt) || R(tt);
        return wt ? tt === !0 ? {
          value: 1,
          valid: wt
        } : tt === "http" || tt === "https" ? {
          value: tt,
          valid: wt
        } : {
          value: 0,
          valid: wt
        } : {
          valid: !1,
          message: "Must be a string or a boolean."
        };
      },
      default: !1
    }), Ve("link_context_toolbar", {
      processor: "boolean",
      default: !1
    }), Ve("link_list", { processor: (tt) => v(tt) || Z(tt) || ne(tt, g) }), Ve("link_default_target", { processor: "string" }), Ve("link_default_protocol", {
      processor: "string",
      default: "https"
    }), Ve("link_target_list", {
      processor: (tt) => R(tt) || ne(tt, g),
      default: !0
    }), Ve("link_rel_list", {
      processor: "object[]",
      default: []
    }), Ve("link_class_list", {
      processor: "object[]",
      default: []
    }), Ve("link_title", {
      processor: "boolean",
      default: !0
    }), Ve("allow_unsafe_link_target", {
      processor: "boolean",
      default: !1
    }), Ve("link_quicklink", {
      processor: "boolean",
      default: !1
    });
  }, at = z("link_assume_external_targets"), _n = z("link_context_toolbar"), st = z("link_list"), Ne = z("link_default_target"), vt = z("link_default_protocol"), Gt = z("link_target_list"), xt = z("link_rel_list"), cn = z("link_class_list"), He = z("link_title"), ut = z("allow_unsafe_link_target"), oe = z("link_quicklink");
  var qn = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const Rn = (Se) => v(Se.value) ? Se.value : "", Zt = (Se) => v(Se.text) ? Se.text : v(Se.title) ? Se.title : "", Jt = (Se, Ve) => {
    const tt = [];
    return qn.each(Se, (wt) => {
      const en = Zt(wt);
      if (wt.menu !== void 0) {
        const ur = Jt(wt.menu, Ve);
        tt.push({
          text: en,
          items: ur
        });
      } else {
        const ur = Ve(wt);
        tt.push({
          text: en,
          value: ur
        });
      }
    }), tt;
  }, wo = (Se = Rn) => (Ve) => ue.from(Ve).map((tt) => Jt(tt, Se)), St = {
    sanitize: (Se) => wo(Rn)(Se),
    sanitizeWith: wo,
    createUi: (Se, Ve) => (tt) => ({
      name: Se,
      type: "listbox",
      label: Ve,
      items: tt
    }),
    getValue: Rn
  }, ke = Object.keys, Ct = Object.hasOwnProperty, an = (Se, Ve) => {
    const tt = ke(Se);
    for (let wt = 0, en = tt.length; wt < en; wt++) {
      const ur = tt[wt], Yo = Se[ur];
      Ve(Yo, ur);
    }
  }, ht = (Se) => (Ve, tt) => {
    Se[tt] = Ve;
  }, bn = (Se, Ve, tt, wt) => {
    an(Se, (en, ur) => {
      (Ve(en, ur) ? tt : wt)(en, ur);
    });
  }, Ye = (Se, Ve) => {
    const tt = {};
    return bn(Se, Ve, ht(tt), se), tt;
  }, nn = (Se, Ve) => Ct.call(Se, Ve), Bt = (Se, Ve) => nn(Se, Ve) && Se[Ve] !== void 0 && Se[Ve] !== null;
  var $n = tinymce.util.Tools.resolve("tinymce.dom.TreeWalker"), mr = tinymce.util.Tools.resolve("tinymce.util.URI");
  const gr = (Se) => L(Se) && Se.nodeName.toLowerCase() === "a", Vr = (Se) => gr(Se) && !!Eo(Se), Xr = (Se, Ve) => {
    if (Se.collapsed)
      return [];
    {
      const tt = Se.cloneContents(), wt = tt.firstChild, en = new $n(wt, tt), ur = [];
      let Yo = wt;
      do
        Ve(Yo) && ur.push(Yo);
      while (Yo = en.next());
      return ur;
    }
  }, pc = (Se) => /^\w+:/i.test(Se), Eo = (Se) => {
    var Ve, tt;
    return (tt = (Ve = Se.getAttribute("data-mce-href")) !== null && Ve !== void 0 ? Ve : Se.getAttribute("href")) !== null && tt !== void 0 ? tt : "";
  }, uo = (Se, Ve) => {
    const tt = ["noopener"], wt = Se ? Se.split(/\s+/) : [], en = (Nr) => qn.trim(Nr.sort().join(" ")), ur = (Nr) => (Nr = Yo(Nr), Nr.length > 0 ? Nr.concat(tt) : tt), Yo = (Nr) => Nr.filter((Ks) => qn.inArray(tt, Ks) === -1), Lr = Ve ? ur(wt) : Yo(wt);
    return Lr.length > 0 ? en(Lr) : "";
  }, Es = (Se) => Se.replace(/\uFEFF/g, ""), br = (Se, Ve) => (Ve = Ve || qo(Se.selection.getRng())[0] || Se.selection.getNode(), Yr(Ve) ? ue.from(Se.dom.select("a[href]", Ve)[0]) : ue.from(Se.dom.getParent(Ve, "a[href]"))), hs = (Se, Ve) => br(Se, Ve).isSome(), Ps = (Se, Ve) => {
    const tt = Ve.fold(() => Se.getContent({ format: "text" }), (wt) => wt.innerText || wt.textContent || "");
    return Es(tt);
  }, qo = (Se) => Xr(Se, Vr), hc = (Se) => qn.grep(Se, Vr), Co = (Se) => hc(Se).length > 0, fl = (Se) => qo(Se).length > 0, fn = (Se) => {
    const Ve = Se.schema.getTextInlineElements(), tt = (ur) => ur.nodeType === 1 && !gr(ur) && !nn(Ve, ur.nodeName.toLowerCase());
    if (br(Se).exists((ur) => ur.hasAttribute("data-mce-block")))
      return !1;
    const en = Se.selection.getRng();
    return en.collapsed ? !0 : Xr(en, tt).length === 0;
  }, Yr = (Se) => L(Se) && Se.nodeName === "FIGURE" && /\bimage\b/i.test(Se.className), xa = (Se) => Le([
    "title",
    "rel",
    "class",
    "target"
  ], (tt, wt) => (Se[wt].each((en) => {
    tt[wt] = en.length > 0 ? en : null;
  }), tt), { href: Se.href }), $i = (Se, Ve) => (Ve === "http" || Ve === "https") && !pc(Se) ? Ve + "://" + Se : Se, Kc = (Se, Ve) => {
    const tt = { ...Ve };
    if (xt(Se).length === 0 && !ut(Se)) {
      const wt = uo(tt.rel, tt.target === "_blank");
      tt.rel = wt || null;
    }
    return ue.from(tt.target).isNone() && Gt(Se) === !1 && (tt.target = Ne(Se)), tt.href = $i(tt.href, at(Se)), tt;
  }, wi = (Se, Ve, tt, wt) => {
    tt.each((en) => {
      nn(Ve, "innerText") ? Ve.innerText = en : Ve.textContent = en;
    }), Se.dom.setAttribs(Ve, wt), Se.selection.select(Ve);
  }, es = (Se, Ve, tt, wt) => {
    const en = Se.dom;
    Yr(Ve) ? Qa(en, Ve, wt) : tt.fold(() => {
      Se.execCommand("mceInsertLink", !1, wt);
    }, (ur) => {
      Se.insertContent(en.createHTML("a", wt, en.encode(ur)));
    });
  }, gc = (Se, Ve, tt) => {
    const wt = Se.selection.getNode(), en = br(Se, wt), ur = Kc(Se, xa(tt));
    Se.undoManager.transact(() => {
      tt.href === Ve.href && Ve.attach(), en.fold(() => {
        es(Se, wt, tt.text, ur);
      }, (Yo) => {
        Se.focus(), wi(Se, Yo, tt.text, ur);
      });
    });
  }, Xl = (Se) => {
    const Ve = Se.dom, tt = Se.selection, wt = tt.getBookmark(), en = tt.getRng().cloneRange(), ur = Ve.getParent(en.startContainer, "a[href]", Se.getBody()), Yo = Ve.getParent(en.endContainer, "a[href]", Se.getBody());
    ur && en.setStartBefore(ur), Yo && en.setEndAfter(Yo), tt.setRng(en), Se.execCommand("unlink"), tt.moveToBookmark(wt);
  }, gs = (Se) => {
    Se.undoManager.transact(() => {
      const Ve = Se.selection.getNode();
      Yr(Ve) ? Xf(Se, Ve) : Xl(Se), Se.focus();
    });
  }, lr = (Se) => {
    const {
      class: Ve,
      href: tt,
      rel: wt,
      target: en,
      text: ur,
      title: Yo
    } = Se;
    return Ye({
      class: Ve.getOrNull(),
      href: tt,
      rel: wt.getOrNull(),
      target: en.getOrNull(),
      text: ur.getOrNull(),
      title: Yo.getOrNull()
    }, (Lr, Nr) => O(Lr) === !1);
  }, Ei = (Se, Ve) => {
    const tt = Se.options.get, wt = {
      allow_html_data_urls: tt("allow_html_data_urls"),
      allow_script_urls: tt("allow_script_urls"),
      allow_svg_data_urls: tt("allow_svg_data_urls")
    }, en = Ve.href;
    return {
      ...Ve,
      href: mr.isDomSafe(en, "a", wt) ? en : ""
    };
  }, Jl = (Se, Ve, tt) => {
    const wt = Ei(Se, tt);
    Se.hasPlugin("rtc", !0) ? Se.execCommand("createlink", !1, lr(wt)) : gc(Se, Ve, wt);
  }, Pd = (Se) => {
    Se.hasPlugin("rtc", !0) ? Se.execCommand("unlink") : gs(Se);
  }, Xf = (Se, Ve) => {
    var tt;
    const wt = Se.dom.select("img", Ve)[0];
    if (wt) {
      const en = Se.dom.getParents(wt, "a[href]", Ve)[0];
      en && ((tt = en.parentNode) === null || tt === void 0 || tt.insertBefore(wt, en), Se.dom.remove(en));
    }
  }, Qa = (Se, Ve, tt) => {
    var wt;
    const en = Se.select("img", Ve)[0];
    if (en) {
      const ur = Se.create("a", tt);
      (wt = en.parentNode) === null || wt === void 0 || wt.insertBefore(ur, en), ur.appendChild(en);
    }
  }, Xa = (Se) => Bt(Se, "items"), ia = (Se, Ve) => Ce(Ve, (tt) => Xa(tt) ? ia(Se, tt.items) : Lt(tt.value === Se, tt)), Nl = (Se, Ve, tt, wt) => {
    const en = wt[Ve], ur = Se.length > 0;
    return en !== void 0 ? ia(en, tt).map((Yo) => ({
      url: {
        value: Yo.value,
        meta: {
          text: ur ? Se : Yo.text,
          attach: se
        }
      },
      text: ur ? Se : Yo.text
    })) : ue.none();
  }, Sp = (Se, Ve) => Ve === "link" ? Se.link : Ve === "anchor" ? Se.anchor : ue.none(), vc = {
    init: (Se, Ve) => {
      const tt = {
        text: Se.text,
        title: Se.title
      }, wt = (Nr) => {
        var Ks;
        return Lt(tt.title.length <= 0, ue.from((Ks = Nr.meta) === null || Ks === void 0 ? void 0 : Ks.title).getOr(""));
      }, en = (Nr) => {
        var Ks;
        return Lt(tt.text.length <= 0, ue.from((Ks = Nr.meta) === null || Ks === void 0 ? void 0 : Ks.text).getOr(Nr.value));
      }, ur = (Nr) => {
        const Ks = en(Nr.url), fo = wt(Nr.url);
        return Ks.isSome() || fo.isSome() ? ue.some({
          ...Ks.map((ta) => ({ text: ta })).getOr({}),
          ...fo.map((ta) => ({ title: ta })).getOr({})
        }) : ue.none();
      }, Yo = (Nr, Ks) => {
        const fo = Sp(Ve, Ks).getOr([]);
        return Nl(tt.text, Ks, fo, Nr);
      };
      return { onChange: (Nr, Ks) => {
        const fo = Ks.name;
        return fo === "url" ? ur(Nr()) : be([
          "anchor",
          "link"
        ], fo) ? Yo(Nr(), fo) : ((fo === "text" || fo === "title") && (tt[fo] = Nr()[fo]), ue.none());
      } };
    },
    getDelta: Nl
  };
  var ea = tinymce.util.Tools.resolve("tinymce.util.Delay");
  const bc = (Se, Ve, tt) => {
    const wt = Se.selection.getRng();
    ea.setEditorTimeout(Se, () => {
      Se.windowManager.confirm(Ve, (en) => {
        Se.selection.setRng(wt), tt(en);
      });
    });
  }, Qu = (Se) => {
    const Ve = Se.href;
    return Ve.indexOf("@") > 0 && Ve.indexOf("/") === -1 && Ve.indexOf("mailto:") === -1 ? ue.some({
      message: "The URL you entered seems to be an email address. Do you want to add the required mailto: prefix?",
      preprocess: (wt) => ({
        ...wt,
        href: "mailto:" + Ve
      })
    }) : ue.none();
  }, wp = (Se, Ve) => (tt) => {
    const wt = tt.href;
    return Se === 1 && !pc(wt) || Se === 0 && /^\s*www(\.|\d\.)/i.test(wt) ? ue.some({
      message: `The URL you entered seems to be an external link. Do you want to add the required ${Ve}:// prefix?`,
      preprocess: (ur) => ({
        ...ur,
        href: Ve + "://" + wt
      })
    }) : ue.none();
  }, Ou = { preprocess: (Se, Ve) => Ce([
    Qu,
    wp(at(Se), vt(Se))
  ], (tt) => tt(Ve)).fold(() => Promise.resolve(Ve), (tt) => new Promise((wt) => {
    bc(Se, tt.message, (en) => {
      wt(en ? tt.preprocess(Ve) : Ve);
    });
  })) }, nt = { getAnchors: (Se) => {
    const Ve = Se.dom.select("a:not([href])"), tt = Ie(Ve, (wt) => {
      const en = wt.name || wt.id;
      return en ? [{
        text: en,
        value: "#" + en
      }] : [];
    });
    return tt.length > 0 ? ue.some([{
      text: "None",
      value: ""
    }].concat(tt)) : ue.none();
  } }, eu = { getClasses: (Se) => {
    const Ve = cn(Se);
    return Ve.length > 0 ? St.sanitize(Ve) : ue.none();
  } }, Ep = (Se) => {
    try {
      return ue.some(JSON.parse(Se));
    } catch {
      return ue.none();
    }
  }, os = { getLinks: (Se) => {
    const Ve = (wt) => Se.convertURL(wt.value || wt.url || "", "href"), tt = st(Se);
    return new Promise((wt) => {
      v(tt) ? fetch(tt).then((en) => en.ok ? en.text().then(Ep) : Promise.reject()).then(wt, () => wt(ue.none())) : Z(tt) ? tt((en) => wt(ue.some(en))) : wt(ue.from(tt));
    }).then((wt) => wt.bind(St.sanitizeWith(Ve)).map((en) => en.length > 0 ? [{
      text: "None",
      value: ""
    }].concat(en) : en));
  } }, Am = { getRels: (Se, Ve) => {
    const tt = xt(Se);
    if (tt.length > 0) {
      const wt = pt(Ve, "_blank"), en = ut(Se) === !1, ur = (Lr) => uo(St.getValue(Lr), wt);
      return (en ? St.sanitizeWith(ur) : St.sanitize)(tt);
    }
    return ue.none();
  } }, tu = [
    {
      text: "Current window",
      value: ""
    },
    {
      text: "New window",
      value: "_blank"
    }
  ], Hs = { getTargets: (Se) => {
    const Ve = Gt(Se);
    return C(Ve) ? St.sanitize(Ve).orThunk(() => ue.some(tu)) : Ve === !1 ? ue.none() : ue.some(tu);
  } }, Gs = (Se, Ve, tt) => {
    const wt = Se.getAttrib(Ve, tt);
    return wt !== null && wt.length > 0 ? ue.some(wt) : ue.none();
  }, Ac = (Se, Ve) => {
    const tt = Se.dom, en = fn(Se) ? ue.some(Ps(Se.selection, Ve)) : ue.none(), ur = Ve.bind((fo) => ue.from(tt.getAttrib(fo, "href"))), Yo = Ve.bind((fo) => ue.from(tt.getAttrib(fo, "target"))), Lr = Ve.bind((fo) => Gs(tt, fo, "rel")), Nr = Ve.bind((fo) => Gs(tt, fo, "class")), Ks = Ve.bind((fo) => Gs(tt, fo, "title"));
    return {
      url: ur,
      text: en,
      title: Ks,
      target: Yo,
      rel: Lr,
      linkClass: Nr
    };
  }, Xu = { collect: (Se, Ve) => os.getLinks(Se).then((tt) => {
    const wt = Ac(Se, Ve);
    return {
      anchor: wt,
      catalogs: {
        targets: Hs.getTargets(Se),
        rels: Am.getRels(Se, wt.target),
        classes: eu.getClasses(Se),
        anchor: nt.getAnchors(Se),
        link: tt
      },
      optNode: Ve,
      flags: { titleEnabled: He(Se) }
    };
  }) }, Ju = (Se, Ve) => (tt) => {
    const wt = tt.getData();
    if (!wt.url.value) {
      Pd(Se), tt.close();
      return;
    }
    const en = (Lr) => ue.from(wt[Lr]).filter((Nr) => !pt(Ve.anchor[Lr], Nr)), ur = {
      href: wt.url.value,
      text: en("text"),
      target: en("target"),
      rel: en("rel"),
      class: en("linkClass"),
      title: en("title")
    }, Yo = {
      href: wt.url.value,
      attach: wt.url.meta !== void 0 && wt.url.meta.attach ? wt.url.meta.attach : se
    };
    Ou.preprocess(Se, ur).then((Lr) => {
      Jl(Se, Yo, Lr);
    }), tt.close();
  }, ed = (Se) => {
    const Ve = br(Se);
    return Xu.collect(Se, Ve);
  }, $o = (Se, Ve) => {
    const tt = Se.anchor, wt = tt.url.getOr("");
    return {
      url: {
        value: wt,
        meta: { original: { value: wt } }
      },
      text: tt.text.getOr(""),
      title: tt.title.getOr(""),
      anchor: wt,
      link: wt,
      rel: tt.rel.getOr(""),
      target: tt.target.or(Ve).getOr(""),
      linkClass: tt.linkClass.getOr("")
    };
  }, ei = (Se, Ve, tt) => {
    const wt = [{
      name: "url",
      type: "urlinput",
      filetype: "file",
      label: "URL",
      picker_text: "Browse links"
    }], en = Se.anchor.text.map(() => ({
      name: "text",
      type: "input",
      label: "Text to display"
    })).toArray(), ur = Se.flags.titleEnabled ? [{
      name: "title",
      type: "input",
      label: "Title"
    }] : [], Yo = ue.from(Ne(tt)), Lr = $o(Se, Yo), Nr = Se.catalogs, Ks = vc.init(Lr, Nr);
    return {
      title: "Insert/Edit Link",
      size: "normal",
      body: {
        type: "panel",
        items: je([
          wt,
          en,
          ur,
          sn([
            Nr.anchor.map(St.createUi("anchor", "Anchors")),
            Nr.rels.map(St.createUi("rel", "Rel")),
            Nr.targets.map(St.createUi("target", "Open link in...")),
            Nr.link.map(St.createUi("link", "Link list")),
            Nr.classes.map(St.createUi("linkClass", "Class"))
          ])
        ])
      },
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: Lr,
      onChange: (ta, { name: Yc }) => {
        Ks.onChange(ta.getData, { name: Yc }).each((Rm) => {
          ta.setData(Rm);
        });
      },
      onSubmit: Ve
    };
  }, Rl = (Se) => {
    ed(Se).then((tt) => {
      const wt = Ju(Se, tt);
      return ei(tt, wt, Se);
    }).then((tt) => {
      Se.windowManager.open(tt);
    });
  }, td = (Se) => {
    Se.addCommand("mceLink", (Ve, tt) => {
      (tt == null ? void 0 : tt.dialog) === !0 || !oe(Se) ? Rl(Se) : Se.dispatch("contexttoolbar-show", { toolbarKey: "quicklink" });
    });
  };
  var Xi = tinymce.util.Tools.resolve("tinymce.util.VK");
  const Zs = (Se, Ve) => {
    document.body.appendChild(Se), Se.dispatchEvent(Ve), document.body.removeChild(Se);
  }, ss = (Se) => {
    const Ve = document.createElement("a");
    Ve.target = "_blank", Ve.href = Se, Ve.rel = "noreferrer noopener";
    const tt = document.createEvent("MouseEvents");
    tt.initMouseEvent("click", !0, !0, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), Zs(Ve, tt);
  }, yc = (Se, Ve) => Se.dom.getParent(Ve, "a[href]"), tm = (Se) => yc(Se, Se.selection.getStart()), Io = (Se) => Se.altKey === !0 && Se.shiftKey === !1 && Se.ctrlKey === !1 && Se.metaKey === !1, za = (Se, Ve) => {
    if (Ve) {
      const tt = Eo(Ve);
      if (/^#/.test(tt)) {
        const wt = Se.dom.select(tt);
        wt.length && Se.selection.scrollIntoView(wt[0], !0);
      } else
        ss(Ve.href);
    }
  }, ti = (Se) => () => {
    Se.execCommand("mceLink", !1, { dialog: !0 });
  }, Ra = (Se) => () => {
    za(Se, tm(Se));
  }, Pl = (Se) => {
    Se.on("click", (Ve) => {
      const tt = yc(Se, Ve.target);
      tt && Xi.metaKeyPressed(Ve) && (Ve.preventDefault(), za(Se, tt));
    }), Se.on("keydown", (Ve) => {
      if (!Ve.isDefaultPrevented() && Ve.keyCode === 13 && Io(Ve)) {
        const tt = tm(Se);
        tt && (Ve.preventDefault(), za(Se, tt));
      }
    });
  }, nu = (Se, Ve) => (Se.on("NodeChange", Ve), () => Se.off("NodeChange", Ve)), Ii = (Se) => (Ve) => {
    const tt = () => {
      Ve.setActive(!Se.mode.isReadOnly() && hs(Se, Se.selection.getNode())), Ve.setEnabled(Se.selection.isEditable());
    };
    return tt(), nu(Se, tt);
  }, Dl = (Se) => (Ve) => {
    const tt = () => {
      Ve.setEnabled(Se.selection.isEditable());
    };
    return tt(), nu(Se, tt);
  }, $l = (Se) => (Se.selection.isCollapsed() ? hc(Se.dom.getParents(Se.selection.getStart())) : qo(Se.selection.getRng())).length === 1, km = (Se) => (Ve) => {
    const tt = () => Ve.setEnabled($l(Se));
    return tt(), nu(Se, tt);
  }, Il = (Se) => (Ve) => {
    const tt = (ur) => Co(ur) || fl(Se.selection.getRng()), wt = Se.dom.getParents(Se.selection.getStart()), en = (ur) => {
      Ve.setEnabled(tt(ur) && Se.selection.isEditable());
    };
    return en(wt), nu(Se, (ur) => en(ur.parents));
  }, xp = (Se) => {
    Se.addShortcut("Meta+K", "", () => {
      Se.execCommand("mceLink");
    });
  }, Nc = (Se) => {
    Se.ui.registry.addToggleButton("link", {
      icon: "link",
      tooltip: "Insert/edit link",
      onAction: ti(Se),
      onSetup: Ii(Se)
    }), Se.ui.registry.addButton("openlink", {
      icon: "new-tab",
      tooltip: "Open link",
      onAction: Ra(Se),
      onSetup: km(Se)
    }), Se.ui.registry.addButton("unlink", {
      icon: "unlink",
      tooltip: "Remove link",
      onAction: () => Pd(Se),
      onSetup: Il(Se)
    });
  }, ku = (Se) => {
    Se.ui.registry.addMenuItem("openlink", {
      text: "Open link",
      icon: "new-tab",
      onAction: Ra(Se),
      onSetup: km(Se)
    }), Se.ui.registry.addMenuItem("link", {
      icon: "link",
      text: "Link...",
      shortcut: "Meta+K",
      onSetup: Dl(Se),
      onAction: ti(Se)
    }), Se.ui.registry.addMenuItem("unlink", {
      icon: "unlink",
      text: "Remove link",
      onAction: () => Pd(Se),
      onSetup: Il(Se)
    });
  }, sf = (Se) => {
    const Ve = "link unlink openlink", tt = "link";
    Se.ui.registry.addContextMenu("link", {
      update: (wt) => Se.dom.isEditable(wt) ? Co(Se.dom.getParents(wt, "a")) ? Ve : tt : ""
    });
  }, Nm = (Se) => {
    const Ve = (en) => {
      en.selection.collapse(!1);
    }, tt = (en) => {
      const ur = Se.selection.getNode();
      return en.setEnabled(hs(Se, ur)), se;
    }, wt = (en) => {
      const ur = br(Se), Yo = fn(Se);
      if (ur.isNone() && Yo) {
        const Lr = Ps(Se.selection, ur);
        return Lt(Lr.length === 0, en);
      } else
        return ue.none();
    };
    Se.ui.registry.addContextForm("quicklink", {
      launch: {
        type: "contextformtogglebutton",
        icon: "link",
        tooltip: "Link",
        onSetup: Ii(Se)
      },
      label: "Link",
      predicate: (en) => _n(Se) && hs(Se, en),
      initValue: () => br(Se).fold(Q(""), Eo),
      commands: [
        {
          type: "contextformtogglebutton",
          icon: "link",
          tooltip: "Link",
          primary: !0,
          onSetup: (en) => {
            const ur = Se.selection.getNode();
            return en.setActive(hs(Se, ur)), Ii(Se)(en);
          },
          onAction: (en) => {
            const ur = en.getValue(), Yo = wt(ur);
            Jl(Se, {
              href: ur,
              attach: se
            }, {
              href: ur,
              text: Yo,
              title: ue.none(),
              rel: ue.none(),
              target: ue.none(),
              class: ue.none()
            }), Ve(Se), en.hide();
          }
        },
        {
          type: "contextformbutton",
          icon: "unlink",
          tooltip: "Remove link",
          onSetup: tt,
          onAction: (en) => {
            Pd(Se), en.hide();
          }
        },
        {
          type: "contextformbutton",
          icon: "new-tab",
          tooltip: "Open link",
          onSetup: tt,
          onAction: (en) => {
            Ra(Se)(), en.hide();
          }
        }
      ]
    });
  };
  var Tp = () => {
    r.add("link", (Se) => {
      bt(Se), Nc(Se), ku(Se), sf(Se), Nm(Se), Pl(Se), td(Se), xp(Se);
    });
  };
  Tp();
})();
(function() {
  var r = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const o = (H, X, fe) => {
    var Me;
    return fe(H, X.prototype) ? !0 : ((Me = H.constructor) === null || Me === void 0 ? void 0 : Me.name) === X.name;
  }, c = (H) => {
    const X = typeof H;
    return H === null ? "null" : X === "object" && Array.isArray(H) ? "array" : X === "object" && o(H, String, (fe, Me) => Me.isPrototypeOf(fe)) ? "string" : X;
  }, i = (H) => (X) => c(X) === H, d = (H) => (X) => typeof X === H, m = i("string"), v = i("object"), g = i("array"), C = d("boolean"), O = (H) => H == null, R = (H) => !O(H), I = d("function"), L = d("number"), Z = () => {
  }, ne = (H, X) => (fe) => H(X(fe)), se = (H) => () => H, Q = (H, X) => H === X;
  function he(H, ...X) {
    return (...fe) => {
      const Me = X.concat(fe);
      return H.apply(null, Me);
    };
  }
  const ue = (H) => (X) => !H(X), G = se(!1);
  class me {
    constructor(X, fe) {
      this.tag = X, this.value = fe;
    }
    static some(X) {
      return new me(!0, X);
    }
    static none() {
      return me.singletonNone;
    }
    fold(X, fe) {
      return this.tag ? fe(this.value) : X();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(X) {
      return this.tag ? me.some(X(this.value)) : me.none();
    }
    bind(X) {
      return this.tag ? X(this.value) : me.none();
    }
    exists(X) {
      return this.tag && X(this.value);
    }
    forall(X) {
      return !this.tag || X(this.value);
    }
    filter(X) {
      return !this.tag || X(this.value) ? this : me.none();
    }
    getOr(X) {
      return this.tag ? this.value : X;
    }
    or(X) {
      return this.tag ? this : X;
    }
    getOrThunk(X) {
      return this.tag ? this.value : X();
    }
    orThunk(X) {
      return this.tag ? this : X();
    }
    getOrDie(X) {
      if (this.tag)
        return this.value;
      throw new Error(X ?? "Called getOrDie on None");
    }
    static from(X) {
      return R(X) ? me.some(X) : me.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(X) {
      this.tag && X(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  me.singletonNone = new me(!1);
  const we = Array.prototype.slice, be = Array.prototype.indexOf, q = Array.prototype.push, Te = (H, X) => be.call(H, X), Le = (H, X) => Te(H, X) > -1, je = (H, X) => {
    for (let fe = 0, Me = H.length; fe < Me; fe++) {
      const We = H[fe];
      if (X(We, fe))
        return !0;
    }
    return !1;
  }, Ie = (H, X) => {
    const fe = H.length, Me = new Array(fe);
    for (let We = 0; We < fe; We++) {
      const Ut = H[We];
      Me[We] = X(Ut, We);
    }
    return Me;
  }, Ce = (H, X) => {
    for (let fe = 0, Me = H.length; fe < Me; fe++) {
      const We = H[fe];
      X(We, fe);
    }
  }, pt = (H, X) => {
    const fe = [];
    for (let Me = 0, We = H.length; Me < We; Me++) {
      const Ut = H[Me];
      X(Ut, Me) && fe.push(Ut);
    }
    return fe;
  }, sn = (H, X) => {
    if (H.length === 0)
      return [];
    {
      let fe = X(H[0]);
      const Me = [];
      let We = [];
      for (let Ut = 0, Wn = H.length; Ut < Wn; Ut++) {
        const xr = H[Ut], wr = X(xr);
        wr !== fe && (Me.push(We), We = []), fe = wr, We.push(xr);
      }
      return We.length !== 0 && Me.push(We), Me;
    }
  }, Lt = (H, X, fe) => (Ce(H, (Me, We) => {
    fe = X(fe, Me, We);
  }), fe), z = (H, X, fe) => {
    for (let Me = 0, We = H.length; Me < We; Me++) {
      const Ut = H[Me];
      if (X(Ut, Me))
        return me.some(Ut);
      if (fe(Ut, Me))
        break;
    }
    return me.none();
  }, bt = (H, X) => z(H, X, G), at = (H) => {
    const X = [];
    for (let fe = 0, Me = H.length; fe < Me; ++fe) {
      if (!g(H[fe]))
        throw new Error("Arr.flatten item " + fe + " was not an array, input: " + H);
      q.apply(X, H[fe]);
    }
    return X;
  }, _n = (H, X) => at(Ie(H, X)), st = (H) => {
    const X = we.call(H, 0);
    return X.reverse(), X;
  }, Ne = (H, X) => X >= 0 && X < H.length ? me.some(H[X]) : me.none(), vt = (H) => Ne(H, 0), Gt = (H) => Ne(H, H.length - 1), xt = (H, X) => {
    const fe = [], Me = I(X) ? (We) => je(fe, (Ut) => X(Ut, We)) : (We) => Le(fe, We);
    for (let We = 0, Ut = H.length; We < Ut; We++) {
      const Wn = H[We];
      Me(Wn) || fe.push(Wn);
    }
    return fe;
  }, cn = (H, X, fe = Q) => H.exists((Me) => fe(Me, X)), He = (H, X, fe = Q) => ut(H, X, fe).getOr(H.isNone() && X.isNone()), ut = (H, X, fe) => H.isSome() && X.isSome() ? me.some(fe(H.getOrDie(), X.getOrDie())) : me.none(), oe = 8, qn = 9, Rn = 11, Zt = 1, Jt = 3, wo = (H, X) => {
    const Me = (X || document).createElement("div");
    if (Me.innerHTML = H, !Me.hasChildNodes() || Me.childNodes.length > 1) {
      const We = "HTML does not have a single root node";
      throw console.error(We, H), new Error(We);
    }
    return St(Me.childNodes[0]);
  }, Ge = (H, X) => {
    const Me = (X || document).createElement(H);
    return St(Me);
  }, qt = (H, X) => {
    const Me = (X || document).createTextNode(H);
    return St(Me);
  }, St = (H) => {
    if (H == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: H };
  }, Ct = {
    fromHtml: wo,
    fromTag: Ge,
    fromText: qt,
    fromDom: St,
    fromPoint: (H, X, fe) => me.from(H.dom.elementFromPoint(X, fe)).map(St)
  }, an = (H, X) => {
    const fe = H.dom;
    if (fe.nodeType !== Zt)
      return !1;
    {
      const Me = fe;
      if (Me.matches !== void 0)
        return Me.matches(X);
      if (Me.msMatchesSelector !== void 0)
        return Me.msMatchesSelector(X);
      if (Me.webkitMatchesSelector !== void 0)
        return Me.webkitMatchesSelector(X);
      if (Me.mozMatchesSelector !== void 0)
        return Me.mozMatchesSelector(X);
      throw new Error("Browser lacks native selectors");
    }
  }, ht = (H, X) => H.dom === X.dom, bn = (H, X) => {
    const fe = H.dom, Me = X.dom;
    return fe === Me ? !1 : fe.contains(Me);
  }, Ye = an, nn = typeof window < "u" ? window : Function("return this;")(), Bt = (H, X) => {
    let fe = X ?? nn;
    for (let Me = 0; Me < H.length && fe !== void 0 && fe !== null; ++Me)
      fe = fe[H[Me]];
    return fe;
  }, $n = (H, X) => {
    const fe = H.split(".");
    return Bt(fe, X);
  }, mr = (H, X) => $n(H, X), gr = (H, X) => {
    const fe = mr(H, X);
    if (fe == null)
      throw new Error(H + " not available on this browser");
    return fe;
  }, Vr = Object.getPrototypeOf, Xr = (H) => gr("HTMLElement", H), pc = (H) => {
    const X = $n("ownerDocument.defaultView", H);
    return v(H) && (Xr(X).prototype.isPrototypeOf(H) || /^HTML\w*Element$/.test(Vr(H).constructor.name));
  }, Eo = (H) => H.dom.nodeName.toLowerCase(), uo = (H) => H.dom.nodeType, Es = (H) => (X) => uo(X) === H, br = (H) => uo(H) === oe || Eo(H) === "#comment", hs = (H) => Ps(H) && pc(H.dom), Ps = Es(Zt), qo = Es(Jt), hc = Es(qn), Co = Es(Rn), fl = (H) => (X) => Ps(X) && Eo(X) === H, fn = (H) => Ct.fromDom(H.dom.ownerDocument), Yr = (H) => hc(H) ? H : fn(H), xa = (H) => me.from(H.dom.parentNode).map(Ct.fromDom), $i = (H) => me.from(H.dom.parentElement).map(Ct.fromDom), Kc = (H) => me.from(H.dom.nextSibling).map(Ct.fromDom), wi = (H) => Ie(H.dom.childNodes, Ct.fromDom), es = (H, X) => {
    const fe = H.dom.childNodes;
    return me.from(fe[X]).map(Ct.fromDom);
  }, gc = (H) => es(H, 0), Xl = (H) => es(H, H.dom.childNodes.length - 1), gs = (H) => Co(H) && R(H.dom.host), Ei = I(Element.prototype.attachShadow) && I(Node.prototype.getRootNode) ? (H) => Ct.fromDom(H.dom.getRootNode()) : Yr, Jl = (H) => {
    const X = Ei(H);
    return gs(X) ? me.some(X) : me.none();
  }, Pd = (H) => Ct.fromDom(H.dom.host), Xf = (H) => {
    const X = qo(H) ? H.dom.parentNode : H.dom;
    if (X == null || X.ownerDocument === null)
      return !1;
    const fe = X.ownerDocument;
    return Jl(Ct.fromDom(X)).fold(() => fe.body.contains(X), ne(Xf, Pd));
  };
  var Qa = (H, X, fe, Me, We) => H(fe, Me) ? me.some(fe) : I(We) && We(fe) ? me.none() : X(fe, Me, We);
  const Xa = (H, X, fe) => {
    let Me = H.dom;
    const We = I(fe) ? fe : G;
    for (; Me.parentNode; ) {
      Me = Me.parentNode;
      const Ut = Ct.fromDom(Me);
      if (X(Ut))
        return me.some(Ut);
      if (We(Ut))
        break;
    }
    return me.none();
  }, ia = (H, X, fe) => Qa((We, Ut) => Ut(We), Xa, H, X, fe), Nl = (H, X, fe) => Xa(H, (Me) => an(Me, X), fe), Sp = (H, X, fe) => Qa((We, Ut) => an(We, Ut), Nl, H, X, fe), Yu = (H) => Sp(H, "[contenteditable]"), vc = (H, X = !1) => Xf(H) ? H.dom.isContentEditable : Yu(H).fold(se(X), (fe) => ea(fe) === "true"), ea = (H) => H.dom.contentEditable, bc = (H, X) => {
    xa(H).each((Me) => {
      Me.dom.insertBefore(X.dom, H.dom);
    });
  }, Qu = (H, X) => {
    Kc(H).fold(() => {
      xa(H).each((We) => {
        of(We, X);
      });
    }, (Me) => {
      bc(Me, X);
    });
  }, wp = (H, X) => {
    gc(H).fold(() => {
      of(H, X);
    }, (Me) => {
      H.dom.insertBefore(X.dom, Me.dom);
    });
  }, of = (H, X) => {
    H.dom.appendChild(X.dom);
  }, Ou = (H, X) => {
    Ce(X, (fe) => {
      bc(H, fe);
    });
  }, Au = (H, X) => {
    Ce(X, (fe) => {
      of(H, fe);
    });
  }, nt = (H) => {
    H.dom.textContent = "", Ce(wi(H), (X) => {
      Ja(X);
    });
  }, Ja = (H) => {
    const X = H.dom;
    X.parentNode !== null && X.parentNode.removeChild(X);
  };
  var eu = tinymce.util.Tools.resolve("tinymce.dom.RangeUtils"), Ep = tinymce.util.Tools.resolve("tinymce.dom.TreeWalker"), Jf = tinymce.util.Tools.resolve("tinymce.util.VK");
  const os = (H) => Ie(H, Ct.fromDom), Cp = Object.keys, Am = (H, X) => {
    const fe = Cp(H);
    for (let Me = 0, We = fe.length; Me < We; Me++) {
      const Ut = fe[Me], Wn = H[Ut];
      X(Wn, Ut);
    }
  }, tu = (H) => (X, fe) => {
    H[fe] = X;
  }, em = (H, X, fe, Me) => {
    Am(H, (We, Ut) => {
      (X(We, Ut) ? fe : Me)(We, Ut);
    });
  }, Hs = (H, X) => {
    const fe = {};
    return em(H, X, tu(fe), Z), fe;
  }, Gs = (H, X, fe) => {
    if (m(fe) || C(fe) || L(fe))
      H.setAttribute(X, fe + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", X, ":: Value ", fe, ":: Element ", H), new Error("Attribute value was not simple");
  }, Ac = (H, X) => {
    const fe = H.dom;
    Am(X, (Me, We) => {
      Gs(fe, We, Me);
    });
  }, kc = (H) => Lt(H.dom.attributes, (X, fe) => (X[fe.name] = fe.value, X), {}), Xu = (H, X) => Ct.fromDom(H.dom.cloneNode(X)), Ju = (H) => Xu(H, !0), ed = (H, X) => {
    const fe = Ct.fromTag(X), Me = kc(H);
    return Ac(fe, Me), fe;
  }, $o = (H, X) => {
    const fe = ed(H, X);
    Qu(H, fe);
    const Me = wi(H);
    return Au(fe, Me), Ja(H), fe;
  };
  var ei = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"), Rl = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const td = (H) => (X) => R(X) && X.nodeName.toLowerCase() === H, Xi = (H) => (X) => R(X) && H.test(X.nodeName), Zs = (H) => R(H) && H.nodeType === 3, ss = (H) => R(H) && H.nodeType === 1, yc = Xi(/^(OL|UL|DL)$/), tm = Xi(/^(OL|UL)$/), Io = td("ol"), za = Xi(/^(LI|DT|DD)$/), ti = Xi(/^(DT|DD)$/), Ra = Xi(/^(TH|TD)$/), Pl = td("br"), nu = (H) => {
    var X;
    return ((X = H.parentNode) === null || X === void 0 ? void 0 : X.firstChild) === H;
  }, Ii = (H, X) => R(X) && X.nodeName in H.schema.getTextBlockElements(), Dl = (H, X) => R(H) && H.nodeName in X, $l = (H, X) => R(X) && X.nodeName in H.schema.getVoidElements(), km = (H, X) => Pl(X) ? H.isBlock(X.nextSibling) && !Pl(X.previousSibling) : !1, Il = (H, X, fe) => {
    const Me = H.isEmpty(X);
    return fe && H.select("span[data-mce-type=bookmark]", X).length > 0 ? !1 : Me;
  }, xp = (H, X) => H.isChildOf(X, H.getRoot()), Nc = (H) => (X) => X.options.get(H), ku = (H) => {
    const X = H.options.register;
    X("lists_indent_on_tab", {
      processor: "boolean",
      default: !0
    });
  }, sf = Nc("lists_indent_on_tab"), Nm = Nc("forced_root_block"), Tp = Nc("forced_root_block_attrs"), Se = (H, X) => {
    const fe = H.dom, Me = H.schema.getBlockElements(), We = fe.createFragment(), Ut = Nm(H), Wn = Tp(H);
    let xr, wr, pr = !1;
    for (wr = fe.create(Ut, Wn), Dl(X.firstChild, Me) || We.appendChild(wr); xr = X.firstChild; ) {
      const Us = xr.nodeName;
      !pr && (Us !== "SPAN" || xr.getAttribute("data-mce-type") !== "bookmark") && (pr = !0), Dl(xr, Me) ? (We.appendChild(xr), wr = null) : (wr || (wr = fe.create(Ut, Wn), We.appendChild(wr)), wr.appendChild(xr));
    }
    return !pr && wr && wr.appendChild(fe.create("br", { "data-mce-bogus": "1" })), We;
  }, Ve = ei.DOM, tt = (H, X, fe) => {
    const Me = (pr) => {
      const Us = pr.parentNode;
      Us && Rl.each(We, (ra) => {
        Us.insertBefore(ra, fe.parentNode);
      }), Ve.remove(pr);
    }, We = Ve.select('span[data-mce-type="bookmark"]', X), Ut = Se(H, fe), Wn = Ve.createRng();
    Wn.setStartAfter(fe), Wn.setEndAfter(X);
    const xr = Wn.extractContents();
    for (let pr = xr.firstChild; pr; pr = pr.firstChild)
      if (pr.nodeName === "LI" && H.dom.isEmpty(pr)) {
        Ve.remove(pr);
        break;
      }
    H.dom.isEmpty(xr) || Ve.insertAfter(xr, X), Ve.insertAfter(Ut, X);
    const wr = fe.parentElement;
    wr && Il(H.dom, wr) && Me(wr), Ve.remove(fe), Il(H.dom, X) && Ve.remove(X);
  }, wt = fl("dd"), en = fl("dt"), ur = (H, X) => {
    wt(X) ? $o(X, "dt") : en(X) && $i(X).each((fe) => tt(H, fe.dom, X.dom));
  }, Yo = (H) => {
    en(H) && $o(H, "dd");
  }, Lr = (H, X, fe) => {
    X === "Indent" ? Ce(fe, Yo) : Ce(fe, (Me) => ur(H, Me));
  }, Nr = (H, X) => {
    if (Zs(H))
      return {
        container: H,
        offset: X
      };
    const fe = eu.getNode(H, X);
    return Zs(fe) ? {
      container: fe,
      offset: X >= H.childNodes.length ? fe.data.length : 0
    } : fe.previousSibling && Zs(fe.previousSibling) ? {
      container: fe.previousSibling,
      offset: fe.previousSibling.data.length
    } : fe.nextSibling && Zs(fe.nextSibling) ? {
      container: fe.nextSibling,
      offset: 0
    } : {
      container: H,
      offset: X
    };
  }, Ks = (H) => {
    const X = H.cloneRange(), fe = Nr(H.startContainer, H.startOffset);
    X.setStart(fe.container, fe.offset);
    const Me = Nr(H.endContainer, H.endOffset);
    return X.setEnd(Me.container, Me.offset), X;
  }, fo = [
    "OL",
    "UL",
    "DL"
  ], ta = fo.join(","), Yc = (H, X) => {
    const fe = X || H.selection.getStart(!0);
    return H.dom.getParent(fe, ta, Va(H, fe));
  }, Rm = (H, X) => R(H) && X.length === 1 && X[0] === H, kn = (H) => pt(H.querySelectorAll(ta), yc), Pm = (H) => {
    const X = Yc(H), fe = H.selection.getSelectedBlocks();
    return Rm(X, fe) ? kn(X) : pt(fe, (Me) => yc(Me) && X !== Me);
  }, ca = (H, X) => {
    const fe = Rl.map(X, (Me) => {
      const We = H.dom.getParent(Me, "li,dd,dt", Va(H, Me));
      return We || Me;
    });
    return xt(fe);
  }, as = (H) => {
    const X = H.selection.getSelectedBlocks();
    return pt(ca(H, X), za);
  }, _p = (H) => pt(as(H), ti), vs = (H, X) => {
    const fe = H.dom.getParents(X, "TD,TH");
    return fe.length > 0 ? fe[0] : H.getBody();
  }, Wv = (H, X) => !yc(X) && !za(X) && je(fo, (fe) => H.isValidChild(X.nodeName, fe)), Va = (H, X) => {
    const fe = H.dom.getParents(X, H.dom.isBlock);
    return bt(fe, (We) => Wv(H.schema, We)).getOr(H.getBody());
  }, Sc = (H) => xa(H).exists((X) => za(X.dom) && gc(X).exists((fe) => !yc(fe.dom)) && Xl(X).exists((fe) => !yc(fe.dom))), Sr = (H, X) => {
    const fe = H.dom.getParents(X, "ol,ul", Va(H, X));
    return Gt(fe);
  }, Rc = (H) => {
    const X = Sr(H, H.selection.getStart()), fe = pt(H.selection.getSelectedBlocks(), tm);
    return X.toArray().concat(fe);
  }, rn = (H) => {
    const X = H.selection.getStart();
    return H.dom.getParents(X, "ol,ul", Va(H, X));
  }, na = (H) => {
    const X = Rc(H), fe = rn(H);
    return bt(fe, (Me) => Sc(Ct.fromDom(Me))).fold(() => Dm(H, X), (Me) => [Me]);
  }, Dm = (H, X) => {
    const fe = Ie(X, (Me) => Sr(H, Me).getOr(Me));
    return xt(fe);
  }, Ta = (H) => /\btox\-/.test(H.className), bs = (H, X) => z(H, yc, Ra).exists((fe) => fe.nodeName === X && !Ta(fe)), Dd = (H, X) => X !== null && !H.dom.isEditable(X), Ur = (H) => {
    const X = Yc(H);
    return Dd(H, X);
  }, Qc = (H, X) => {
    const fe = H.dom.getParent(X, "ol,ul,dl");
    return Dd(H, fe);
  }, ni = (H, X) => {
    const fe = H.selection.getNode();
    return X({
      parents: H.dom.getParents(fe),
      element: fe
    }), H.on("NodeChange", X), () => H.off("NodeChange", X);
  }, Xc = (H, X) => {
    const Me = (X || document).createDocumentFragment();
    return Ce(H, (We) => {
      Me.appendChild(We.dom);
    }), Ct.fromDom(Me);
  }, Ds = (H, X, fe) => H.dispatch("ListMutation", {
    action: X,
    element: fe
  }), _a = ((H) => (X) => X.replace(H, ""))(/^\s+|\s+$/g), $d = (H) => H.length > 0, Oo = (H) => !$d(H), Nu = (H) => H.style !== void 0 && I(H.style.getPropertyValue), Ru = (H, X, fe) => {
    if (!m(fe))
      throw console.error("Invalid call to CSS.set. Property ", X, ":: Value ", fe, ":: Element ", H), new Error("CSS value must be a string: " + fe);
    Nu(H) && H.style.setProperty(X, fe);
  }, Jc = (H, X, fe) => {
    const Me = H.dom;
    Ru(Me, X, fe);
  }, Ml = (H) => Ye(H, "OL,UL"), Op = (H) => Ye(H, "LI"), no = (H) => gc(H).exists(Ml), Oa = (H) => Xl(H).exists(Ml), Pa = (H) => "listAttributes" in H, jv = (H) => "isComment" in H, zs = (H) => "isFragment" in H, Mi = (H) => H.depth > 0, hi = (H) => H.isSelected, Fh = (H) => {
    const X = wi(H), fe = Oa(H) ? X.slice(0, -1) : X;
    return Ie(fe, Ju);
  }, Lh = (H, X, fe) => xa(H).filter(Ps).map((Me) => ({
    depth: X,
    dirty: !1,
    isSelected: fe,
    content: Fh(H),
    itemAttributes: kc(H),
    listAttributes: kc(Me),
    listType: Eo(Me),
    isInPreviousLi: !1
  })), Fl = (H, X) => {
    of(H.item, X.list);
  }, $m = (H) => {
    for (let X = 1; X < H.length; X++)
      Fl(H[X - 1], H[X]);
  }, is = (H, X) => {
    ut(Gt(H), vt(X), Fl);
  }, ru = (H, X) => {
    const fe = {
      list: Ct.fromTag(X, H),
      item: Ct.fromTag("li", H)
    };
    return of(fe.list, fe.item), fe;
  }, Ji = (H, X, fe) => {
    const Me = [];
    for (let We = 0; We < fe; We++)
      Me.push(ru(H, Pa(X) ? X.listType : X.parentListType));
    return Me;
  }, ri = (H, X) => {
    for (let fe = 0; fe < H.length - 1; fe++)
      Jc(H[fe].item, "list-style-type", "none");
    Gt(H).each((fe) => {
      Pa(X) && (Ac(fe.list, X.listAttributes), Ac(fe.item, X.itemAttributes)), Au(fe.item, X.content);
    });
  }, Da = (H, X) => {
    Eo(H.list) !== X.listType && (H.list = $o(H.list, X.listType)), Ac(H.list, X.listAttributes);
  }, Vs = (H, X, fe) => {
    const Me = Ct.fromTag("li", H);
    return Ac(Me, X), Au(Me, fe), Me;
  }, Ll = (H, X) => {
    of(H.list, X), H.item = X;
  }, cf = (H, X, fe) => {
    const Me = X.slice(0, fe.depth);
    return Gt(Me).each((We) => {
      if (Pa(fe)) {
        const Ut = Vs(H, fe.itemAttributes, fe.content);
        Ll(We, Ut), Da(We, fe);
      } else if (zs(fe))
        Au(We.item, fe.content);
      else {
        const Ut = Ct.fromHtml(`<!--${fe.content}-->`);
        of(We.list, Ut);
      }
    }), Me;
  }, nm = (H, X, fe) => {
    const Me = Ji(H, fe, fe.depth - X.length);
    return $m(Me), ri(Me, fe), is(X, Me), X.concat(Me);
  }, Bh = (H, X) => {
    let fe = me.none();
    const Me = Lt(X, (We, Ut, Wn) => jv(Ut) ? Wn === 0 ? (fe = me.some(Ut), We) : cf(H, We, Ut) : Ut.depth > We.length ? nm(H, We, Ut) : cf(H, We, Ut), []);
    return fe.each((We) => {
      const Ut = Ct.fromHtml(`<!--${We.content}-->`);
      vt(Me).each((Wn) => {
        wp(Wn.list, Ut);
      });
    }), vt(Me).map((We) => We.list);
  }, Ap = (H, X) => {
    switch (H) {
      case "Indent":
        X.depth++;
        break;
      case "Outdent":
        X.depth--;
        break;
      case "Flatten":
        X.depth = 0;
    }
    X.dirty = !0;
  }, Pc = (H, X) => {
    Pa(H) && Pa(X) && (H.listType = X.listType, H.listAttributes = { ...X.listAttributes });
  }, kp = (H) => {
    H.listAttributes = Hs(H.listAttributes, (X, fe) => fe !== "start");
  }, gi = (H, X) => {
    const fe = H[X].depth, Me = (Ut) => Ut.depth === fe && !Ut.dirty, We = (Ut) => Ut.depth < fe;
    return z(st(H.slice(0, X)), Me, We).orThunk(() => z(H.slice(X + 1), Me, We));
  }, Pu = (H) => (Ce(H, (X, fe) => {
    gi(H, fe).fold(() => {
      X.dirty && Pa(X) && kp(X);
    }, (Me) => Pc(X, Me));
  }), H), Np = (H) => {
    let X = H;
    return {
      get: () => X,
      set: (We) => {
        X = We;
      }
    };
  }, nd = (H, X, fe, Me) => {
    var We;
    if (br(Me))
      return [{
        depth: H + 1,
        content: (We = Me.dom.nodeValue) !== null && We !== void 0 ? We : "",
        dirty: !1,
        isSelected: !1,
        isComment: !0
      }];
    X.each((xr) => {
      ht(xr.start, Me) && fe.set(!0);
    });
    const Ut = Lh(Me, H, fe.get());
    X.each((xr) => {
      ht(xr.end, Me) && fe.set(!1);
    });
    const Wn = Xl(Me).filter(Ml).map((xr) => wc(H, X, fe, xr)).getOr([]);
    return Ut.toArray().concat(Wn);
  }, Im = (H, X, fe, Me) => gc(Me).filter(Ml).fold(() => nd(H, X, fe, Me), (We) => {
    const Ut = Lt(wi(Me), (Wn, xr, wr) => {
      if (wr === 0)
        return Wn;
      if (Op(xr))
        return Wn.concat(nd(H, X, fe, xr));
      {
        const pr = {
          isFragment: !0,
          depth: H,
          content: [xr],
          isSelected: !1,
          dirty: !1,
          parentListType: Eo(We)
        };
        return Wn.concat(pr);
      }
    }, []);
    return wc(H, X, fe, We).concat(Ut);
  }), wc = (H, X, fe, Me) => _n(wi(Me), (We) => {
    const Ut = Ml(We) ? wc : Im, Wn = H + 1;
    return Ut(Wn, X, fe, We);
  }), Mm = (H, X) => {
    const fe = Np(!1), Me = 0;
    return Ie(H, (We) => ({
      sourceList: We,
      entries: wc(Me, X, fe, We)
    }));
  }, Id = (H, X) => {
    const fe = Pu(X);
    return Ie(fe, (Me) => {
      const We = jv(Me) ? Xc([Ct.fromHtml(`<!--${Me.content}-->`)]) : Xc(Me.content);
      return Ct.fromDom(Se(H, We.dom));
    });
  }, Ig = (H, X) => {
    const fe = Pu(X);
    return Bh(H.contentDocument, fe).toArray();
  }, Mg = (H, X) => _n(sn(X, Mi), (fe) => vt(fe).exists(Mi) ? Ig(H, fe) : Id(H, fe)), lf = (H, X) => {
    Ce(pt(H, hi), (fe) => Ap(X, fe));
  }, Ec = (H) => {
    const X = Ie(as(H), Ct.fromDom);
    return ut(bt(X, ue(no)), bt(st(X), ue(no)), (fe, Me) => ({
      start: fe,
      end: Me
    }));
  }, Fg = (H, X, fe) => {
    const Me = Mm(X, Ec(H));
    Ce(Me, (We) => {
      lf(We.entries, fe);
      const Ut = Mg(H, We.entries);
      Ce(Ut, (Wn) => {
        Ds(H, fe === "Indent" ? "IndentList" : "OutdentList", Wn.dom);
      }), Ou(We.sourceList, Ut), Ja(We.sourceList);
    });
  }, Fe = (H, X) => {
    const fe = os(na(H)), Me = os(_p(H));
    let We = !1;
    if (fe.length || Me.length) {
      const Ut = H.selection.getBookmark();
      Fg(H, fe, X), Lr(H, X, Me), H.selection.moveToBookmark(Ut), H.selection.setRng(Ks(H.selection.getRng())), H.nodeChanged(), We = !0;
    }
    return We;
  }, uf = (H, X) => !Ur(H) && Fe(H, X), Bl = (H) => uf(H, "Indent"), Fm = (H) => uf(H, "Outdent"), Lg = (H) => uf(H, "Flatten"), Lm = "\uFEFF", Je = (H) => H === Lm, Wt = (H, X, fe) => Xa(H, X, fe).isSome(), Ft = (H, X) => Wt(H, he(ht, X));
  var er = tinymce.util.Tools.resolve("tinymce.dom.BookmarkManager");
  const Qr = ei.DOM, No = (H) => {
    const X = {}, fe = (Me) => {
      let We = H[Me ? "startContainer" : "endContainer"], Ut = H[Me ? "startOffset" : "endOffset"];
      if (ss(We)) {
        const Wn = Qr.create("span", { "data-mce-type": "bookmark" });
        We.hasChildNodes() ? (Ut = Math.min(Ut, We.childNodes.length - 1), Me ? We.insertBefore(Wn, We.childNodes[Ut]) : Qr.insertAfter(Wn, We.childNodes[Ut])) : We.appendChild(Wn), We = Wn, Ut = 0;
      }
      X[Me ? "startContainer" : "endContainer"] = We, X[Me ? "startOffset" : "endOffset"] = Ut;
    };
    return fe(!0), H.collapsed || fe(), X;
  }, Qo = (H) => {
    const X = (Me) => {
      const We = (xr) => {
        var wr;
        let pr = (wr = xr.parentNode) === null || wr === void 0 ? void 0 : wr.firstChild, Us = 0;
        for (; pr; ) {
          if (pr === xr)
            return Us;
          (!ss(pr) || pr.getAttribute("data-mce-type") !== "bookmark") && Us++, pr = pr.nextSibling;
        }
        return -1;
      };
      let Ut = H[Me ? "startContainer" : "endContainer"], Wn = H[Me ? "startOffset" : "endOffset"];
      if (Ut) {
        if (ss(Ut) && Ut.parentNode) {
          const xr = Ut;
          Wn = We(Ut), Ut = Ut.parentNode, Qr.remove(xr), !Ut.hasChildNodes() && Qr.isBlock(Ut) && Ut.appendChild(Qr.create("br"));
        }
        H[Me ? "startContainer" : "endContainer"] = Ut, H[Me ? "startOffset" : "endOffset"] = Wn;
      }
    };
    X(!0), X();
    const fe = Qr.createRng();
    return fe.setStart(H.startContainer, H.startOffset), H.endContainer && fe.setEnd(H.endContainer, H.endOffset), Ks(fe);
  }, Xo = (H) => {
    switch (H) {
      case "UL":
        return "ToggleUlList";
      case "OL":
        return "ToggleOlList";
      case "DL":
        return "ToggleDLList";
    }
  }, Rp = (H, X, fe) => {
    const Me = fe["list-style-type"] ? fe["list-style-type"] : null;
    H.setStyle(X, "list-style-type", Me);
  }, qv = (H, X) => {
    Rl.each(X, (fe, Me) => {
      H.setAttribute(Me, fe);
    });
  }, $a = (H, X, fe) => {
    qv(X, fe["list-attributes"]), Rl.each(H.select("li", X), (Me) => {
      qv(Me, fe["list-item-attributes"]);
    });
  }, Hl = (H, X, fe) => {
    Rp(H, X, fe), $a(H, X, fe);
  }, Bg = (H, X, fe) => {
    Rl.each(fe, (Me) => H.setStyle(X, Me, ""));
  }, oi = (H, X) => R(X) && !Dl(X, H.schema.getBlockElements()), ga = (H, X, fe, Me) => {
    let We = X[fe ? "startContainer" : "endContainer"];
    const Ut = X[fe ? "startOffset" : "endOffset"];
    ss(We) && (We = We.childNodes[Math.min(Ut, We.childNodes.length - 1)] || We), !fe && Pl(We.nextSibling) && (We = We.nextSibling);
    const Wn = (wr) => {
      for (; !H.dom.isBlock(wr) && wr.parentNode && Me !== wr; )
        wr = wr.parentNode;
      return wr;
    }, xr = (wr, pr) => {
      var Us;
      const ra = new Ep(wr, Wn(wr)), hl = pr ? "next" : "prev";
      let Ld;
      for (; Ld = ra[hl](); )
        if (!($l(H, Ld) || Je(Ld.textContent) || ((Us = Ld.textContent) === null || Us === void 0 ? void 0 : Us.length) === 0))
          return me.some(Ld);
      return me.none();
    };
    if (fe && Zs(We))
      if (Je(We.textContent))
        We = xr(We, !1).getOr(We);
      else
        for (We.parentNode !== null && oi(H, We.parentNode) && (We = We.parentNode); We.previousSibling !== null && (oi(H, We.previousSibling) || Zs(We.previousSibling)); )
          We = We.previousSibling;
    if (!fe && Zs(We))
      if (Je(We.textContent))
        We = xr(We, !0).getOr(We);
      else
        for (We.parentNode !== null && oi(H, We.parentNode) && (We = We.parentNode); We.nextSibling !== null && (oi(H, We.nextSibling) || Zs(We.nextSibling)); )
          We = We.nextSibling;
    for (; We.parentNode !== Me; ) {
      const wr = We.parentNode;
      if (Ii(H, We) || /^(TD|TH)$/.test(wr.nodeName))
        return We;
      We = wr;
    }
    return We;
  }, Du = (H, X, fe) => {
    const Me = [], We = H.dom, Ut = ga(H, X, !0, fe), Wn = ga(H, X, !1, fe);
    let xr;
    const wr = [];
    for (let pr = Ut; pr && (wr.push(pr), pr !== Wn); pr = pr.nextSibling)
      ;
    return Rl.each(wr, (pr) => {
      var Us;
      if (Ii(H, pr)) {
        Me.push(pr), xr = null;
        return;
      }
      if (We.isBlock(pr) || Pl(pr)) {
        Pl(pr) && We.remove(pr), xr = null;
        return;
      }
      const ra = pr.nextSibling;
      if (er.isBookmarkNode(pr) && (yc(ra) || Ii(H, ra) || !ra && pr.parentNode === fe)) {
        xr = null;
        return;
      }
      xr || (xr = We.create("p"), (Us = pr.parentNode) === null || Us === void 0 || Us.insertBefore(xr, pr), Me.push(xr)), xr.appendChild(pr);
    }), Me;
  }, ys = (H, X, fe) => {
    const Me = H.getStyle(X, "list-style-type");
    let We = fe ? fe["list-style-type"] : "";
    return We = We === null ? "" : We, Me === We;
  }, ou = (H, X) => {
    const fe = H.selection.getStart(!0), Me = ga(H, X, !0, H.getBody());
    return Ft(Ct.fromDom(Me), Ct.fromDom(X.commonAncestorContainer)) ? X.commonAncestorContainer : fe;
  }, ec = (H, X, fe) => {
    const Me = H.selection.getRng();
    let We = "LI";
    const Ut = Va(H, ou(H, Me)), Wn = H.dom;
    if (Wn.getContentEditable(H.selection.getNode()) === "false")
      return;
    X = X.toUpperCase(), X === "DL" && (We = "DT");
    const xr = No(Me), wr = pt(Du(H, Me, Ut), H.dom.isEditable);
    Rl.each(wr, (pr) => {
      let Us;
      const ra = pr.previousSibling, hl = pr.parentNode;
      za(hl) || (ra && yc(ra) && ra.nodeName === X && ys(Wn, ra, fe) ? (Us = ra, pr = Wn.rename(pr, We), ra.appendChild(pr)) : (Us = Wn.create(X), hl.insertBefore(Us, pr), Us.appendChild(pr), pr = Wn.rename(pr, We)), Bg(Wn, pr, [
        "margin",
        "margin-right",
        "margin-bottom",
        "margin-left",
        "margin-top",
        "padding",
        "padding-right",
        "padding-bottom",
        "padding-left",
        "padding-top"
      ]), Hl(Wn, Us, fe), Md(H.dom, Us));
    }), H.selection.setRng(Qo(xr));
  }, Bm = (H, X) => yc(H) && H.nodeName === (X == null ? void 0 : X.nodeName), Gv = (H, X, fe) => {
    const Me = H.getStyle(X, "list-style-type", !0), We = H.getStyle(fe, "list-style-type", !0);
    return Me === We;
  }, Pp = (H, X) => H.className === X.className, Hh = (H, X, fe) => Bm(X, fe) && Gv(H, X, fe) && Pp(X, fe), Md = (H, X) => {
    let fe, Me = X.nextSibling;
    if (Hh(H, X, Me)) {
      const We = Me;
      for (; fe = We.firstChild; )
        X.appendChild(fe);
      H.remove(We);
    }
    if (Me = X.previousSibling, Hh(H, X, Me)) {
      const We = Me;
      for (; fe = We.lastChild; )
        X.insertBefore(fe, X.firstChild);
      H.remove(We);
    }
  }, Cc = (H, X, fe, Me) => {
    if (X.nodeName !== fe) {
      const We = H.dom.rename(X, fe);
      Hl(H.dom, We, Me), Ds(H, Xo(fe), We);
    } else
      Hl(H.dom, X, Me), Ds(H, Xo(fe), X);
  }, Dp = (H, X, fe, Me) => {
    if (X.classList.forEach((We, Ut, Wn) => {
      We.startsWith("tox-") && (Wn.remove(We), Wn.length === 0 && X.removeAttribute("class"));
    }), X.nodeName !== fe) {
      const We = H.dom.rename(X, fe);
      Hl(H.dom, We, Me), Ds(H, Xo(fe), We);
    } else
      Hl(H.dom, X, Me), Ds(H, Xo(fe), X);
  }, wy = (H, X, fe, Me, We) => {
    const Ut = yc(X);
    if (Ut && X.nodeName === Me && !Hm(We) && !Ta(X))
      Lg(H);
    else {
      ec(H, Me, We);
      const Wn = No(H.selection.getRng()), xr = Ut ? [
        X,
        ...fe
      ] : fe, wr = Ut && Ta(X) ? Dp : Cc;
      Rl.each(xr, (pr) => {
        wr(H, pr, Me, We);
      }), H.selection.setRng(Qo(Wn));
    }
  }, Hm = (H) => "list-style-type" in H, zh = (H, X, fe, Me) => {
    if (X !== H.getBody())
      if (X)
        if (X.nodeName === fe && !Hm(Me) && !Ta(X))
          Lg(H);
        else {
          const We = No(H.selection.getRng());
          Ta(X) && X.classList.forEach((Wn, xr, wr) => {
            Wn.startsWith("tox-") && (wr.remove(Wn), wr.length === 0 && X.removeAttribute("class"));
          }), Hl(H.dom, X, Me);
          const Ut = H.dom.rename(X, fe);
          Md(H.dom, Ut), H.selection.setRng(Qo(We)), ec(H, fe, Me), Ds(H, Xo(fe), Ut);
        }
      else
        ec(H, fe, Me), Ds(H, Xo(fe), X);
  }, df = (H, X, fe) => {
    const Me = Yc(H);
    if (Qc(H, Me))
      return;
    const We = Pm(H), Ut = v(fe) ? fe : {};
    We.length > 0 ? wy(H, Me, We, X, Ut) : zh(H, Me, X, Ut);
  }, ff = ei.DOM, rm = (H, X) => {
    const fe = X.parentElement;
    if (fe && fe.nodeName === "LI" && fe.firstChild === X) {
      const Me = fe.previousSibling;
      Me && Me.nodeName === "LI" ? (Me.appendChild(X), Il(H, fe) && ff.remove(fe)) : ff.setStyle(fe, "listStyleType", "none");
    }
    if (yc(fe)) {
      const Me = fe.previousSibling;
      Me && Me.nodeName === "LI" && Me.appendChild(X);
    }
  }, cs = (H, X) => {
    const fe = Rl.grep(H.select("ol,ul", X));
    Rl.each(fe, (Me) => {
      rm(H, Me);
    });
  }, Ss = (H, X, fe, Me) => {
    let We = X.startContainer;
    const Ut = X.startOffset;
    if (Zs(We) && (fe ? Ut < We.data.length : Ut > 0))
      return We;
    const Wn = H.schema.getNonEmptyElements();
    ss(We) && (We = eu.getNode(We, Ut));
    const xr = new Ep(We, Me);
    fe && km(H.dom, We) && xr.next();
    const wr = fe ? xr.next.bind(xr) : xr.prev2.bind(xr);
    for (; We = wr(); )
      if (We.nodeName === "LI" && !We.hasChildNodes() || Wn[We.nodeName] || Zs(We) && We.data.length > 0)
        return We;
    return null;
  }, Fi = (H, X) => {
    const fe = X.childNodes;
    return fe.length === 1 && !yc(fe[0]) && H.isBlock(fe[0]);
  }, Hg = (H) => me.from(H).map(Ct.fromDom).filter(hs).exists((X) => vc(X) && !Le(["details"], Eo(X))), Zv = (H, X) => {
    Fi(H, X) && Hg(X.firstChild) && H.remove(X.firstChild, !0);
  }, Ci = (H, X, fe) => {
    let Me;
    const We = Fi(H, fe) ? fe.firstChild : fe;
    if (Zv(H, X), !Il(H, X, !0))
      for (; Me = X.firstChild; )
        We.appendChild(Me);
  }, su = (H, X, fe) => {
    let Me;
    const We = X.parentNode;
    if (!xp(H, X) || !xp(H, fe))
      return;
    yc(fe.lastChild) && (Me = fe.lastChild), We === fe.lastChild && Pl(We.previousSibling) && H.remove(We.previousSibling);
    const Ut = fe.lastChild;
    Ut && Pl(Ut) && X.hasChildNodes() && H.remove(Ut), Il(H, fe, !0) && nt(Ct.fromDom(fe)), Ci(H, X, fe), Me && fe.appendChild(Me);
    const xr = bn(Ct.fromDom(fe), Ct.fromDom(X)) ? H.getParents(X, yc, fe) : [];
    H.remove(X), Ce(xr, (wr) => {
      Il(H, wr) && wr !== H.getRoot() && H.remove(wr);
    });
  }, Li = (H, X, fe) => {
    nt(Ct.fromDom(fe)), su(H.dom, X, fe), H.selection.setCursorLocation(fe, 0);
  }, au = (H, X, fe, Me) => {
    const We = H.dom;
    if (We.isEmpty(Me))
      Li(H, fe, Me);
    else {
      const Ut = No(X);
      su(We, fe, Me), H.selection.setRng(Qo(Ut));
    }
  }, Vh = (H, X, fe, Me) => {
    const We = No(X);
    su(H.dom, fe, Me);
    const Ut = Qo(We);
    H.selection.setRng(Ut);
  }, Rr = (H, X) => {
    const fe = H.dom, Me = H.selection, We = Me.getStart(), Ut = vs(H, We), Wn = fe.getParent(Me.getStart(), "LI", Ut);
    if (Wn) {
      const xr = Wn.parentElement;
      if (xr === H.getBody() && Il(fe, xr))
        return !0;
      const wr = Ks(Me.getRng()), pr = fe.getParent(Ss(H, wr, X, Ut), "LI", Ut), Us = pr && (X ? fe.isChildOf(Wn, pr) : fe.isChildOf(pr, Wn));
      if (pr && pr !== Wn && !Us)
        return H.undoManager.transact(() => {
          X ? au(H, wr, pr, Wn) : nu(Wn) ? Fm(H) : Vh(H, wr, Wn, pr);
        }), !0;
      if (Us && !X && pr !== Wn)
        return H.undoManager.transact(() => {
          if (wr.commonAncestorContainer.parentElement) {
            const ra = No(wr), hl = wr.commonAncestorContainer.parentElement;
            Ci(fe, wr.commonAncestorContainer.parentElement, pr), hl.remove();
            const Ld = Qo(ra);
            H.selection.setRng(Ld);
          }
        }), !0;
      if (!pr && !X && wr.startOffset === 0 && wr.endOffset === 0)
        return H.undoManager.transact(() => {
          Lg(H);
        }), !0;
    }
    return !1;
  }, el = (H, X, fe) => {
    const Me = H.getParent(X.parentNode, H.isBlock, fe);
    H.remove(X), Me && H.isEmpty(Me) && H.remove(Me);
  }, mf = (H, X) => {
    const fe = H.dom, Me = H.selection.getStart(), We = vs(H, Me), Ut = fe.getParent(Me, fe.isBlock, We);
    if (Ut && fe.isEmpty(Ut)) {
      const Wn = Ks(H.selection.getRng()), xr = fe.getParent(Ss(H, Wn, X, We), "LI", We);
      if (xr) {
        const wr = (hl) => Le([
          "td",
          "th",
          "caption"
        ], Eo(hl)), pr = (hl) => hl.dom === We, Us = ia(Ct.fromDom(xr), wr, pr), ra = ia(Ct.fromDom(Wn.startContainer), wr, pr);
        return He(Us, ra, ht) ? (H.undoManager.transact(() => {
          const hl = xr.parentNode;
          el(fe, Ut, We), Md(fe, hl), H.selection.select(xr, !0), H.selection.collapse(X);
        }), !0) : !1;
      }
    }
    return !1;
  }, Ia = (H, X) => Rr(H, X) || mf(H, X), Bi = (H) => {
    const X = H.selection.getStart(), fe = vs(H, X);
    return H.dom.getParent(X, "LI,DT,DD", fe) || as(H).length > 0;
  }, Kv = (H) => Bi(H) ? (H.undoManager.transact(() => {
    H.execCommand("Delete"), cs(H.dom, H.getBody());
  }), !0) : !1, Hi = (H, X) => {
    const fe = H.selection;
    return !Qc(H, fe.getNode()) && (fe.isCollapsed() ? Ia(H, X) : Kv(H));
  }, va = (H) => {
    H.on("ExecCommand", (X) => {
      const fe = X.command.toLowerCase();
      (fe === "delete" || fe === "forwarddelete") && Bi(H) && cs(H.dom, H.getBody());
    }), H.on("keydown", (X) => {
      X.keyCode === Jf.BACKSPACE ? Hi(H, !1) && X.preventDefault() : X.keyCode === Jf.DELETE && Hi(H, !0) && X.preventDefault();
    });
  }, ml = (H) => ({
    backspaceDelete: (X) => {
      Hi(H, X);
    }
  }), Aa = (H, X) => {
    const fe = Yc(H);
    fe === null || Qc(H, fe) || H.undoManager.transact(() => {
      v(X.styles) && H.dom.setStyles(fe, X.styles), v(X.attrs) && Am(X.attrs, (Me, We) => H.dom.setAttrib(fe, We, Me));
    });
  }, rd = (H) => {
    const X = st(_a(H).split("")), fe = Ie(X, (Me, We) => {
      const Ut = Me.toUpperCase().charCodeAt(0) - "A".charCodeAt(0) + 1;
      return Math.pow(26, We) * Ut;
    });
    return Lt(fe, (Me, We) => Me + We, 0);
  }, Fd = (H) => {
    if (H--, H < 0)
      return "";
    {
      const X = H % 26, fe = Math.floor(H / 26), Me = Fd(fe), We = String.fromCharCode("A".charCodeAt(0) + X);
      return Me + We;
    }
  }, $s = (H) => /^[A-Z]+$/.test(H), ba = (H) => /^[a-z]+$/.test(H), tl = (H) => /^[0-9]+$/.test(H), od = (H) => tl(H) ? 2 : $s(H) ? 0 : ba(H) ? 1 : Oo(H) ? 3 : 4, Ys = (H) => {
    switch (od(H)) {
      case 2:
        return me.some({
          listStyleType: me.none(),
          start: H
        });
      case 0:
        return me.some({
          listStyleType: me.some("upper-alpha"),
          start: rd(H).toString()
        });
      case 1:
        return me.some({
          listStyleType: me.some("lower-alpha"),
          start: rd(H).toString()
        });
      case 3:
        return me.some({
          listStyleType: me.none(),
          start: ""
        });
      case 4:
        return me.none();
    }
  }, zg = (H) => {
    const X = parseInt(H.start, 10);
    return cn(H.listStyleType, "upper-alpha") ? Fd(X) : cn(H.listStyleType, "lower-alpha") ? Fd(X).toLowerCase() : H.start;
  }, Yv = (H) => {
    const X = Yc(H);
    !Io(X) || Qc(H, X) || H.windowManager.open({
      title: "List Properties",
      body: {
        type: "panel",
        items: [{
          type: "input",
          name: "start",
          label: "Start list at number",
          inputMode: "numeric"
        }]
      },
      initialData: {
        start: zg({
          start: H.dom.getAttrib(X, "start", "1"),
          listStyleType: me.from(H.dom.getStyle(X, "list-style-type"))
        })
      },
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      onSubmit: (fe) => {
        const Me = fe.getData();
        Ys(Me.start).each((We) => {
          H.execCommand("mceListUpdate", !1, {
            attrs: { start: We.start === "1" ? "" : We.start },
            styles: { "list-style-type": We.listStyleType.getOr("") }
          });
        }), fe.close();
      }
    });
  }, Vo = (H, X) => () => {
    const fe = Yc(H);
    return R(fe) && fe.nodeName === X;
  }, $u = (H) => {
    H.addCommand("mceListProps", () => {
      Yv(H);
    });
  }, mo = (H) => {
    H.on("BeforeExecCommand", (X) => {
      const fe = X.command.toLowerCase();
      fe === "indent" ? Bl(H) : fe === "outdent" && Fm(H);
    }), H.addCommand("InsertUnorderedList", (X, fe) => {
      df(H, "UL", fe);
    }), H.addCommand("InsertOrderedList", (X, fe) => {
      df(H, "OL", fe);
    }), H.addCommand("InsertDefinitionList", (X, fe) => {
      df(H, "DL", fe);
    }), H.addCommand("RemoveList", () => {
      Lg(H);
    }), $u(H), H.addCommand("mceListUpdate", (X, fe) => {
      v(fe) && Aa(H, fe);
    }), H.addQueryStateHandler("InsertUnorderedList", Vo(H, "UL")), H.addQueryStateHandler("InsertOrderedList", Vo(H, "OL")), H.addQueryStateHandler("InsertDefinitionList", Vo(H, "DL"));
  };
  var zi = tinymce.util.Tools.resolve("tinymce.html.Node");
  const iu = (H) => H.type === 3, sd = (H) => H.length === 0, ye = (H) => {
    const X = (We, Ut) => {
      const Wn = zi.create("li");
      Ce(We, (xr) => Wn.append(xr)), Ut ? H.insert(Wn, Ut, !0) : H.append(Wn);
    }, fe = (We, Ut) => iu(Ut) ? [
      ...We,
      Ut
    ] : !sd(We) && !iu(Ut) ? (X(We, Ut), []) : We, Me = Lt(H.children(), fe, []);
    sd(Me) || X(Me);
  }, cu = (H) => {
    H.on("PreInit", () => {
      const { parser: X } = H;
      X.addNodeFilter("ul,ol", (fe) => Ce(fe, ye));
    });
  }, zm = (H) => {
    H.on("keydown", (X) => {
      X.keyCode !== Jf.TAB || Jf.metaKeyPressed(X) || H.undoManager.transact(() => {
        (X.shiftKey ? Fm(H) : Bl(H)) && X.preventDefault();
      });
    });
  }, pl = (H) => {
    sf(H) && zm(H), va(H);
  }, ts = (H, X) => (fe) => {
    const Me = (We) => {
      fe.setActive(bs(We.parents, X)), fe.setEnabled(!Qc(H, We.element) && H.selection.isEditable());
    };
    return fe.setEnabled(H.selection.isEditable()), ni(H, Me);
  }, Qv = (H) => {
    const X = (fe) => () => H.execCommand(fe);
    H.hasPlugin("advlist") || (H.ui.registry.addToggleButton("numlist", {
      icon: "ordered-list",
      active: !1,
      tooltip: "Numbered list",
      onAction: X("InsertOrderedList"),
      onSetup: ts(H, "OL")
    }), H.ui.registry.addToggleButton("bullist", {
      icon: "unordered-list",
      active: !1,
      tooltip: "Bullet list",
      onAction: X("InsertUnorderedList"),
      onSetup: ts(H, "UL")
    }));
  }, Uh = (H, X) => (fe) => ni(H, (We) => fe.setEnabled(bs(We.parents, X) && !Qc(H, We.element))), Vg = (H) => {
    const X = {
      text: "List properties...",
      icon: "ordered-list",
      onAction: () => H.execCommand("mceListProps"),
      onSetup: Uh(H, "OL")
    };
    H.ui.registry.addMenuItem("listprops", X), H.ui.registry.addContextMenu("lists", {
      update: (fe) => {
        const Me = Yc(H, fe);
        return Io(Me) ? ["listprops"] : [];
      }
    });
  };
  var Iu = () => {
    r.add("lists", (H) => (ku(H), cu(H), H.hasPlugin("rtc", !0) ? $u(H) : (pl(H), mo(H)), Qv(H), Vg(H), ml(H)));
  };
  Iu();
})();
(function() {
  var r = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const c = ((Ge) => (qt) => Ge === qt)(null), i = (Ge) => Ge, d = (Ge, qt) => {
    const St = Ge.length, ke = new Array(St);
    for (let Ct = 0; Ct < St; Ct++) {
      const an = Ge[Ct];
      ke[Ct] = qt(an, Ct);
    }
    return ke;
  }, v = {
    aletter: "[A-Za-z---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]",
    midnumlet: "[-'\\.]",
    midletter: "[:]",
    midnum: "[+*/,;;]",
    numeric: "[0-9---------------------------------]",
    cr: "\\r",
    lf: "\\n",
    newline: "[\v\f\u2028\u2029]",
    extend: "[------------------------------------------------------------------------------------------------------]",
    format: "[----\uFEFF-]",
    katakana: "[-------]",
    extendnumlet: "[=_--<>]",
    punctuation: "[~|!-*+-\\/:;?@\\[-`{};----------------------------------------------]"
  }, g = {
    ALETTER: 0,
    MIDNUMLET: 1,
    MIDLETTER: 2,
    MIDNUM: 3,
    NUMERIC: 4,
    CR: 5,
    LF: 6,
    NEWLINE: 7,
    EXTEND: 8,
    FORMAT: 9,
    KATAKANA: 10,
    EXTENDNUMLET: 11,
    AT: 12,
    OTHER: 13
  }, C = [
    new RegExp(v.aletter),
    new RegExp(v.midnumlet),
    new RegExp(v.midletter),
    new RegExp(v.midnum),
    new RegExp(v.numeric),
    new RegExp(v.cr),
    new RegExp(v.lf),
    new RegExp(v.newline),
    new RegExp(v.extend),
    new RegExp(v.format),
    new RegExp(v.katakana),
    new RegExp(v.extendnumlet),
    new RegExp("@")
  ], O = "", R = new RegExp("^" + v.punctuation + "$"), I = /^\s+$/, L = C, Z = g.OTHER, ne = (Ge) => {
    let qt = Z;
    const St = L.length;
    for (let ke = 0; ke < St; ++ke) {
      const Ct = L[ke];
      if (Ct && Ct.test(Ge)) {
        qt = ke;
        break;
      }
    }
    return qt;
  }, se = (Ge) => {
    const qt = {};
    return (St) => {
      if (qt[St])
        return qt[St];
      {
        const ke = Ge(St);
        return qt[St] = ke, ke;
      }
    };
  }, Q = (Ge) => {
    const qt = se(ne);
    return d(Ge, qt);
  }, he = (Ge, qt) => {
    const St = Ge[qt], ke = Ge[qt + 1];
    if (qt < 0 || qt > Ge.length - 1 && qt !== 0 || St === g.ALETTER && ke === g.ALETTER)
      return !1;
    const Ct = Ge[qt + 2];
    if (St === g.ALETTER && (ke === g.MIDLETTER || ke === g.MIDNUMLET || ke === g.AT) && Ct === g.ALETTER)
      return !1;
    const an = Ge[qt - 1];
    return (St === g.MIDLETTER || St === g.MIDNUMLET || ke === g.AT) && ke === g.ALETTER && an === g.ALETTER || (St === g.NUMERIC || St === g.ALETTER) && (ke === g.NUMERIC || ke === g.ALETTER) || (St === g.MIDNUM || St === g.MIDNUMLET) && ke === g.NUMERIC && an === g.NUMERIC || St === g.NUMERIC && (ke === g.MIDNUM || ke === g.MIDNUMLET) && Ct === g.NUMERIC || (St === g.EXTEND || St === g.FORMAT) && (ke === g.ALETTER || ke === g.NUMERIC || ke === g.KATAKANA || ke === g.EXTEND || ke === g.FORMAT) || (ke === g.EXTEND || ke === g.FORMAT && (Ct === g.ALETTER || Ct === g.NUMERIC || Ct === g.KATAKANA || Ct === g.EXTEND || Ct === g.FORMAT)) && (St === g.ALETTER || St === g.NUMERIC || St === g.KATAKANA || St === g.EXTEND || St === g.FORMAT) || St === g.CR && ke === g.LF ? !1 : St === g.NEWLINE || St === g.CR || St === g.LF || ke === g.NEWLINE || ke === g.CR || ke === g.LF ? !0 : !(St === g.KATAKANA && ke === g.KATAKANA || ke === g.EXTENDNUMLET && (St === g.ALETTER || St === g.NUMERIC || St === g.KATAKANA || St === g.EXTENDNUMLET) || St === g.EXTENDNUMLET && (ke === g.ALETTER || ke === g.NUMERIC || ke === g.KATAKANA) || St === g.AT);
  }, ue = O, G = I, me = R, we = (Ge) => Ge === "http" || Ge === "https", be = (Ge, qt) => {
    let St;
    for (St = qt; St < Ge.length && !G.test(Ge[St]); St++)
      ;
    return St;
  }, q = (Ge, qt) => {
    const St = be(Ge, qt + 1);
    return Ge.slice(qt + 1, St).join(ue).substr(0, 3) === "://" ? St : qt;
  }, Te = (Ge, qt, St, ke) => {
    const Ct = [], an = [];
    let ht = [];
    for (let bn = 0; bn < St.length; ++bn)
      if (ht.push(Ge[bn]), he(St, bn)) {
        const Ye = qt[bn];
        if ((ke.includeWhitespace || !G.test(Ye)) && (ke.includePunctuation || !me.test(Ye))) {
          const nn = bn - ht.length + 1, Bt = bn + 1, $n = qt.slice(nn, Bt).join(ue);
          if (we($n)) {
            const mr = q(qt, bn), gr = Ge.slice(Bt, mr);
            Array.prototype.push.apply(ht, gr), bn = mr;
          }
          Ct.push(ht), an.push({
            start: nn,
            end: Bt
          });
        }
        ht = [];
      }
    return {
      words: Ct,
      indices: an
    };
  }, Le = () => ({
    includeWhitespace: !1,
    includePunctuation: !1
  }), je = (Ge, qt, St) => {
    St = {
      ...Le(),
      ...St
    };
    const ke = d(Ge, qt), Ct = Q(ke);
    return Te(Ge, ke, Ct, St);
  }, Ce = (Ge, qt, St) => je(Ge, qt, St).words, pt = (Ge) => Ge.replace(/\uFEFF/g, "");
  var sn = tinymce.util.Tools.resolve("tinymce.dom.TreeWalker");
  const Lt = (Ge, qt) => {
    const St = qt.getBlockElements(), ke = qt.getVoidElements(), Ct = (nn) => St[nn.nodeName] || ke[nn.nodeName], an = [];
    let ht = "";
    const bn = new sn(Ge, Ge);
    let Ye;
    for (; Ye = bn.next(); )
      Ye.nodeType === 3 ? ht += pt(Ye.data) : Ct(Ye) && ht.length && (an.push(ht), ht = "");
    return ht.length && an.push(ht), an;
  }, z = (Ge) => Ge.replace(/\u200B/g, ""), bt = (Ge) => Ge.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "_").length, at = (Ge, qt) => {
    const St = z(Lt(Ge, qt).join(`
`));
    return Ce(St.split(""), i).length;
  }, _n = (Ge, qt) => {
    const St = Lt(Ge, qt).join("");
    return bt(St);
  }, st = (Ge, qt) => {
    const St = Lt(Ge, qt).join("").replace(/\s/g, "");
    return bt(St);
  }, Ne = (Ge, qt) => () => qt(Ge.getBody(), Ge.schema), vt = (Ge, qt) => () => qt(Ge.selection.getRng().cloneContents(), Ge.schema), Gt = (Ge) => Ne(Ge, at), xt = (Ge) => ({
    body: {
      getWordCount: Gt(Ge),
      getCharacterCount: Ne(Ge, _n),
      getCharacterCountWithoutSpaces: Ne(Ge, st)
    },
    selection: {
      getWordCount: vt(Ge, at),
      getCharacterCount: vt(Ge, _n),
      getCharacterCountWithoutSpaces: vt(Ge, st)
    },
    getCount: Gt(Ge)
  }), cn = (Ge, qt) => {
    Ge.windowManager.open({
      title: "Word Count",
      body: {
        type: "panel",
        items: [{
          type: "table",
          header: [
            "Count",
            "Document",
            "Selection"
          ],
          cells: [
            [
              "Words",
              String(qt.body.getWordCount()),
              String(qt.selection.getWordCount())
            ],
            [
              "Characters (no spaces)",
              String(qt.body.getCharacterCountWithoutSpaces()),
              String(qt.selection.getCharacterCountWithoutSpaces())
            ],
            [
              "Characters",
              String(qt.body.getCharacterCount()),
              String(qt.selection.getCharacterCount())
            ]
          ]
        }]
      },
      buttons: [{
        type: "cancel",
        name: "close",
        text: "Close",
        primary: !0
      }]
    });
  }, He = (Ge, qt) => {
    Ge.addCommand("mceWordCount", () => cn(Ge, qt));
  }, ut = (Ge, qt) => {
    let St = null;
    return {
      cancel: () => {
        c(St) || (clearTimeout(St), St = null);
      },
      throttle: (...an) => {
        c(St) && (St = setTimeout(() => {
          St = null, Ge.apply(null, an);
        }, qt));
      }
    };
  };
  var oe = tinymce.util.Tools.resolve("tinymce.util.Delay");
  const qn = (Ge, qt) => {
    Ge.dispatch("wordCountUpdate", {
      wordCount: {
        words: qt.body.getWordCount(),
        characters: qt.body.getCharacterCount(),
        charactersWithoutSpaces: qt.body.getCharacterCountWithoutSpaces()
      }
    });
  }, Rn = (Ge, qt) => {
    qn(Ge, qt);
  }, Zt = (Ge, qt, St) => {
    const ke = ut(() => Rn(Ge, qt), St);
    Ge.on("init", () => {
      Rn(Ge, qt), oe.setEditorTimeout(Ge, () => {
        Ge.on("SetContent BeforeAddUndo Undo Redo ViewUpdate keyup", ke.throttle);
      }, 0), Ge.on("remove", ke.cancel);
    });
  }, Jt = (Ge) => {
    const qt = () => Ge.execCommand("mceWordCount");
    Ge.ui.registry.addButton("wordcount", {
      tooltip: "Word count",
      icon: "character-count",
      onAction: qt
    }), Ge.ui.registry.addMenuItem("wordcount", {
      text: "Word count",
      icon: "character-count",
      onAction: qt
    });
  };
  var wo = (Ge = 300) => {
    r.add("wordcount", (qt) => {
      const St = xt(qt);
      return He(qt, St), Jt(qt), Zt(qt, St, Ge), St;
    });
  };
  wo();
})();
var Uv = {};
Object.defineProperty(Uv, "__esModule", { value: !0 });
function Wme(r, o) {
  for (var c = 0; c < o.length; c++) {
    var i = o[c];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(r, i.key, i);
  }
}
function k1(r, o, c) {
  return o && Wme(r.prototype, o), c && Wme(r, c), r;
}
function Sy(r, o) {
  r.prototype = Object.create(o.prototype), r.prototype.constructor = r, r.__proto__ = o;
}
function jse(r) {
  return jse = Object.setPrototypeOf ? Object.getPrototypeOf : function(c) {
    return c.__proto__ || Object.getPrototypeOf(c);
  }, jse(r);
}
function nj(r, o) {
  return nj = Object.setPrototypeOf || function(i, d) {
    return i.__proto__ = d, i;
  }, nj(r, o);
}
function XZe() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function CW(r, o, c) {
  return XZe() ? CW = Reflect.construct : CW = function(d, m, v) {
    var g = [null];
    g.push.apply(g, m);
    var C = Function.bind.apply(d, g), O = new C();
    return v && nj(O, v.prototype), O;
  }, CW.apply(null, arguments);
}
function JZe(r) {
  return Function.toString.call(r).indexOf("[native code]") !== -1;
}
function qse(r) {
  var o = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return qse = function(i) {
    if (i === null || !JZe(i))
      return i;
    if (typeof i != "function")
      throw new TypeError("Super expression must either be null or a function");
    if (typeof o < "u") {
      if (o.has(i))
        return o.get(i);
      o.set(i, d);
    }
    function d() {
      return CW(i, arguments, jse(this).constructor);
    }
    return d.prototype = Object.create(i.prototype, {
      constructor: {
        value: d,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), nj(d, i);
  }, qse(r);
}
function eKe(r, o) {
  if (r == null)
    return {};
  var c = {}, i = Object.keys(r), d, m;
  for (m = 0; m < i.length; m++)
    d = i[m], !(o.indexOf(d) >= 0) && (c[d] = r[d]);
  return c;
}
function tKe(r, o) {
  if (r) {
    if (typeof r == "string")
      return jme(r, o);
    var c = Object.prototype.toString.call(r).slice(8, -1);
    if (c === "Object" && r.constructor && (c = r.constructor.name), c === "Map" || c === "Set")
      return Array.from(c);
    if (c === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(c))
      return jme(r, o);
  }
}
function jme(r, o) {
  (o == null || o > r.length) && (o = r.length);
  for (var c = 0, i = new Array(o); c < o; c++)
    i[c] = r[c];
  return i;
}
function g2(r) {
  var o = 0;
  if (typeof Symbol > "u" || r[Symbol.iterator] == null) {
    if (Array.isArray(r) || (r = tKe(r)))
      return function() {
        return o >= r.length ? {
          done: !0
        } : {
          done: !1,
          value: r[o++]
        };
      };
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  return o = r[Symbol.iterator](), o.next.bind(o);
}
var Bk = /* @__PURE__ */ function(r) {
  Sy(o, r);
  function o() {
    return r.apply(this, arguments) || this;
  }
  return o;
}(/* @__PURE__ */ qse(Error)), nKe = /* @__PURE__ */ function(r) {
  Sy(o, r);
  function o(c) {
    return r.call(this, "Invalid DateTime: " + c.toMessage()) || this;
  }
  return o;
}(Bk), rKe = /* @__PURE__ */ function(r) {
  Sy(o, r);
  function o(c) {
    return r.call(this, "Invalid Interval: " + c.toMessage()) || this;
  }
  return o;
}(Bk), oKe = /* @__PURE__ */ function(r) {
  Sy(o, r);
  function o(c) {
    return r.call(this, "Invalid Duration: " + c.toMessage()) || this;
  }
  return o;
}(Bk), QL = /* @__PURE__ */ function(r) {
  Sy(o, r);
  function o() {
    return r.apply(this, arguments) || this;
  }
  return o;
}(Bk), Rye = /* @__PURE__ */ function(r) {
  Sy(o, r);
  function o(c) {
    return r.call(this, "Invalid unit " + c) || this;
  }
  return o;
}(Bk), dy = /* @__PURE__ */ function(r) {
  Sy(o, r);
  function o() {
    return r.apply(this, arguments) || this;
  }
  return o;
}(Bk), c2 = /* @__PURE__ */ function(r) {
  Sy(o, r);
  function o() {
    return r.call(this, "Zone is an abstract class") || this;
  }
  return o;
}(Bk), _r = "numeric", N1 = "short", Mv = "long", rj = {
  year: _r,
  month: _r,
  day: _r
}, zie = {
  year: _r,
  month: N1,
  day: _r
}, Pye = {
  year: _r,
  month: N1,
  day: _r,
  weekday: N1
}, Vie = {
  year: _r,
  month: Mv,
  day: _r
}, Uie = {
  year: _r,
  month: Mv,
  day: _r,
  weekday: Mv
}, Wie = {
  hour: _r,
  minute: _r
}, jie = {
  hour: _r,
  minute: _r,
  second: _r
}, qie = {
  hour: _r,
  minute: _r,
  second: _r,
  timeZoneName: N1
}, Gie = {
  hour: _r,
  minute: _r,
  second: _r,
  timeZoneName: Mv
}, Zie = {
  hour: _r,
  minute: _r,
  hour12: !1
}, Kie = {
  hour: _r,
  minute: _r,
  second: _r,
  hour12: !1
}, Yie = {
  hour: _r,
  minute: _r,
  second: _r,
  hour12: !1,
  timeZoneName: N1
}, Qie = {
  hour: _r,
  minute: _r,
  second: _r,
  hour12: !1,
  timeZoneName: Mv
}, Xie = {
  year: _r,
  month: _r,
  day: _r,
  hour: _r,
  minute: _r
}, Jie = {
  year: _r,
  month: _r,
  day: _r,
  hour: _r,
  minute: _r,
  second: _r
}, ece = {
  year: _r,
  month: N1,
  day: _r,
  hour: _r,
  minute: _r
}, tce = {
  year: _r,
  month: N1,
  day: _r,
  hour: _r,
  minute: _r,
  second: _r
}, Dye = {
  year: _r,
  month: N1,
  day: _r,
  weekday: N1,
  hour: _r,
  minute: _r
}, nce = {
  year: _r,
  month: Mv,
  day: _r,
  hour: _r,
  minute: _r,
  timeZoneName: N1
}, rce = {
  year: _r,
  month: Mv,
  day: _r,
  hour: _r,
  minute: _r,
  second: _r,
  timeZoneName: N1
}, oce = {
  year: _r,
  month: Mv,
  day: _r,
  weekday: Mv,
  hour: _r,
  minute: _r,
  timeZoneName: Mv
}, sce = {
  year: _r,
  month: Mv,
  day: _r,
  weekday: Mv,
  hour: _r,
  minute: _r,
  second: _r,
  timeZoneName: Mv
};
function Ka(r) {
  return typeof r > "u";
}
function xk(r) {
  return typeof r == "number";
}
function mq(r) {
  return typeof r == "number" && r % 1 === 0;
}
function sKe(r) {
  return typeof r == "string";
}
function aKe(r) {
  return Object.prototype.toString.call(r) === "[object Date]";
}
function QS() {
  try {
    return typeof Intl < "u" && Intl.DateTimeFormat;
  } catch {
    return !1;
  }
}
function r5() {
  return !Ka(Intl.DateTimeFormat.prototype.formatToParts);
}
function $ye() {
  try {
    return typeof Intl < "u" && !!Intl.RelativeTimeFormat;
  } catch {
    return !1;
  }
}
function iKe(r) {
  return Array.isArray(r) ? r : [r];
}
function qme(r, o, c) {
  if (r.length !== 0)
    return r.reduce(function(i, d) {
      var m = [o(d), d];
      return i && c(i[0], m[0]) === i[0] ? i : m;
    }, null)[1];
}
function Iye(r, o) {
  return o.reduce(function(c, i) {
    return c[i] = r[i], c;
  }, {});
}
function j$(r, o) {
  return Object.prototype.hasOwnProperty.call(r, o);
}
function aC(r, o, c) {
  return mq(r) && r >= o && r <= c;
}
function cKe(r, o) {
  return r - o * Math.floor(r / o);
}
function VD(r, o) {
  o === void 0 && (o = 2);
  var c = r < 0 ? "-" : "", i = c ? r * -1 : r, d;
  return i.toString().length < o ? d = ("0".repeat(o) + i).slice(-o) : d = i.toString(), "" + c + d;
}
function Th(r) {
  if (!(Ka(r) || r === null || r === ""))
    return parseInt(r, 10);
}
function ace(r) {
  if (!(Ka(r) || r === null || r === "")) {
    var o = parseFloat("0." + r) * 1e3;
    return Math.floor(o);
  }
}
function ice(r, o, c) {
  c === void 0 && (c = !1);
  var i = Math.pow(10, o), d = c ? Math.trunc : Math.round;
  return d(r * i) / i;
}
function o5(r) {
  return r % 4 === 0 && (r % 100 !== 0 || r % 400 === 0);
}
function uB(r) {
  return o5(r) ? 366 : 365;
}
function oj(r, o) {
  var c = cKe(o - 1, 12) + 1, i = r + (o - c) / 12;
  return c === 2 ? o5(i) ? 29 : 28 : [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][c - 1];
}
function cce(r) {
  var o = Date.UTC(r.year, r.month - 1, r.day, r.hour, r.minute, r.second, r.millisecond);
  return r.year < 100 && r.year >= 0 && (o = new Date(o), o.setUTCFullYear(o.getUTCFullYear() - 1900)), +o;
}
function sj(r) {
  var o = (r + Math.floor(r / 4) - Math.floor(r / 100) + Math.floor(r / 400)) % 7, c = r - 1, i = (c + Math.floor(c / 4) - Math.floor(c / 100) + Math.floor(c / 400)) % 7;
  return o === 4 || i === 3 ? 53 : 52;
}
function Gse(r) {
  return r > 99 ? r : r > 60 ? 1900 + r : 2e3 + r;
}
function Mye(r, o, c, i) {
  i === void 0 && (i = null);
  var d = new Date(r), m = {
    hour12: !1,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  i && (m.timeZone = i);
  var v = Object.assign({
    timeZoneName: o
  }, m), g = QS();
  if (g && r5()) {
    var C = new Intl.DateTimeFormat(c, v).formatToParts(d).find(function(Z) {
      return Z.type.toLowerCase() === "timezonename";
    });
    return C ? C.value : null;
  } else if (g) {
    var O = new Intl.DateTimeFormat(c, m).format(d), R = new Intl.DateTimeFormat(c, v).format(d), I = R.substring(O.length), L = I.replace(/^[, \u200e]+/, "");
    return L;
  } else
    return null;
}
function pq(r, o) {
  var c = parseInt(r, 10);
  Number.isNaN(c) && (c = 0);
  var i = parseInt(o, 10) || 0, d = c < 0 || Object.is(c, -0) ? -i : i;
  return c * 60 + d;
}
function Fye(r) {
  var o = Number(r);
  if (typeof r == "boolean" || r === "" || Number.isNaN(o))
    throw new dy("Invalid unit value " + r);
  return o;
}
function aj(r, o, c) {
  var i = {};
  for (var d in r)
    if (j$(r, d)) {
      if (c.indexOf(d) >= 0)
        continue;
      var m = r[d];
      if (m == null)
        continue;
      i[o(d)] = Fye(m);
    }
  return i;
}
function ij(r, o) {
  var c = Math.trunc(Math.abs(r / 60)), i = Math.trunc(Math.abs(r % 60)), d = r >= 0 ? "+" : "-";
  switch (o) {
    case "short":
      return "" + d + VD(c, 2) + ":" + VD(i, 2);
    case "narrow":
      return "" + d + c + (i > 0 ? ":" + i : "");
    case "techie":
      return "" + d + VD(c, 2) + VD(i, 2);
    default:
      throw new RangeError("Value format " + o + " is out of range for property format");
  }
}
function hq(r) {
  return Iye(r, ["hour", "minute", "second", "millisecond"]);
}
var Lye = /[A-Za-z_+-]{1,256}(:?\/[A-Za-z_+-]{1,256}(\/[A-Za-z_+-]{1,256})?)?/;
function Yl(r) {
  return JSON.stringify(r, Object.keys(r).sort());
}
var lKe = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], Bye = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], uKe = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function Hye(r) {
  switch (r) {
    case "narrow":
      return [].concat(uKe);
    case "short":
      return [].concat(Bye);
    case "long":
      return [].concat(lKe);
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
var zye = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"], Vye = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"], dKe = ["M", "T", "W", "T", "F", "S", "S"];
function Uye(r) {
  switch (r) {
    case "narrow":
      return [].concat(dKe);
    case "short":
      return [].concat(Vye);
    case "long":
      return [].concat(zye);
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
var Wye = ["AM", "PM"], fKe = ["Before Christ", "Anno Domini"], mKe = ["BC", "AD"], pKe = ["B", "A"];
function jye(r) {
  switch (r) {
    case "narrow":
      return [].concat(pKe);
    case "short":
      return [].concat(mKe);
    case "long":
      return [].concat(fKe);
    default:
      return null;
  }
}
function hKe(r) {
  return Wye[r.hour < 12 ? 0 : 1];
}
function gKe(r, o) {
  return Uye(o)[r.weekday - 1];
}
function vKe(r, o) {
  return Hye(o)[r.month - 1];
}
function bKe(r, o) {
  return jye(o)[r.year < 0 ? 0 : 1];
}
function yKe(r, o, c, i) {
  c === void 0 && (c = "always"), i === void 0 && (i = !1);
  var d = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  }, m = ["hours", "minutes", "seconds"].indexOf(r) === -1;
  if (c === "auto" && m) {
    var v = r === "days";
    switch (o) {
      case 1:
        return v ? "tomorrow" : "next " + d[r][0];
      case -1:
        return v ? "yesterday" : "last " + d[r][0];
      case 0:
        return v ? "today" : "this " + d[r][0];
    }
  }
  var g = Object.is(o, -0) || o < 0, C = Math.abs(o), O = C === 1, R = d[r], I = i ? O ? R[1] : R[2] || R[1] : O ? d[r][0] : r;
  return g ? C + " " + I + " ago" : "in " + C + " " + I;
}
function SKe(r) {
  var o = Iye(r, ["weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName", "hour12"]), c = Yl(o), i = "EEEE, LLLL d, yyyy, h:mm a";
  switch (c) {
    case Yl(rj):
      return "M/d/yyyy";
    case Yl(zie):
      return "LLL d, yyyy";
    case Yl(Pye):
      return "EEE, LLL d, yyyy";
    case Yl(Vie):
      return "LLLL d, yyyy";
    case Yl(Uie):
      return "EEEE, LLLL d, yyyy";
    case Yl(Wie):
      return "h:mm a";
    case Yl(jie):
      return "h:mm:ss a";
    case Yl(qie):
      return "h:mm a";
    case Yl(Gie):
      return "h:mm a";
    case Yl(Zie):
      return "HH:mm";
    case Yl(Kie):
      return "HH:mm:ss";
    case Yl(Yie):
      return "HH:mm";
    case Yl(Qie):
      return "HH:mm";
    case Yl(Xie):
      return "M/d/yyyy, h:mm a";
    case Yl(ece):
      return "LLL d, yyyy, h:mm a";
    case Yl(nce):
      return "LLLL d, yyyy, h:mm a";
    case Yl(oce):
      return i;
    case Yl(Jie):
      return "M/d/yyyy, h:mm:ss a";
    case Yl(tce):
      return "LLL d, yyyy, h:mm:ss a";
    case Yl(Dye):
      return "EEE, d LLL yyyy, h:mm a";
    case Yl(rce):
      return "LLLL d, yyyy, h:mm:ss a";
    case Yl(sce):
      return "EEEE, LLLL d, yyyy, h:mm:ss a";
    default:
      return i;
  }
}
function Gme(r, o) {
  for (var c = "", i = g2(r), d; !(d = i()).done; ) {
    var m = d.value;
    m.literal ? c += m.val : c += o(m.val);
  }
  return c;
}
var wKe = {
  D: rj,
  DD: zie,
  DDD: Vie,
  DDDD: Uie,
  t: Wie,
  tt: jie,
  ttt: qie,
  tttt: Gie,
  T: Zie,
  TT: Kie,
  TTT: Yie,
  TTTT: Qie,
  f: Xie,
  ff: ece,
  fff: nce,
  ffff: oce,
  F: Jie,
  FF: tce,
  FFF: rce,
  FFFF: sce
}, IS = /* @__PURE__ */ function() {
  r.create = function(i, d) {
    return d === void 0 && (d = {}), new r(i, d);
  }, r.parseFormat = function(i) {
    for (var d = null, m = "", v = !1, g = [], C = 0; C < i.length; C++) {
      var O = i.charAt(C);
      O === "'" ? (m.length > 0 && g.push({
        literal: v,
        val: m
      }), d = null, m = "", v = !v) : v || O === d ? m += O : (m.length > 0 && g.push({
        literal: !1,
        val: m
      }), m = O, d = O);
    }
    return m.length > 0 && g.push({
      literal: v,
      val: m
    }), g;
  }, r.macroTokenToFormatOpts = function(i) {
    return wKe[i];
  };
  function r(c, i) {
    this.opts = i, this.loc = c, this.systemLoc = null;
  }
  var o = r.prototype;
  return o.formatWithSystemDefault = function(i, d) {
    this.systemLoc === null && (this.systemLoc = this.loc.redefaultToSystem());
    var m = this.systemLoc.dtFormatter(i, Object.assign({}, this.opts, d));
    return m.format();
  }, o.formatDateTime = function(i, d) {
    d === void 0 && (d = {});
    var m = this.loc.dtFormatter(i, Object.assign({}, this.opts, d));
    return m.format();
  }, o.formatDateTimeParts = function(i, d) {
    d === void 0 && (d = {});
    var m = this.loc.dtFormatter(i, Object.assign({}, this.opts, d));
    return m.formatToParts();
  }, o.resolvedOptions = function(i, d) {
    d === void 0 && (d = {});
    var m = this.loc.dtFormatter(i, Object.assign({}, this.opts, d));
    return m.resolvedOptions();
  }, o.num = function(i, d) {
    if (d === void 0 && (d = 0), this.opts.forceSimple)
      return VD(i, d);
    var m = Object.assign({}, this.opts);
    return d > 0 && (m.padTo = d), this.loc.numberFormatter(m).format(i);
  }, o.formatDateTimeFromString = function(i, d) {
    var m = this, v = this.loc.listingMode() === "en", g = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory" && r5(), C = function(he, ue) {
      return m.loc.extract(i, he, ue);
    }, O = function(he) {
      return i.isOffsetFixed && i.offset === 0 && he.allowZ ? "Z" : i.isValid ? i.zone.formatOffset(i.ts, he.format) : "";
    }, R = function() {
      return v ? hKe(i) : C({
        hour: "numeric",
        hour12: !0
      }, "dayperiod");
    }, I = function(he, ue) {
      return v ? vKe(i, he) : C(ue ? {
        month: he
      } : {
        month: he,
        day: "numeric"
      }, "month");
    }, L = function(he, ue) {
      return v ? gKe(i, he) : C(ue ? {
        weekday: he
      } : {
        weekday: he,
        month: "long",
        day: "numeric"
      }, "weekday");
    }, Z = function(he) {
      var ue = r.macroTokenToFormatOpts(he);
      return ue ? m.formatWithSystemDefault(i, ue) : he;
    }, ne = function(he) {
      return v ? bKe(i, he) : C({
        era: he
      }, "era");
    }, se = function(he) {
      switch (he) {
        case "S":
          return m.num(i.millisecond);
        case "u":
        case "SSS":
          return m.num(i.millisecond, 3);
        case "s":
          return m.num(i.second);
        case "ss":
          return m.num(i.second, 2);
        case "m":
          return m.num(i.minute);
        case "mm":
          return m.num(i.minute, 2);
        case "h":
          return m.num(i.hour % 12 === 0 ? 12 : i.hour % 12);
        case "hh":
          return m.num(i.hour % 12 === 0 ? 12 : i.hour % 12, 2);
        case "H":
          return m.num(i.hour);
        case "HH":
          return m.num(i.hour, 2);
        case "Z":
          return O({
            format: "narrow",
            allowZ: m.opts.allowZ
          });
        case "ZZ":
          return O({
            format: "short",
            allowZ: m.opts.allowZ
          });
        case "ZZZ":
          return O({
            format: "techie",
            allowZ: m.opts.allowZ
          });
        case "ZZZZ":
          return i.zone.offsetName(i.ts, {
            format: "short",
            locale: m.loc.locale
          });
        case "ZZZZZ":
          return i.zone.offsetName(i.ts, {
            format: "long",
            locale: m.loc.locale
          });
        case "z":
          return i.zoneName;
        case "a":
          return R();
        case "d":
          return g ? C({
            day: "numeric"
          }, "day") : m.num(i.day);
        case "dd":
          return g ? C({
            day: "2-digit"
          }, "day") : m.num(i.day, 2);
        case "c":
          return m.num(i.weekday);
        case "ccc":
          return L("short", !0);
        case "cccc":
          return L("long", !0);
        case "ccccc":
          return L("narrow", !0);
        case "E":
          return m.num(i.weekday);
        case "EEE":
          return L("short", !1);
        case "EEEE":
          return L("long", !1);
        case "EEEEE":
          return L("narrow", !1);
        case "L":
          return g ? C({
            month: "numeric",
            day: "numeric"
          }, "month") : m.num(i.month);
        case "LL":
          return g ? C({
            month: "2-digit",
            day: "numeric"
          }, "month") : m.num(i.month, 2);
        case "LLL":
          return I("short", !0);
        case "LLLL":
          return I("long", !0);
        case "LLLLL":
          return I("narrow", !0);
        case "M":
          return g ? C({
            month: "numeric"
          }, "month") : m.num(i.month);
        case "MM":
          return g ? C({
            month: "2-digit"
          }, "month") : m.num(i.month, 2);
        case "MMM":
          return I("short", !1);
        case "MMMM":
          return I("long", !1);
        case "MMMMM":
          return I("narrow", !1);
        case "y":
          return g ? C({
            year: "numeric"
          }, "year") : m.num(i.year);
        case "yy":
          return g ? C({
            year: "2-digit"
          }, "year") : m.num(i.year.toString().slice(-2), 2);
        case "yyyy":
          return g ? C({
            year: "numeric"
          }, "year") : m.num(i.year, 4);
        case "yyyyyy":
          return g ? C({
            year: "numeric"
          }, "year") : m.num(i.year, 6);
        case "G":
          return ne("short");
        case "GG":
          return ne("long");
        case "GGGGG":
          return ne("narrow");
        case "kk":
          return m.num(i.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return m.num(i.weekYear, 4);
        case "W":
          return m.num(i.weekNumber);
        case "WW":
          return m.num(i.weekNumber, 2);
        case "o":
          return m.num(i.ordinal);
        case "ooo":
          return m.num(i.ordinal, 3);
        case "q":
          return m.num(i.quarter);
        case "qq":
          return m.num(i.quarter, 2);
        case "X":
          return m.num(Math.floor(i.ts / 1e3));
        case "x":
          return m.num(i.ts);
        default:
          return Z(he);
      }
    };
    return Gme(r.parseFormat(d), se);
  }, o.formatDurationFromString = function(i, d) {
    var m = this, v = function(L) {
      switch (L[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, g = function(L) {
      return function(Z) {
        var ne = v(Z);
        return ne ? m.num(L.get(ne), Z.length) : Z;
      };
    }, C = r.parseFormat(d), O = C.reduce(function(I, L) {
      var Z = L.literal, ne = L.val;
      return Z ? I : I.concat(ne);
    }, []), R = i.shiftTo.apply(i, O.map(v).filter(function(I) {
      return I;
    }));
    return Gme(C, g(R));
  }, r;
}(), w1 = /* @__PURE__ */ function() {
  function r(c, i) {
    this.reason = c, this.explanation = i;
  }
  var o = r.prototype;
  return o.toMessage = function() {
    return this.explanation ? this.reason + ": " + this.explanation : this.reason;
  }, r;
}(), fI = /* @__PURE__ */ function() {
  function r() {
  }
  var o = r.prototype;
  return o.offsetName = function(i, d) {
    throw new c2();
  }, o.formatOffset = function(i, d) {
    throw new c2();
  }, o.offset = function(i) {
    throw new c2();
  }, o.equals = function(i) {
    throw new c2();
  }, k1(r, [{
    key: "type",
    /**
     * The type of zone
     * @abstract
     * @type {string}
     */
    get: function() {
      throw new c2();
    }
    /**
     * The name of this zone.
     * @abstract
     * @type {string}
     */
  }, {
    key: "name",
    get: function() {
      throw new c2();
    }
    /**
     * Returns whether the offset is known to be fixed for the whole year.
     * @abstract
     * @type {boolean}
     */
  }, {
    key: "universal",
    get: function() {
      throw new c2();
    }
  }, {
    key: "isValid",
    get: function() {
      throw new c2();
    }
  }]), r;
}(), qoe = null, qye = /* @__PURE__ */ function(r) {
  Sy(o, r);
  function o() {
    return r.apply(this, arguments) || this;
  }
  var c = o.prototype;
  return c.offsetName = function(d, m) {
    var v = m.format, g = m.locale;
    return Mye(d, v, g);
  }, c.formatOffset = function(d, m) {
    return ij(this.offset(d), m);
  }, c.offset = function(d) {
    return -new Date(d).getTimezoneOffset();
  }, c.equals = function(d) {
    return d.type === "local";
  }, k1(o, [{
    key: "type",
    /** @override **/
    get: function() {
      return "local";
    }
    /** @override **/
  }, {
    key: "name",
    get: function() {
      return QS() ? new Intl.DateTimeFormat().resolvedOptions().timeZone : "local";
    }
    /** @override **/
  }, {
    key: "universal",
    get: function() {
      return !1;
    }
  }, {
    key: "isValid",
    get: function() {
      return !0;
    }
  }], [{
    key: "instance",
    /**
     * Get a singleton instance of the local zone
     * @return {LocalZone}
     */
    get: function() {
      return qoe === null && (qoe = new o()), qoe;
    }
  }]), o;
}(fI), EKe = RegExp("^" + Lye.source + "$"), xW = {};
function CKe(r) {
  return xW[r] || (xW[r] = new Intl.DateTimeFormat("en-US", {
    hour12: !1,
    timeZone: r,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit"
  })), xW[r];
}
var xKe = {
  year: 0,
  month: 1,
  day: 2,
  hour: 3,
  minute: 4,
  second: 5
};
function TKe(r, o) {
  var c = r.format(o).replace(/\u200E/g, ""), i = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(c), d = i[1], m = i[2], v = i[3], g = i[4], C = i[5], O = i[6];
  return [v, d, m, g, C, O];
}
function _Ke(r, o) {
  for (var c = r.formatToParts(o), i = [], d = 0; d < c.length; d++) {
    var m = c[d], v = m.type, g = m.value, C = xKe[v];
    Ka(C) || (i[C] = parseInt(g, 10));
  }
  return i;
}
var sW = {}, LS = /* @__PURE__ */ function(r) {
  Sy(o, r), o.create = function(d) {
    return sW[d] || (sW[d] = new o(d)), sW[d];
  }, o.resetCache = function() {
    sW = {}, xW = {};
  }, o.isValidSpecifier = function(d) {
    return !!(d && d.match(EKe));
  }, o.isValidZone = function(d) {
    try {
      return new Intl.DateTimeFormat("en-US", {
        timeZone: d
      }).format(), !0;
    } catch {
      return !1;
    }
  }, o.parseGMTOffset = function(d) {
    if (d) {
      var m = d.match(/^Etc\/GMT(0|[+-]\d{1,2})$/i);
      if (m)
        return -60 * parseInt(m[1]);
    }
    return null;
  };
  function o(i) {
    var d;
    return d = r.call(this) || this, d.zoneName = i, d.valid = o.isValidZone(i), d;
  }
  var c = o.prototype;
  return c.offsetName = function(d, m) {
    var v = m.format, g = m.locale;
    return Mye(d, v, g, this.name);
  }, c.formatOffset = function(d, m) {
    return ij(this.offset(d), m);
  }, c.offset = function(d) {
    var m = new Date(d);
    if (isNaN(m))
      return NaN;
    var v = CKe(this.name), g = v.formatToParts ? _Ke(v, m) : TKe(v, m), C = g[0], O = g[1], R = g[2], I = g[3], L = g[4], Z = g[5], ne = I === 24 ? 0 : I, se = cce({
      year: C,
      month: O,
      day: R,
      hour: ne,
      minute: L,
      second: Z,
      millisecond: 0
    }), Q = +m, he = Q % 1e3;
    return Q -= he >= 0 ? he : 1e3 + he, (se - Q) / (60 * 1e3);
  }, c.equals = function(d) {
    return d.type === "iana" && d.name === this.name;
  }, k1(o, [{
    key: "type",
    get: function() {
      return "iana";
    }
    /** @override **/
  }, {
    key: "name",
    get: function() {
      return this.zoneName;
    }
    /** @override **/
  }, {
    key: "universal",
    get: function() {
      return !1;
    }
  }, {
    key: "isValid",
    get: function() {
      return this.valid;
    }
  }]), o;
}(fI), Goe = null, Dv = /* @__PURE__ */ function(r) {
  Sy(o, r), o.instance = function(d) {
    return d === 0 ? o.utcInstance : new o(d);
  }, o.parseSpecifier = function(d) {
    if (d) {
      var m = d.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (m)
        return new o(pq(m[1], m[2]));
    }
    return null;
  }, k1(o, null, [{
    key: "utcInstance",
    /**
     * Get a singleton instance of UTC
     * @return {FixedOffsetZone}
     */
    get: function() {
      return Goe === null && (Goe = new o(0)), Goe;
    }
  }]);
  function o(i) {
    var d;
    return d = r.call(this) || this, d.fixed = i, d;
  }
  var c = o.prototype;
  return c.offsetName = function() {
    return this.name;
  }, c.formatOffset = function(d, m) {
    return ij(this.fixed, m);
  }, c.offset = function() {
    return this.fixed;
  }, c.equals = function(d) {
    return d.type === "fixed" && d.fixed === this.fixed;
  }, k1(o, [{
    key: "type",
    get: function() {
      return "fixed";
    }
    /** @override **/
  }, {
    key: "name",
    get: function() {
      return this.fixed === 0 ? "UTC" : "UTC" + ij(this.fixed, "narrow");
    }
  }, {
    key: "universal",
    get: function() {
      return !0;
    }
  }, {
    key: "isValid",
    get: function() {
      return !0;
    }
  }]), o;
}(fI), Zse = /* @__PURE__ */ function(r) {
  Sy(o, r);
  function o(i) {
    var d;
    return d = r.call(this) || this, d.zoneName = i, d;
  }
  var c = o.prototype;
  return c.offsetName = function() {
    return null;
  }, c.formatOffset = function() {
    return "";
  }, c.offset = function() {
    return NaN;
  }, c.equals = function() {
    return !1;
  }, k1(o, [{
    key: "type",
    get: function() {
      return "invalid";
    }
    /** @override **/
  }, {
    key: "name",
    get: function() {
      return this.zoneName;
    }
    /** @override **/
  }, {
    key: "universal",
    get: function() {
      return !1;
    }
  }, {
    key: "isValid",
    get: function() {
      return !1;
    }
  }]), o;
}(fI);
function FA(r, o) {
  var c;
  if (Ka(r) || r === null)
    return o;
  if (r instanceof fI)
    return r;
  if (sKe(r)) {
    var i = r.toLowerCase();
    return i === "local" ? o : i === "utc" || i === "gmt" ? Dv.utcInstance : (c = LS.parseGMTOffset(r)) != null ? Dv.instance(c) : LS.isValidSpecifier(i) ? LS.create(r) : Dv.parseSpecifier(i) || new Zse(r);
  } else
    return xk(r) ? Dv.instance(r) : typeof r == "object" && r.offset && typeof r.offset == "number" ? r : new Zse(r);
}
var Zme = function() {
  return Date.now();
}, Zoe = null, Kme = null, Yme = null, Qme = null, Xme = !1, Zu = /* @__PURE__ */ function() {
  function r() {
  }
  return r.resetCaches = function() {
    Zf.resetCache(), LS.resetCache();
  }, k1(r, null, [{
    key: "now",
    /**
     * Get the callback for returning the current timestamp.
     * @type {function}
     */
    get: function() {
      return Zme;
    },
    set: function(c) {
      Zme = c;
    }
    /**
     * Get the default time zone to create DateTimes in.
     * @type {string}
     */
  }, {
    key: "defaultZoneName",
    get: function() {
      return r.defaultZone.name;
    },
    set: function(c) {
      c ? Zoe = FA(c) : Zoe = null;
    }
    /**
     * Get the default time zone object to create DateTimes in. Does not affect existing instances.
     * @type {Zone}
     */
  }, {
    key: "defaultZone",
    get: function() {
      return Zoe || qye.instance;
    }
    /**
     * Get the default locale to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
  }, {
    key: "defaultLocale",
    get: function() {
      return Kme;
    },
    set: function(c) {
      Kme = c;
    }
    /**
     * Get the default numbering system to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
  }, {
    key: "defaultNumberingSystem",
    get: function() {
      return Yme;
    },
    set: function(c) {
      Yme = c;
    }
    /**
     * Get the default output calendar to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
  }, {
    key: "defaultOutputCalendar",
    get: function() {
      return Qme;
    },
    set: function(c) {
      Qme = c;
    }
    /**
     * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
     * @type {boolean}
     */
  }, {
    key: "throwOnInvalid",
    get: function() {
      return Xme;
    },
    set: function(c) {
      Xme = c;
    }
  }]), r;
}(), Kse = {};
function Yse(r, o) {
  o === void 0 && (o = {});
  var c = JSON.stringify([r, o]), i = Kse[c];
  return i || (i = new Intl.DateTimeFormat(r, o), Kse[c] = i), i;
}
var Qse = {};
function OKe(r, o) {
  o === void 0 && (o = {});
  var c = JSON.stringify([r, o]), i = Qse[c];
  return i || (i = new Intl.NumberFormat(r, o), Qse[c] = i), i;
}
var Xse = {};
function AKe(r, o) {
  o === void 0 && (o = {});
  var c = o;
  c.base;
  var i = eKe(c, ["base"]), d = JSON.stringify([r, i]), m = Xse[d];
  return m || (m = new Intl.RelativeTimeFormat(r, o), Xse[d] = m), m;
}
var $A = null;
function kKe() {
  if ($A)
    return $A;
  if (QS()) {
    var r = new Intl.DateTimeFormat().resolvedOptions().locale;
    return $A = !r || r === "und" ? "en-US" : r, $A;
  } else
    return $A = "en-US", $A;
}
function NKe(r) {
  var o = r.indexOf("-u-");
  if (o === -1)
    return [r];
  var c, i = r.substring(0, o);
  try {
    c = Yse(r).resolvedOptions();
  } catch {
    c = Yse(i).resolvedOptions();
  }
  var d = c, m = d.numberingSystem, v = d.calendar;
  return [i, m, v];
}
function RKe(r, o, c) {
  return QS() ? ((c || o) && (r += "-u", c && (r += "-ca-" + c), o && (r += "-nu-" + o)), r) : [];
}
function PKe(r) {
  for (var o = [], c = 1; c <= 12; c++) {
    var i = Ad.utc(2016, c, 1);
    o.push(r(i));
  }
  return o;
}
function DKe(r) {
  for (var o = [], c = 1; c <= 7; c++) {
    var i = Ad.utc(2016, 11, 13 + c);
    o.push(r(i));
  }
  return o;
}
function aW(r, o, c, i, d) {
  var m = r.listingMode(c);
  return m === "error" ? null : m === "en" ? i(o) : d(o);
}
function $Ke(r) {
  return r.numberingSystem && r.numberingSystem !== "latn" ? !1 : r.numberingSystem === "latn" || !r.locale || r.locale.startsWith("en") || QS() && new Intl.DateTimeFormat(r.intl).resolvedOptions().numberingSystem === "latn";
}
var IKe = /* @__PURE__ */ function() {
  function r(c, i, d) {
    if (this.padTo = d.padTo || 0, this.floor = d.floor || !1, !i && QS()) {
      var m = {
        useGrouping: !1
      };
      d.padTo > 0 && (m.minimumIntegerDigits = d.padTo), this.inf = OKe(c, m);
    }
  }
  var o = r.prototype;
  return o.format = function(i) {
    if (this.inf) {
      var d = this.floor ? Math.floor(i) : i;
      return this.inf.format(d);
    } else {
      var m = this.floor ? Math.floor(i) : ice(i, 3);
      return VD(m, this.padTo);
    }
  }, r;
}(), MKe = /* @__PURE__ */ function() {
  function r(c, i, d) {
    this.opts = d, this.hasIntl = QS();
    var m;
    if (c.zone.universal && this.hasIntl) {
      var v = -1 * (c.offset / 60), g = v >= 0 ? "Etc/GMT+" + v : "Etc/GMT" + v, C = LS.isValidZone(g);
      c.offset !== 0 && C ? (m = g, this.dt = c) : (m = "UTC", d.timeZoneName ? this.dt = c : this.dt = c.offset === 0 ? c : Ad.fromMillis(c.ts + c.offset * 60 * 1e3));
    } else
      c.zone.type === "local" ? this.dt = c : (this.dt = c, m = c.zone.name);
    if (this.hasIntl) {
      var O = Object.assign({}, this.opts);
      m && (O.timeZone = m), this.dtf = Yse(i, O);
    }
  }
  var o = r.prototype;
  return o.format = function() {
    if (this.hasIntl)
      return this.dtf.format(this.dt.toJSDate());
    var i = SKe(this.opts), d = Zf.create("en-US");
    return IS.create(d).formatDateTimeFromString(this.dt, i);
  }, o.formatToParts = function() {
    return this.hasIntl && r5() ? this.dtf.formatToParts(this.dt.toJSDate()) : [];
  }, o.resolvedOptions = function() {
    return this.hasIntl ? this.dtf.resolvedOptions() : {
      locale: "en-US",
      numberingSystem: "latn",
      outputCalendar: "gregory"
    };
  }, r;
}(), FKe = /* @__PURE__ */ function() {
  function r(c, i, d) {
    this.opts = Object.assign({
      style: "long"
    }, d), !i && $ye() && (this.rtf = AKe(c, d));
  }
  var o = r.prototype;
  return o.format = function(i, d) {
    return this.rtf ? this.rtf.format(i, d) : yKe(d, i, this.opts.numeric, this.opts.style !== "long");
  }, o.formatToParts = function(i, d) {
    return this.rtf ? this.rtf.formatToParts(i, d) : [];
  }, r;
}(), Zf = /* @__PURE__ */ function() {
  r.fromOpts = function(i) {
    return r.create(i.locale, i.numberingSystem, i.outputCalendar, i.defaultToEN);
  }, r.create = function(i, d, m, v) {
    v === void 0 && (v = !1);
    var g = i || Zu.defaultLocale, C = g || (v ? "en-US" : kKe()), O = d || Zu.defaultNumberingSystem, R = m || Zu.defaultOutputCalendar;
    return new r(C, O, R, g);
  }, r.resetCache = function() {
    $A = null, Kse = {}, Qse = {}, Xse = {};
  }, r.fromObject = function(i) {
    var d = i === void 0 ? {} : i, m = d.locale, v = d.numberingSystem, g = d.outputCalendar;
    return r.create(m, v, g);
  };
  function r(c, i, d, m) {
    var v = NKe(c), g = v[0], C = v[1], O = v[2];
    this.locale = g, this.numberingSystem = i || C || null, this.outputCalendar = d || O || null, this.intl = RKe(this.locale, this.numberingSystem, this.outputCalendar), this.weekdaysCache = {
      format: {},
      standalone: {}
    }, this.monthsCache = {
      format: {},
      standalone: {}
    }, this.meridiemCache = null, this.eraCache = {}, this.specifiedLocale = m, this.fastNumbersCached = null;
  }
  var o = r.prototype;
  return o.listingMode = function(i) {
    i === void 0 && (i = !0);
    var d = QS(), m = d && r5(), v = this.isEnglish(), g = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return !m && !(v && g) && !i ? "error" : !m || v && g ? "en" : "intl";
  }, o.clone = function(i) {
    return !i || Object.getOwnPropertyNames(i).length === 0 ? this : r.create(i.locale || this.specifiedLocale, i.numberingSystem || this.numberingSystem, i.outputCalendar || this.outputCalendar, i.defaultToEN || !1);
  }, o.redefaultToEN = function(i) {
    return i === void 0 && (i = {}), this.clone(Object.assign({}, i, {
      defaultToEN: !0
    }));
  }, o.redefaultToSystem = function(i) {
    return i === void 0 && (i = {}), this.clone(Object.assign({}, i, {
      defaultToEN: !1
    }));
  }, o.months = function(i, d, m) {
    var v = this;
    return d === void 0 && (d = !1), m === void 0 && (m = !0), aW(this, i, m, Hye, function() {
      var g = d ? {
        month: i,
        day: "numeric"
      } : {
        month: i
      }, C = d ? "format" : "standalone";
      return v.monthsCache[C][i] || (v.monthsCache[C][i] = PKe(function(O) {
        return v.extract(O, g, "month");
      })), v.monthsCache[C][i];
    });
  }, o.weekdays = function(i, d, m) {
    var v = this;
    return d === void 0 && (d = !1), m === void 0 && (m = !0), aW(this, i, m, Uye, function() {
      var g = d ? {
        weekday: i,
        year: "numeric",
        month: "long",
        day: "numeric"
      } : {
        weekday: i
      }, C = d ? "format" : "standalone";
      return v.weekdaysCache[C][i] || (v.weekdaysCache[C][i] = DKe(function(O) {
        return v.extract(O, g, "weekday");
      })), v.weekdaysCache[C][i];
    });
  }, o.meridiems = function(i) {
    var d = this;
    return i === void 0 && (i = !0), aW(this, void 0, i, function() {
      return Wye;
    }, function() {
      if (!d.meridiemCache) {
        var m = {
          hour: "numeric",
          hour12: !0
        };
        d.meridiemCache = [Ad.utc(2016, 11, 13, 9), Ad.utc(2016, 11, 13, 19)].map(function(v) {
          return d.extract(v, m, "dayperiod");
        });
      }
      return d.meridiemCache;
    });
  }, o.eras = function(i, d) {
    var m = this;
    return d === void 0 && (d = !0), aW(this, i, d, jye, function() {
      var v = {
        era: i
      };
      return m.eraCache[i] || (m.eraCache[i] = [Ad.utc(-40, 1, 1), Ad.utc(2017, 1, 1)].map(function(g) {
        return m.extract(g, v, "era");
      })), m.eraCache[i];
    });
  }, o.extract = function(i, d, m) {
    var v = this.dtFormatter(i, d), g = v.formatToParts(), C = g.find(function(O) {
      return O.type.toLowerCase() === m;
    });
    return C ? C.value : null;
  }, o.numberFormatter = function(i) {
    return i === void 0 && (i = {}), new IKe(this.intl, i.forceSimple || this.fastNumbers, i);
  }, o.dtFormatter = function(i, d) {
    return d === void 0 && (d = {}), new MKe(i, this.intl, d);
  }, o.relFormatter = function(i) {
    return i === void 0 && (i = {}), new FKe(this.intl, this.isEnglish(), i);
  }, o.isEnglish = function() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || QS() && new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }, o.equals = function(i) {
    return this.locale === i.locale && this.numberingSystem === i.numberingSystem && this.outputCalendar === i.outputCalendar;
  }, k1(r, [{
    key: "fastNumbers",
    get: function() {
      return this.fastNumbersCached == null && (this.fastNumbersCached = $Ke(this)), this.fastNumbersCached;
    }
  }]), r;
}();
function mI() {
  for (var r = arguments.length, o = new Array(r), c = 0; c < r; c++)
    o[c] = arguments[c];
  var i = o.reduce(function(d, m) {
    return d + m.source;
  }, "");
  return RegExp("^" + i + "$");
}
function Hk() {
  for (var r = arguments.length, o = new Array(r), c = 0; c < r; c++)
    o[c] = arguments[c];
  return function(i) {
    return o.reduce(function(d, m) {
      var v = d[0], g = d[1], C = d[2], O = m(i, C), R = O[0], I = O[1], L = O[2];
      return [Object.assign(v, R), g || I, L];
    }, [{}, null, 1]).slice(0, 2);
  };
}
function pI(r) {
  if (r == null)
    return [null, null];
  for (var o = arguments.length, c = new Array(o > 1 ? o - 1 : 0), i = 1; i < o; i++)
    c[i - 1] = arguments[i];
  for (var d = 0, m = c; d < m.length; d++) {
    var v = m[d], g = v[0], C = v[1], O = g.exec(r);
    if (O)
      return C(O);
  }
  return [null, null];
}
function Gye() {
  for (var r = arguments.length, o = new Array(r), c = 0; c < r; c++)
    o[c] = arguments[c];
  return function(i, d) {
    var m = {}, v;
    for (v = 0; v < o.length; v++)
      m[o[v]] = Th(i[d + v]);
    return [m, null, d + v];
  };
}
var Zye = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/, lce = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/, Kye = RegExp("" + lce.source + Zye.source + "?"), uce = RegExp("(?:T" + Kye.source + ")?"), LKe = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/, BKe = /(\d{4})-?W(\d\d)(?:-?(\d))?/, HKe = /(\d{4})-?(\d{3})/, zKe = Gye("weekYear", "weekNumber", "weekDay"), VKe = Gye("year", "ordinal"), UKe = /(\d{4})-(\d\d)-(\d\d)/, Yye = RegExp(lce.source + " ?(?:" + Zye.source + "|(" + Lye.source + "))?"), WKe = RegExp("(?: " + Yye.source + ")?");
function KD(r, o, c) {
  var i = r[o];
  return Ka(i) ? c : Th(i);
}
function Qye(r, o) {
  var c = {
    year: KD(r, o),
    month: KD(r, o + 1, 1),
    day: KD(r, o + 2, 1)
  };
  return [c, null, o + 3];
}
function zk(r, o) {
  var c = {
    hours: KD(r, o, 0),
    minutes: KD(r, o + 1, 0),
    seconds: KD(r, o + 2, 0),
    milliseconds: ace(r[o + 3])
  };
  return [c, null, o + 4];
}
function hI(r, o) {
  var c = !r[o] && !r[o + 1], i = pq(r[o + 1], r[o + 2]), d = c ? null : Dv.instance(i);
  return [{}, d, o + 3];
}
function Xye(r, o) {
  var c = r[o] ? LS.create(r[o]) : null;
  return [{}, c, o + 1];
}
var jKe = RegExp("^T?" + lce.source + "$"), qKe = /^-?P(?:(?:(-?\d{1,9})Y)?(?:(-?\d{1,9})M)?(?:(-?\d{1,9})W)?(?:(-?\d{1,9})D)?(?:T(?:(-?\d{1,9})H)?(?:(-?\d{1,9})M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,9}))?S)?)?)$/;
function GKe(r) {
  var o = r[0], c = r[1], i = r[2], d = r[3], m = r[4], v = r[5], g = r[6], C = r[7], O = r[8], R = o[0] === "-", I = C && C[0] === "-", L = function(ne, se) {
    return se === void 0 && (se = !1), ne !== void 0 && (se || ne && R) ? -ne : ne;
  };
  return [{
    years: L(Th(c)),
    months: L(Th(i)),
    weeks: L(Th(d)),
    days: L(Th(m)),
    hours: L(Th(v)),
    minutes: L(Th(g)),
    seconds: L(Th(C), C === "-0"),
    milliseconds: L(ace(O), I)
  }];
}
var ZKe = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function dce(r, o, c, i, d, m, v) {
  var g = {
    year: o.length === 2 ? Gse(Th(o)) : Th(o),
    month: Bye.indexOf(c) + 1,
    day: Th(i),
    hour: Th(d),
    minute: Th(m)
  };
  return v && (g.second = Th(v)), r && (g.weekday = r.length > 3 ? zye.indexOf(r) + 1 : Vye.indexOf(r) + 1), g;
}
var KKe = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function YKe(r) {
  var o = r[1], c = r[2], i = r[3], d = r[4], m = r[5], v = r[6], g = r[7], C = r[8], O = r[9], R = r[10], I = r[11], L = dce(o, d, i, c, m, v, g), Z;
  return C ? Z = ZKe[C] : O ? Z = 0 : Z = pq(R, I), [L, new Dv(Z)];
}
function QKe(r) {
  return r.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
var XKe = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/, JKe = /^(Monday|Tuesday|Wedsday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/, eYe = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function Jme(r) {
  var o = r[1], c = r[2], i = r[3], d = r[4], m = r[5], v = r[6], g = r[7], C = dce(o, d, i, c, m, v, g);
  return [C, Dv.utcInstance];
}
function tYe(r) {
  var o = r[1], c = r[2], i = r[3], d = r[4], m = r[5], v = r[6], g = r[7], C = dce(o, g, c, i, d, m, v);
  return [C, Dv.utcInstance];
}
var nYe = mI(LKe, uce), rYe = mI(BKe, uce), oYe = mI(HKe, uce), sYe = mI(Kye), aYe = Hk(Qye, zk, hI), iYe = Hk(zKe, zk, hI), cYe = Hk(VKe, zk, hI), lYe = Hk(zk, hI);
function uYe(r) {
  return pI(r, [nYe, aYe], [rYe, iYe], [oYe, cYe], [sYe, lYe]);
}
function dYe(r) {
  return pI(QKe(r), [KKe, YKe]);
}
function fYe(r) {
  return pI(r, [XKe, Jme], [JKe, Jme], [eYe, tYe]);
}
function mYe(r) {
  return pI(r, [qKe, GKe]);
}
var pYe = Hk(zk);
function hYe(r) {
  return pI(r, [jKe, pYe]);
}
var gYe = mI(UKe, WKe), vYe = mI(Yye), bYe = Hk(Qye, zk, hI, Xye), yYe = Hk(zk, hI, Xye);
function SYe(r) {
  return pI(r, [gYe, bYe], [vYe, yYe]);
}
var wYe = "Invalid Duration", Jye = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: {
    minutes: 60,
    seconds: 60 * 60,
    milliseconds: 60 * 60 * 1e3
  },
  minutes: {
    seconds: 60,
    milliseconds: 60 * 1e3
  },
  seconds: {
    milliseconds: 1e3
  }
}, EYe = Object.assign({
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  }
}, Jye), ly = 146097 / 400, ID = 146097 / 4800, CYe = Object.assign({
  years: {
    quarters: 4,
    months: 12,
    weeks: ly / 7,
    days: ly,
    hours: ly * 24,
    minutes: ly * 24 * 60,
    seconds: ly * 24 * 60 * 60,
    milliseconds: ly * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: ly / 28,
    days: ly / 4,
    hours: ly * 24 / 4,
    minutes: ly * 24 * 60 / 4,
    seconds: ly * 24 * 60 * 60 / 4,
    milliseconds: ly * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: ID / 7,
    days: ID,
    hours: ID * 24,
    minutes: ID * 24 * 60,
    seconds: ID * 24 * 60 * 60,
    milliseconds: ID * 24 * 60 * 60 * 1e3
  }
}, Jye), LD = ["years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds"], xYe = LD.slice(0).reverse();
function NA(r, o, c) {
  c === void 0 && (c = !1);
  var i = {
    values: c ? o.values : Object.assign({}, r.values, o.values || {}),
    loc: r.loc.clone(o.loc),
    conversionAccuracy: o.conversionAccuracy || r.conversionAccuracy
  };
  return new kh(i);
}
function TYe(r) {
  return r < 0 ? Math.floor(r) : Math.ceil(r);
}
function e1e(r, o, c, i, d) {
  var m = r[d][c], v = o[c] / m, g = Math.sign(v) === Math.sign(i[d]), C = !g && i[d] !== 0 && Math.abs(v) <= 1 ? TYe(v) : Math.trunc(v);
  i[d] += C, o[c] -= C * m;
}
function _Ye(r, o) {
  xYe.reduce(function(c, i) {
    return Ka(o[i]) ? c : (c && e1e(r, o, c, o, i), i);
  }, null);
}
var kh = /* @__PURE__ */ function() {
  function r(c) {
    var i = c.conversionAccuracy === "longterm" || !1;
    this.values = c.values, this.loc = c.loc || Zf.create(), this.conversionAccuracy = i ? "longterm" : "casual", this.invalid = c.invalid || null, this.matrix = i ? CYe : EYe, this.isLuxonDuration = !0;
  }
  r.fromMillis = function(i, d) {
    return r.fromObject(Object.assign({
      milliseconds: i
    }, d));
  }, r.fromObject = function(i) {
    if (i == null || typeof i != "object")
      throw new dy("Duration.fromObject: argument expected to be an object, got " + (i === null ? "null" : typeof i));
    return new r({
      values: aj(i, r.normalizeUnit, [
        "locale",
        "numberingSystem",
        "conversionAccuracy",
        "zone"
        // a bit of debt; it's super inconvenient internally not to be able to blindly pass this
      ]),
      loc: Zf.fromObject(i),
      conversionAccuracy: i.conversionAccuracy
    });
  }, r.fromISO = function(i, d) {
    var m = mYe(i), v = m[0];
    if (v) {
      var g = Object.assign(v, d);
      return r.fromObject(g);
    } else
      return r.invalid("unparsable", 'the input "' + i + `" can't be parsed as ISO 8601`);
  }, r.fromISOTime = function(i, d) {
    var m = hYe(i), v = m[0];
    if (v) {
      var g = Object.assign(v, d);
      return r.fromObject(g);
    } else
      return r.invalid("unparsable", 'the input "' + i + `" can't be parsed as ISO 8601`);
  }, r.invalid = function(i, d) {
    if (d === void 0 && (d = null), !i)
      throw new dy("need to specify a reason the Duration is invalid");
    var m = i instanceof w1 ? i : new w1(i, d);
    if (Zu.throwOnInvalid)
      throw new oKe(m);
    return new r({
      invalid: m
    });
  }, r.normalizeUnit = function(i) {
    var d = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[i && i.toLowerCase()];
    if (!d)
      throw new Rye(i);
    return d;
  }, r.isDuration = function(i) {
    return i && i.isLuxonDuration || !1;
  };
  var o = r.prototype;
  return o.toFormat = function(i, d) {
    d === void 0 && (d = {});
    var m = Object.assign({}, d, {
      floor: d.round !== !1 && d.floor !== !1
    });
    return this.isValid ? IS.create(this.loc, m).formatDurationFromString(this, i) : wYe;
  }, o.toObject = function(i) {
    if (i === void 0 && (i = {}), !this.isValid)
      return {};
    var d = Object.assign({}, this.values);
    return i.includeConfig && (d.conversionAccuracy = this.conversionAccuracy, d.numberingSystem = this.loc.numberingSystem, d.locale = this.loc.locale), d;
  }, o.toISO = function() {
    if (!this.isValid)
      return null;
    var i = "P";
    return this.years !== 0 && (i += this.years + "Y"), (this.months !== 0 || this.quarters !== 0) && (i += this.months + this.quarters * 3 + "M"), this.weeks !== 0 && (i += this.weeks + "W"), this.days !== 0 && (i += this.days + "D"), (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) && (i += "T"), this.hours !== 0 && (i += this.hours + "H"), this.minutes !== 0 && (i += this.minutes + "M"), (this.seconds !== 0 || this.milliseconds !== 0) && (i += ice(this.seconds + this.milliseconds / 1e3, 3) + "S"), i === "P" && (i += "T0S"), i;
  }, o.toISOTime = function(i) {
    if (i === void 0 && (i = {}), !this.isValid)
      return null;
    var d = this.toMillis();
    if (d < 0 || d >= 864e5)
      return null;
    i = Object.assign({
      suppressMilliseconds: !1,
      suppressSeconds: !1,
      includePrefix: !1,
      format: "extended"
    }, i);
    var m = this.shiftTo("hours", "minutes", "seconds", "milliseconds"), v = i.format === "basic" ? "hhmm" : "hh:mm";
    (!i.suppressSeconds || m.seconds !== 0 || m.milliseconds !== 0) && (v += i.format === "basic" ? "ss" : ":ss", (!i.suppressMilliseconds || m.milliseconds !== 0) && (v += ".SSS"));
    var g = m.toFormat(v);
    return i.includePrefix && (g = "T" + g), g;
  }, o.toJSON = function() {
    return this.toISO();
  }, o.toString = function() {
    return this.toISO();
  }, o.toMillis = function() {
    return this.as("milliseconds");
  }, o.valueOf = function() {
    return this.toMillis();
  }, o.plus = function(i) {
    if (!this.isValid)
      return this;
    for (var d = jA(i), m = {}, v = g2(LD), g; !(g = v()).done; ) {
      var C = g.value;
      (j$(d.values, C) || j$(this.values, C)) && (m[C] = d.get(C) + this.get(C));
    }
    return NA(this, {
      values: m
    }, !0);
  }, o.minus = function(i) {
    if (!this.isValid)
      return this;
    var d = jA(i);
    return this.plus(d.negate());
  }, o.mapUnits = function(i) {
    if (!this.isValid)
      return this;
    for (var d = {}, m = 0, v = Object.keys(this.values); m < v.length; m++) {
      var g = v[m];
      d[g] = Fye(i(this.values[g], g));
    }
    return NA(this, {
      values: d
    }, !0);
  }, o.get = function(i) {
    return this[r.normalizeUnit(i)];
  }, o.set = function(i) {
    if (!this.isValid)
      return this;
    var d = Object.assign(this.values, aj(i, r.normalizeUnit, []));
    return NA(this, {
      values: d
    });
  }, o.reconfigure = function(i) {
    var d = i === void 0 ? {} : i, m = d.locale, v = d.numberingSystem, g = d.conversionAccuracy, C = this.loc.clone({
      locale: m,
      numberingSystem: v
    }), O = {
      loc: C
    };
    return g && (O.conversionAccuracy = g), NA(this, O);
  }, o.as = function(i) {
    return this.isValid ? this.shiftTo(i).get(i) : NaN;
  }, o.normalize = function() {
    if (!this.isValid)
      return this;
    var i = this.toObject();
    return _Ye(this.matrix, i), NA(this, {
      values: i
    }, !0);
  }, o.shiftTo = function() {
    for (var i = arguments.length, d = new Array(i), m = 0; m < i; m++)
      d[m] = arguments[m];
    if (!this.isValid)
      return this;
    if (d.length === 0)
      return this;
    d = d.map(function(ue) {
      return r.normalizeUnit(ue);
    });
    for (var v = {}, g = {}, C = this.toObject(), O, R = g2(LD), I; !(I = R()).done; ) {
      var L = I.value;
      if (d.indexOf(L) >= 0) {
        O = L;
        var Z = 0;
        for (var ne in g)
          Z += this.matrix[ne][L] * g[ne], g[ne] = 0;
        xk(C[L]) && (Z += C[L]);
        var se = Math.trunc(Z);
        v[L] = se, g[L] = Z - se;
        for (var Q in C)
          LD.indexOf(Q) > LD.indexOf(L) && e1e(this.matrix, C, Q, v, L);
      } else
        xk(C[L]) && (g[L] = C[L]);
    }
    for (var he in g)
      g[he] !== 0 && (v[O] += he === O ? g[he] : g[he] / this.matrix[O][he]);
    return NA(this, {
      values: v
    }, !0).normalize();
  }, o.negate = function() {
    if (!this.isValid)
      return this;
    for (var i = {}, d = 0, m = Object.keys(this.values); d < m.length; d++) {
      var v = m[d];
      i[v] = -this.values[v];
    }
    return NA(this, {
      values: i
    }, !0);
  }, o.equals = function(i) {
    if (!this.isValid || !i.isValid || !this.loc.equals(i.loc))
      return !1;
    function d(C, O) {
      return C === void 0 || C === 0 ? O === void 0 || O === 0 : C === O;
    }
    for (var m = g2(LD), v; !(v = m()).done; ) {
      var g = v.value;
      if (!d(this.values[g], i.values[g]))
        return !1;
    }
    return !0;
  }, k1(r, [{
    key: "locale",
    get: function() {
      return this.isValid ? this.loc.locale : null;
    }
    /**
     * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
     *
     * @type {string}
     */
  }, {
    key: "numberingSystem",
    get: function() {
      return this.isValid ? this.loc.numberingSystem : null;
    }
  }, {
    key: "years",
    get: function() {
      return this.isValid ? this.values.years || 0 : NaN;
    }
    /**
     * Get the quarters.
     * @type {number}
     */
  }, {
    key: "quarters",
    get: function() {
      return this.isValid ? this.values.quarters || 0 : NaN;
    }
    /**
     * Get the months.
     * @type {number}
     */
  }, {
    key: "months",
    get: function() {
      return this.isValid ? this.values.months || 0 : NaN;
    }
    /**
     * Get the weeks
     * @type {number}
     */
  }, {
    key: "weeks",
    get: function() {
      return this.isValid ? this.values.weeks || 0 : NaN;
    }
    /**
     * Get the days.
     * @type {number}
     */
  }, {
    key: "days",
    get: function() {
      return this.isValid ? this.values.days || 0 : NaN;
    }
    /**
     * Get the hours.
     * @type {number}
     */
  }, {
    key: "hours",
    get: function() {
      return this.isValid ? this.values.hours || 0 : NaN;
    }
    /**
     * Get the minutes.
     * @type {number}
     */
  }, {
    key: "minutes",
    get: function() {
      return this.isValid ? this.values.minutes || 0 : NaN;
    }
    /**
     * Get the seconds.
     * @return {number}
     */
  }, {
    key: "seconds",
    get: function() {
      return this.isValid ? this.values.seconds || 0 : NaN;
    }
    /**
     * Get the milliseconds.
     * @return {number}
     */
  }, {
    key: "milliseconds",
    get: function() {
      return this.isValid ? this.values.milliseconds || 0 : NaN;
    }
    /**
     * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
     * on invalid DateTimes or Intervals.
     * @return {boolean}
     */
  }, {
    key: "isValid",
    get: function() {
      return this.invalid === null;
    }
    /**
     * Returns an error code if this Duration became invalid, or null if the Duration is valid
     * @return {string}
     */
  }, {
    key: "invalidReason",
    get: function() {
      return this.invalid ? this.invalid.reason : null;
    }
    /**
     * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
     * @type {string}
     */
  }, {
    key: "invalidExplanation",
    get: function() {
      return this.invalid ? this.invalid.explanation : null;
    }
  }]), r;
}();
function jA(r) {
  if (xk(r))
    return kh.fromMillis(r);
  if (kh.isDuration(r))
    return r;
  if (typeof r == "object")
    return kh.fromObject(r);
  throw new dy("Unknown duration argument " + r + " of type " + typeof r);
}
var WL = "Invalid Interval";
function OYe(r, o) {
  return !r || !r.isValid ? dB.invalid("missing or invalid start") : !o || !o.isValid ? dB.invalid("missing or invalid end") : o < r ? dB.invalid("end before start", "The end of an interval must be after its start, but you had start=" + r.toISO() + " and end=" + o.toISO()) : null;
}
var dB = /* @__PURE__ */ function() {
  function r(c) {
    this.s = c.start, this.e = c.end, this.invalid = c.invalid || null, this.isLuxonInterval = !0;
  }
  r.invalid = function(i, d) {
    if (d === void 0 && (d = null), !i)
      throw new dy("need to specify a reason the Interval is invalid");
    var m = i instanceof w1 ? i : new w1(i, d);
    if (Zu.throwOnInvalid)
      throw new rKe(m);
    return new r({
      invalid: m
    });
  }, r.fromDateTimes = function(i, d) {
    var m = GL(i), v = GL(d), g = OYe(m, v);
    return g ?? new r({
      start: m,
      end: v
    });
  }, r.after = function(i, d) {
    var m = jA(d), v = GL(i);
    return r.fromDateTimes(v, v.plus(m));
  }, r.before = function(i, d) {
    var m = jA(d), v = GL(i);
    return r.fromDateTimes(v.minus(m), v);
  }, r.fromISO = function(i, d) {
    var m = (i || "").split("/", 2), v = m[0], g = m[1];
    if (v && g) {
      var C, O;
      try {
        C = Ad.fromISO(v, d), O = C.isValid;
      } catch {
        O = !1;
      }
      var R, I;
      try {
        R = Ad.fromISO(g, d), I = R.isValid;
      } catch {
        I = !1;
      }
      if (O && I)
        return r.fromDateTimes(C, R);
      if (O) {
        var L = kh.fromISO(g, d);
        if (L.isValid)
          return r.after(C, L);
      } else if (I) {
        var Z = kh.fromISO(v, d);
        if (Z.isValid)
          return r.before(R, Z);
      }
    }
    return r.invalid("unparsable", 'the input "' + i + `" can't be parsed as ISO 8601`);
  }, r.isInterval = function(i) {
    return i && i.isLuxonInterval || !1;
  };
  var o = r.prototype;
  return o.length = function(i) {
    return i === void 0 && (i = "milliseconds"), this.isValid ? this.toDuration.apply(this, [i]).get(i) : NaN;
  }, o.count = function(i) {
    if (i === void 0 && (i = "milliseconds"), !this.isValid)
      return NaN;
    var d = this.start.startOf(i), m = this.end.startOf(i);
    return Math.floor(m.diff(d, i).get(i)) + 1;
  }, o.hasSame = function(i) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, i) : !1;
  }, o.isEmpty = function() {
    return this.s.valueOf() === this.e.valueOf();
  }, o.isAfter = function(i) {
    return this.isValid ? this.s > i : !1;
  }, o.isBefore = function(i) {
    return this.isValid ? this.e <= i : !1;
  }, o.contains = function(i) {
    return this.isValid ? this.s <= i && this.e > i : !1;
  }, o.set = function(i) {
    var d = i === void 0 ? {} : i, m = d.start, v = d.end;
    return this.isValid ? r.fromDateTimes(m || this.s, v || this.e) : this;
  }, o.splitAt = function() {
    var i = this;
    if (!this.isValid)
      return [];
    for (var d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    for (var g = m.map(GL).filter(function(Z) {
      return i.contains(Z);
    }).sort(), C = [], O = this.s, R = 0; O < this.e; ) {
      var I = g[R] || this.e, L = +I > +this.e ? this.e : I;
      C.push(r.fromDateTimes(O, L)), O = L, R += 1;
    }
    return C;
  }, o.splitBy = function(i) {
    var d = jA(i);
    if (!this.isValid || !d.isValid || d.as("milliseconds") === 0)
      return [];
    for (var m = this.s, v = 1, g, C = []; m < this.e; ) {
      var O = this.start.plus(d.mapUnits(function(R) {
        return R * v;
      }));
      g = +O > +this.e ? this.e : O, C.push(r.fromDateTimes(m, g)), m = g, v += 1;
    }
    return C;
  }, o.divideEqually = function(i) {
    return this.isValid ? this.splitBy(this.length() / i).slice(0, i) : [];
  }, o.overlaps = function(i) {
    return this.e > i.s && this.s < i.e;
  }, o.abutsStart = function(i) {
    return this.isValid ? +this.e == +i.s : !1;
  }, o.abutsEnd = function(i) {
    return this.isValid ? +i.e == +this.s : !1;
  }, o.engulfs = function(i) {
    return this.isValid ? this.s <= i.s && this.e >= i.e : !1;
  }, o.equals = function(i) {
    return !this.isValid || !i.isValid ? !1 : this.s.equals(i.s) && this.e.equals(i.e);
  }, o.intersection = function(i) {
    if (!this.isValid)
      return this;
    var d = this.s > i.s ? this.s : i.s, m = this.e < i.e ? this.e : i.e;
    return d >= m ? null : r.fromDateTimes(d, m);
  }, o.union = function(i) {
    if (!this.isValid)
      return this;
    var d = this.s < i.s ? this.s : i.s, m = this.e > i.e ? this.e : i.e;
    return r.fromDateTimes(d, m);
  }, r.merge = function(i) {
    var d = i.sort(function(g, C) {
      return g.s - C.s;
    }).reduce(function(g, C) {
      var O = g[0], R = g[1];
      return R ? R.overlaps(C) || R.abutsStart(C) ? [O, R.union(C)] : [O.concat([R]), C] : [O, C];
    }, [[], null]), m = d[0], v = d[1];
    return v && m.push(v), m;
  }, r.xor = function(i) {
    for (var d, m = null, v = 0, g = [], C = i.map(function(ne) {
      return [{
        time: ne.s,
        type: "s"
      }, {
        time: ne.e,
        type: "e"
      }];
    }), O = (d = Array.prototype).concat.apply(d, C), R = O.sort(function(ne, se) {
      return ne.time - se.time;
    }), I = g2(R), L; !(L = I()).done; ) {
      var Z = L.value;
      v += Z.type === "s" ? 1 : -1, v === 1 ? m = Z.time : (m && +m != +Z.time && g.push(r.fromDateTimes(m, Z.time)), m = null);
    }
    return r.merge(g);
  }, o.difference = function() {
    for (var i = this, d = arguments.length, m = new Array(d), v = 0; v < d; v++)
      m[v] = arguments[v];
    return r.xor([this].concat(m)).map(function(g) {
      return i.intersection(g);
    }).filter(function(g) {
      return g && !g.isEmpty();
    });
  }, o.toString = function() {
    return this.isValid ? "[" + this.s.toISO() + "  " + this.e.toISO() + ")" : WL;
  }, o.toISO = function(i) {
    return this.isValid ? this.s.toISO(i) + "/" + this.e.toISO(i) : WL;
  }, o.toISODate = function() {
    return this.isValid ? this.s.toISODate() + "/" + this.e.toISODate() : WL;
  }, o.toISOTime = function(i) {
    return this.isValid ? this.s.toISOTime(i) + "/" + this.e.toISOTime(i) : WL;
  }, o.toFormat = function(i, d) {
    var m = d === void 0 ? {} : d, v = m.separator, g = v === void 0 ? "  " : v;
    return this.isValid ? "" + this.s.toFormat(i) + g + this.e.toFormat(i) : WL;
  }, o.toDuration = function(i, d) {
    return this.isValid ? this.e.diff(this.s, i, d) : kh.invalid(this.invalidReason);
  }, o.mapEndpoints = function(i) {
    return r.fromDateTimes(i(this.s), i(this.e));
  }, k1(r, [{
    key: "start",
    get: function() {
      return this.isValid ? this.s : null;
    }
    /**
     * Returns the end of the Interval
     * @type {DateTime}
     */
  }, {
    key: "end",
    get: function() {
      return this.isValid ? this.e : null;
    }
    /**
     * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
     * @type {boolean}
     */
  }, {
    key: "isValid",
    get: function() {
      return this.invalidReason === null;
    }
    /**
     * Returns an error code if this Interval is invalid, or null if the Interval is valid
     * @type {string}
     */
  }, {
    key: "invalidReason",
    get: function() {
      return this.invalid ? this.invalid.reason : null;
    }
    /**
     * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
     * @type {string}
     */
  }, {
    key: "invalidExplanation",
    get: function() {
      return this.invalid ? this.invalid.explanation : null;
    }
  }]), r;
}(), XL = /* @__PURE__ */ function() {
  function r() {
  }
  return r.hasDST = function(c) {
    c === void 0 && (c = Zu.defaultZone);
    var i = Ad.now().setZone(c).set({
      month: 12
    });
    return !c.universal && i.offset !== i.set({
      month: 6
    }).offset;
  }, r.isValidIANAZone = function(c) {
    return LS.isValidSpecifier(c) && LS.isValidZone(c);
  }, r.normalizeZone = function(c) {
    return FA(c, Zu.defaultZone);
  }, r.months = function(c, i) {
    c === void 0 && (c = "long");
    var d = i === void 0 ? {} : i, m = d.locale, v = m === void 0 ? null : m, g = d.numberingSystem, C = g === void 0 ? null : g, O = d.locObj, R = O === void 0 ? null : O, I = d.outputCalendar, L = I === void 0 ? "gregory" : I;
    return (R || Zf.create(v, C, L)).months(c);
  }, r.monthsFormat = function(c, i) {
    c === void 0 && (c = "long");
    var d = i === void 0 ? {} : i, m = d.locale, v = m === void 0 ? null : m, g = d.numberingSystem, C = g === void 0 ? null : g, O = d.locObj, R = O === void 0 ? null : O, I = d.outputCalendar, L = I === void 0 ? "gregory" : I;
    return (R || Zf.create(v, C, L)).months(c, !0);
  }, r.weekdays = function(c, i) {
    c === void 0 && (c = "long");
    var d = i === void 0 ? {} : i, m = d.locale, v = m === void 0 ? null : m, g = d.numberingSystem, C = g === void 0 ? null : g, O = d.locObj, R = O === void 0 ? null : O;
    return (R || Zf.create(v, C, null)).weekdays(c);
  }, r.weekdaysFormat = function(c, i) {
    c === void 0 && (c = "long");
    var d = i === void 0 ? {} : i, m = d.locale, v = m === void 0 ? null : m, g = d.numberingSystem, C = g === void 0 ? null : g, O = d.locObj, R = O === void 0 ? null : O;
    return (R || Zf.create(v, C, null)).weekdays(c, !0);
  }, r.meridiems = function(c) {
    var i = c === void 0 ? {} : c, d = i.locale, m = d === void 0 ? null : d;
    return Zf.create(m).meridiems();
  }, r.eras = function(c, i) {
    c === void 0 && (c = "short");
    var d = i === void 0 ? {} : i, m = d.locale, v = m === void 0 ? null : m;
    return Zf.create(v, null, "gregory").eras(c);
  }, r.features = function() {
    var c = !1, i = !1, d = !1, m = !1;
    if (QS()) {
      c = !0, i = r5(), m = $ye();
      try {
        d = new Intl.DateTimeFormat("en", {
          timeZone: "America/New_York"
        }).resolvedOptions().timeZone === "America/New_York";
      } catch {
        d = !1;
      }
    }
    return {
      intl: c,
      intlTokens: i,
      zones: d,
      relative: m
    };
  }, r;
}();
function epe(r, o) {
  var c = function(m) {
    return m.toUTC(0, {
      keepLocalTime: !0
    }).startOf("day").valueOf();
  }, i = c(o) - c(r);
  return Math.floor(kh.fromMillis(i).as("days"));
}
function AYe(r, o, c) {
  for (var i = [["years", function(se, Q) {
    return Q.year - se.year;
  }], ["quarters", function(se, Q) {
    return Q.quarter - se.quarter;
  }], ["months", function(se, Q) {
    return Q.month - se.month + (Q.year - se.year) * 12;
  }], ["weeks", function(se, Q) {
    var he = epe(se, Q);
    return (he - he % 7) / 7;
  }], ["days", epe]], d = {}, m, v, g = 0, C = i; g < C.length; g++) {
    var O = C[g], R = O[0], I = O[1];
    if (c.indexOf(R) >= 0) {
      var L;
      m = R;
      var Z = I(r, o);
      if (v = r.plus((L = {}, L[R] = Z, L)), v > o) {
        var ne;
        r = r.plus((ne = {}, ne[R] = Z - 1, ne)), Z -= 1;
      } else
        r = v;
      d[R] = Z;
    }
  }
  return [r, d, v, m];
}
function kYe(r, o, c, i) {
  var d = AYe(r, o, c), m = d[0], v = d[1], g = d[2], C = d[3], O = o - m, R = c.filter(function(ne) {
    return ["hours", "minutes", "seconds", "milliseconds"].indexOf(ne) >= 0;
  });
  if (R.length === 0) {
    if (g < o) {
      var I;
      g = m.plus((I = {}, I[C] = 1, I));
    }
    g !== m && (v[C] = (v[C] || 0) + O / (g - m));
  }
  var L = kh.fromObject(Object.assign(v, i));
  if (R.length > 0) {
    var Z;
    return (Z = kh.fromMillis(O, i)).shiftTo.apply(Z, R).plus(L);
  } else
    return L;
}
var fce = {
  arab: "[-]",
  arabext: "[-]",
  bali: "[-]",
  beng: "[-]",
  deva: "[-]",
  fullwide: "[-]",
  gujr: "[-]",
  hanidec: "[|||||||||]",
  khmr: "[-]",
  knda: "[-]",
  laoo: "[-]",
  limb: "[-]",
  mlym: "[-]",
  mong: "[-]",
  mymr: "[-]",
  orya: "[-]",
  tamldec: "[-]",
  telu: "[-]",
  thai: "[-]",
  tibt: "[-]",
  latn: "\\d"
}, tpe = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
}, NYe = fce.hanidec.replace(/[\[|\]]/g, "").split("");
function RYe(r) {
  var o = parseInt(r, 10);
  if (isNaN(o)) {
    o = "";
    for (var c = 0; c < r.length; c++) {
      var i = r.charCodeAt(c);
      if (r[c].search(fce.hanidec) !== -1)
        o += NYe.indexOf(r[c]);
      else
        for (var d in tpe) {
          var m = tpe[d], v = m[0], g = m[1];
          i >= v && i <= g && (o += i - v);
        }
    }
    return parseInt(o, 10);
  } else
    return o;
}
function b1(r, o) {
  var c = r.numberingSystem;
  return o === void 0 && (o = ""), new RegExp("" + fce[c || "latn"] + o);
}
var PYe = "missing Intl.DateTimeFormat.formatToParts support";
function Pi(r, o) {
  return o === void 0 && (o = function(i) {
    return i;
  }), {
    regex: r,
    deser: function(i) {
      var d = i[0];
      return o(RYe(d));
    }
  };
}
var DYe = String.fromCharCode(160), t1e = "( |" + DYe + ")", n1e = new RegExp(t1e, "g");
function $Ye(r) {
  return r.replace(/\./g, "\\.?").replace(n1e, t1e);
}
function npe(r) {
  return r.replace(/\./g, "").replace(n1e, " ").toLowerCase();
}
function y1(r, o) {
  return r === null ? null : {
    regex: RegExp(r.map($Ye).join("|")),
    deser: function(i) {
      var d = i[0];
      return r.findIndex(function(m) {
        return npe(d) === npe(m);
      }) + o;
    }
  };
}
function rpe(r, o) {
  return {
    regex: r,
    deser: function(i) {
      var d = i[1], m = i[2];
      return pq(d, m);
    },
    groups: o
  };
}
function ope(r) {
  return {
    regex: r,
    deser: function(c) {
      var i = c[0];
      return i;
    }
  };
}
function IYe(r) {
  return r.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function MYe(r, o) {
  var c = b1(o), i = b1(o, "{2}"), d = b1(o, "{3}"), m = b1(o, "{4}"), v = b1(o, "{6}"), g = b1(o, "{1,2}"), C = b1(o, "{1,3}"), O = b1(o, "{1,6}"), R = b1(o, "{1,9}"), I = b1(o, "{2,4}"), L = b1(o, "{4,6}"), Z = function(he) {
    return {
      regex: RegExp(IYe(he.val)),
      deser: function(G) {
        var me = G[0];
        return me;
      },
      literal: !0
    };
  }, ne = function(he) {
    if (r.literal)
      return Z(he);
    switch (he.val) {
      case "G":
        return y1(o.eras("short", !1), 0);
      case "GG":
        return y1(o.eras("long", !1), 0);
      case "y":
        return Pi(O);
      case "yy":
        return Pi(I, Gse);
      case "yyyy":
        return Pi(m);
      case "yyyyy":
        return Pi(L);
      case "yyyyyy":
        return Pi(v);
      case "M":
        return Pi(g);
      case "MM":
        return Pi(i);
      case "MMM":
        return y1(o.months("short", !0, !1), 1);
      case "MMMM":
        return y1(o.months("long", !0, !1), 1);
      case "L":
        return Pi(g);
      case "LL":
        return Pi(i);
      case "LLL":
        return y1(o.months("short", !1, !1), 1);
      case "LLLL":
        return y1(o.months("long", !1, !1), 1);
      case "d":
        return Pi(g);
      case "dd":
        return Pi(i);
      case "o":
        return Pi(C);
      case "ooo":
        return Pi(d);
      case "HH":
        return Pi(i);
      case "H":
        return Pi(g);
      case "hh":
        return Pi(i);
      case "h":
        return Pi(g);
      case "mm":
        return Pi(i);
      case "m":
        return Pi(g);
      case "q":
        return Pi(g);
      case "qq":
        return Pi(i);
      case "s":
        return Pi(g);
      case "ss":
        return Pi(i);
      case "S":
        return Pi(C);
      case "SSS":
        return Pi(d);
      case "u":
        return ope(R);
      case "a":
        return y1(o.meridiems(), 0);
      case "kkkk":
        return Pi(m);
      case "kk":
        return Pi(I, Gse);
      case "W":
        return Pi(g);
      case "WW":
        return Pi(i);
      case "E":
      case "c":
        return Pi(c);
      case "EEE":
        return y1(o.weekdays("short", !1, !1), 1);
      case "EEEE":
        return y1(o.weekdays("long", !1, !1), 1);
      case "ccc":
        return y1(o.weekdays("short", !0, !1), 1);
      case "cccc":
        return y1(o.weekdays("long", !0, !1), 1);
      case "Z":
      case "ZZ":
        return rpe(new RegExp("([+-]" + g.source + ")(?::(" + i.source + "))?"), 2);
      case "ZZZ":
        return rpe(new RegExp("([+-]" + g.source + ")(" + i.source + ")?"), 2);
      case "z":
        return ope(/[a-z_+-/]{1,256}?/i);
      default:
        return Z(he);
    }
  }, se = ne(r) || {
    invalidReason: PYe
  };
  return se.token = r, se;
}
var FYe = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour: {
    numeric: "h",
    "2-digit": "hh"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  }
};
function LYe(r, o, c) {
  var i = r.type, d = r.value;
  if (i === "literal")
    return {
      literal: !0,
      val: d
    };
  var m = c[i], v = FYe[i];
  if (typeof v == "object" && (v = v[m]), v)
    return {
      literal: !1,
      val: v
    };
}
function BYe(r) {
  var o = r.map(function(c) {
    return c.regex;
  }).reduce(function(c, i) {
    return c + "(" + i.source + ")";
  }, "");
  return ["^" + o + "$", r];
}
function HYe(r, o, c) {
  var i = r.match(o);
  if (i) {
    var d = {}, m = 1;
    for (var v in c)
      if (j$(c, v)) {
        var g = c[v], C = g.groups ? g.groups + 1 : 1;
        !g.literal && g.token && (d[g.token.val[0]] = g.deser(i.slice(m, m + C))), m += C;
      }
    return [i, d];
  } else
    return [i, {}];
}
function zYe(r) {
  var o = function(m) {
    switch (m) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  }, c;
  Ka(r.Z) ? Ka(r.z) ? c = null : c = LS.create(r.z) : c = new Dv(r.Z), Ka(r.q) || (r.M = (r.q - 1) * 3 + 1), Ka(r.h) || (r.h < 12 && r.a === 1 ? r.h += 12 : r.h === 12 && r.a === 0 && (r.h = 0)), r.G === 0 && r.y && (r.y = -r.y), Ka(r.u) || (r.S = ace(r.u));
  var i = Object.keys(r).reduce(function(d, m) {
    var v = o(m);
    return v && (d[v] = r[m]), d;
  }, {});
  return [i, c];
}
var Koe = null;
function VYe() {
  return Koe || (Koe = Ad.fromMillis(1555555555555)), Koe;
}
function UYe(r, o) {
  if (r.literal)
    return r;
  var c = IS.macroTokenToFormatOpts(r.val);
  if (!c)
    return r;
  var i = IS.create(o, c), d = i.formatDateTimeParts(VYe()), m = d.map(function(v) {
    return LYe(v, o, c);
  });
  return m.includes(void 0) ? r : m;
}
function WYe(r, o) {
  var c;
  return (c = Array.prototype).concat.apply(c, r.map(function(i) {
    return UYe(i, o);
  }));
}
function r1e(r, o, c) {
  var i = WYe(IS.parseFormat(c), r), d = i.map(function(Q) {
    return MYe(Q, r);
  }), m = d.find(function(Q) {
    return Q.invalidReason;
  });
  if (m)
    return {
      input: o,
      tokens: i,
      invalidReason: m.invalidReason
    };
  var v = BYe(d), g = v[0], C = v[1], O = RegExp(g, "i"), R = HYe(o, O, C), I = R[0], L = R[1], Z = L ? zYe(L) : [null, null], ne = Z[0], se = Z[1];
  if (j$(L, "a") && j$(L, "H"))
    throw new QL("Can't include meridiem when specifying 24-hour format");
  return {
    input: o,
    tokens: i,
    regex: O,
    rawMatches: I,
    matches: L,
    result: ne,
    zone: se
  };
}
function jYe(r, o, c) {
  var i = r1e(r, o, c), d = i.result, m = i.zone, v = i.invalidReason;
  return [d, m, v];
}
var o1e = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], s1e = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function fy(r, o) {
  return new w1("unit out of range", "you specified " + o + " (of type " + typeof o + ") as a " + r + ", which is invalid");
}
function a1e(r, o, c) {
  var i = new Date(Date.UTC(r, o - 1, c)).getUTCDay();
  return i === 0 ? 7 : i;
}
function i1e(r, o, c) {
  return c + (o5(r) ? s1e : o1e)[o - 1];
}
function c1e(r, o) {
  var c = o5(r) ? s1e : o1e, i = c.findIndex(function(m) {
    return m < o;
  }), d = o - c[i];
  return {
    month: i + 1,
    day: d
  };
}
function Jse(r) {
  var o = r.year, c = r.month, i = r.day, d = i1e(o, c, i), m = a1e(o, c, i), v = Math.floor((d - m + 10) / 7), g;
  return v < 1 ? (g = o - 1, v = sj(g)) : v > sj(o) ? (g = o + 1, v = 1) : g = o, Object.assign({
    weekYear: g,
    weekNumber: v,
    weekday: m
  }, hq(r));
}
function spe(r) {
  var o = r.weekYear, c = r.weekNumber, i = r.weekday, d = a1e(o, 1, 4), m = uB(o), v = c * 7 + i - d - 3, g;
  v < 1 ? (g = o - 1, v += uB(g)) : v > m ? (g = o + 1, v -= uB(o)) : g = o;
  var C = c1e(g, v), O = C.month, R = C.day;
  return Object.assign({
    year: g,
    month: O,
    day: R
  }, hq(r));
}
function Yoe(r) {
  var o = r.year, c = r.month, i = r.day, d = i1e(o, c, i);
  return Object.assign({
    year: o,
    ordinal: d
  }, hq(r));
}
function ape(r) {
  var o = r.year, c = r.ordinal, i = c1e(o, c), d = i.month, m = i.day;
  return Object.assign({
    year: o,
    month: d,
    day: m
  }, hq(r));
}
function qYe(r) {
  var o = mq(r.weekYear), c = aC(r.weekNumber, 1, sj(r.weekYear)), i = aC(r.weekday, 1, 7);
  return o ? c ? i ? !1 : fy("weekday", r.weekday) : fy("week", r.week) : fy("weekYear", r.weekYear);
}
function GYe(r) {
  var o = mq(r.year), c = aC(r.ordinal, 1, uB(r.year));
  return o ? c ? !1 : fy("ordinal", r.ordinal) : fy("year", r.year);
}
function l1e(r) {
  var o = mq(r.year), c = aC(r.month, 1, 12), i = aC(r.day, 1, oj(r.year, r.month));
  return o ? c ? i ? !1 : fy("day", r.day) : fy("month", r.month) : fy("year", r.year);
}
function u1e(r) {
  var o = r.hour, c = r.minute, i = r.second, d = r.millisecond, m = aC(o, 0, 23) || o === 24 && c === 0 && i === 0 && d === 0, v = aC(c, 0, 59), g = aC(i, 0, 59), C = aC(d, 0, 999);
  return m ? v ? g ? C ? !1 : fy("millisecond", d) : fy("second", i) : fy("minute", c) : fy("hour", o);
}
var Qoe = "Invalid DateTime", ipe = 864e13;
function iW(r) {
  return new w1("unsupported zone", 'the zone "' + r.name + '" is not supported');
}
function Xoe(r) {
  return r.weekData === null && (r.weekData = Jse(r.c)), r.weekData;
}
function jL(r, o) {
  var c = {
    ts: r.ts,
    zone: r.zone,
    c: r.c,
    o: r.o,
    loc: r.loc,
    invalid: r.invalid
  };
  return new Ad(Object.assign({}, c, o, {
    old: c
  }));
}
function d1e(r, o, c) {
  var i = r - o * 60 * 1e3, d = c.offset(i);
  if (o === d)
    return [i, o];
  i -= (d - o) * 60 * 1e3;
  var m = c.offset(i);
  return d === m ? [i, d] : [r - Math.min(d, m) * 60 * 1e3, Math.max(d, m)];
}
function cpe(r, o) {
  r += o * 60 * 1e3;
  var c = new Date(r);
  return {
    year: c.getUTCFullYear(),
    month: c.getUTCMonth() + 1,
    day: c.getUTCDate(),
    hour: c.getUTCHours(),
    minute: c.getUTCMinutes(),
    second: c.getUTCSeconds(),
    millisecond: c.getUTCMilliseconds()
  };
}
function TW(r, o, c) {
  return d1e(cce(r), o, c);
}
function lpe(r, o) {
  var c = r.o, i = r.c.year + Math.trunc(o.years), d = r.c.month + Math.trunc(o.months) + Math.trunc(o.quarters) * 3, m = Object.assign({}, r.c, {
    year: i,
    month: d,
    day: Math.min(r.c.day, oj(i, d)) + Math.trunc(o.days) + Math.trunc(o.weeks) * 7
  }), v = kh.fromObject({
    years: o.years - Math.trunc(o.years),
    quarters: o.quarters - Math.trunc(o.quarters),
    months: o.months - Math.trunc(o.months),
    weeks: o.weeks - Math.trunc(o.weeks),
    days: o.days - Math.trunc(o.days),
    hours: o.hours,
    minutes: o.minutes,
    seconds: o.seconds,
    milliseconds: o.milliseconds
  }).as("milliseconds"), g = cce(m), C = d1e(g, c, r.zone), O = C[0], R = C[1];
  return v !== 0 && (O += v, R = r.zone.offset(O)), {
    ts: O,
    o: R
  };
}
function qL(r, o, c, i, d) {
  var m = c.setZone, v = c.zone;
  if (r && Object.keys(r).length !== 0) {
    var g = o || v, C = Ad.fromObject(Object.assign(r, c, {
      zone: g,
      // setZone is a valid option in the calling methods, but not in fromObject
      setZone: void 0
    }));
    return m ? C : C.setZone(v);
  } else
    return Ad.invalid(new w1("unparsable", 'the input "' + d + `" can't be parsed as ` + i));
}
function BD(r, o, c) {
  return c === void 0 && (c = !0), r.isValid ? IS.create(Zf.create("en-US"), {
    allowZ: c,
    forceSimple: !0
  }).formatDateTimeFromString(r, o) : null;
}
function upe(r, o) {
  var c = o.suppressSeconds, i = c === void 0 ? !1 : c, d = o.suppressMilliseconds, m = d === void 0 ? !1 : d, v = o.includeOffset, g = o.includePrefix, C = g === void 0 ? !1 : g, O = o.includeZone, R = O === void 0 ? !1 : O, I = o.spaceZone, L = I === void 0 ? !1 : I, Z = o.format, ne = Z === void 0 ? "extended" : Z, se = ne === "basic" ? "HHmm" : "HH:mm";
  (!i || r.second !== 0 || r.millisecond !== 0) && (se += ne === "basic" ? "ss" : ":ss", (!m || r.millisecond !== 0) && (se += ".SSS")), (R || v) && L && (se += " "), R ? se += "z" : v && (se += ne === "basic" ? "ZZZ" : "ZZ");
  var Q = BD(r, se);
  return C && (Q = "T" + Q), Q;
}
var f1e = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, ZYe = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, KYe = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, m1e = ["year", "month", "day", "hour", "minute", "second", "millisecond"], YYe = ["weekYear", "weekNumber", "weekday", "hour", "minute", "second", "millisecond"], QYe = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function dpe(r) {
  var o = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[r.toLowerCase()];
  if (!o)
    throw new Rye(r);
  return o;
}
function fpe(r, o) {
  for (var c = g2(m1e), i; !(i = c()).done; ) {
    var d = i.value;
    Ka(r[d]) && (r[d] = f1e[d]);
  }
  var m = l1e(r) || u1e(r);
  if (m)
    return Ad.invalid(m);
  var v = Zu.now(), g = o.offset(v), C = TW(r, g, o), O = C[0], R = C[1];
  return new Ad({
    ts: O,
    zone: o,
    o: R
  });
}
function mpe(r, o, c) {
  var i = Ka(c.round) ? !0 : c.round, d = function(I, L) {
    I = ice(I, i || c.calendary ? 0 : 2, !0);
    var Z = o.loc.clone(c).relFormatter(c);
    return Z.format(I, L);
  }, m = function(I) {
    return c.calendary ? o.hasSame(r, I) ? 0 : o.startOf(I).diff(r.startOf(I), I).get(I) : o.diff(r, I).get(I);
  };
  if (c.unit)
    return d(m(c.unit), c.unit);
  for (var v = g2(c.units), g; !(g = v()).done; ) {
    var C = g.value, O = m(C);
    if (Math.abs(O) >= 1)
      return d(O, C);
  }
  return d(r > o ? -0 : 0, c.units[c.units.length - 1]);
}
var Ad = /* @__PURE__ */ function() {
  function r(c) {
    var i = c.zone || Zu.defaultZone, d = c.invalid || (Number.isNaN(c.ts) ? new w1("invalid input") : null) || (i.isValid ? null : iW(i));
    this.ts = Ka(c.ts) ? Zu.now() : c.ts;
    var m = null, v = null;
    if (!d) {
      var g = c.old && c.old.ts === this.ts && c.old.zone.equals(i);
      if (g) {
        var C = [c.old.c, c.old.o];
        m = C[0], v = C[1];
      } else {
        var O = i.offset(this.ts);
        m = cpe(this.ts, O), d = Number.isNaN(m.year) ? new w1("invalid input") : null, m = d ? null : m, v = d ? null : O;
      }
    }
    this._zone = i, this.loc = c.loc || Zf.create(), this.invalid = d, this.weekData = null, this.c = m, this.o = v, this.isLuxonDateTime = !0;
  }
  r.now = function() {
    return new r({});
  }, r.local = function(i, d, m, v, g, C, O) {
    return Ka(i) ? r.now() : fpe({
      year: i,
      month: d,
      day: m,
      hour: v,
      minute: g,
      second: C,
      millisecond: O
    }, Zu.defaultZone);
  }, r.utc = function(i, d, m, v, g, C, O) {
    return Ka(i) ? new r({
      ts: Zu.now(),
      zone: Dv.utcInstance
    }) : fpe({
      year: i,
      month: d,
      day: m,
      hour: v,
      minute: g,
      second: C,
      millisecond: O
    }, Dv.utcInstance);
  }, r.fromJSDate = function(i, d) {
    d === void 0 && (d = {});
    var m = aKe(i) ? i.valueOf() : NaN;
    if (Number.isNaN(m))
      return r.invalid("invalid input");
    var v = FA(d.zone, Zu.defaultZone);
    return v.isValid ? new r({
      ts: m,
      zone: v,
      loc: Zf.fromObject(d)
    }) : r.invalid(iW(v));
  }, r.fromMillis = function(i, d) {
    if (d === void 0 && (d = {}), xk(i))
      return i < -ipe || i > ipe ? r.invalid("Timestamp out of range") : new r({
        ts: i,
        zone: FA(d.zone, Zu.defaultZone),
        loc: Zf.fromObject(d)
      });
    throw new dy("fromMillis requires a numerical input, but received a " + typeof i + " with value " + i);
  }, r.fromSeconds = function(i, d) {
    if (d === void 0 && (d = {}), xk(i))
      return new r({
        ts: i * 1e3,
        zone: FA(d.zone, Zu.defaultZone),
        loc: Zf.fromObject(d)
      });
    throw new dy("fromSeconds requires a numerical input");
  }, r.fromObject = function(i) {
    var d = FA(i.zone, Zu.defaultZone);
    if (!d.isValid)
      return r.invalid(iW(d));
    var m = Zu.now(), v = d.offset(m), g = aj(i, dpe, ["zone", "locale", "outputCalendar", "numberingSystem"]), C = !Ka(g.ordinal), O = !Ka(g.year), R = !Ka(g.month) || !Ka(g.day), I = O || R, L = g.weekYear || g.weekNumber, Z = Zf.fromObject(i);
    if ((I || C) && L)
      throw new QL("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
    if (R && C)
      throw new QL("Can't mix ordinal dates with month/day");
    var ne = L || g.weekday && !I, se, Q, he = cpe(m, v);
    ne ? (se = YYe, Q = ZYe, he = Jse(he)) : C ? (se = QYe, Q = KYe, he = Yoe(he)) : (se = m1e, Q = f1e);
    for (var ue = !1, G = g2(se), me; !(me = G()).done; ) {
      var we = me.value, be = g[we];
      Ka(be) ? ue ? g[we] = Q[we] : g[we] = he[we] : ue = !0;
    }
    var q = ne ? qYe(g) : C ? GYe(g) : l1e(g), Te = q || u1e(g);
    if (Te)
      return r.invalid(Te);
    var Le = ne ? spe(g) : C ? ape(g) : g, je = TW(Le, v, d), Ie = je[0], Ce = je[1], pt = new r({
      ts: Ie,
      zone: d,
      o: Ce,
      loc: Z
    });
    return g.weekday && I && i.weekday !== pt.weekday ? r.invalid("mismatched weekday", "you can't specify both a weekday of " + g.weekday + " and a date of " + pt.toISO()) : pt;
  }, r.fromISO = function(i, d) {
    d === void 0 && (d = {});
    var m = uYe(i), v = m[0], g = m[1];
    return qL(v, g, d, "ISO 8601", i);
  }, r.fromRFC2822 = function(i, d) {
    d === void 0 && (d = {});
    var m = dYe(i), v = m[0], g = m[1];
    return qL(v, g, d, "RFC 2822", i);
  }, r.fromHTTP = function(i, d) {
    d === void 0 && (d = {});
    var m = fYe(i), v = m[0], g = m[1];
    return qL(v, g, d, "HTTP", d);
  }, r.fromFormat = function(i, d, m) {
    if (m === void 0 && (m = {}), Ka(i) || Ka(d))
      throw new dy("fromFormat requires an input string and a format");
    var v = m, g = v.locale, C = g === void 0 ? null : g, O = v.numberingSystem, R = O === void 0 ? null : O, I = Zf.fromOpts({
      locale: C,
      numberingSystem: R,
      defaultToEN: !0
    }), L = jYe(I, i, d), Z = L[0], ne = L[1], se = L[2];
    return se ? r.invalid(se) : qL(Z, ne, m, "format " + d, i);
  }, r.fromString = function(i, d, m) {
    return m === void 0 && (m = {}), r.fromFormat(i, d, m);
  }, r.fromSQL = function(i, d) {
    d === void 0 && (d = {});
    var m = SYe(i), v = m[0], g = m[1];
    return qL(v, g, d, "SQL", i);
  }, r.invalid = function(i, d) {
    if (d === void 0 && (d = null), !i)
      throw new dy("need to specify a reason the DateTime is invalid");
    var m = i instanceof w1 ? i : new w1(i, d);
    if (Zu.throwOnInvalid)
      throw new nKe(m);
    return new r({
      invalid: m
    });
  }, r.isDateTime = function(i) {
    return i && i.isLuxonDateTime || !1;
  };
  var o = r.prototype;
  return o.get = function(i) {
    return this[i];
  }, o.resolvedLocaleOpts = function(i) {
    i === void 0 && (i = {});
    var d = IS.create(this.loc.clone(i), i).resolvedOptions(this), m = d.locale, v = d.numberingSystem, g = d.calendar;
    return {
      locale: m,
      numberingSystem: v,
      outputCalendar: g
    };
  }, o.toUTC = function(i, d) {
    return i === void 0 && (i = 0), d === void 0 && (d = {}), this.setZone(Dv.instance(i), d);
  }, o.toLocal = function() {
    return this.setZone(Zu.defaultZone);
  }, o.setZone = function(i, d) {
    var m = d === void 0 ? {} : d, v = m.keepLocalTime, g = v === void 0 ? !1 : v, C = m.keepCalendarTime, O = C === void 0 ? !1 : C;
    if (i = FA(i, Zu.defaultZone), i.equals(this.zone))
      return this;
    if (i.isValid) {
      var R = this.ts;
      if (g || O) {
        var I = i.offset(this.ts), L = this.toObject(), Z = TW(L, I, i);
        R = Z[0];
      }
      return jL(this, {
        ts: R,
        zone: i
      });
    } else
      return r.invalid(iW(i));
  }, o.reconfigure = function(i) {
    var d = i === void 0 ? {} : i, m = d.locale, v = d.numberingSystem, g = d.outputCalendar, C = this.loc.clone({
      locale: m,
      numberingSystem: v,
      outputCalendar: g
    });
    return jL(this, {
      loc: C
    });
  }, o.setLocale = function(i) {
    return this.reconfigure({
      locale: i
    });
  }, o.set = function(i) {
    if (!this.isValid)
      return this;
    var d = aj(i, dpe, []), m = !Ka(d.weekYear) || !Ka(d.weekNumber) || !Ka(d.weekday), v = !Ka(d.ordinal), g = !Ka(d.year), C = !Ka(d.month) || !Ka(d.day), O = g || C, R = d.weekYear || d.weekNumber;
    if ((O || v) && R)
      throw new QL("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
    if (C && v)
      throw new QL("Can't mix ordinal dates with month/day");
    var I;
    m ? I = spe(Object.assign(Jse(this.c), d)) : Ka(d.ordinal) ? (I = Object.assign(this.toObject(), d), Ka(d.day) && (I.day = Math.min(oj(I.year, I.month), I.day))) : I = ape(Object.assign(Yoe(this.c), d));
    var L = TW(I, this.o, this.zone), Z = L[0], ne = L[1];
    return jL(this, {
      ts: Z,
      o: ne
    });
  }, o.plus = function(i) {
    if (!this.isValid)
      return this;
    var d = jA(i);
    return jL(this, lpe(this, d));
  }, o.minus = function(i) {
    if (!this.isValid)
      return this;
    var d = jA(i).negate();
    return jL(this, lpe(this, d));
  }, o.startOf = function(i) {
    if (!this.isValid)
      return this;
    var d = {}, m = kh.normalizeUnit(i);
    switch (m) {
      case "years":
        d.month = 1;
      case "quarters":
      case "months":
        d.day = 1;
      case "weeks":
      case "days":
        d.hour = 0;
      case "hours":
        d.minute = 0;
      case "minutes":
        d.second = 0;
      case "seconds":
        d.millisecond = 0;
        break;
    }
    if (m === "weeks" && (d.weekday = 1), m === "quarters") {
      var v = Math.ceil(this.month / 3);
      d.month = (v - 1) * 3 + 1;
    }
    return this.set(d);
  }, o.endOf = function(i) {
    var d;
    return this.isValid ? this.plus((d = {}, d[i] = 1, d)).startOf(i).minus(1) : this;
  }, o.toFormat = function(i, d) {
    return d === void 0 && (d = {}), this.isValid ? IS.create(this.loc.redefaultToEN(d)).formatDateTimeFromString(this, i) : Qoe;
  }, o.toLocaleString = function(i) {
    return i === void 0 && (i = rj), this.isValid ? IS.create(this.loc.clone(i), i).formatDateTime(this) : Qoe;
  }, o.toLocaleParts = function(i) {
    return i === void 0 && (i = {}), this.isValid ? IS.create(this.loc.clone(i), i).formatDateTimeParts(this) : [];
  }, o.toISO = function(i) {
    return i === void 0 && (i = {}), this.isValid ? this.toISODate(i) + "T" + this.toISOTime(i) : null;
  }, o.toISODate = function(i) {
    var d = i === void 0 ? {} : i, m = d.format, v = m === void 0 ? "extended" : m, g = v === "basic" ? "yyyyMMdd" : "yyyy-MM-dd";
    return this.year > 9999 && (g = "+" + g), BD(this, g);
  }, o.toISOWeekDate = function() {
    return BD(this, "kkkk-'W'WW-c");
  }, o.toISOTime = function(i) {
    var d = i === void 0 ? {} : i, m = d.suppressMilliseconds, v = m === void 0 ? !1 : m, g = d.suppressSeconds, C = g === void 0 ? !1 : g, O = d.includeOffset, R = O === void 0 ? !0 : O, I = d.includePrefix, L = I === void 0 ? !1 : I, Z = d.format, ne = Z === void 0 ? "extended" : Z;
    return upe(this, {
      suppressSeconds: C,
      suppressMilliseconds: v,
      includeOffset: R,
      includePrefix: L,
      format: ne
    });
  }, o.toRFC2822 = function() {
    return BD(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", !1);
  }, o.toHTTP = function() {
    return BD(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }, o.toSQLDate = function() {
    return BD(this, "yyyy-MM-dd");
  }, o.toSQLTime = function(i) {
    var d = i === void 0 ? {} : i, m = d.includeOffset, v = m === void 0 ? !0 : m, g = d.includeZone, C = g === void 0 ? !1 : g;
    return upe(this, {
      includeOffset: v,
      includeZone: C,
      spaceZone: !0
    });
  }, o.toSQL = function(i) {
    return i === void 0 && (i = {}), this.isValid ? this.toSQLDate() + " " + this.toSQLTime(i) : null;
  }, o.toString = function() {
    return this.isValid ? this.toISO() : Qoe;
  }, o.valueOf = function() {
    return this.toMillis();
  }, o.toMillis = function() {
    return this.isValid ? this.ts : NaN;
  }, o.toSeconds = function() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }, o.toJSON = function() {
    return this.toISO();
  }, o.toBSON = function() {
    return this.toJSDate();
  }, o.toObject = function(i) {
    if (i === void 0 && (i = {}), !this.isValid)
      return {};
    var d = Object.assign({}, this.c);
    return i.includeConfig && (d.outputCalendar = this.outputCalendar, d.numberingSystem = this.loc.numberingSystem, d.locale = this.loc.locale), d;
  }, o.toJSDate = function() {
    return new Date(this.isValid ? this.ts : NaN);
  }, o.diff = function(i, d, m) {
    if (d === void 0 && (d = "milliseconds"), m === void 0 && (m = {}), !this.isValid || !i.isValid)
      return kh.invalid(this.invalid || i.invalid, "created by diffing an invalid DateTime");
    var v = Object.assign({
      locale: this.locale,
      numberingSystem: this.numberingSystem
    }, m), g = iKe(d).map(kh.normalizeUnit), C = i.valueOf() > this.valueOf(), O = C ? this : i, R = C ? i : this, I = kYe(O, R, g, v);
    return C ? I.negate() : I;
  }, o.diffNow = function(i, d) {
    return i === void 0 && (i = "milliseconds"), d === void 0 && (d = {}), this.diff(r.now(), i, d);
  }, o.until = function(i) {
    return this.isValid ? dB.fromDateTimes(this, i) : this;
  }, o.hasSame = function(i, d) {
    if (!this.isValid)
      return !1;
    var m = i.valueOf(), v = this.setZone(i.zone, {
      keepLocalTime: !0
    });
    return v.startOf(d) <= m && m <= v.endOf(d);
  }, o.equals = function(i) {
    return this.isValid && i.isValid && this.valueOf() === i.valueOf() && this.zone.equals(i.zone) && this.loc.equals(i.loc);
  }, o.toRelative = function(i) {
    if (i === void 0 && (i = {}), !this.isValid)
      return null;
    var d = i.base || r.fromObject({
      zone: this.zone
    }), m = i.padding ? this < d ? -i.padding : i.padding : 0, v = ["years", "months", "days", "hours", "minutes", "seconds"], g = i.unit;
    return Array.isArray(i.unit) && (v = i.unit, g = void 0), mpe(d, this.plus(m), Object.assign(i, {
      numeric: "always",
      units: v,
      unit: g
    }));
  }, o.toRelativeCalendar = function(i) {
    return i === void 0 && (i = {}), this.isValid ? mpe(i.base || r.fromObject({
      zone: this.zone
    }), this, Object.assign(i, {
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: !0
    })) : null;
  }, r.min = function() {
    for (var i = arguments.length, d = new Array(i), m = 0; m < i; m++)
      d[m] = arguments[m];
    if (!d.every(r.isDateTime))
      throw new dy("min requires all arguments be DateTimes");
    return qme(d, function(v) {
      return v.valueOf();
    }, Math.min);
  }, r.max = function() {
    for (var i = arguments.length, d = new Array(i), m = 0; m < i; m++)
      d[m] = arguments[m];
    if (!d.every(r.isDateTime))
      throw new dy("max requires all arguments be DateTimes");
    return qme(d, function(v) {
      return v.valueOf();
    }, Math.max);
  }, r.fromFormatExplain = function(i, d, m) {
    m === void 0 && (m = {});
    var v = m, g = v.locale, C = g === void 0 ? null : g, O = v.numberingSystem, R = O === void 0 ? null : O, I = Zf.fromOpts({
      locale: C,
      numberingSystem: R,
      defaultToEN: !0
    });
    return r1e(I, i, d);
  }, r.fromStringExplain = function(i, d, m) {
    return m === void 0 && (m = {}), r.fromFormatExplain(i, d, m);
  }, k1(r, [{
    key: "isValid",
    get: function() {
      return this.invalid === null;
    }
    /**
     * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
     * @type {string}
     */
  }, {
    key: "invalidReason",
    get: function() {
      return this.invalid ? this.invalid.reason : null;
    }
    /**
     * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
     * @type {string}
     */
  }, {
    key: "invalidExplanation",
    get: function() {
      return this.invalid ? this.invalid.explanation : null;
    }
    /**
     * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
     *
     * @type {string}
     */
  }, {
    key: "locale",
    get: function() {
      return this.isValid ? this.loc.locale : null;
    }
    /**
     * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
     *
     * @type {string}
     */
  }, {
    key: "numberingSystem",
    get: function() {
      return this.isValid ? this.loc.numberingSystem : null;
    }
    /**
     * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
     *
     * @type {string}
     */
  }, {
    key: "outputCalendar",
    get: function() {
      return this.isValid ? this.loc.outputCalendar : null;
    }
    /**
     * Get the time zone associated with this DateTime.
     * @type {Zone}
     */
  }, {
    key: "zone",
    get: function() {
      return this._zone;
    }
    /**
     * Get the name of the time zone.
     * @type {string}
     */
  }, {
    key: "zoneName",
    get: function() {
      return this.isValid ? this.zone.name : null;
    }
    /**
     * Get the year
     * @example DateTime.local(2017, 5, 25).year //=> 2017
     * @type {number}
     */
  }, {
    key: "year",
    get: function() {
      return this.isValid ? this.c.year : NaN;
    }
    /**
     * Get the quarter
     * @example DateTime.local(2017, 5, 25).quarter //=> 2
     * @type {number}
     */
  }, {
    key: "quarter",
    get: function() {
      return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
    }
    /**
     * Get the month (1-12).
     * @example DateTime.local(2017, 5, 25).month //=> 5
     * @type {number}
     */
  }, {
    key: "month",
    get: function() {
      return this.isValid ? this.c.month : NaN;
    }
    /**
     * Get the day of the month (1-30ish).
     * @example DateTime.local(2017, 5, 25).day //=> 25
     * @type {number}
     */
  }, {
    key: "day",
    get: function() {
      return this.isValid ? this.c.day : NaN;
    }
    /**
     * Get the hour of the day (0-23).
     * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
     * @type {number}
     */
  }, {
    key: "hour",
    get: function() {
      return this.isValid ? this.c.hour : NaN;
    }
    /**
     * Get the minute of the hour (0-59).
     * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
     * @type {number}
     */
  }, {
    key: "minute",
    get: function() {
      return this.isValid ? this.c.minute : NaN;
    }
    /**
     * Get the second of the minute (0-59).
     * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
     * @type {number}
     */
  }, {
    key: "second",
    get: function() {
      return this.isValid ? this.c.second : NaN;
    }
    /**
     * Get the millisecond of the second (0-999).
     * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
     * @type {number}
     */
  }, {
    key: "millisecond",
    get: function() {
      return this.isValid ? this.c.millisecond : NaN;
    }
    /**
     * Get the week year
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
     * @type {number}
     */
  }, {
    key: "weekYear",
    get: function() {
      return this.isValid ? Xoe(this).weekYear : NaN;
    }
    /**
     * Get the week number of the week year (1-52ish).
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
     * @type {number}
     */
  }, {
    key: "weekNumber",
    get: function() {
      return this.isValid ? Xoe(this).weekNumber : NaN;
    }
    /**
     * Get the day of the week.
     * 1 is Monday and 7 is Sunday
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2014, 11, 31).weekday //=> 4
     * @type {number}
     */
  }, {
    key: "weekday",
    get: function() {
      return this.isValid ? Xoe(this).weekday : NaN;
    }
    /**
     * Get the ordinal (meaning the day of the year)
     * @example DateTime.local(2017, 5, 25).ordinal //=> 145
     * @type {number|DateTime}
     */
  }, {
    key: "ordinal",
    get: function() {
      return this.isValid ? Yoe(this.c).ordinal : NaN;
    }
    /**
     * Get the human readable short month name, such as 'Oct'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
     * @type {string}
     */
  }, {
    key: "monthShort",
    get: function() {
      return this.isValid ? XL.months("short", {
        locObj: this.loc
      })[this.month - 1] : null;
    }
    /**
     * Get the human readable long month name, such as 'October'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).monthLong //=> October
     * @type {string}
     */
  }, {
    key: "monthLong",
    get: function() {
      return this.isValid ? XL.months("long", {
        locObj: this.loc
      })[this.month - 1] : null;
    }
    /**
     * Get the human readable short weekday, such as 'Mon'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
     * @type {string}
     */
  }, {
    key: "weekdayShort",
    get: function() {
      return this.isValid ? XL.weekdays("short", {
        locObj: this.loc
      })[this.weekday - 1] : null;
    }
    /**
     * Get the human readable long weekday, such as 'Monday'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
     * @type {string}
     */
  }, {
    key: "weekdayLong",
    get: function() {
      return this.isValid ? XL.weekdays("long", {
        locObj: this.loc
      })[this.weekday - 1] : null;
    }
    /**
     * Get the UTC offset of this DateTime in minutes
     * @example DateTime.now().offset //=> -240
     * @example DateTime.utc().offset //=> 0
     * @type {number}
     */
  }, {
    key: "offset",
    get: function() {
      return this.isValid ? +this.o : NaN;
    }
    /**
     * Get the short human name for the zone's current offset, for example "EST" or "EDT".
     * Defaults to the system's locale if no locale has been specified
     * @type {string}
     */
  }, {
    key: "offsetNameShort",
    get: function() {
      return this.isValid ? this.zone.offsetName(this.ts, {
        format: "short",
        locale: this.locale
      }) : null;
    }
    /**
     * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
     * Defaults to the system's locale if no locale has been specified
     * @type {string}
     */
  }, {
    key: "offsetNameLong",
    get: function() {
      return this.isValid ? this.zone.offsetName(this.ts, {
        format: "long",
        locale: this.locale
      }) : null;
    }
    /**
     * Get whether this zone's offset ever changes, as in a DST.
     * @type {boolean}
     */
  }, {
    key: "isOffsetFixed",
    get: function() {
      return this.isValid ? this.zone.universal : null;
    }
    /**
     * Get whether the DateTime is in a DST.
     * @type {boolean}
     */
  }, {
    key: "isInDST",
    get: function() {
      return this.isOffsetFixed ? !1 : this.offset > this.set({
        month: 1
      }).offset || this.offset > this.set({
        month: 5
      }).offset;
    }
    /**
     * Returns true if this DateTime is in a leap year, false otherwise
     * @example DateTime.local(2016).isInLeapYear //=> true
     * @example DateTime.local(2013).isInLeapYear //=> false
     * @type {boolean}
     */
  }, {
    key: "isInLeapYear",
    get: function() {
      return o5(this.year);
    }
    /**
     * Returns the number of days in this DateTime's month
     * @example DateTime.local(2016, 2).daysInMonth //=> 29
     * @example DateTime.local(2016, 3).daysInMonth //=> 31
     * @type {number}
     */
  }, {
    key: "daysInMonth",
    get: function() {
      return oj(this.year, this.month);
    }
    /**
     * Returns the number of days in this DateTime's year
     * @example DateTime.local(2016).daysInYear //=> 366
     * @example DateTime.local(2013).daysInYear //=> 365
     * @type {number}
     */
  }, {
    key: "daysInYear",
    get: function() {
      return this.isValid ? uB(this.year) : NaN;
    }
    /**
     * Returns the number of weeks in this DateTime's year
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2004).weeksInWeekYear //=> 53
     * @example DateTime.local(2013).weeksInWeekYear //=> 52
     * @type {number}
     */
  }, {
    key: "weeksInWeekYear",
    get: function() {
      return this.isValid ? sj(this.weekYear) : NaN;
    }
  }], [{
    key: "DATE_SHORT",
    get: function() {
      return rj;
    }
    /**
     * {@link toLocaleString} format like 'Oct 14, 1983'
     * @type {Object}
     */
  }, {
    key: "DATE_MED",
    get: function() {
      return zie;
    }
    /**
     * {@link toLocaleString} format like 'Fri, Oct 14, 1983'
     * @type {Object}
     */
  }, {
    key: "DATE_MED_WITH_WEEKDAY",
    get: function() {
      return Pye;
    }
    /**
     * {@link toLocaleString} format like 'October 14, 1983'
     * @type {Object}
     */
  }, {
    key: "DATE_FULL",
    get: function() {
      return Vie;
    }
    /**
     * {@link toLocaleString} format like 'Tuesday, October 14, 1983'
     * @type {Object}
     */
  }, {
    key: "DATE_HUGE",
    get: function() {
      return Uie;
    }
    /**
     * {@link toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
  }, {
    key: "TIME_SIMPLE",
    get: function() {
      return Wie;
    }
    /**
     * {@link toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
  }, {
    key: "TIME_WITH_SECONDS",
    get: function() {
      return jie;
    }
    /**
     * {@link toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
     * @type {Object}
     */
  }, {
    key: "TIME_WITH_SHORT_OFFSET",
    get: function() {
      return qie;
    }
    /**
     * {@link toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
     * @type {Object}
     */
  }, {
    key: "TIME_WITH_LONG_OFFSET",
    get: function() {
      return Gie;
    }
    /**
     * {@link toLocaleString} format like '09:30', always 24-hour.
     * @type {Object}
     */
  }, {
    key: "TIME_24_SIMPLE",
    get: function() {
      return Zie;
    }
    /**
     * {@link toLocaleString} format like '09:30:23', always 24-hour.
     * @type {Object}
     */
  }, {
    key: "TIME_24_WITH_SECONDS",
    get: function() {
      return Kie;
    }
    /**
     * {@link toLocaleString} format like '09:30:23 EDT', always 24-hour.
     * @type {Object}
     */
  }, {
    key: "TIME_24_WITH_SHORT_OFFSET",
    get: function() {
      return Yie;
    }
    /**
     * {@link toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
     * @type {Object}
     */
  }, {
    key: "TIME_24_WITH_LONG_OFFSET",
    get: function() {
      return Qie;
    }
    /**
     * {@link toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
  }, {
    key: "DATETIME_SHORT",
    get: function() {
      return Xie;
    }
    /**
     * {@link toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
  }, {
    key: "DATETIME_SHORT_WITH_SECONDS",
    get: function() {
      return Jie;
    }
    /**
     * {@link toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
  }, {
    key: "DATETIME_MED",
    get: function() {
      return ece;
    }
    /**
     * {@link toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
  }, {
    key: "DATETIME_MED_WITH_SECONDS",
    get: function() {
      return tce;
    }
    /**
     * {@link toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
  }, {
    key: "DATETIME_MED_WITH_WEEKDAY",
    get: function() {
      return Dye;
    }
    /**
     * {@link toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
     * @type {Object}
     */
  }, {
    key: "DATETIME_FULL",
    get: function() {
      return nce;
    }
    /**
     * {@link toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
     * @type {Object}
     */
  }, {
    key: "DATETIME_FULL_WITH_SECONDS",
    get: function() {
      return rce;
    }
    /**
     * {@link toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
     * @type {Object}
     */
  }, {
    key: "DATETIME_HUGE",
    get: function() {
      return oce;
    }
    /**
     * {@link toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
     * @type {Object}
     */
  }, {
    key: "DATETIME_HUGE_WITH_SECONDS",
    get: function() {
      return sce;
    }
  }]), r;
}();
function GL(r) {
  if (Ad.isDateTime(r))
    return r;
  if (r && r.valueOf && xk(r.valueOf()))
    return Ad.fromJSDate(r);
  if (r && typeof r == "object")
    return Ad.fromObject(r);
  throw new dy("Unknown datetime argument: " + r + ", of type " + typeof r);
}
var XYe = "1.28.1";
Uv.DateTime = Ad;
Uv.Duration = kh;
Uv.FixedOffsetZone = Dv;
Uv.IANAZone = LS;
Uv.Info = XL;
Uv.Interval = dB;
Uv.InvalidZone = Zse;
Uv.LocalZone = qye;
Uv.Settings = Zu;
Uv.VERSION = XYe;
Uv.Zone = fI;
Object.defineProperty(Ko, "__esModule", { value: !0 });
var ha = ae, Kn = gUe, JYe = vUe, eQe = bUe, tQe = pWe, nQe = nq, rQe = wge, oQe = lie, rs = cqe, sQe = Zqe, aQe = yGe, iQe = xGe, cQe = ZGe, lQe = NZe, uQe = Oye, dQe = YZe, fQe = $h, mQe = Uv, pQe = Fve;
function Ih(r) {
  return r && typeof r == "object" && "default" in r ? r : { default: r };
}
var ot = /* @__PURE__ */ Ih(ha), mce = /* @__PURE__ */ Ih(JYe), p1e = /* @__PURE__ */ Ih(eQe), hQe = /* @__PURE__ */ Ih(tQe), eae = /* @__PURE__ */ Ih(nQe), Tk = /* @__PURE__ */ Ih(rQe), v2 = /* @__PURE__ */ Ih(oQe), h1e = /* @__PURE__ */ Ih(sQe), gQe = /* @__PURE__ */ Ih(aQe), vQe = /* @__PURE__ */ Ih(iQe), bQe = /* @__PURE__ */ Ih(cQe), ppe = /* @__PURE__ */ Ih(lQe), yQe = /* @__PURE__ */ Ih(uQe), SQe = /* @__PURE__ */ Ih(fQe), wQe = /* @__PURE__ */ Ih(pQe);
class pce extends ha.Component {
  render() {
    const {
      popupId: o,
      size: c,
      trigger: i,
      content: d,
      position: m,
      inverted: v,
      ariaLabel: g,
      hoverable: C
    } = this.props;
    return /* @__PURE__ */ ot.default.createElement(Kn.Popup, {
      id: o,
      size: c,
      position: m,
      inverted: v,
      hoverable: C,
      on: ["hover", "focus"],
      trigger: /* @__PURE__ */ ot.default.cloneElement(i, {
        role: "button",
        tabIndex: 0,
        "aria-label": g
      }),
      content: /* @__PURE__ */ ot.default.createElement("p", {
        role: "tooltip",
        "aria-live": "polite"
      }, d)
    });
  }
}
pce.defaultProps = {
  inverted: !1,
  position: "top left",
  size: "small",
  hoverable: !0
};
class gq extends ha.Component {
  constructor() {
    super(...arguments), this.myRef = /* @__PURE__ */ ot.default.createRef(), this.setSrc = function(o, c) {
      if ((arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1) ? o.classList.contains("fallback_image") || (o.className += " fallback_image") : o.classList.contains("fallback_image") && o.classList.remove("fallback_image"), o.nodeName !== "IMG") {
        const d = o.querySelector("img");
        if (!d)
          throw Error("No img tag found");
        o = d;
      }
      o.src = c;
    };
  }
  async componentDidMount() {
    const {
      fallbackSrc: o,
      loadFallbackFirst: c,
      src: i
    } = this.props;
    if (c)
      try {
        await mce.default.get(i), this.setSrc(this.myRef.current, i);
      } catch {
        console.warn(`
        '${i}' couldn't be resolved. '${o}' will be used instead.`);
      }
  }
  render() {
    const {
      alt: o,
      className: c,
      src: i,
      fallbackSrc: d,
      loadFallbackFirst: m,
      ...v
    } = this.props, g = m ? `${c} fallback_image` : `${c} placeholder`, C = m ? d : i;
    return /* @__PURE__ */ ot.default.createElement(Kn.Ref, {
      innerRef: this.myRef
    }, /* @__PURE__ */ ot.default.createElement(Kn.Image, Object.assign({
      className: g,
      alt: o,
      src: C
    }, !m && {
      onError: (O) => {
        let {
          currentTarget: R
        } = O;
        R.onerror = null, this.setSrc(R, d, !0);
      },
      onLoad: () => {
        m || this.myRef.current.classList.remove("placeholder");
      }
    }, v)));
  }
}
gq.defaultProps = {
  className: "",
  alt: "No image found",
  fallbackSrc: "/static/images/square-placeholder.png",
  loadFallbackFirst: !1
};
const tae = (r) => {
  let o, c;
  switch (r.scheme) {
    case "orcid":
      o = "/static/images/orcid.svg", c = `https://orcid.org/${r.identifier}`;
      break;
    case "gnd":
      o = "/static/images/gnd-icon.svg", c = `https://d-nb.info/gnd/${r.identifier}`;
      break;
    case "ror":
    case "isni":
    case "grid":
      return;
    default:
      return /* @__PURE__ */ ot.default.createElement(ot.default.Fragment, null, r.scheme, ": ", r.identifier);
  }
  return /* @__PURE__ */ ot.default.createElement("span", {
    key: r.identifier
  }, /* @__PURE__ */ ot.default.createElement("a", {
    href: c,
    target: "_blank",
    rel: "noopener noreferrer"
  }, /* @__PURE__ */ ot.default.createElement(gq, {
    src: o,
    className: "inline-id-icon mr-5",
    verticalAlign: "middle"
  }), r.scheme === "orcid" && r.identifier));
}, nae = (r, o) => {
  if (o) {
    var c, i, d, m;
    const C = (c = [r == null ? void 0 : r.location_name, r == null ? void 0 : r.country_name]) === null || c === void 0 || (i = c.filter(Boolean)) === null || i === void 0 ? void 0 : i.join(", "), O = r == null || (d = r.types) === null || d === void 0 || (m = d.map((R) => R.charAt(0).toUpperCase() + R.slice(1))) === null || m === void 0 ? void 0 : m.join(", ");
    return `${C || ""}${C && O ? "  " : ""}${O || ""}`.trim();
  } else {
    var v, g;
    return (r == null || (v = r.affiliations) === null || v === void 0 || (g = v.map((C) => {
      var O;
      return ((O = C.acronym) === null || O === void 0 ? void 0 : O.length) > 0 ? `${C.name} (${C.acronym})` : C.name;
    })) === null || g === void 0 ? void 0 : g.join(", ")) || "";
  }
}, EQe = (r, o) => r.map((i) => {
  var d;
  i.affiliations = i.affiliations || [], i.identifiers = i.identifiers || [];
  const m = nae(i, o);
  let v = i.name;
  i.acronym && (v += ` (${i.acronym})`);
  const g = [];
  return (d = i.identifiers) === null || d === void 0 || d.forEach((C) => {
    const O = tae(C);
    O && g.push(O);
  }), {
    text: i.name,
    value: i.id || i.name,
    name: i.name,
    extra: i,
    id: i.id,
    key: i.id,
    // Needed by RemoteSelectField to filter out unique values
    content: /* @__PURE__ */ ot.default.createElement(p1e.default, {
      id: "ReactInvenioForms.AffiliationsSuggestions.content",
      key: i.id,
      creatibutor: i,
      isOrganization: o,
      idString: g,
      makeSubheader: nae,
      makeIdEntry: tae
    }, /* @__PURE__ */ ot.default.createElement(Kn.Header, null, v, " ", g.length > 0 && /* @__PURE__ */ ot.default.createElement(ot.default.Fragment, null, "(", g, ")"), m.length > 0 && /* @__PURE__ */ ot.default.createElement(Kn.Header.Subheader, null, m)))
  };
});
class g1e extends ha.Component {
  render() {
    const {
      id: o,
      user: c,
      linkToDetailView: i
    } = this.props, d = c.profile.full_name || c.username;
    return /* @__PURE__ */ ot.default.createElement(Kn.Item, {
      className: "flex",
      key: o
    }, /* @__PURE__ */ ot.default.createElement(gq, {
      src: c.links.avatar,
      avatar: !0,
      loadFallbackFirst: !0
    }), /* @__PURE__ */ ot.default.createElement(Kn.Item.Content, {
      className: "ml-10"
    }, /* @__PURE__ */ ot.default.createElement(Kn.Item.Header, {
      className: c.description ? "" : "mt-5"
    }, i ? /* @__PURE__ */ ot.default.createElement("a", {
      href: i
    }, /* @__PURE__ */ ot.default.createElement("b", null, d)) : /* @__PURE__ */ ot.default.createElement("b", null, d), c.type === "group" && /* @__PURE__ */ ot.default.createElement(Kn.Label, {
      className: "ml-10"
    }, "Group"), c.is_current_user && /* @__PURE__ */ ot.default.createElement(Kn.Label, {
      size: "tiny",
      className: "primary ml-10"
    }, "You")), /* @__PURE__ */ ot.default.createElement(Kn.Item.Meta, null, /* @__PURE__ */ ot.default.createElement("div", {
      className: "truncate-lines-1"
    }, " ", c.profile.affiliations))));
  }
}
g1e.defaultProps = {
  linkToDetailView: void 0
};
const s5 = /* @__PURE__ */ ot.default.createContext({
  bulkActionContext: {},
  addToSelected: () => {
  },
  allSelected: !1,
  setAllSelected: () => {
  },
  selectedCount: 0
});
class hce extends ha.Component {
  constructor(o) {
    super(o), this.handleOnChange = () => {
      const {
        setAllSelected: i,
        allSelected: d
      } = this.context;
      this.setState({
        allSelectedChecked: !d
      }), i(!d, !0);
    }, this.handleActionOnChange = (i, d) => {
      let {
        value: m,
        ...v
      } = d;
      if (!m)
        return;
      const {
        optionSelectionCallback: g
      } = this.props, {
        selectedCount: C,
        bulkActionContext: O
      } = this.context, R = hQe.default(O, (I) => {
        let {
          selected: L
        } = I;
        return L === !0;
      });
      g(m, R, C);
    };
    const {
      allSelected: c
    } = this.props;
    this.state = {
      allSelectedChecked: c
    };
  }
  componentDidMount() {
    const {
      allSelected: o
    } = this.context;
    this.setState({
      allSelectedChecked: o
    });
  }
  render() {
    const {
      bulkDropdownOptions: o
    } = this.props, {
      allSelectedChecked: c
    } = this.state, {
      allSelected: i,
      selectedCount: d
    } = this.context, m = d === 0, v = o.map((g) => {
      let {
        key: C,
        value: O,
        text: R
      } = g;
      return {
        key: C,
        value: O,
        text: R,
        disabled: m
      };
    });
    return /* @__PURE__ */ ot.default.createElement("div", {
      className: "flex"
    }, /* @__PURE__ */ ot.default.createElement(Kn.Checkbox, {
      className: "align-self-center mr-10",
      onChange: this.handleOnChange,
      checked: c && i
    }), /* @__PURE__ */ ot.default.createElement(Kn.Dropdown, {
      className: "align-self-center fluid-responsive",
      text: `${d} members selected`,
      options: v,
      "aria-label": "bulk actions",
      item: !0,
      selection: !0,
      value: null,
      selectOnBlur: !1,
      onChange: this.handleActionOnChange,
      selectOnNavigation: !1
    }));
  }
}
hce.contextType = s5;
hce.defaultProps = {
  allSelected: !1
};
class v1e extends ha.Component {
  constructor(o) {
    var c;
    super(o), c = this, this.addToSelected = (i, d) => {
      const {
        selectedCount: m
      } = this.state;
      if (eae.default(this.selected, `${i}`) ? this.selected[i].selected = !this.selected[i].selected : (this.selected[i].selected = !0, this.selected[i].data = d), !this.selected[i].selected)
        this.setAllSelected(!1), this.setSelectedCount(m - 1);
      else {
        const v = m + 1;
        this.setSelectedCount(v), Object.keys(this.selected).length === v && this.setAllSelected(!0);
      }
    }, this.setSelectedCount = (i) => {
      this.setState({
        selectedCount: i
      });
    }, this.setAllSelected = function(i) {
      let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
      if (c.setState({
        allSelected: i
      }), d) {
        for (const [m] of Object.entries(c.selected))
          c.selected[m].selected = i;
        i ? c.setSelectedCount(Object.keys(c.selected).length) : c.setSelectedCount(0);
      }
    }, this.selected = {}, this.state = {
      allSelected: !1,
      selectedCount: 0
    };
  }
  render() {
    const {
      children: o
    } = this.props, {
      allSelected: c,
      selectedCount: i
    } = this.state;
    return /* @__PURE__ */ ot.default.createElement(s5.Provider, {
      value: {
        bulkActionContext: this.selected,
        addToSelected: this.addToSelected,
        setAllSelected: this.setAllSelected,
        allSelected: c,
        selectedCount: i
      }
    }, o);
  }
}
v1e.contextType = s5;
class b1e extends ha.Component {
  constructor(o) {
    super(o), this.isChecked = (c, i) => {
      const {
        rowId: d
      } = this.props;
      return eae.default(c, `${d}`) || i ? c[d].selected : !1;
    }, this.subscribeToContext = () => {
      const {
        rowId: c,
        data: i
      } = this.props, {
        allSelected: d,
        bulkActionContext: m
      } = this.context;
      eae.default(m, `${c}`) || (m[c] = {
        selected: d,
        data: i
      });
    }, this.handleOnChange = () => {
      const {
        addToSelected: c
      } = this.context, {
        rowId: i,
        data: d
      } = this.props, {
        isChecked: m
      } = this.state;
      this.setState({
        isChecked: !m
      }), c(i, d);
    }, this.state = {
      isChecked: !1
    };
  }
  componentDidMount() {
    this.subscribeToContext();
    const {
      bulkActionContext: o,
      allSelected: c
    } = this.context;
    this.setState({
      isChecked: this.isChecked(o, c)
    });
  }
  render() {
    const {
      bulkActionContext: o,
      allSelected: c
    } = this.context;
    return /* @__PURE__ */ ot.default.createElement(Kn.Checkbox, {
      className: "mt-auto mb-auto ",
      checked: this.isChecked(o, c) || c,
      onChange: this.handleOnChange
    });
  }
}
b1e.contextType = s5;
class y1e extends ot.default.Component {
  render() {
    const o = /* @__PURE__ */ ot.default.createRef(), {
      mobile: c,
      tablet: i,
      computer: d,
      widescreen: m,
      largeScreen: v,
      width: g,
      open: C,
      onHideClick: O,
      children: R,
      ariaLabel: I
    } = this.props;
    return /* @__PURE__ */ ot.default.createElement(ot.default.Fragment, null, /* @__PURE__ */ ot.default.createElement(Kn.Grid.Column, {
      as: "aside",
      "aria-label": I,
      mobile: c,
      tablet: i,
      width: g,
      only: "mobile tablet"
    }, /* @__PURE__ */ ot.default.createElement(Kn.Sidebar, {
      as: Kn.Segment,
      animation: "overlay",
      visible: C,
      width: "wide",
      onHide: O,
      onShow: () => o.current.focus()
    }, /* @__PURE__ */ ot.default.createElement(Kn.Button, {
      basic: !0,
      icon: "close",
      size: "small",
      floated: "right",
      onClick: O,
      "aria-label": "Close filter",
      ref: o,
      className: "mb-20"
    }), R)), /* @__PURE__ */ ot.default.createElement(Kn.Grid.Column, {
      as: "aside",
      "aria-label": I,
      width: g,
      only: "computer",
      computer: d,
      largeScreen: v,
      widescreen: m
    }, R));
  }
}
y1e.defaultProps = {
  width: void 0,
  mobile: void 0,
  tablet: void 0,
  computer: void 0,
  widescreen: void 0,
  largeScreen: void 0,
  ariaLabel: void 0
};
const CQe = (r) => {
  let {
    fieldErrors: o
  } = r;
  return /* @__PURE__ */ ot.default.createElement(Kn.Message.List, null, o.map((c) => /* @__PURE__ */ ot.default.createElement(Kn.Message.Item, {
    key: c
  }, c.field && c.field !== "_schema" && /* @__PURE__ */ ot.default.createElement("strong", null, c.field, ": "), c.message ? c.message : c.messages && c.messages.length === 1 ? c.messages[0] : /* @__PURE__ */ ot.default.createElement(Kn.Message.List, null, c.messages.map((i) => /* @__PURE__ */ ot.default.createElement(Kn.Message.Item, {
    key: i
  }, i))))));
};
class S1e extends ha.Component {
  render() {
    const {
      header: o,
      errors: c,
      content: i,
      icon: d,
      ...m
    } = this.props;
    return /* @__PURE__ */ ot.default.createElement(Kn.Message, Object.assign({
      icon: !!d
    }, m), d && /* @__PURE__ */ ot.default.createElement(Kn.Icon, {
      name: d
    }), /* @__PURE__ */ ot.default.createElement(Kn.Message.Content, {
      role: "alert"
    }, o && /* @__PURE__ */ ot.default.createElement(Kn.Message.Header, null, o), i, !Tk.default(c) && /* @__PURE__ */ ot.default.createElement(CQe, {
      fieldErrors: c
    })));
  }
}
S1e.defaultProps = {
  errors: void 0,
  header: void 0,
  uiProps: void 0,
  icon: void 0,
  content: void 0
};
class w1e extends ha.Component {
  constructor(o) {
    super(o), this.getSubfieldErrors = (c) => {
      const {
        includesPaths: i
      } = this.props, {
        form: {
          errors: d,
          initialErrors: m
        }
      } = c, v = [];
      for (const g of i) {
        const C = v2.default(d, g) || v2.default(m, g);
        if (C)
          if (typeof C == "object") {
            const O = this.findErrorObjects(C);
            v.push(...O);
          } else
            v.push(C);
      }
      return v;
    }, this.categorizeErrors = (c) => {
      const i = {
        info: [],
        warning: [],
        error: []
      };
      for (const d of c)
        Object.prototype.hasOwnProperty.call(d, "severity") ? i[`${d.severity}`].push(d) : i.error.push(d);
      return i;
    }, this.state = {
      errors: void 0
    };
  }
  componentDidMount() {
    const {
      formProps: o,
      hasError: c
    } = this.props, i = this.getSubfieldErrors(o), d = this.categorizeErrors(i);
    c(d), this.setState({
      errors: d
    });
  }
  componentDidUpdate(o, c, i) {
    const {
      formProps: {
        form: {
          errors: d,
          initialErrors: m
        }
      },
      formProps: v,
      hasError: g
    } = this.props;
    if (o.formProps.form.errors !== d || o.formProps.form.initialErrors !== m) {
      const C = this.getSubfieldErrors(v), O = this.categorizeErrors(C);
      g(O), this.setState({
        errors: O
      });
    }
  }
  findErrorObjects(o) {
    const c = [];
    function i(d) {
      typeof d != "object" || d === null || ("message" in d && "severity" in d && c.push(d), Object.keys(d).forEach((m) => {
        i(d[m]);
      }));
    }
    return i(o), c;
  }
  severityLabel(o, c) {
    var i;
    if (c == null)
      return o;
    const d = c[o];
    return (i = d == null ? void 0 : d.label) !== null && i !== void 0 ? i : o;
  }
  render() {
    const {
      errors: o
    } = this.state, {
      severityChecks: c
    } = this.props;
    return o === void 0 ? null : Object.entries(o).map((i) => {
      let [d, m] = i;
      return !Tk.default(m) && /* @__PURE__ */ ot.default.createElement(Kn.Label, {
        key: d,
        size: "tiny",
        circular: !0,
        className: `accordion-label ${d}`
      }, m.length, " ", this.severityLabel(d, c), m.length > 1 ? "s" : "");
    });
  }
}
w1e.defaultProps = {
  severityChecks: null
};
class vq extends ha.Component {
  constructor(o) {
    super(o), this.handleTitleClick = (i, d) => {
      let {
        index: m
      } = d;
      const {
        activeIndex: v
      } = this.state;
      this.setState({
        activeIndex: v === m ? -1 : m
      });
    }, this.hasError = (i) => {
      const d = i.error.length > 0;
      this.setState({
        hasError: d
      });
    }, this.renderAccordion = (i) => {
      const {
        label: d,
        children: m,
        includesPaths: v,
        severityChecks: g
      } = this.props, {
        hasError: C,
        activeIndex: O
      } = this.state, R = h1e.default(this.props, ["optimized", "includesPaths"]), I = C ? "error" : "";
      return /* @__PURE__ */ ot.default.createElement(Kn.Accordion, Object.assign({
        inverted: !0,
        className: `invenio-accordion-field ${I} secondary`
      }, R), /* @__PURE__ */ ot.default.createElement(Kn.Accordion.Title, {
        active: O === 0,
        index: 0,
        onClick: this.handleTitleClick,
        onKeyDown: (L) => {
          (L.key === "Enter" || L.key === " ") && this.handleTitleClick(L, {
            index: 0
          });
        },
        tabIndex: 0
      }, d, /* @__PURE__ */ ot.default.createElement(w1e, {
        hasError: this.hasError,
        formProps: i,
        includesPaths: v,
        severityChecks: g
      }), /* @__PURE__ */ ot.default.createElement(Kn.Icon, {
        name: O === 0 ? "angle down" : "angle right"
      })), /* @__PURE__ */ ot.default.createElement(Kn.Accordion.Content, {
        active: O === 0
      }, /* @__PURE__ */ ot.default.createElement(Kn.Container, null, m)));
    };
    const {
      active: c
    } = this.props;
    this.state = {
      hasError: !1,
      activeIndex: c ? 0 : -1
    };
  }
  render() {
    const {
      optimized: o
    } = this.props, c = o ? rs.FastField : rs.Field;
    return /* @__PURE__ */ ot.default.createElement(c, {
      name: "",
      component: this.renderAccordion
    });
  }
}
vq.defaultProps = {
  active: !0,
  includesPaths: [],
  label: "",
  optimized: !1,
  children: null,
  ui: null,
  severityChecks: null
};
class Mh extends ha.Component {
  render() {
    const {
      htmlFor: o,
      icon: c,
      label: i,
      className: d
    } = this.props;
    return /* @__PURE__ */ ot.default.createElement("label", {
      htmlFor: o,
      className: d
    }, c ? /* @__PURE__ */ ot.default.createElement(Kn.Icon, {
      name: c
    }) : null, i);
  }
}
Mh.defaultProps = {
  className: "field-label-class invenio-field-label",
  icon: "",
  htmlFor: void 0,
  label: void 0
};
class gce extends ha.Component {
  constructor(o) {
    super(o), this.hasGroupErrors = (c) => {
      const {
        fieldPath: i
      } = this.props;
      for (const d in c)
        if (d.startsWith(i))
          return !0;
      return !1;
    }, this.getValues = (c, i) => {
      const {
        requiredOptions: d,
        defaultNewValue: m,
        showEmptyValue: v
      } = this.props, {
        hasBeenShown: g
      } = this.state, C = rs.getIn(c, i, []);
      !g && Tk.default(d) && Tk.default(C) && v && (C.push({
        __key: C.length,
        ...m
      }), this.setState({
        hasBeenShown: !0
      }));
      for (const O of d)
        gQe.default(C, vQe.default(O)).length === 0 && C.push({
          __key: C.length,
          ...O
        });
      return C;
    }, this.renderFormField = (c) => {
      const {
        form: {
          values: i,
          errors: d
        },
        ...m
      } = c, {
        addButtonLabel: v,
        addButtonClassName: g,
        children: C,
        defaultNewValue: O,
        fieldPath: R,
        label: I,
        labelIcon: L,
        helpText: Z,
        requiredOptions: ne,
        showEmptyValue: se,
        ...Q
      } = this.props, he = this.hasGroupErrors(d) ? {
        error: {}
      } : {}, {
        nextKey: ue
      } = this.state, G = this.getValues(i, R);
      return /* @__PURE__ */ ot.default.createElement(Kn.Form.Field, Object.assign({}, Q, he), /* @__PURE__ */ ot.default.createElement(Mh, {
        htmlFor: R,
        icon: L,
        label: I
      }), G.map((me, we, be) => {
        const q = R, Te = we, Le = me.__key || we;
        return /* @__PURE__ */ ot.default.createElement("div", {
          key: Le
        }, C({
          array: be,
          arrayHelpers: m,
          arrayPath: q,
          indexPath: Te,
          key: Le,
          value: me,
          ...c
        }));
      }), Z && /* @__PURE__ */ ot.default.createElement("label", {
        className: "helptext"
      }, Z), /* @__PURE__ */ ot.default.createElement(Kn.Form.Group, null, /* @__PURE__ */ ot.default.createElement(Kn.Form.Button, {
        type: "button",
        icon: !0,
        className: g,
        labelPosition: "left",
        onClick: () => {
          m.push({
            ...O,
            __key: ue
          }), this.setState((me) => ({
            nextKey: me.nextKey - 1
          }));
        }
      }, /* @__PURE__ */ ot.default.createElement(Kn.Icon, {
        name: "add"
      }), v)));
    }, this.state = {
      // Chosen because it will never cross with 0-indexed pre-existing keys.
      nextKey: -1,
      hasBeenShown: !1
    };
  }
  render() {
    const {
      fieldPath: o
    } = this.props;
    return /* @__PURE__ */ ot.default.createElement(rs.FieldArray, {
      className: "invenio-array-field",
      name: o,
      id: o,
      component: this.renderFormField
    });
  }
}
gce.defaultProps = {
  addButtonLabel: "Add new row",
  addButtonClassName: "align-self-end mt-15",
  helpText: "",
  label: "",
  labelIcon: "",
  requiredOptions: [],
  showEmptyValue: !1
};
class E1e extends ha.Component {
  render() {
    const {
      formik: o,
      onSubmit: c,
      children: i
    } = this.props;
    return /* @__PURE__ */ ot.default.createElement(rs.Formik, Object.assign({
      onSubmit: c
    }, o), /* @__PURE__ */ ot.default.createElement(Kn.Form, null, i));
  }
}
E1e.defaultProps = {
  formik: void 0
};
class C1e extends ha.Component {
  constructor() {
    super(...arguments), this.renderFormField = (o) => {
      const {
        fieldPath: c,
        label: i,
        ...d
      } = this.props, {
        form: {
          values: m,
          handleBlur: v,
          errors: g,
          initialErrors: C,
          initialValues: O,
          setFieldValue: R
        }
      } = o, I = rs.getIn(m, c, !1), L = rs.getIn(O, c, !1), Z = g || L === I && C;
      return /* @__PURE__ */ ot.default.createElement(Kn.Form.Group, {
        inline: !0
      }, /* @__PURE__ */ ot.default.createElement("label", {
        htmlFor: c
      }, i), /* @__PURE__ */ ot.default.createElement(Kn.Form.Checkbox, Object.assign({
        id: c,
        name: c,
        onChange: () => R(c, !I),
        onBlur: v,
        checked: I,
        error: this.renderError(Z, c)
      }, d)));
    };
  }
  renderError(o, c) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "left";
    const d = o[c];
    return d ? {
      content: d,
      pointing: i
    } : null;
  }
  render() {
    const {
      optimized: o,
      fieldPath: c
    } = this.props, i = o ? rs.FastField : rs.Field;
    return /* @__PURE__ */ ot.default.createElement(i, {
      className: "invenio-boolean-field",
      name: c,
      component: this.renderFormField
    });
  }
}
C1e.defaultProps = {
  label: "",
  optimized: !1
};
class vce extends ha.Component {
  constructor() {
    super(...arguments), this.renderFormField = (o) => {
      let {
        form: {
          errors: c,
          initialErrors: i
        }
      } = o;
      const {
        fieldPath: d,
        ...m
      } = this.props, v = v2.default(c, d, "") || v2.default(i, d, "");
      return v ? /* @__PURE__ */ ot.default.createElement(Kn.Label, Object.assign({
        pointing: !0,
        prompt: !0,
        content: v
      }, m)) : null;
    };
  }
  render() {
    const {
      fieldPath: o
    } = this.props;
    return /* @__PURE__ */ ot.default.createElement(rs.Field, {
      className: "invenio-error-label-field",
      name: o
    }, this.renderFormField);
  }
}
class bq extends ha.Component {
  constructor() {
    var o;
    super(...arguments), o = this, this.getAllErrSubPaths = function(c) {
      let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      const d = [];
      for (let m in c) {
        let v = i + (i ? "." : "") + m;
        typeof c[m] == "string" || c[m].severity !== void 0 ? d.push(v) : typeof c[m] == "object" && d.push(...o.getAllErrSubPaths(c[m], v));
      }
      return d;
    }, this.computeErrors = (c, i) => {
      const {
        fieldPath: d,
        injectedError: m,
        hasSubfields: v
      } = this.props;
      let g;
      if (m)
        g = m;
      else if (g = v2.default(c, d, "") || v2.default(i, d, ""), v) {
        const R = this.getAllErrSubPaths(g);
        Tk.default(R) || (g = v2.default(g, R[0], ""));
      }
      const C = Object.prototype.hasOwnProperty.call(g, "severity");
      let O;
      return C ? O = g.message : !C && !v && typeof g == "object" ? O = null : O = g, {
        error: g,
        errMessage: O,
        hasSeverity: C
      };
    }, this.renderErrors = (c) => {
      let {
        form: {
          errors: i,
          initialErrors: d
        }
      } = c;
      const {
        fieldPath: m,
        pointing: v
      } = this.props, {
        error: g,
        errMessage: C,
        hasSeverity: O
      } = this.computeErrors(i, d);
      if (C === null)
        return null;
      const R = !O || g.severity === "error", I = R ? "times circle" : "info circle";
      return /* @__PURE__ */ ot.default.createElement(Kn.Label, {
        pointing: v,
        className: R ? "prompt" : g.severity
      }, O && /* @__PURE__ */ ot.default.createElement(pce, {
        popupId: `invenio-form-feedback-error-${m}`,
        ariaLabel: "Form field feedback error",
        trigger: /* @__PURE__ */ ot.default.createElement(Kn.Icon, {
          name: I
        }),
        content: /* @__PURE__ */ ot.default.createElement("span", {
          dangerouslySetInnerHTML: {
            __html: g.description
          }
        }),
        position: "top center",
        hoverable: !0
      }), C);
    };
  }
  render() {
    const {
      fieldPath: o
    } = this.props;
    return /* @__PURE__ */ ot.default.createElement(rs.Field, {
      className: "invenio-error-label-field",
      name: o
    }, this.renderErrors);
  }
}
bq.defaultProps = {
  injectedError: void 0,
  pointing: "left",
  fieldPath: void 0,
  hasSubfields: !1
};
class x1e extends ot.default.Component {
  constructor() {
    super(...arguments), this.hasGroupErrors = (o) => {
      const {
        fieldPath: c
      } = this.props;
      for (const i in o)
        if (i.startsWith(c))
          return !0;
      return !1;
    }, this.renderBasicField = (o, c, i) => /* @__PURE__ */ ot.default.createElement("div", {
      className: c.join(" ")
    }, o && /* @__PURE__ */ ot.default.createElement("div", {
      className: "group-action"
    }, o), i), this.renderFormField = (o) => {
      const {
        action: c,
        basic: i,
        border: d,
        children: m,
        fieldPath: v,
        ...g
      } = o, C = rs.getIn(o, "form.errors"), O = ["form-group"];
      return d && O.push("border"), v && this.hasGroupErrors(C) && O.push("error"), i ? this.renderBasicField(c, O, m) : /* @__PURE__ */ ot.default.createElement(Kn.Form.Group, Object.assign({
        className: O.join(" ")
      }, g), c && /* @__PURE__ */ ot.default.createElement("div", {
        className: "group-action"
      }, c), m);
    };
  }
  render() {
    const {
      optimized: o,
      fieldPath: c,
      ...i
    } = this.props, d = o ? rs.FastField : rs.Field;
    return /* @__PURE__ */ ot.default.createElement(d, Object.assign({
      name: c,
      component: this.renderFormField,
      fieldPath: c,
      className: "invenio-group-field"
    }, i));
  }
}
x1e.defaultProps = {
  border: !1,
  fieldPath: "",
  optimized: !1,
  action: void 0,
  basic: !1,
  children: void 0
};
class a5 extends ha.Component {
  constructor() {
    super(...arguments), this.renderError = (o, c, i, d, m) => {
      const {
        error: v,
        fieldPath: g
      } = this.props, C = v || rs.getIn(m, g, null) || // We check if initialValue changed to display the initialError,
      // otherwise it would be displayed despite updating the field
      c === d && rs.getIn(i, g, null);
      return C && /* @__PURE__ */ ot.default.createElement(bq, {
        errorMessage: C,
        pointing: "above",
        fieldPath: g
      });
    }, this.renderFormField = (o) => {
      const {
        form: {
          values: c,
          setFieldValue: i,
          handleBlur: d,
          errors: m,
          initialErrors: v,
          initialValues: g,
          meta: C
        },
        ...O
      } = o, {
        defaultValue: R,
        error: I,
        fieldPath: L,
        label: Z,
        options: ne,
        onChange: se,
        onAddItem: Q,
        multiple: he,
        ...ue
      } = O, G = he ? [] : "", me = rs.getIn(c, L, R || G), we = rs.getIn(g, L, G);
      return /* @__PURE__ */ ot.default.createElement(Kn.Form.Dropdown, Object.assign({
        fluid: !0,
        className: "invenio-select-field",
        selection: !0,
        error: this.renderError(C, we, v, me, m),
        label: {
          children: Z
        },
        name: L,
        onBlur: d,
        onChange: (be, q) => {
          se ? (se({
            event: be,
            data: q,
            formikProps: o
          }), be.target.value = "") : i(L, q.value);
        },
        onAddItem: (be, q) => {
          Q && Q({
            event: be,
            data: q,
            formikProps: o
          });
        },
        options: ne,
        value: me,
        multiple: he,
        selectOnBlur: !1
      }, ue));
    };
  }
  render() {
    const {
      optimized: o,
      fieldPath: c,
      ...i
    } = this.props, d = o ? rs.FastField : rs.Field;
    return /* @__PURE__ */ ot.default.createElement(d, Object.assign({
      name: c,
      component: this.renderFormField,
      fieldPath: c
    }, i));
  }
}
a5.defaultProps = {
  defaultValue: "",
  optimized: !1,
  error: void 0,
  label: "",
  onChange: void 0,
  onAddItem: void 0,
  multiple: !1
};
const xQe = {
  withCredentials: !0,
  xsrfCookieName: "csrftoken",
  xsrfHeaderName: "X-CSRFToken",
  headers: {
    Accept: "application/vnd.inveniordm.v1+json",
    "Content-Type": "application/json"
  }
}, TQe = mce.default.create(xQe), T1e = (r) => {
  let o = !1;
  return {
    promise: new Promise((i, d) => {
      r.then((m) => o ? d("UNMOUNTED") : i(m), (m) => d(o ? "UNMOUNTED" : m));
    }),
    cancel() {
      o = !0;
    }
  };
}, _Qe = 20, OQe = (r) => r.map((o) => ({
  text: o.title,
  value: o.id,
  key: o.id
}));
class yq extends ha.Component {
  constructor(o) {
    super(o), this.onSelectValue = (i, d, m) => {
      let {
        options: v,
        value: g,
        ...C
      } = d;
      const {
        multiple: O
      } = this.props, R = v.filter((I) => O ? g.includes(I.value) : I.value === g);
      this.setState({
        selectedSuggestions: R,
        searchQuery: null,
        error: !1,
        open: !!O
      }, () => m(R));
    }, this.handleAddition = (i, d, m) => {
      let {
        value: v
      } = d;
      const {
        serializeAddedValue: g
      } = this.props, {
        selectedSuggestions: C
      } = this.state, O = g ? g(v) : {
        text: v,
        value: v,
        key: v,
        name: v
      }, R = [...C, O];
      this.setState((I) => ({
        selectedSuggestions: R,
        suggestions: ppe.default([...I.suggestions, ...R], "value")
      }), () => m(R));
    }, this.onSearchChange = bQe.default(async (i, d) => {
      let {
        searchQuery: m
      } = d;
      this.cancellableAction && this.cancellableAction.cancel(), await this.executeSearch(m);
    }, this.props.debounceTime), this.executeSearch = async (i) => {
      const {
        preSearchChange: d,
        serializeSuggestions: m
      } = this.props, v = d(i), {
        searchQuery: g
      } = this.state;
      if (g !== i) {
        this.setState({
          isFetching: !0,
          searchQuery: v
        });
        try {
          const C = await this.fetchSuggestions(v), O = m(C);
          this.setState((R) => ({
            suggestions: ppe.default([...R.selectedSuggestions, ...O], "key"),
            isFetching: !1,
            error: !1,
            open: !0
          }));
        } catch (C) {
          console.error(C), this.setState({
            error: !0,
            isFetching: !1
          });
        }
      }
    }, this.fetchSuggestions = async (i) => {
      const {
        suggestionAPIUrl: d,
        suggestionAPIQueryParams: m,
        suggestionAPIHeaders: v,
        searchQueryParamName: g
      } = this.props;
      this.cancellableAction = T1e(mce.default.get(d, {
        params: {
          [g]: i,
          size: _Qe,
          ...m
        },
        headers: v,
        // There is a bug in axios that prevents brackets from being encoded,
        // remove the paramsSerializer when fixed.
        // https://github.com/axios/axios/issues/3316
        paramsSerializer: (R) => yQe.default.stringify(R, {
          arrayFormat: "repeat"
        })
      }));
      try {
        var C, O;
        const R = await this.cancellableAction.promise;
        return R == null || (C = R.data) === null || C === void 0 || (O = C.hits) === null || O === void 0 ? void 0 : O.hits;
      } catch (R) {
        console.error(R);
      }
    }, this.getNoResultsMessage = () => {
      const {
        loadingMessage: i,
        suggestionsErrorMessage: d,
        noQueryMessage: m,
        noResultsMessage: v
      } = this.props, {
        isFetching: g,
        error: C,
        searchQuery: O
      } = this.state;
      return g ? i : C ? /* @__PURE__ */ ot.default.createElement(Kn.Message, {
        negative: !0,
        size: "mini",
        content: d
      }) : O ? v : m;
    }, this.onClose = () => {
      this.setState({
        open: !1
      });
    }, this.onBlur = () => {
      const {
        searchOnFocus: i
      } = this.props;
      this.setState((d) => ({
        open: !1,
        error: !1,
        searchQuery: i ? d.searchQuery : null,
        suggestions: i ? d.suggestions : d.selectedSuggestions
      }));
    }, this.onFocus = async () => {
      this.setState({
        open: !0
      });
      const {
        searchOnFocus: i
      } = this.props;
      if (i) {
        const {
          searchQuery: d
        } = this.state;
        await this.executeSearch(d || "");
      }
    }, this.getProps = () => {
      const {
        fieldPath: i,
        suggestionAPIUrl: d,
        suggestionAPIQueryParams: m,
        serializeSuggestions: v,
        serializeAddedValue: g,
        suggestionAPIHeaders: C,
        debounceTime: O,
        searchQueryParamName: R,
        noResultsMessage: I,
        loadingMessage: L,
        suggestionsErrorMessage: Z,
        noQueryMessage: ne,
        initialSuggestions: se,
        preSearchChange: Q,
        onValueChange: he,
        search: ue,
        isFocused: G,
        ...me
      } = this.props;
      return {
        compProps: {
          fieldPath: i,
          suggestionAPIUrl: d,
          suggestionAPIQueryParams: m,
          suggestionAPIHeaders: C,
          serializeSuggestions: v,
          serializeAddedValue: g,
          debounceTime: O,
          searchQueryParamName: R,
          noResultsMessage: I,
          loadingMessage: L,
          suggestionsErrorMessage: Z,
          noQueryMessage: ne,
          initialSuggestions: se,
          preSearchChange: Q,
          onValueChange: he,
          search: ue,
          isFocused: G
        },
        uiProps: me
      };
    };
    const c = o.initialSuggestions ? o.serializeSuggestions(o.initialSuggestions) : [];
    this.state = {
      isFetching: !1,
      suggestions: c,
      selectedSuggestions: c,
      error: !1,
      searchQuery: null,
      open: !1
    };
  }
  componentWillUnmount() {
    this.cancellableAction && this.cancellableAction.cancel();
  }
  render() {
    const {
      compProps: o,
      uiProps: c
    } = this.getProps(), {
      error: i,
      suggestions: d,
      open: m,
      isFetching: v
    } = this.state;
    return /* @__PURE__ */ ot.default.createElement(a5, Object.assign({}, c, {
      allowAdditions: i ? !1 : c.allowAdditions,
      fieldPath: o.fieldPath,
      options: d,
      noResultsMessage: this.getNoResultsMessage(),
      search: o.search,
      searchInput: {
        id: o.fieldPath,
        autoFocus: o.isFocused
      },
      lazyLoad: !0,
      open: m,
      onClose: this.onClose,
      onFocus: this.onFocus,
      onBlur: this.onBlur,
      onSearchChange: this.onSearchChange,
      onAddItem: (g) => {
        let {
          event: C,
          data: O,
          formikProps: R
        } = g;
        this.handleAddition(C, O, (I) => {
          o.onValueChange && o.onValueChange({
            event: C,
            data: O,
            formikProps: R
          }, I);
        });
      },
      onChange: (g) => {
        let {
          event: C,
          data: O,
          formikProps: R
        } = g;
        this.onSelectValue(C, O, (I) => {
          o.onValueChange ? o.onValueChange({
            event: C,
            data: O,
            formikProps: R
          }, I) : R.form.setFieldValue(o.fieldPath, O.value);
        });
      },
      loading: v,
      className: "invenio-remote-select-field"
    }));
  }
}
yq.defaultProps = {
  debounceTime: 500,
  suggestionAPIQueryParams: {},
  suggestionAPIHeaders: {},
  serializeSuggestions: OQe,
  searchQueryParamName: "suggest",
  suggestionsErrorMessage: "Something went wrong...",
  noQueryMessage: "Search...",
  noResultsMessage: "No results found.",
  loadingMessage: "Loading...",
  preSearchChange: (r) => r,
  search: !0,
  multiple: !1,
  serializeAddedValue: void 0,
  initialSuggestions: [],
  onValueChange: void 0,
  isFocused: !1,
  searchOnFocus: !1
};
class bce extends ha.Component {
  render() {
    const {
      fieldPath: o,
      error: c,
      helpText: i,
      disabled: d,
      label: m,
      optimized: v,
      required: g,
      ...C
    } = this.props, O = v ? rs.FastField : rs.Field;
    return /* @__PURE__ */ ot.default.createElement(ot.default.Fragment, null, /* @__PURE__ */ ot.default.createElement(O, {
      className: "invenio-text-input-field",
      id: o,
      name: o
    }, (R) => {
      let {
        field: I,
        meta: L
      } = R;
      const Z = c || L.error || // We check if initialValue changed to display the initialError,
      // otherwise it would be displayed despite updating the field
      !L.touched && L.initialError;
      let ne = null;
      return typeof Z == "string" ? ne = Z : typeof Z == "object" && Z.message && Z.severity && (ne = /* @__PURE__ */ ot.default.createElement(bq, {
        errorMessage: Z,
        pointing: "above",
        fieldPath: o
      })), /* @__PURE__ */ ot.default.createElement(Kn.Form.Input, Object.assign({}, I, {
        error: ne,
        disabled: d,
        fluid: !0,
        label: m,
        id: o,
        required: g
      }, C));
    }), i && /* @__PURE__ */ ot.default.createElement("label", {
      className: "helptext"
    }, i));
  }
}
bce.defaultProps = {
  error: void 0,
  helpText: "",
  disabled: !1,
  optimized: !1,
  required: !1
};
class yce extends ha.Component {
  constructor() {
    super(...arguments), this.renderFormField = (o) => {
      let {
        form: c,
        ...i
      } = o;
      const {
        fieldPath: d,
        ...m
      } = i;
      return /* @__PURE__ */ ot.default.createElement(Kn.Form.Field, {
        className: "invenio-text-area-field"
      }, /* @__PURE__ */ ot.default.createElement(Kn.Form.TextArea, Object.assign({
        id: d,
        name: d,
        onChange: c.handleChange,
        onBlur: c.handleBlur,
        value: rs.getIn(c.values, d, "")
      }, m)), /* @__PURE__ */ ot.default.createElement(vce, {
        fieldPath: d
      }));
    };
  }
  render() {
    const {
      optimized: o,
      fieldPath: c,
      ...i
    } = this.props, d = o ? rs.FastField : rs.Field;
    return /* @__PURE__ */ ot.default.createElement(d, Object.assign({
      id: c,
      name: c,
      component: this.renderFormField,
      fieldPath: c
    }, i));
  }
}
yce.defaultProps = {
  optimized: !1
};
class MB extends ha.Component {
  constructor() {
    super(...arguments), this.renderFormField = (o) => {
      const {
        checked: c,
        fieldPath: i,
        label: d,
        labelIcon: m,
        onChange: v,
        value: g,
        ...C
      } = this.props, O = (I, L) => {
        v ? v({
          event: I,
          data: L,
          formikProps: o
        }) : o.form.setFieldValue(i, g);
      }, R = h1e.default(C, ["optimized"]);
      return /* @__PURE__ */ ot.default.createElement(Kn.Form.Radio, Object.assign({
        name: i,
        label: /* @__PURE__ */ ot.default.createElement(Mh, {
          htmlFor: i,
          icon: m,
          label: d
        }),
        value: rs.getIn(o.form.values, i, ""),
        checked: c,
        onChange: O,
        className: "invenio-radio-field"
      }, R));
    };
  }
  render() {
    const {
      optimized: o,
      fieldPath: c
    } = this.props, i = o ? rs.FastField : rs.Field;
    return /* @__PURE__ */ ot.default.createElement(i, {
      name: c,
      component: this.renderFormField
    });
  }
}
MB.defaultProps = {
  checked: !1,
  label: "",
  optimized: !1,
  labelIcon: "",
  onChange: void 0,
  value: ""
};
class Sce extends ha.Component {
  render() {
    const {
      id: o,
      initialValue: c,
      disabled: i,
      minHeight: d,
      onBlur: m,
      onChange: v,
      onFocus: g,
      editorConfig: C,
      inputValue: O,
      onEditorChange: R
    } = this.props, I = {
      branding: !1,
      menubar: !1,
      statusbar: !1,
      min_height: d,
      content_style: "body { font-size: 14px; }",
      plugins: ["codesample", "link", "lists", "table", "autoresize", "wordcount"],
      contextmenu: !1,
      toolbar: "blocks | bold italic link codesample blockquote table | bullist numlist | outdent indent | wordcount | undo redo",
      autoresize_bottom_margin: 20,
      block_formats: "Paragraph=p; Header 1=h1; Header 2=h2; Header 3=h3",
      table_advtab: !1,
      convert_urls: !1,
      ...C
    };
    return /* @__PURE__ */ ot.default.createElement(dQe.Editor, {
      initialValue: c,
      value: O,
      init: I,
      id: o,
      disabled: i,
      onBlur: m,
      onFocus: g,
      onChange: v,
      onEditorChange: R
    });
  }
}
Sce.defaultProps = {
  minHeight: 250,
  initialValue: "",
  inputValue: "",
  id: void 0,
  disabled: void 0,
  onChange: void 0,
  onEditorChange: void 0,
  onBlur: void 0,
  onFocus: void 0,
  editorConfig: void 0
};
class wce extends ha.Component {
  constructor() {
    super(...arguments), this.renderFormField = (o) => {
      const {
        fieldPath: c,
        label: i,
        required: d,
        className: m,
        editor: v,
        editorConfig: g
      } = this.props, C = rs.getIn(o.form.values, c, ""), O = rs.getIn(o.form.initialValues, c, ""), R = rs.getIn(o.form.errors, c, !1) || // We check if initialValue changed to display the initialError,
      // otherwise it would be displayed despite updating the field
      O === C && rs.getIn(o.form.initialErrors, c, !1);
      return /* @__PURE__ */ ot.default.createElement(Kn.Form.Field, {
        id: c,
        required: d,
        error: R,
        className: m
      }, /* @__PURE__ */ ot.default.isValidElement(i) ? i : /* @__PURE__ */ ot.default.createElement("label", {
        htmlFor: c
      }, i), v || /* @__PURE__ */ ot.default.createElement(Sce, {
        initialValue: O,
        inputValue: () => C,
        optimized: !0,
        editorConfig: g,
        onBlur: (I, L) => {
          o.form.setFieldValue(c, L.getContent()), o.form.setFieldTouched(c, !0);
        }
      }), /* @__PURE__ */ ot.default.createElement(vce, {
        fieldPath: c
      }));
    };
  }
  render() {
    const {
      optimized: o,
      fieldPath: c
    } = this.props, i = o ? rs.FastField : rs.Field;
    return /* @__PURE__ */ ot.default.createElement(i, {
      id: c,
      name: c,
      component: this.renderFormField
    });
  }
}
wce.defaultProps = {
  className: "invenio-rich-input-field",
  optimized: !1,
  required: !1,
  label: "",
  editor: void 0,
  editorConfig: void 0
};
class _1e extends ha.Component {
  constructor() {
    super(...arguments), this.renderFormField = (o) => {
      const {
        onValue: c,
        offValue: i,
        onLabel: d,
        offLabel: m,
        fieldPath: v,
        onChange: g,
        ...C
      } = this.props, O = rs.getIn(o.form.values, v) === c, R = () => {
        O ? o.form.setFieldValue(v, i) : o.form.setFieldValue(v, c), g && g({
          checked: !O
        });
      };
      return /* @__PURE__ */ ot.default.createElement(MB, Object.assign({}, C, {
        className: "invenio-toggle-field",
        toggle: !0,
        fieldPath: v,
        checked: rs.getIn(o.form.values, v) === c,
        label: rs.getIn(o.form.values, v) === c ? d : m,
        onChange: R
      }));
    };
  }
  render() {
    const {
      optimized: o,
      fieldPath: c
    } = this.props, i = o ? rs.FastField : rs.Field;
    return /* @__PURE__ */ ot.default.createElement(i, {
      name: c,
      component: this.renderFormField
    });
  }
}
_1e.defaultProps = {
  onChange: void 0,
  optimized: !0
};
class AQe extends ha.Component {
  render() {
    const {
      removeFieldCallback: o,
      fieldPath: c,
      field: i,
      label: d
    } = this.props;
    return /* @__PURE__ */ ot.default.createElement(ot.default.Fragment, null, /* @__PURE__ */ ot.default.createElement(Mh, {
      htmlFor: c,
      label: d,
      className: "mr-10"
    }), /* @__PURE__ */ ot.default.createElement(Kn.Popup, {
      content: "Remove empty fields from the form",
      trigger: /* @__PURE__ */ ot.default.createElement(Kn.Button, {
        icon: !0,
        size: "mini",
        onClick: () => o(i)
      }, /* @__PURE__ */ ot.default.createElement(Kn.Icon, {
        name: "trash alternate outline"
      }))
    }));
  }
}
class O1e extends ha.Component {
  constructor(o) {
    super(o), this.resetFilter = () => {
      const {
        fieldsList: i
      } = this.props;
      this.setState({
        filteredFieldsList: i
      });
    }, this.filter = () => {
      const {
        fieldsList: i
      } = this.props, {
        searchPhrase: d,
        filter: m
      } = this.state;
      !d && !m && this.resetFilter();
      const v = Object.fromEntries(
        // eslint-disable-next-line no-unused-vars
        Object.entries(i).filter((g) => {
          let [C, O] = g;
          const R = !m || O.section.section === m, I = !d || O.label.toLowerCase().includes(d.toLowerCase());
          return R && I;
        })
      );
      this.setState({
        filteredFieldsList: v
      });
    }, this.handleSearch = (i, d) => {
      let {
        value: m
      } = d;
      this.setState({
        searchPhrase: m
      }, () => this.filter());
    }, this.handleDomainFilter = (i, d) => {
      let {
        value: m
      } = d;
      this.setState({
        filter: m
      }, () => this.filter());
    };
    const {
      fieldsList: c
    } = o;
    this.state = {
      filteredFieldsList: c,
      searchPhrase: void 0,
      filter: void 0
    };
  }
  render() {
    const {
      filteredFieldsList: o
    } = this.state, {
      alreadyAddedFields: c,
      fieldPath: i,
      handleSelectField: d,
      sections: m
    } = this.props, v = m.map((g) => ({
      key: g,
      text: g,
      value: g
    }));
    return /* @__PURE__ */ ot.default.createElement(ot.default.Fragment, null, /* @__PURE__ */ ot.default.createElement(Kn.Segment, {
      as: Kn.Modal.Content,
      attached: "bottom ml-0"
    }, /* @__PURE__ */ ot.default.createElement(Kn.Grid, null, /* @__PURE__ */ ot.default.createElement(Kn.Grid.Column, {
      width: 10
    }, /* @__PURE__ */ ot.default.createElement(Kn.Input, {
      fluid: !0,
      icon: "search",
      placeholder: "Search field names...",
      onChange: this.handleSearch
    })), /* @__PURE__ */ ot.default.createElement(Kn.Grid.Column, {
      width: 6
    }, /* @__PURE__ */ ot.default.createElement("span", {
      className: "flex align-items-center"
    }, "in:", " ", /* @__PURE__ */ ot.default.createElement(Kn.Dropdown, {
      className: "ml-5",
      fluid: !0,
      inline: !0,
      clearable: !0,
      selection: !0,
      placeholder: "All domains",
      options: v,
      onChange: this.handleDomainFilter
    }))))), /* @__PURE__ */ ot.default.createElement(Kn.Modal.Content, {
      scrolling: !0
    }, /* @__PURE__ */ ot.default.createElement(Kn.Item.Group, {
      divided: !0,
      relaxed: !0
    }, Object.entries(o).map((g) => {
      let [C, O] = g;
      const R = C.split(":"), I = c.includes(`${i}.${C}`);
      return /* @__PURE__ */ ot.default.createElement(Kn.Item, {
        key: C,
        className: I ? "pr-10 pl-10 disabled" : "clickable pr-10 pl-10",
        fieldName: C,
        field: o[C],
        onClick: (L) => I ? {} : d(L, C, O)
      }, /* @__PURE__ */ ot.default.createElement(Kn.Item.Content, null, /* @__PURE__ */ ot.default.createElement(Kn.Item.Header, {
        className: I ? "text-muted mb-5" : "mb-5"
      }, /* @__PURE__ */ ot.default.createElement(ot.default.Fragment, null, O.label, " ", I && /* @__PURE__ */ ot.default.createElement("span", {
        className: "right-floated"
      }, /* @__PURE__ */ ot.default.createElement(Kn.Icon, {
        name: "checkmark",
        color: "green"
      }), " ", /* @__PURE__ */ ot.default.createElement("span", null, " Added")))), /* @__PURE__ */ ot.default.createElement(Kn.Item.Description, null, /* @__PURE__ */ ot.default.createElement(Kn.Grid, null, /* @__PURE__ */ ot.default.createElement(Kn.Grid.Column, {
        width: 12
      }, O.note))), /* @__PURE__ */ ot.default.createElement(Kn.Item.Extra, null, /* @__PURE__ */ ot.default.createElement(Kn.Label, null, /* @__PURE__ */ ot.default.createElement(Kn.Icon, {
        name: O.section.icon
      }), O.section.section, ": ", R[0]), O.multiple_values === !0 && /* @__PURE__ */ ot.default.createElement(Kn.Label, {
        basic: !0
      }, /* @__PURE__ */ ot.default.createElement(Kn.Icon, {
        name: "list ol"
      }), " Multiple value field"), O.type === "text" && /* @__PURE__ */ ot.default.createElement(Kn.Label, {
        basic: !0
      }, /* @__PURE__ */ ot.default.createElement(Kn.Icon, {
        name: "text cursor"
      }), " Text field"))));
    }), " ")));
  }
}
O1e.defaultProps = {
  sections: void 0
};
async function Sq(r, o) {
  let {
    ui_widget: c,
    fieldPath: i,
    record: d,
    props: m
  } = o, v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, g;
  for (const O of r)
    try {
      var C;
      const R = await O(c);
      if (g = (C = R.default) !== null && C !== void 0 ? C : R[c], g)
        break;
    } catch {
      continue;
    }
  if (g === void 0)
    throw console.error(`Failed to import default component ${c}.js`), Error("Component not found in any loader");
  return v ? /* @__PURE__ */ ot.default.createElement(g, {
    ...m,
    record: d,
    key: i,
    fieldPath: i
  }) : g;
}
async function A1e(r) {
  let {
    templateLoaders: o,
    fieldPathPrefix: c,
    fields: i,
    record: d
  } = r;
  return [...await ((g, C, O) => {
    const R = [];
    return O.forEach((I) => {
      R.push(Sq(g, {
        ...I,
        fieldPath: C ? `${C}.${I.field}` : I.field,
        record: d
      }));
    }), Promise.all(R);
  })(o, c, i)];
}
class k1e extends ha.Component {
  constructor(o) {
    var c;
    super(o), c = this, this.handleModalOpen = () => {
      this.setState({
        modalOpen: !0
      });
    }, this.handleModalClosed = () => {
      this.setState({
        modalOpen: !1
      });
    }, this.handleSelectField = (d, m, v) => {
      const {
        selectedFieldTarget: g
      } = this.state;
      g && g.classList.toggle("selected-background"), d.currentTarget.classList.toggle("selected-background");
      const C = {
        field: m,
        props: {
          ...v
        },
        ui_widget: v.ui_widget
      };
      this.setState({
        selectedField: {
          ...C
        },
        selectedFieldTarget: d.currentTarget
      });
    }, this.handleAddField = async function() {
      let d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
      const {
        selectedField: m,
        addFields: v,
        selectedFieldTarget: g,
        existingFields: C
      } = c.state, {
        fieldPath: O,
        templateLoaders: R,
        addFieldCallback: I
      } = c.props;
      c.setState({
        loading: !0
      }), m.props.label = /* @__PURE__ */ ot.default.createElement(AQe, {
        fieldPath: `${O}.${m.field}`,
        removeFieldCallback: c.handleRemoveField,
        field: {
          key: `${O}.${m.field}`
        },
        label: m.props.label
      });
      const L = await Sq(R, {
        ...m,
        fieldPath: `${O}.${m.field}`
      }), Z = () => {
        const {
          addFields: ne
        } = c.state;
        I(ne), c.setState({
          addFields: []
        }), c.handleModalClosed();
      };
      g.classList.toggle("selected-background"), c.setState({
        addFields: [...v, L],
        existingFields: [...C, L.key],
        selectedField: void 0,
        selectedFieldTarget: void 0,
        loading: !1
      }, () => d ? Z() : null);
    }, this.handleCancel = () => {
      const {
        addFields: d
      } = this.state, {
        addFieldCallback: m
      } = this.props;
      m(d), this.setState({
        addFields: []
      }), this.handleModalClosed();
    }, this.handleRemoveField = (d) => {
      const {
        existingFields: m
      } = this.state, {
        removeFieldCallback: v
      } = this.props, g = m.filter((C) => d.key !== C);
      this.setState({
        existingFields: [...g]
      }), v(d);
    };
    const {
      existingFields: i
    } = o;
    this.state = {
      modalOpen: !1,
      selectedField: void 0,
      selectedFieldTarget: void 0,
      addFields: [],
      existingFields: [...i],
      loading: !1
    };
  }
  render() {
    const {
      fieldPath: o,
      // injected by the custom field loader via the `field` config property
      icon: c,
      label: i,
      record: d,
      templateLoaders: m,
      addFieldCallback: v,
      removeFieldCallback: g,
      sections: C,
      existingFields: O,
      ...R
    } = this.props, {
      modalOpen: I,
      existingFields: L,
      loading: Z,
      selectedField: ne
    } = this.state;
    return /* @__PURE__ */ ot.default.createElement(ot.default.Fragment, null, /* @__PURE__ */ ot.default.createElement(Kn.Button, {
      icon: !0,
      labelPosition: "left",
      onClick: this.handleModalOpen
    }, /* @__PURE__ */ ot.default.createElement(Kn.Icon, {
      name: "plus"
    }), "Add field"), /* @__PURE__ */ ot.default.createElement(Kn.Modal, {
      open: I
    }, /* @__PURE__ */ ot.default.createElement(Kn.Modal.Header, null, "Add domain specific fields"), /* @__PURE__ */ ot.default.createElement(O1e, {
      fieldPath: o,
      handleSelectField: this.handleSelectField,
      alreadyAddedFields: L,
      fieldsList: R,
      sections: C
    }), /* @__PURE__ */ ot.default.createElement(Kn.Modal.Actions, null, /* @__PURE__ */ ot.default.createElement(Kn.Button, {
      onClick: this.handleCancel,
      floated: "left",
      labelPosition: "left",
      content: "Close"
    }), /* @__PURE__ */ ot.default.createElement(Kn.Button, {
      icon: !0,
      labelPosition: "left",
      onClick: () => this.handleAddField(!1),
      disabled: Z || !ne,
      loading: Z
    }, /* @__PURE__ */ ot.default.createElement(Kn.Icon, {
      name: "plus"
    }), "Add field and continue"), /* @__PURE__ */ ot.default.createElement(Kn.Button, {
      icon: !0,
      labelPosition: "left",
      onClick: () => this.handleAddField(!0),
      disabled: Z || !ne,
      loading: Z
    }, /* @__PURE__ */ ot.default.createElement(Kn.Icon, {
      name: "plus"
    }), "Add field and close"))));
  }
}
k1e.defaultProps = {
  icon: void 0,
  label: void 0,
  sections: void 0
};
class N1e extends ha.Component {
  constructor(o) {
    super(o), this.getFieldsConfig = (m) => {
      const v = {};
      for (const g of m)
        for (const C of g.fieldsConfig) {
          const {
            field: O,
            props: R,
            ui_widget: I,
            ...L
          } = C;
          v[O] = {
            ui_widget: I,
            section: g,
            ...R,
            ...L
          };
        }
      return v;
    }, this.getFieldsWithValues = (m) => {
      const {
        tempFields: v,
        recordFields: g
      } = this.state, C = [];
      for (const O of m)
        (g.includes(O.key) || v.includes(O)) && C.push(O);
      return C;
    }, this.getSectionOfField = (m) => {
      const {
        sections: v
      } = this.state;
      for (const g of v)
        if (g.fields.map((C) => C.key).includes(m.key))
          return g.section;
    }, this.addFieldCallback = (m) => {
      const {
        sections: v,
        tempFields: g
      } = this.state, C = [...v];
      for (const O of m) {
        const R = this.getSectionOfField(O);
        for (const I of C)
          I.section === R && (I.fields = [...I.fields, O].sort((L, Z) => L.key.localeCompare(Z.key)));
      }
      this.setState({
        sections: [...C],
        tempFields: [...g, ...m]
      });
    }, this.removeFieldCallback = (m) => {
      const {
        sections: v,
        tempFields: g
      } = this.state, C = [...v];
      let O = [...g];
      const R = this.getSectionOfField(m);
      for (const I of C)
        I.section === R && (I.fields = I.fields.filter((L) => m.key !== L.key), O = O.filter((L) => m.key !== L.key));
      this.setState({
        sections: [...C],
        tempFields: [...O]
      });
    };
    const {
      sections: c,
      record: i
    } = o;
    console.warn(o);
    let d = [];
    i && !Tk.default(i.custom_fields) && (d = Object.keys(i.custom_fields).map((m) => `custom_fields.${m}`)), this.state = {
      sections: c,
      tempFields: [],
      recordFields: d
    }, this.fieldsCfg = this.getFieldsConfig(c), this.sectionsList = c.map((m) => m.section);
  }
  render() {
    const {
      templateLoaders: o,
      record: c,
      discoverSectionLabel: i
    } = this.props, {
      sections: d,
      tempFields: m,
      recordFields: v
    } = this.state, g = [...Object.entries(m).map((O) => {
      let [R, I] = O;
      return I.key;
    }), ...v], C = m.map((O) => O.key);
    return /* @__PURE__ */ ot.default.createElement(vq, {
      key: "discover-fields",
      includesPaths: C,
      label: i,
      active: !0,
      id: "domain-specific-fields-section"
    }, d.map((O) => {
      let {
        fields: R,
        paths: I,
        ...L
      } = O;
      const Z = this.getFieldsWithValues(R);
      if (!Tk.default(Z))
        return /* @__PURE__ */ ot.default.createElement("div", {
          key: L.section,
          className: "rel-mb-2"
        }, /* @__PURE__ */ ot.default.createElement(Mh, {
          htmlFor: L.section,
          icon: L.icon,
          label: L.section
        }), /* @__PURE__ */ ot.default.createElement(Kn.Divider, {
          fitted: !0,
          className: "rel-mb-1"
        }), /* @__PURE__ */ ot.default.createElement("div", {
          className: "rel-ml-1"
        }, Z));
    }), /* @__PURE__ */ ot.default.createElement(k1e, Object.assign({
      fieldPath: "custom_fields"
    }, this.fieldsCfg, {
      templateLoaders: o,
      addFieldCallback: this.addFieldCallback,
      removeFieldCallback: this.removeFieldCallback,
      sections: this.sectionsList,
      record: c,
      existingFields: g
    })));
  }
}
N1e.defaultProps = {
  discoverSectionLabel: "Domain specific fields"
};
var R1e = p1e.default.component("ReactInvenioForms.DiscoverFieldsSection", N1e);
class P1e extends ha.Component {
  constructor(o) {
    super(o), this.populateConfig = async () => {
      const {
        includesPaths: c,
        fieldPathPrefix: i
      } = this.props;
      try {
        const {
          sectionsConfig: d,
          discoverFieldsConfig: m
        } = await this.loadCustomFieldsWidgets(), v = await Promise.all(d.map(async (C) => {
          const O = c(C.fields, i), R = await this.loadSectionWidget(C);
          return {
            ...C,
            paths: O,
            widget: R
          };
        })).then((C) => C), g = m.map((C) => {
          const O = c(C.fields, i);
          return {
            ...C,
            paths: O
          };
        });
        this.setState({
          sections: v,
          discoverFieldsSections: g
        });
      } catch (d) {
        console.error("Couldn't load custom fields widgets.", d);
      }
    }, this.state = {
      sections: void 0,
      discoverFieldsSections: void 0
    };
  }
  componentDidMount() {
    this.populateConfig();
  }
  async loadSectionWidget(o) {
    const {
      templateLoaders: c,
      record: i,
      includesPaths: d,
      fieldPathPrefix: m
    } = this.props, v = d(o.fields, m);
    if (o.ui_widget)
      return await Sq(c, {
        ...o,
        fieldPath: void 0,
        record: i,
        props: {
          includesPaths: v,
          children: o
        }
      }, !1);
  }
  async loadCustomFieldsWidgets() {
    const {
      config: o,
      fieldPathPrefix: c,
      templateLoaders: i,
      record: d
    } = this.props, m = [], v = [];
    for (const g of o) {
      const C = await A1e({
        templateLoaders: i,
        fieldPathPrefix: c,
        fields: g.fields,
        record: d
      });
      g.discoverable_fields ? v.push({
        ...g,
        fields: C,
        fieldsConfig: g.fields
      }) : m.push({
        ...g,
        fields: C
      });
    }
    return {
      sectionsConfig: m,
      discoverFieldsConfig: v
    };
  }
  render() {
    const {
      sections: o,
      discoverFieldsSections: c
    } = this.state, {
      templateLoaders: i,
      record: d,
      severityChecks: m
    } = this.props;
    return /* @__PURE__ */ ot.default.createElement(ot.default.Fragment, null, o && o.map((v) => {
      const {
        fields: g,
        paths: C,
        displaySection: O = !0,
        section: R,
        widget: I,
        id: L
      } = v, Z = v.active !== void 0 ? v.active : !0, ne = I !== void 0 ? I : vq;
      return O ? /* @__PURE__ */ ot.default.createElement(ne, {
        key: `section-${R}`,
        includesPaths: C,
        severityChecks: m,
        label: R,
        active: Z,
        id: L
      }, g) : /* @__PURE__ */ ot.default.createElement(Kn.Container, {
        key: "custom-fields-section"
      }, g);
    }), c && c.length > 0 && /* @__PURE__ */ ot.default.createElement(R1e, {
      templateLoaders: i,
      sections: c,
      record: d
    }));
  }
}
P1e.defaultProps = {
  includesPaths: (r) => r.map((o) => o.key),
  severityChecks: null
};
class D1e extends ha.Component {
  constructor() {
    super(...arguments), this.serializeSubjects = (o) => o.map((c) => {
      var i;
      return {
        text: (c.scheme ? `(${c.scheme}) ` : "") + c.subject,
        value: (i = c.id) !== null && i !== void 0 ? i : c.subject,
        key: c.id,
        ...c.id ? {
          id: c.id
        } : {},
        subject: c.subject
      };
    }), this.prepareSuggest = (o) => {
      const {
        limitTo: c
      } = this.props;
      return c === "" || c === "all" ? o : `${c}:${o}`;
    };
  }
  render() {
    const {
      fieldPath: o,
      required: c,
      multiple: i,
      placeholder: d,
      clearable: m,
      label: v,
      icon: g,
      width: C,
      allowAdditions: O,
      noQueryMessage: R,
      ...I
    } = this.props, L = v ? /* @__PURE__ */ ot.default.createElement(Mh, {
      htmlFor: o,
      icon: g,
      label: v
    }) : /* @__PURE__ */ ot.default.createElement(ot.default.Fragment, null, /* @__PURE__ */ ot.default.createElement("label", {
      htmlFor: o,
      className: "mobile-hidden",
      "aria-label": "Placeholder label for alignment purposes"
    }, ""));
    return /* @__PURE__ */ ot.default.createElement(rs.Field, {
      name: o
    }, (Z) => {
      let {
        form: {
          values: ne
        }
      } = Z;
      return /* @__PURE__ */ ot.default.createElement(yq, Object.assign({}, I, {
        clearable: m,
        fieldPath: o,
        initialSuggestions: rs.getIn(ne, o, []),
        multiple: i,
        noQueryMessage: R,
        placeholder: d,
        preSearchChange: this.prepareSuggest,
        required: c,
        serializeSuggestions: this.serializeSubjects,
        serializeAddedValue: (se) => ({
          text: se,
          value: se,
          key: se,
          subject: se
        }),
        suggestionAPIUrl: "/api/subjects",
        onValueChange: (se, Q) => {
          let {
            formikProps: he
          } = se;
          he.form.setFieldValue(o, Q.map((ue) => ({
            subject: ue.subject,
            id: ue.id
          })));
        },
        label: L,
        value: rs.getIn(ne, o, []).map((se) => {
          var Q;
          return (Q = se.id) !== null && Q !== void 0 ? Q : se.subject;
        }),
        allowAdditions: O,
        width: C
      }));
    });
  }
}
D1e.defaultProps = {
  required: !1,
  limitTo: "",
  label: "",
  icon: void 0,
  multiple: !0,
  clearable: !0,
  placeholder: "Search for a subject by name",
  width: void 0,
  noQueryMessage: "Search or create subjects...",
  allowAdditions: !0
};
class $1e extends ha.Component {
  render() {
    const {
      description: o,
      fieldPath: c,
      required: i,
      label: d,
      icon: m,
      clearable: v,
      placeholder: g,
      multiple: C,
      autocompleteFrom: O,
      autocompleteFromAcceptHeader: R
    } = this.props;
    return /* @__PURE__ */ ot.default.createElement(ot.default.Fragment, null, /* @__PURE__ */ ot.default.createElement(Mh, {
      htmlFor: c,
      icon: m,
      label: d
    }), /* @__PURE__ */ ot.default.createElement(rs.Field, {
      name: c
    }, (I) => {
      let {
        form: {
          values: L
        }
      } = I;
      return /* @__PURE__ */ ot.default.createElement(yq, {
        clearable: v,
        required: i,
        fieldPath: c,
        multiple: C,
        noQueryMessage: g,
        placeholder: g,
        suggestionAPIUrl: O,
        suggestionAPIHeaders: {
          Accept: R
        },
        serializeSuggestions: (Z) => SQe.default(Z) ? Z.map((ne) => ({
          text: ne.title_l10n,
          value: ne.id,
          key: ne.id
        })) : [{
          text: Z.title_l10n,
          value: Z.id,
          key: Z.id
        }],
        initialSuggestions: v2.default(L, `ui.${c}`, [])
      });
    }), o && /* @__PURE__ */ ot.default.createElement("label", {
      className: "helptext"
    }, o));
  }
}
$1e.defaultProps = {
  icon: void 0,
  autocompleteFromAcceptHeader: "application/vnd.inveniordm.v1+json",
  clearable: !1,
  multiple: !1,
  required: !1
};
class I1e extends ha.Component {
  constructor() {
    super(...arguments), this.serializeOptions = (o) => o == null ? void 0 : o.map((c) => ({
      text: c.title_l10n,
      value: c.id,
      key: c.id
    }));
  }
  render() {
    const {
      description: o,
      placeholder: c,
      fieldPath: i,
      label: d,
      icon: m,
      options: v,
      search: g,
      multiple: C,
      clearable: O,
      required: R
    } = this.props;
    return /* @__PURE__ */ ot.default.createElement(ot.default.Fragment, null, /* @__PURE__ */ ot.default.createElement(a5, {
      fieldPath: i,
      label: /* @__PURE__ */ ot.default.createElement(Mh, {
        htmlFor: i,
        icon: m,
        label: d
      }),
      options: this.serializeOptions(v),
      search: g,
      "aria-label": d,
      multiple: C,
      placeholder: {
        role: "option",
        content: c
      },
      clearable: O,
      required: R,
      optimized: !0,
      defaultValue: C ? [] : ""
    }), o && /* @__PURE__ */ ot.default.createElement("label", {
      className: "helptext"
    }, o));
  }
}
I1e.defaultProps = {
  icon: void 0,
  search: !1,
  multiple: !1,
  clearable: !0,
  required: !1
};
class M1e extends ha.Component {
  render() {
    const {
      fieldPath: o,
      required: c,
      label: i,
      icon: d,
      description: m,
      editorConfig: v
    } = this.props;
    return /* @__PURE__ */ ot.default.createElement(ot.default.Fragment, null, /* @__PURE__ */ ot.default.createElement(wce, {
      key: o,
      fieldPath: o,
      required: c,
      editorConfig: v,
      label: /* @__PURE__ */ ot.default.createElement(Mh, {
        htmlFor: o,
        icon: d,
        label: i
      })
    }), m && /* @__PURE__ */ ot.default.createElement("label", {
      className: "helptext"
    }, m));
  }
}
M1e.defaultProps = {
  icon: void 0,
  editorConfig: {},
  required: !1
};
class F1e extends ha.Component {
  render() {
    const {
      fieldPath: o,
      required: c,
      label: i,
      icon: d,
      description: m,
      rows: v
    } = this.props;
    return /* @__PURE__ */ ot.default.createElement(ot.default.Fragment, null, /* @__PURE__ */ ot.default.createElement(yce, {
      key: o,
      fieldPath: o,
      required: c,
      label: /* @__PURE__ */ ot.default.createElement(Mh, {
        htmlFor: o,
        icon: d,
        label: i
      }),
      rows: v
    }), m && /* @__PURE__ */ ot.default.createElement("label", {
      className: "helptext"
    }, m));
  }
}
F1e.defaultProps = {
  icon: void 0,
  required: !1,
  rows: 3
};
class Ece extends ha.Component {
  render() {
    const {
      fieldPath: o,
      required: c,
      label: i,
      icon: d,
      placeholder: m,
      description: v,
      disabled: g,
      type: C
    } = this.props;
    return /* @__PURE__ */ ot.default.createElement(bce, {
      key: o,
      fieldPath: o,
      required: c,
      helpText: v,
      disabled: g,
      label: /* @__PURE__ */ ot.default.createElement(Mh, {
        htmlFor: o,
        icon: d,
        label: i
      }),
      placeholder: m,
      type: C
    });
  }
}
Ece.defaultProps = {
  icon: void 0,
  required: !1,
  disabled: !1,
  type: "input"
};
function L1e(r) {
  let {
    additionLabel: o,
    description: c,
    placeholder: i,
    fieldPath: d,
    label: m,
    icon: v,
    required: g
  } = r;
  const [C, O] = ha.useState([]), {
    values: R
  } = rs.useFormikContext(), I = (L) => L == null ? void 0 : L.map((Z) => ({
    text: Z,
    key: Z,
    value: Z
  }));
  return /* @__PURE__ */ ot.default.createElement(ot.default.Fragment, null, /* @__PURE__ */ ot.default.createElement(a5, {
    fieldPath: d,
    label: /* @__PURE__ */ ot.default.createElement(Mh, {
      htmlFor: d,
      icon: v,
      label: m
    }),
    options: I(rs.getIn(R, d, [])),
    placeholder: i,
    required: g,
    search: !0,
    multiple: !0,
    clearable: !0,
    optimized: !0,
    defaultValue: [],
    noResultsMessage: i,
    additionLabel: o,
    onChange: (L) => {
      let {
        data: Z,
        formikProps: ne
      } = L;
      O(I(Z.value)), ne.form.setFieldValue(d, Z.value);
    },
    allowAdditions: !0,
    onAddItem: (L) => {
      let {
        data: Z
      } = L;
      O([{
        text: Z.value,
        value: Z.value
      }, ...C]);
    }
  }), c && /* @__PURE__ */ ot.default.createElement("label", {
    className: "helptext"
  }, c));
}
L1e.defaultProps = {
  additionLabel: void 0,
  icon: void 0,
  required: !1
};
const kQe = (r) => /* @__PURE__ */ ot.default.createElement(Ece, Object.assign({}, r, {
  type: "number"
}));
function B1e(r) {
  let {
    description: o,
    icon: c,
    falseLabel: i,
    fieldPath: d,
    label: m,
    trueLabel: v,
    required: g
  } = r;
  const [C, O] = rs.useField(d);
  return /* @__PURE__ */ ot.default.createElement(ot.default.Fragment, null, /* @__PURE__ */ ot.default.createElement(Kn.Form.Group, {
    inline: !0,
    className: "mb-0"
  }, /* @__PURE__ */ ot.default.createElement(Kn.Form.Field, {
    required: g
  }, /* @__PURE__ */ ot.default.createElement(Mh, {
    htmlFor: d,
    icon: c,
    label: m
  })), /* @__PURE__ */ ot.default.createElement(MB, {
    fieldPath: d,
    label: v,
    checked: O.value === !0,
    value: !0,
    optimized: !0
  }), /* @__PURE__ */ ot.default.createElement(MB, {
    fieldPath: d,
    label: i,
    checked: O.value === !1,
    value: !1,
    optimized: !0
  }), O.error && /* @__PURE__ */ ot.default.createElement(Kn.Form.Field, {
    required: g,
    className: "error"
  }, /* @__PURE__ */ ot.default.createElement(Kn.Label, {
    pointing: "left",
    prompt: !0
  }, O.error))), o && /* @__PURE__ */ ot.default.createElement("label", {
    className: "helptext"
  }, o));
}
B1e.defaultProps = {
  icon: void 0,
  required: !1
};
let H1e = class extends ha.Component {
  render() {
    const {
      fieldPath: o,
      required: c,
      label: i,
      icon: d,
      description: m,
      disabled: v,
      children: g,
      addButtonLabel: C,
      defaultNewValue: O,
      className: R
    } = this.props;
    return /* @__PURE__ */ ot.default.createElement(gce, {
      key: o,
      fieldPath: o,
      required: c,
      helpText: m,
      disabled: v,
      label: /* @__PURE__ */ ot.default.createElement(Mh, {
        htmlFor: o,
        icon: d,
        label: i
      }),
      addButtonLabel: C,
      defaultNewValue: O,
      className: R
    }, g);
  }
};
H1e.defaultProps = {
  icon: void 0,
  required: !1,
  disabled: !1,
  className: ""
};
const NQe = function(r) {
  let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "en";
  return mQe.DateTime.fromISO(r).setLocale(o).toRelative();
};
function RQe(r) {
  let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  if (wQe.default(r)) {
    const c = o ? 1e3 : 1024, i = c, d = c * i, m = c * d;
    return r < i ? `${r} bytes` : r < d ? `${(r / i).toFixed(2)} ${o ? "KB" : "KiB"}` : r < m ? `${(r / d).toFixed(2)} ${o ? "MB" : "MiB"}` : `${(r / m).toFixed(2)} ${o ? "GB" : "GiB"}`;
  }
  return "";
}
function PQe(r) {
  return r.map((o) => ({
    key: o.key,
    text: o.text,
    value: o.key,
    content: /* @__PURE__ */ ot.default.createElement(ot.default.Fragment, null, /* @__PURE__ */ ot.default.createElement("div", null, o.text), /* @__PURE__ */ ot.default.createElement("div", null, /* @__PURE__ */ ot.default.createElement("small", {
      className: "text-muted"
    }, o.description)))
  }));
}
Ko.AccordionField = vq;
Ko.AffiliationsSuggestions = EQe;
Ko.Array = H1e;
Ko.ArrayField = gce;
Ko.AutocompleteDropdown = $1e;
var DQe = Ko.BaseForm = E1e;
Ko.BooleanCheckbox = B1e;
Ko.BooleanField = C1e;
Ko.BulkActionsContext = s5;
Ko.CustomFields = P1e;
Ko.DiscoverFieldsSection = R1e;
Ko.Dropdown = I1e;
Ko.ErrorLabel = vce;
Ko.ErrorMessage = S1e;
Ko.FeedbackLabel = bq;
Ko.FieldLabel = Mh;
Ko.GridResponsiveSidebarColumn = y1e;
Ko.GroupField = x1e;
Ko.Image = gq;
Ko.Input = Ece;
Ko.InvenioPopup = pce;
Ko.MultiInput = L1e;
Ko.NumberInput = kQe;
Ko.RadioField = MB;
Ko.RemoteSelectField = yq;
Ko.RichEditor = Sce;
Ko.RichInput = M1e;
Ko.RichInputField = wce;
Ko.SearchResultsBulkActions = hce;
Ko.SearchResultsBulkActionsManager = v1e;
Ko.SearchResultsRowCheckbox = b1e;
Ko.SelectField = a5;
Ko.SubjectAutocompleteDropdown = D1e;
Ko.TextArea = F1e;
Ko.TextAreaField = yce;
Ko.TextField = bce;
Ko.ToggleField = _1e;
Ko.UserListItemCompact = g1e;
Ko.dropdownOptionsGenerator = PQe;
Ko.http = TQe;
Ko.humanReadableBytes = RQe;
Ko.importWidget = Sq;
Ko.loadWidgetsFromConfig = A1e;
Ko.makeIdEntry = tae;
Ko.makeSubheader = nae;
Ko.toRelativeTime = NQe;
Ko.withCancel = T1e;
const $Qe = {
  title: "",
  description: "",
  mode: "import",
  status: "",
  startTime: null,
  endTime: null,
  recordType: "",
  serializer: ""
}, IQe = () => {
  const r = (o) => {
    console.log("Form submitted with values:", o);
  };
  return /* @__PURE__ */ ae.createElement(DQe, { formik: { initialValues: $Qe }, onSubmit: r }, /* @__PURE__ */ ae.createElement("p", null, "TEST"));
}, MQe = () => {
  const [r, o] = Spe(!1);
  return /* @__PURE__ */ ae.createElement(
    HD,
    {
      closeIcon: !0,
      onClose: () => o(!1),
      onOpen: () => o(!0),
      open: r,
      trigger: /* @__PURE__ */ ae.createElement(hy, { color: "green", icon: !0, labelPosition: "left" }, /* @__PURE__ */ ae.createElement(fc, { name: "add" }), "New Import")
    },
    /* @__PURE__ */ ae.createElement(zS, null, "New Import Task"),
    /* @__PURE__ */ ae.createElement(HS, null, /* @__PURE__ */ ae.createElement(IQe, null)),
    /* @__PURE__ */ ae.createElement(w2, null, /* @__PURE__ */ ae.createElement(hy, { onClick: () => o(!1) }, "Close"))
  );
}, FQe = ({
  currentQueryState: r,
  updateQueryState: o
}) => {
  var m;
  const c = [
    { key: "all", label: "All", value: null },
    { key: "pending", label: "Pending", value: "pending" },
    { key: "success", label: "Success", value: "success" },
    { key: "failed", label: "Failed", value: "failed" }
  ], i = (m = r.filters) == null ? void 0 : m.find(
    (v) => v[0] === "status"
  ), d = (v) => {
    var C;
    const g = ((C = r.filters) == null ? void 0 : C.filter(
      (O) => O[0] !== "status"
    )) || [];
    v && g.push(["status", v]), o({
      ...r,
      filters: g,
      page: 1
    });
  };
  return /* @__PURE__ */ ae.createElement(h2, { activeIndex: 0, compact: !0, size: "tiny" }, c.map(({ key: v, label: g, value: C }) => /* @__PURE__ */ ae.createElement(
    h2.Item,
    {
      key: v,
      name: v,
      active: (i == null ? void 0 : i[1]) === C || C === null && !i,
      onClick: () => d(C)
    },
    g
  )));
}, z1e = LVe(FQe);
function rae(r) {
  return typeof r == "object" && r != null && !Array.isArray(r);
}
var LQe = (r) => typeof r == "object" && r !== null;
function BQe(r) {
  return Object.fromEntries(Object.entries(r ?? {}).filter(([o, c]) => c !== void 0));
}
var HQe = (r) => r === "base";
function zQe(r) {
  return r.slice().filter((o) => !HQe(o));
}
function hpe(r) {
  return String.fromCharCode(r + (r > 25 ? 39 : 97));
}
function VQe(r) {
  let o = "", c;
  for (c = Math.abs(r); c > 52; c = c / 52 | 0)
    o = hpe(c % 52) + o;
  return hpe(c % 52) + o;
}
function UQe(r, o) {
  let c = o.length;
  for (; c; )
    r = r * 33 ^ o.charCodeAt(--c);
  return r;
}
function WQe(r) {
  return VQe(UQe(5381, r) >>> 0);
}
var V1e = /\s*!(important)?/i;
function jQe(r) {
  return typeof r == "string" ? V1e.test(r) : !1;
}
function qQe(r) {
  return typeof r == "string" ? r.replace(V1e, "").trim() : r;
}
function U1e(r) {
  return typeof r == "string" ? r.replaceAll(" ", "_") : r;
}
var Cce = (r) => {
  const o = /* @__PURE__ */ new Map();
  return (...i) => {
    const d = JSON.stringify(i);
    if (o.has(d))
      return o.get(d);
    const m = r(...i);
    return o.set(d, m), m;
  };
}, GQe = /* @__PURE__ */ new Set(["__proto__", "constructor", "prototype"]);
function W1e(...r) {
  return r.reduce((o, c) => (c && Object.keys(c).forEach((i) => {
    if (GQe.has(i))
      return;
    const d = o[i], m = c[i];
    rae(d) && rae(m) ? o[i] = W1e(d, m) : o[i] = m;
  }), o), {});
}
var ZQe = (r) => r != null;
function j1e(r, o, c = {}) {
  const { stop: i, getKey: d } = c;
  function m(v, g = []) {
    if (LQe(v)) {
      const C = {};
      for (const [O, R] of Object.entries(v)) {
        const I = (d == null ? void 0 : d(O, R)) ?? O, L = [...g, I];
        if (i != null && i(v, L))
          return o(v, g);
        const Z = m(R, L);
        ZQe(Z) && (C[I] = Z);
      }
      return C;
    }
    return o(v, g);
  }
  return m(r);
}
function KQe(r, o) {
  return r.reduce(
    (c, i, d) => {
      const m = o[d];
      return i != null && (c[m] = i), c;
    },
    {}
  );
}
function q1e(r, o, c = !0) {
  const { utility: i, conditions: d } = o, { hasShorthand: m, resolveShorthand: v } = i;
  return j1e(
    r,
    (g) => Array.isArray(g) ? KQe(g, d.breakpoints.keys) : g,
    {
      stop: (g) => Array.isArray(g),
      getKey: c ? (g) => m ? v(g) : g : void 0
    }
  );
}
var YQe = {
  shift: (r) => r,
  finalize: (r) => r,
  breakpoints: { keys: [] }
}, QQe = (r) => typeof r == "string" ? r.replaceAll(/[\n\s]+/g, " ") : r;
function XQe(r) {
  const { utility: o, hash: c, conditions: i = YQe } = r, d = (v) => [o.prefix, v].filter(Boolean).join("-"), m = (v, g) => {
    let C;
    if (c) {
      const O = [...i.finalize(v), g];
      C = d(o.toHash(O, WQe));
    } else
      C = [...i.finalize(v), d(g)].join(":");
    return C;
  };
  return Cce(({ base: v, ...g } = {}) => {
    const C = Object.assign(g, v), O = q1e(C, r), R = /* @__PURE__ */ new Set();
    return j1e(O, (I, L) => {
      if (I == null)
        return;
      const Z = jQe(I), [ne, ...se] = i.shift(L), Q = zQe(se), he = o.transform(ne, qQe(QQe(I)));
      let ue = m(Q, he.className);
      Z && (ue = `${ue}!`), R.add(ue);
    }), Array.from(R).join(" ");
  });
}
function JQe(...r) {
  return r.flat().filter((o) => rae(o) && Object.keys(BQe(o)).length > 0);
}
function eXe(r) {
  function o(d) {
    const m = JQe(...d);
    return m.length === 1 ? m : m.map((v) => q1e(v, r));
  }
  function c(...d) {
    return W1e(...o(d));
  }
  function i(...d) {
    return Object.assign({}, ...o(d));
  }
  return { mergeCss: Cce(c), assignCss: i };
}
var tXe = /([A-Z])/g, nXe = /^ms-/, rXe = Cce((r) => r.startsWith("--") ? r : r.replace(tXe, "-$1").replace(nXe, "-ms-").toLowerCase()), oXe = "cm,mm,Q,in,pc,pt,px,em,ex,ch,rem,lh,rlh,vw,vh,vmin,vmax,vb,vi,svw,svh,lvw,lvh,dvw,dvh,cqw,cqh,cqi,cqb,cqmin,cqmax,%";
`${oXe.split(",").join("|")}`;
const sXe = "_hover,_focus,_focusWithin,_focusVisible,_disabled,_active,_visited,_target,_readOnly,_readWrite,_empty,_checked,_enabled,_expanded,_highlighted,_complete,_incomplete,_dragging,_before,_after,_firstLetter,_firstLine,_marker,_selection,_file,_backdrop,_first,_last,_only,_even,_odd,_firstOfType,_lastOfType,_onlyOfType,_peerFocus,_peerHover,_peerActive,_peerFocusWithin,_peerFocusVisible,_peerDisabled,_peerChecked,_peerInvalid,_peerExpanded,_peerPlaceholderShown,_groupFocus,_groupHover,_groupActive,_groupFocusWithin,_groupFocusVisible,_groupDisabled,_groupChecked,_groupExpanded,_groupInvalid,_indeterminate,_required,_valid,_invalid,_autofill,_inRange,_outOfRange,_placeholder,_placeholderShown,_pressed,_selected,_grabbed,_underValue,_overValue,_atValue,_default,_optional,_open,_closed,_fullscreen,_loading,_hidden,_current,_currentPage,_currentStep,_today,_unavailable,_rangeStart,_rangeEnd,_now,_topmost,_motionReduce,_motionSafe,_print,_landscape,_portrait,_dark,_light,_osDark,_osLight,_highContrast,_lessContrast,_moreContrast,_ltr,_rtl,_scrollbar,_scrollbarThumb,_scrollbarTrack,_horizontal,_vertical,_icon,_starting,sm,smOnly,smDown,md,mdOnly,mdDown,lg,lgOnly,lgDown,xl,xlOnly,xlDown,2xl,2xlOnly,2xlDown,smToMd,smToLg,smToXl,smTo2xl,mdToLg,mdToXl,mdTo2xl,lgToXl,lgTo2xl,xlTo2xl,@/xs,@/sm,@/md,@/lg,@/xl,@/2xl,@/3xl,@/4xl,@/5xl,@/6xl,@/7xl,@/8xl,base", G1e = new Set(sXe.split(",")), aXe = /^@|&|&$/;
function gpe(r) {
  return G1e.has(r) || aXe.test(r);
}
const iXe = /^_/, cXe = /&|@/;
function lXe(r) {
  return r.map((o) => G1e.has(o) ? o.replace(iXe, "") : cXe.test(o) ? `[${U1e(o.trim())}]` : o);
}
function uXe(r) {
  return r.sort((o, c) => {
    const i = gpe(o), d = gpe(c);
    return i && !d ? 1 : !i && d ? -1 : 0;
  });
}
const dXe = "aspectRatio:asp,boxDecorationBreak:bx-db,zIndex:z,boxSizing:bx-s,objectPosition:obj-p,objectFit:obj-f,overscrollBehavior:ovs-b,overscrollBehaviorX:ovs-bx,overscrollBehaviorY:ovs-by,position:pos/1,top:top,left:left,inset:inset,insetInline:inset-x/insetX,insetBlock:inset-y/insetY,insetBlockEnd:inset-be,insetBlockStart:inset-bs,insetInlineEnd:inset-e/insetEnd/end,insetInlineStart:inset-s/insetStart/start,right:right,bottom:bottom,float:float,visibility:vis,display:d,hideFrom:hide,hideBelow:show,flexBasis:flex-b,flex:flex,flexDirection:flex-d/flexDir,flexGrow:flex-g,flexShrink:flex-sh,gridTemplateColumns:grid-tc,gridTemplateRows:grid-tr,gridColumn:grid-c,gridRow:grid-r,gridColumnStart:grid-cs,gridColumnEnd:grid-ce,gridAutoFlow:grid-af,gridAutoColumns:grid-ac,gridAutoRows:grid-ar,gap:gap,gridGap:grid-g,gridRowGap:grid-rg,gridColumnGap:grid-cg,rowGap:rg,columnGap:cg,justifyContent:jc,alignContent:ac,alignItems:ai,alignSelf:as,padding:p/1,paddingLeft:pl/1,paddingRight:pr/1,paddingTop:pt/1,paddingBottom:pb/1,paddingBlock:py/1/paddingY,paddingBlockEnd:pbe,paddingBlockStart:pbs,paddingInline:px/paddingX/1,paddingInlineEnd:pe/1/paddingEnd,paddingInlineStart:ps/1/paddingStart,marginLeft:ml/1,marginRight:mr/1,marginTop:mt/1,marginBottom:mb/1,margin:m/1,marginBlock:my/1/marginY,marginBlockEnd:mbe,marginBlockStart:mbs,marginInline:mx/1/marginX,marginInlineEnd:me/1/marginEnd,marginInlineStart:ms/1/marginStart,spaceX:sx,spaceY:sy,outlineWidth:ring-w/ringWidth,outlineColor:ring-c/ringColor,outline:ring/1,outlineOffset:ring-o/ringOffset,divideX:dvd-x,divideY:dvd-y,divideColor:dvd-c,divideStyle:dvd-s,width:w/1,inlineSize:w-is,minWidth:min-w/minW,minInlineSize:min-w-is,maxWidth:max-w/maxW,maxInlineSize:max-w-is,height:h/1,blockSize:h-bs,minHeight:min-h/minH,minBlockSize:min-h-bs,maxHeight:max-h/maxH,maxBlockSize:max-b,color:c,fontFamily:ff,fontSize:fs,fontSizeAdjust:fs-a,fontPalette:fp,fontKerning:fk,fontFeatureSettings:ff-s,fontWeight:fw,fontSmoothing:fsmt,fontVariant:fv,fontVariantAlternates:fv-alt,fontVariantCaps:fv-caps,fontVariationSettings:fv-s,fontVariantNumeric:fv-num,letterSpacing:ls,lineHeight:lh,textAlign:ta,textDecoration:td,textDecorationColor:td-c,textEmphasisColor:te-c,textDecorationStyle:td-s,textDecorationThickness:td-t,textUnderlineOffset:tu-o,textTransform:tt,textIndent:ti,textShadow:tsh,textShadowColor:tsh-c/textShadowColor,textOverflow:tov,verticalAlign:va,wordBreak:wb,textWrap:tw,truncate:trunc,lineClamp:lc,listStyleType:li-t,listStylePosition:li-pos,listStyleImage:li-img,listStyle:li-s,backgroundPosition:bg-p/bgPosition,backgroundPositionX:bg-p-x/bgPositionX,backgroundPositionY:bg-p-y/bgPositionY,backgroundAttachment:bg-a/bgAttachment,backgroundClip:bg-cp/bgClip,background:bg/1,backgroundColor:bg-c/bgColor,backgroundOrigin:bg-o/bgOrigin,backgroundImage:bg-i/bgImage,backgroundRepeat:bg-r/bgRepeat,backgroundBlendMode:bg-bm/bgBlendMode,backgroundSize:bg-s/bgSize,backgroundGradient:bg-grad/bgGradient,textGradient:txt-grad,gradientFromPosition:grad-from-pos,gradientToPosition:grad-to-pos,gradientFrom:grad-from,gradientTo:grad-to,gradientVia:grad-via,gradientViaPosition:grad-via-pos,borderRadius:bdr/rounded,borderTopLeftRadius:bdr-tl/roundedTopLeft,borderTopRightRadius:bdr-tr/roundedTopRight,borderBottomRightRadius:bdr-br/roundedBottomRight,borderBottomLeftRadius:bdr-bl/roundedBottomLeft,borderTopRadius:bdr-t/roundedTop,borderRightRadius:bdr-r/roundedRight,borderBottomRadius:bdr-b/roundedBottom,borderLeftRadius:bdr-l/roundedLeft,borderStartStartRadius:bdr-ss/roundedStartStart,borderStartEndRadius:bdr-se/roundedStartEnd,borderStartRadius:bdr-s/roundedStart,borderEndStartRadius:bdr-es/roundedEndStart,borderEndEndRadius:bdr-ee/roundedEndEnd,borderEndRadius:bdr-e/roundedEnd,border:bd,borderWidth:bd-w,borderTopWidth:bd-t-w,borderLeftWidth:bd-l-w,borderRightWidth:bd-r-w,borderBottomWidth:bd-b-w,borderBlockStartWidth:bd-bs-w,borderBlockEndWidth:bd-be-w,borderColor:bd-c,borderInline:bd-x/borderX,borderInlineWidth:bd-x-w/borderXWidth,borderInlineColor:bd-x-c/borderXColor,borderBlock:bd-y/borderY,borderBlockWidth:bd-y-w/borderYWidth,borderBlockColor:bd-y-c/borderYColor,borderLeft:bd-l,borderLeftColor:bd-l-c,borderInlineStart:bd-s/borderStart,borderInlineStartWidth:bd-s-w/borderStartWidth,borderInlineStartColor:bd-s-c/borderStartColor,borderRight:bd-r,borderRightColor:bd-r-c,borderInlineEnd:bd-e/borderEnd,borderInlineEndWidth:bd-e-w/borderEndWidth,borderInlineEndColor:bd-e-c/borderEndColor,borderTop:bd-t,borderTopColor:bd-t-c,borderBottom:bd-b,borderBottomColor:bd-b-c,borderBlockEnd:bd-be,borderBlockEndColor:bd-be-c,borderBlockStart:bd-bs,borderBlockStartColor:bd-bs-c,opacity:op,boxShadow:bx-sh/shadow,boxShadowColor:bx-sh-c/shadowColor,mixBlendMode:mix-bm,filter:filter,brightness:brightness,contrast:contrast,grayscale:grayscale,hueRotate:hue-rotate,invert:invert,saturate:saturate,sepia:sepia,dropShadow:drop-shadow,blur:blur,backdropFilter:bkdp,backdropBlur:bkdp-blur,backdropBrightness:bkdp-brightness,backdropContrast:bkdp-contrast,backdropGrayscale:bkdp-grayscale,backdropHueRotate:bkdp-hue-rotate,backdropInvert:bkdp-invert,backdropOpacity:bkdp-opacity,backdropSaturate:bkdp-saturate,backdropSepia:bkdp-sepia,borderCollapse:bd-cl,borderSpacing:bd-sp,borderSpacingX:bd-sx,borderSpacingY:bd-sy,tableLayout:tbl,transitionTimingFunction:trs-tmf,transitionDelay:trs-dly,transitionDuration:trs-dur,transitionProperty:trs-prop,transition:trs,animation:anim,animationName:anim-n,animationTimingFunction:anim-tmf,animationDuration:anim-dur,animationDelay:anim-dly,animationPlayState:anim-ps,animationComposition:anim-comp,animationFillMode:anim-fm,animationDirection:anim-dir,animationIterationCount:anim-ic,animationRange:anim-r,animationState:anim-s,animationRangeStart:anim-rs,animationRangeEnd:anim-re,animationTimeline:anim-tl,transformOrigin:trf-o,transformBox:trf-b,transformStyle:trf-s,transform:trf,rotate:rotate,rotateX:rotate-x,rotateY:rotate-y,rotateZ:rotate-z,scale:scale,scaleX:scale-x,scaleY:scale-y,translate:translate,translateX:translate-x/x,translateY:translate-y/y,translateZ:translate-z/z,accentColor:ac-c,caretColor:ca-c,scrollBehavior:scr-bhv,scrollbar:scr-bar,scrollbarColor:scr-bar-c,scrollbarGutter:scr-bar-g,scrollbarWidth:scr-bar-w,scrollMargin:scr-m,scrollMarginLeft:scr-ml,scrollMarginRight:scr-mr,scrollMarginTop:scr-mt,scrollMarginBottom:scr-mb,scrollMarginBlock:scr-my/scrollMarginY,scrollMarginBlockEnd:scr-mbe,scrollMarginBlockStart:scr-mbt,scrollMarginInline:scr-mx/scrollMarginX,scrollMarginInlineEnd:scr-me,scrollMarginInlineStart:scr-ms,scrollPadding:scr-p,scrollPaddingBlock:scr-py/scrollPaddingY,scrollPaddingBlockStart:scr-pbs,scrollPaddingBlockEnd:scr-pbe,scrollPaddingInline:scr-px/scrollPaddingX,scrollPaddingInlineEnd:scr-pe,scrollPaddingInlineStart:scr-ps,scrollPaddingLeft:scr-pl,scrollPaddingRight:scr-pr,scrollPaddingTop:scr-pt,scrollPaddingBottom:scr-pb,scrollSnapAlign:scr-sa,scrollSnapStop:scrs-s,scrollSnapType:scrs-t,scrollSnapStrictness:scrs-strt,scrollSnapMargin:scrs-m,scrollSnapMarginTop:scrs-mt,scrollSnapMarginBottom:scrs-mb,scrollSnapMarginLeft:scrs-ml,scrollSnapMarginRight:scrs-mr,scrollSnapCoordinate:scrs-c,scrollSnapDestination:scrs-d,scrollSnapPointsX:scrs-px,scrollSnapPointsY:scrs-py,scrollSnapTypeX:scrs-tx,scrollSnapTypeY:scrs-ty,scrollTimeline:scrtl,scrollTimelineAxis:scrtl-a,scrollTimelineName:scrtl-n,touchAction:tch-a,userSelect:us,overflow:ov,overflowWrap:ov-wrap,overflowX:ov-x,overflowY:ov-y,overflowAnchor:ov-a,overflowBlock:ov-b,overflowInline:ov-i,overflowClipBox:ovcp-bx,overflowClipMargin:ovcp-m,overscrollBehaviorBlock:ovs-bb,overscrollBehaviorInline:ovs-bi,fill:fill,stroke:stk,strokeWidth:stk-w,strokeDasharray:stk-dsh,strokeDashoffset:stk-do,strokeLinecap:stk-lc,strokeLinejoin:stk-lj,strokeMiterlimit:stk-ml,strokeOpacity:stk-op,srOnly:sr,debug:debug,appearance:ap,backfaceVisibility:bfv,clipPath:cp-path,hyphens:hy,mask:msk,maskImage:msk-i,maskSize:msk-s,textSizeAdjust:txt-adj,container:cq,containerName:cq-n,containerType:cq-t,cursor:cursor,textStyle:textStyle", Z1e = /* @__PURE__ */ new Map(), K1e = /* @__PURE__ */ new Map();
dXe.split(",").forEach((r) => {
  const [o, c] = r.split(":"), [i, ...d] = c.split("/");
  Z1e.set(o, i), d.length && d.forEach((m) => {
    K1e.set(m === "1" ? i : m, o);
  });
});
const vpe = (r) => K1e.get(r) || r, Y1e = {
  conditions: {
    shift: uXe,
    finalize: lXe,
    breakpoints: { keys: ["base", "sm", "md", "lg", "xl", "2xl"] }
  },
  utility: {
    transform: (r, o) => {
      const c = vpe(r);
      return { className: `${Z1e.get(c) || rXe(c)}_${U1e(o)}` };
    },
    hasShorthand: !0,
    toHash: (r, o) => o(r.join(":")),
    resolveShorthand: vpe
  }
}, fXe = XQe(Y1e), LA = (...r) => fXe(Q1e(...r));
LA.raw = (...r) => Q1e(...r);
const { mergeCss: Q1e, assignCss: EXe } = eXe(Y1e), ZL = {
  searchBarRow: LA({
    display: "flex !important",
    flexWrap: "wrap",
    alignItems: "center",
    gap: "1rem",
    paddingBlock: "0.5rem",
    minBlockSize: "3rem"
  }),
  facets: LA({
    flex: "0 0 auto"
  }),
  search: LA({
    flex: "1 1 auto",
    minInlineSize: "15rem"
  }),
  import: LA({
    flex: "0 0 auto"
  }),
  visuallyHidden: LA({
    srOnly: !0
  })
}, mXe = () => /* @__PURE__ */ ae.createElement(
  "section",
  {
    className: ZL.searchBarRow,
    "aria-label": "Records search and filters"
  },
  /* @__PURE__ */ ae.createElement("div", { className: ZL.facets }, /* @__PURE__ */ ae.createElement(z1e, null)),
  /* @__PURE__ */ ae.createElement("div", { className: ZL.search }, /* @__PURE__ */ ae.createElement(
    rUe,
    {
      autofocus: !0,
      actionProps: {
        icon: "search",
        content: "Search",
        className: "search",
        "aria-label": "Submit search",
        type: "submit"
      },
      placeholder: "Search records...",
      "aria-describedby": "search-instructions"
    }
  ), /* @__PURE__ */ ae.createElement("span", { className: ZL.visuallyHidden }, "Type keywords to search through records. Press Enter to submit.")),
  /* @__PURE__ */ ae.createElement("div", { className: ZL.import }, /* @__PURE__ */ ae.createElement(MQe, null))
), pXe = () => {
  const { config: r } = mUe();
  return /* @__PURE__ */ ae.createElement(Pv, null, /* @__PURE__ */ ae.createElement(Pv.Row, { verticalAlign: "middle" }, /* @__PURE__ */ ae.createElement(Pv.Column, { width: 4, textAlign: "left" }, /* @__PURE__ */ ae.createElement(DVe, { label: (o) => /* @__PURE__ */ ae.createElement("p", null, "Showing ", o, " task(s)") })), /* @__PURE__ */ ae.createElement(Pv.Column, { width: 8, textAlign: "center" }, /* @__PURE__ */ ae.createElement(UVe, { options: { size: "mini" } })), /* @__PURE__ */ ae.createElement(Pv.Column, { width: 4, textAlign: "right" }, /* @__PURE__ */ ae.createElement(
    eUe,
    {
      values: r.paginationOptions.resultsPerPage,
      label: (o) => /* @__PURE__ */ ae.createElement("p", null, o, " results per page")
    }
  ))));
}, hXe = ({
  config: r = {},
  overriddenComponents: o = {}
}) => {
  var m, v, g, C, O;
  const c = {
    ...tC,
    ...r,
    initialQueryState: {
      ...tC.initialQueryState,
      ...r.initialQueryState
    },
    layoutOptions: {
      ...tC.layoutOptions,
      ...r.layoutOptions
    },
    paginationOptions: {
      ...tC.paginationOptions,
      ...r.paginationOptions,
      resultsPerPage: ((m = r.paginationOptions) == null ? void 0 : m.resultsPerPage) || tC.paginationOptions.resultsPerPage
    },
    searchApi: {
      ...tC.searchApi,
      ...r.searchApi,
      axios: {
        ...tC.searchApi.axios,
        ...(v = r.searchApi) == null ? void 0 : v.axios,
        headers: {
          ...tC.searchApi.axios.headers,
          ...(C = (g = r.searchApi) == null ? void 0 : g.axios) == null ? void 0 : C.headers
        }
      },
      invenio: {
        ...tC.searchApi.invenio,
        ...(O = r.searchApi) == null ? void 0 : O.invenio
      }
    }
  }, i = new tbe(c.searchApi), d = {
    [`${c.appId}.ResultsList.item`]: pUe,
    [`${c.appId}.ResultsList.container`]: hUe,
    [`${c.appId}.SearchFacets`]: z1e,
    ...o
  };
  return /* @__PURE__ */ ae.createElement(Mj.Provider, { value: d }, /* @__PURE__ */ ae.createElement(
    bVe,
    {
      appName: c.appId,
      searchApi: i,
      initialQueryState: c.initialQueryState
    },
    /* @__PURE__ */ ae.createElement(fUe, { config: c }, /* @__PURE__ */ ae.createElement(mXe, null), /* @__PURE__ */ ae.createElement(YVe, null, /* @__PURE__ */ ae.createElement(MVe, null), /* @__PURE__ */ ae.createElement(Fbe, null)), /* @__PURE__ */ ae.createElement(pXe, null))
  ));
}, gXe = {
  bulkImporter: LA({
    padding: "2rem"
  })
}, CXe = () => /* @__PURE__ */ ae.createElement("div", { className: gXe.bulkImporter }, /* @__PURE__ */ ae.createElement(yC, { as: "h1" }, "Bulk Importer"), /* @__PURE__ */ ae.createElement("p", null, "A more modern approach for an invenio compatible bulk importer."), /* @__PURE__ */ ae.createElement(hXe, null));
function xXe(r) {
  return new tbe(r);
}
function TXe(r, o = {}, c = !0) {
  return {
    axios: {
      url: r,
      headers: {
        Accept: "application/vnd.inveniordm.v1+json",
        ...o
      },
      withCredentials: c
    }
  };
}
export {
  CXe as BulkImporter,
  MQe as ImportModal,
  hXe as Search,
  xXe as createSearchApi,
  TXe as createSearchApiConfig
};
